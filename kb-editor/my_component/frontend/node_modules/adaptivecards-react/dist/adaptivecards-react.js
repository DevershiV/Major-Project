(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("React"));
	else if(typeof define === 'function' && define.amd)
		define(["React"], factory);
	else if(typeof exports === 'object')
		exports["AdaptiveCards"] = factory(require("React"));
	else
		root["AdaptiveCards"] = factory(root["React"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_react__) {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/linkify-it/index.js":
/*!******************************************!*\
  !*** ./node_modules/linkify-it/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



////////////////////////////////////////////////////////////////////////////////
// Helpers

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) { return; }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

function _class(obj) { return Object.prototype.toString.call(obj); }
function isString(obj) { return _class(obj) === '[object String]'; }
function isObject(obj) { return _class(obj) === '[object Object]'; }
function isRegExp(obj) { return _class(obj) === '[object RegExp]'; }
function isFunction(obj) { return _class(obj) === '[object Function]'; }


function escapeRE(str) { return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&'); }

////////////////////////////////////////////////////////////////////////////////


var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};


function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function (acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}


var defaultSchemas = {
  'http:': {
    validate: function (text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.http =  new RegExp(
          '^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i'
        );
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  'https:':  'http:',
  'ftp:':    'http:',
  '//':      {
    validate: function (text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.no_http) {
      // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.no_http =  new RegExp(
          '^' +
          self.re.src_auth +
          // Don't allow single-level domains, because of false positives like '//test'
          // with code comments
          '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' +
          self.re.src_port +
          self.re.src_host_terminator +
          self.re.src_path,

          'i'
        );
      }

      if (self.re.no_http.test(tail)) {
        // should not be `://` & `///`, that protects from errors in protocol name
        if (pos >= 3 && text[pos - 3] === ':') { return 0; }
        if (pos >= 3 && text[pos - 3] === '/') { return 0; }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  'mailto:': {
    validate: function (text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.mailto) {
        self.re.mailto =  new RegExp(
          '^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i'
        );
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};

/*eslint-disable max-len*/

// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');

/*eslint-enable max-len*/

////////////////////////////////////////////////////////////////////////////////

function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__   = '';
}

function createValidator(re) {
  return function (text, pos) {
    var tail = text.slice(pos);

    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}

function createNormalizer() {
  return function (match, self) {
    self.normalize(match);
  };
}

// Schemas compiler. Build regexps.
//
function compile(self) {

  // Load & clone RE patterns.
  var re = self.re = __webpack_require__(/*! ./lib/re */ "./node_modules/linkify-it/lib/re.js")(self.__opts__);

  // Define dynamic patterns
  var tlds = self.__tlds__.slice();

  self.onCompile();

  if (!self.__tlds_replaced__) {
    tlds.push(tlds_2ch_src_re);
  }
  tlds.push(re.src_xn);

  re.src_tlds = tlds.join('|');

  function untpl(tpl) { return tpl.replace('%TLDS%', re.src_tlds); }

  re.email_fuzzy      = RegExp(untpl(re.tpl_email_fuzzy), 'i');
  re.link_fuzzy       = RegExp(untpl(re.tpl_link_fuzzy), 'i');
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');
  re.host_fuzzy_test  = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');

  //
  // Compile each schema
  //

  var aliases = [];

  self.__compiled__ = {}; // Reset compiled data

  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }

  Object.keys(self.__schemas__).forEach(function (name) {
    var val = self.__schemas__[name];

    // skip disabled methods
    if (val === null) { return; }

    var compiled = { validate: null, link: null };

    self.__compiled__[name] = compiled;

    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }

      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }

      return;
    }

    if (isString(val)) {
      aliases.push(name);
      return;
    }

    schemaError(name, val);
  });

  //
  // Compile postponed aliases
  //

  aliases.forEach(function (alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      // Silently fail on missed schemas to avoid errons on disable.
      // schemaError(alias, self.__schemas__[alias]);
      return;
    }

    self.__compiled__[alias].validate =
      self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize =
      self.__compiled__[self.__schemas__[alias]].normalize;
  });

  //
  // Fake record for guessed links
  //
  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

  //
  // Build schema condition
  //
  var slist = Object.keys(self.__compiled__)
                      .filter(function (name) {
                        // Filter disabled & fake schemas
                        return name.length > 0 && self.__compiled__[name];
                      })
                      .map(escapeRE)
                      .join('|');
  // (?!_) cause 1.5x slowdown
  self.re.schema_test   = RegExp('(^|(?!_)(?:[><\uff5c]|' + re.src_ZPCc + '))(' + slist + ')', 'i');
  self.re.schema_search = RegExp('(^|(?!_)(?:[><\uff5c]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');

  self.re.pretest = RegExp(
    '(' + self.re.schema_test.source + ')|(' + self.re.host_fuzzy_test.source + ')|@',
    'i'
  );

  //
  // Cleanup
  //

  resetScanCache(self);
}

/**
 * class Match
 *
 * Match result. Single element of array, returned by [[LinkifyIt#match]]
 **/
function Match(self, shift) {
  var start = self.__index__,
      end   = self.__last_index__,
      text  = self.__text_cache__.slice(start, end);

  /**
   * Match#schema -> String
   *
   * Prefix (protocol) for matched string.
   **/
  this.schema    = self.__schema__.toLowerCase();
  /**
   * Match#index -> Number
   *
   * First position of matched string.
   **/
  this.index     = start + shift;
  /**
   * Match#lastIndex -> Number
   *
   * Next position after matched string.
   **/
  this.lastIndex = end + shift;
  /**
   * Match#raw -> String
   *
   * Matched string.
   **/
  this.raw       = text;
  /**
   * Match#text -> String
   *
   * Notmalized text of matched string.
   **/
  this.text      = text;
  /**
   * Match#url -> String
   *
   * Normalized url of matched string.
   **/
  this.url       = text;
}

function createMatch(self, shift) {
  var match = new Match(self, shift);

  self.__compiled__[match.schema].normalize(match, self);

  return match;
}


/**
 * class LinkifyIt
 **/

/**
 * new LinkifyIt(schemas, options)
 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Creates new linkifier instance with optional additional schemas.
 * Can be called without `new` keyword for convenience.
 *
 * By default understands:
 *
 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
 * - "fuzzy" links and emails (example.com, foo@bar.com).
 *
 * `schemas` is an object, where each key/value describes protocol/rule:
 *
 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
 *   for example). `linkify-it` makes shure that prefix is not preceeded with
 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
 * - __value__ - rule to check tail after link prefix
 *   - _String_ - just alias to existing rule
 *   - _Object_
 *     - _validate_ - validator function (should return matched length on success),
 *       or `RegExp`.
 *     - _normalize_ - optional function to normalize text & url of matched result
 *       (for example, for @twitter mentions).
 *
 * `options`:
 *
 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
 *   like version numbers. Default `false`.
 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
 *
 **/
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }

  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }

  this.__opts__           = assign({}, defaultOptions, options);

  // Cache last tested result. Used to skip repeating steps on next `match` call.
  this.__index__          = -1;
  this.__last_index__     = -1; // Next scan position
  this.__schema__         = '';
  this.__text_cache__     = '';

  this.__schemas__        = assign({}, defaultSchemas, schemas);
  this.__compiled__       = {};

  this.__tlds__           = tlds_default;
  this.__tlds_replaced__  = false;

  this.re = {};

  compile(this);
}


/** chainable
 * LinkifyIt#add(schema, definition)
 * - schema (String): rule name (fixed pattern prefix)
 * - definition (String|RegExp|Object): schema definition
 *
 * Add new rule definition. See constructor description for details.
 **/
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};


/** chainable
 * LinkifyIt#set(options)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Set recognition options for links without schema.
 **/
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};


/**
 * LinkifyIt#test(text) -> Boolean
 *
 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
 **/
LinkifyIt.prototype.test = function test(text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__      = -1;

  if (!text.length) { return false; }

  var m, ml, me, len, shift, next, re, tld_pos, at_pos;

  // try to scan for link with schema - that's the most simple rule
  if (this.re.schema_test.test(text)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text)) !== null) {
      len = this.testSchemaAt(text, m[2], re.lastIndex);
      if (len) {
        this.__schema__     = m[2];
        this.__index__      = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }

  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
    // guess schemaless links
    tld_pos = text.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      // if tld is located after found link - no need to check fuzzy pattern
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

          shift = ml.index + ml[1].length;

          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__     = '';
            this.__index__      = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }

  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
    // guess schemaless emails
    at_pos = text.indexOf('@');
    if (at_pos >= 0) {
      // We can't skip this check, because this cases are possible:
      // 192.168.1.1@gmail.com, my.in@example.com
      if ((me = text.match(this.re.email_fuzzy)) !== null) {

        shift = me.index + me[1].length;
        next  = me.index + me[0].length;

        if (this.__index__ < 0 || shift < this.__index__ ||
            (shift === this.__index__ && next > this.__last_index__)) {
          this.__schema__     = 'mailto:';
          this.__index__      = shift;
          this.__last_index__ = next;
        }
      }
    }
  }

  return this.__index__ >= 0;
};


/**
 * LinkifyIt#pretest(text) -> Boolean
 *
 * Very quick check, that can give false positives. Returns true if link MAY BE
 * can exists. Can be used for speed optimization, when you need to check that
 * link NOT exists.
 **/
LinkifyIt.prototype.pretest = function pretest(text) {
  return this.re.pretest.test(text);
};


/**
 * LinkifyIt#testSchemaAt(text, name, position) -> Number
 * - text (String): text to scan
 * - name (String): rule (schema) name
 * - position (Number): text offset to check from
 *
 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
 * at given position. Returns length of found pattern (0 on fail).
 **/
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
  // If not supported schema check requested - terminate
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
};


/**
 * LinkifyIt#match(text) -> Array|null
 *
 * Returns array of found link descriptions or `null` on fail. We strongly
 * recommend to use [[LinkifyIt#test]] first, for best speed.
 *
 * ##### Result match description
 *
 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
 *   protocol-neutral  links.
 * - __index__ - offset of matched text
 * - __lastIndex__ - index of next char after mathch end
 * - __raw__ - matched text
 * - __text__ - normalized text
 * - __url__ - link, generated from matched text
 **/
LinkifyIt.prototype.match = function match(text) {
  var shift = 0, result = [];

  // Try to take previous element from cache, if .test() called before
  if (this.__index__ >= 0 && this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }

  // Cut head if cache was used
  var tail = shift ? text.slice(shift) : text;

  // Scan string until end reached
  while (this.test(tail)) {
    result.push(createMatch(this, shift));

    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }

  if (result.length) {
    return result;
  }

  return null;
};


/** chainable
 * LinkifyIt#tlds(list [, keepOld]) -> this
 * - list (Array): list of tlds
 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
 *
 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
 * to avoid false positives. By default this algorythm used:
 *
 * - hostname with any 2-letter root zones are ok.
 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
 *   are ok.
 * - encoded (`xn--...`) root zones are ok.
 *
 * If list is replaced, then exact match for 2-chars root zones will be checked.
 **/
LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
  list = Array.isArray(list) ? list : [ list ];

  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }

  this.__tlds__ = this.__tlds__.concat(list)
                                  .sort()
                                  .filter(function (el, idx, arr) {
                                    return el !== arr[idx - 1];
                                  })
                                  .reverse();

  compile(this);
  return this;
};

/**
 * LinkifyIt#normalize(match)
 *
 * Default normalizer (if schema does not define it's own).
 **/
LinkifyIt.prototype.normalize = function normalize(match) {

  // Do minimal possible changes by default. Need to collect feedback prior
  // to move forward https://github.com/markdown-it/linkify-it/issues/1

  if (!match.schema) { match.url = 'http://' + match.url; }

  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
    match.url = 'mailto:' + match.url;
  }
};


/**
 * LinkifyIt#onCompile()
 *
 * Override to modify basic RegExp-s.
 **/
LinkifyIt.prototype.onCompile = function onCompile() {
};


module.exports = LinkifyIt;


/***/ }),

/***/ "./node_modules/linkify-it/lib/re.js":
/*!*******************************************!*\
  !*** ./node_modules/linkify-it/lib/re.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



module.exports = function (opts) {
  var re = {};

  // Use direct extract instead of `regenerate` to reduse browserified size
  re.src_Any = __webpack_require__(/*! uc.micro/properties/Any/regex */ "./node_modules/uc.micro/properties/Any/regex.js").source;
  re.src_Cc  = __webpack_require__(/*! uc.micro/categories/Cc/regex */ "./node_modules/uc.micro/categories/Cc/regex.js").source;
  re.src_Z   = __webpack_require__(/*! uc.micro/categories/Z/regex */ "./node_modules/uc.micro/categories/Z/regex.js").source;
  re.src_P   = __webpack_require__(/*! uc.micro/categories/P/regex */ "./node_modules/uc.micro/categories/P/regex.js").source;

  // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
  re.src_ZPCc = [ re.src_Z, re.src_P, re.src_Cc ].join('|');

  // \p{\Z\Cc} (white spaces + control)
  re.src_ZCc = [ re.src_Z, re.src_Cc ].join('|');

  // Experimental. List of chars, completely prohibited in links
  // because can separate it from other part of text
  var text_separators = '[><\uff5c]';

  // All possible word characters (everything without punctuation, spaces & controls)
  // Defined via punctuation & spaces to save space
  // Should be something like \p{\L\N\S\M} (\w but without `_`)
  re.src_pseudo_letter       = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';
  // The same as abothe but without [0-9]
  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

  ////////////////////////////////////////////////////////////////////////////////

  re.src_ip4 =

    '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

  // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
  re.src_auth    = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';

  re.src_port =

    '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

  re.src_host_terminator =

    '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';

  re.src_path =

    '(?:' +
      '[/?#]' +
        '(?:' +
          '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-]).|' +
          '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' +
          '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' +
          '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' +
          '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' +
          "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" +
          "\\'(?=" + re.src_pseudo_letter + '|[-]).|' +  // allow `I'm_king` if no pair found
          '\\.{2,}[a-zA-Z0-9%/&]|' + // google has many dots in "google search" links (#66, #81).
                                     // github has ... in commit range links,
                                     // Restrict to
                                     // - english
                                     // - percent-encoded
                                     // - parts of file path
                                     // - params separator
                                     // until more examples found.
          '\\.(?!' + re.src_ZCc + '|[.]).|' +
          (opts && opts['---'] ?
            '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
            :
            '\\-+|'
          ) +
          '\\,(?!' + re.src_ZCc + ').|' +       // allow `,,,` in paths
          '\\!+(?!' + re.src_ZCc + '|[!]).|' +  // allow `!!!` in paths, but not at the end
          '\\?(?!' + re.src_ZCc + '|[?]).' +
        ')+' +
      '|\\/' +
    ')?';

  // Allow anything in markdown spec, forbid quote (") at the first position
  // because emails enclosed in quotes are far more common
  re.src_email_name =

    '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';

  re.src_xn =

    'xn--[a-z0-9\\-]{1,59}';

  // More to read about domain names
  // http://serverfault.com/questions/638260/

  re.src_domain_root =

    // Allow letters & digits (http://test1)
    '(?:' +
      re.src_xn +
      '|' +
      re.src_pseudo_letter + '{1,63}' +
    ')';

  re.src_domain =

    '(?:' +
      re.src_xn +
      '|' +
      '(?:' + re.src_pseudo_letter + ')' +
      '|' +
      '(?:' + re.src_pseudo_letter + '(?:-|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' +
    ')';

  re.src_host =

    '(?:' +
    // Don't need IP check, because digits are already allowed in normal domain names
    //   src_ip4 +
    // '|' +
      '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain/*_root*/ + ')' +
    ')';

  re.tpl_host_fuzzy =

    '(?:' +
      re.src_ip4 +
    '|' +
      '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' +
    ')';

  re.tpl_host_no_ip_fuzzy =

    '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';

  re.src_host_strict =

    re.src_host + re.src_host_terminator;

  re.tpl_host_fuzzy_strict =

    re.tpl_host_fuzzy + re.src_host_terminator;

  re.src_host_port_strict =

    re.src_host + re.src_port + re.src_host_terminator;

  re.tpl_host_port_fuzzy_strict =

    re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;

  re.tpl_host_port_no_ip_fuzzy_strict =

    re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;


  ////////////////////////////////////////////////////////////////////////////////
  // Main rules

  // Rude test fuzzy links by host, for quick deny
  re.tpl_host_fuzzy_test =

    'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';

  re.tpl_email_fuzzy =

      '(^|' + text_separators + '|"|\\(|' + re.src_ZCc + ')' +
      '(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';

  re.tpl_link_fuzzy =
      // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uff5c]|' + re.src_ZPCc + '))' +
      '((?![$+<=>^`|\uff5c])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';

  re.tpl_link_no_ip_fuzzy =
      // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uff5c]|' + re.src_ZPCc + '))' +
      '((?![$+<=>^`|\uff5c])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';

  return re;
};


/***/ }),

/***/ "./node_modules/markdown-it/index.js":
/*!*******************************************!*\
  !*** ./node_modules/markdown-it/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



module.exports = __webpack_require__(/*! ./lib/ */ "./node_modules/markdown-it/lib/index.js");


/***/ }),

/***/ "./node_modules/markdown-it/lib/common/entities.js":
/*!*********************************************************!*\
  !*** ./node_modules/markdown-it/lib/common/entities.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// HTML5 entities map: { name -> utf16string }
//


/*eslint quotes:0*/
module.exports = __webpack_require__(/*! entities/lib/maps/entities.json */ "./node_modules/entities/lib/maps/entities.json");


/***/ }),

/***/ "./node_modules/markdown-it/lib/common/html_blocks.js":
/*!************************************************************!*\
  !*** ./node_modules/markdown-it/lib/common/html_blocks.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
// List of valid html blocks names, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#html-blocks




module.exports = [
  'address',
  'article',
  'aside',
  'base',
  'basefont',
  'blockquote',
  'body',
  'caption',
  'center',
  'col',
  'colgroup',
  'dd',
  'details',
  'dialog',
  'dir',
  'div',
  'dl',
  'dt',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'frame',
  'frameset',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'head',
  'header',
  'hr',
  'html',
  'iframe',
  'legend',
  'li',
  'link',
  'main',
  'menu',
  'menuitem',
  'nav',
  'noframes',
  'ol',
  'optgroup',
  'option',
  'p',
  'param',
  'section',
  'source',
  'summary',
  'table',
  'tbody',
  'td',
  'tfoot',
  'th',
  'thead',
  'title',
  'tr',
  'track',
  'ul'
];


/***/ }),

/***/ "./node_modules/markdown-it/lib/common/html_re.js":
/*!********************************************************!*\
  !*** ./node_modules/markdown-it/lib/common/html_re.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
// Regexps to match html elements



var attr_name     = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

var unquoted      = '[^"\'=<>`\\x00-\\x20]+';
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';

var attr_value  = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

var attribute   = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

var open_tag    = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

var close_tag   = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment     = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing  = '<[?][\\s\\S]*?[?]>';
var declaration = '<![A-Z]+\\s+[^>]*>';
var cdata       = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment +
                        '|' + processing + '|' + declaration + '|' + cdata + ')');
var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

module.exports.HTML_TAG_RE = HTML_TAG_RE;
module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;


/***/ }),

/***/ "./node_modules/markdown-it/lib/common/utils.js":
/*!******************************************************!*\
  !*** ./node_modules/markdown-it/lib/common/utils.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Utilities
//



function _class(obj) { return Object.prototype.toString.call(obj); }

function isString(obj) { return _class(obj) === '[object String]'; }

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function has(object, key) {
  return _hasOwnProperty.call(object, key);
}

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) { return; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

// Remove element from array and put another array at those position.
// Useful for some operations with tokens
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) { return false; }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }
  // control codes
  if (c >= 0x00 && c <= 0x08) { return false; }
  if (c === 0x0B) { return false; }
  if (c >= 0x0E && c <= 0x1F) { return false; }
  if (c >= 0x7F && c <= 0x9F) { return false; }
  // out of range
  if (c > 0x10FFFF) { return false; }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}


var UNESCAPE_MD_RE  = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

var entities = __webpack_require__(/*! ./entities */ "./node_modules/markdown-it/lib/common/entities.js");

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  }

  if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ?
      parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);

    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }

  return match;
}

/*function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(ENTITY_RE, replaceEntityPattern);
}*/

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) { return str; }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) { return str; }

  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) { return escaped; }
    return replaceEntityPattern(match, entity);
  });
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////

function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }
  return false;
}

// Zs (unicode class) || [\t\f\v\r\n]
function isWhiteSpace(code) {
  if (code >= 0x2000 && code <= 0x200A) { return true; }
  switch (code) {
    case 0x09: // \t
    case 0x0A: // \n
    case 0x0B: // \v
    case 0x0C: // \f
    case 0x0D: // \r
    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////

/*eslint-disable max-len*/
var UNICODE_PUNCT_RE = __webpack_require__(/*! uc.micro/categories/P/regex */ "./node_modules/uc.micro/categories/P/regex.js");

// Currently without astral characters support.
function isPunctChar(ch) {
  return UNICODE_PUNCT_RE.test(ch);
}


// Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21/* ! */:
    case 0x22/* " */:
    case 0x23/* # */:
    case 0x24/* $ */:
    case 0x25/* % */:
    case 0x26/* & */:
    case 0x27/* ' */:
    case 0x28/* ( */:
    case 0x29/* ) */:
    case 0x2A/* * */:
    case 0x2B/* + */:
    case 0x2C/* , */:
    case 0x2D/* - */:
    case 0x2E/* . */:
    case 0x2F/* / */:
    case 0x3A/* : */:
    case 0x3B/* ; */:
    case 0x3C/* < */:
    case 0x3D/* = */:
    case 0x3E/* > */:
    case 0x3F/* ? */:
    case 0x40/* @ */:
    case 0x5B/* [ */:
    case 0x5C/* \ */:
    case 0x5D/* ] */:
    case 0x5E/* ^ */:
    case 0x5F/* _ */:
    case 0x60/* ` */:
    case 0x7B/* { */:
    case 0x7C/* | */:
    case 0x7D/* } */:
    case 0x7E/* ~ */:
      return true;
    default:
      return false;
  }
}

// Hepler to unify [reference labels].
//
function normalizeReference(str) {
  // Trim and collapse whitespace
  //
  str = str.trim().replace(/\s+/g, ' ');

  // In node v10 'ẞ'.toLowerCase() === 'Ṿ', which is presumed to be a bug
  // fixed in v12 (couldn't find any details).
  //
  // So treat this one as a special case
  // (remove this when node v10 is no longer supported).
  //
  if ('ẞ'.toLowerCase() === 'Ṿ') {
    str = str.replace(/ẞ/g, 'ß');
  }

  // .toLowerCase().toUpperCase() should get rid of all differences
  // between letter variants.
  //
  // Simple .toLowerCase() doesn't normalize 125 code points correctly,
  // and .toUpperCase doesn't normalize 6 of them (list of exceptions:
  // İ, ϴ, ẞ, Ω, K, Å - those are already uppercased, but have differently
  // uppercased versions).
  //
  // Here's an example showing how it happens. Lets take greek letter omega:
  // uppercase U+0398 (Θ), U+03f4 (ϴ) and lowercase U+03b8 (θ), U+03d1 (ϑ)
  //
  // Unicode entries:
  // 0398;GREEK CAPITAL LETTER THETA;Lu;0;L;;;;;N;;;;03B8;
  // 03B8;GREEK SMALL LETTER THETA;Ll;0;L;;;;;N;;;0398;;0398
  // 03D1;GREEK THETA SYMBOL;Ll;0;L;<compat> 03B8;;;;N;GREEK SMALL LETTER SCRIPT THETA;;0398;;0398
  // 03F4;GREEK CAPITAL THETA SYMBOL;Lu;0;L;<compat> 0398;;;;N;;;;03B8;
  //
  // Case-insensitive comparison should treat all of them as equivalent.
  //
  // But .toLowerCase() doesn't change ϑ (it's already lowercase),
  // and .toUpperCase() doesn't change ϴ (already uppercase).
  //
  // Applying first lower then upper case normalizes any character:
  // '\u0398\u03f4\u03b8\u03d1'.toLowerCase().toUpperCase() === '\u0398\u0398\u0398\u0398'
  //
  // Note: this is equivalent to unicode case folding; unicode normalization
  // is a different step that is not required here.
  //
  // Final result should be uppercased, because it's later stored in an object
  // (this avoid a conflict with Object.prototype members,
  // most notably, `__proto__`)
  //
  return str.toLowerCase().toUpperCase();
}

////////////////////////////////////////////////////////////////////////////////

// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//
exports.lib                 = {};
exports.lib.mdurl = __webpack_require__(/*! mdurl */ "./node_modules/mdurl/index.js");
exports.lib.ucmicro = __webpack_require__(/*! uc.micro */ "./node_modules/uc.micro/index.js");

exports.assign              = assign;
exports.isString            = isString;
exports.has                 = has;
exports.unescapeMd          = unescapeMd;
exports.unescapeAll         = unescapeAll;
exports.isValidEntityCode   = isValidEntityCode;
exports.fromCodePoint       = fromCodePoint;
// exports.replaceEntities     = replaceEntities;
exports.escapeHtml          = escapeHtml;
exports.arrayReplaceAt      = arrayReplaceAt;
exports.isSpace             = isSpace;
exports.isWhiteSpace        = isWhiteSpace;
exports.isMdAsciiPunct      = isMdAsciiPunct;
exports.isPunctChar         = isPunctChar;
exports.escapeRE            = escapeRE;
exports.normalizeReference  = normalizeReference;


/***/ }),

/***/ "./node_modules/markdown-it/lib/helpers/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/markdown-it/lib/helpers/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Just a shortcut for bulk export



exports.parseLinkLabel = __webpack_require__(/*! ./parse_link_label */ "./node_modules/markdown-it/lib/helpers/parse_link_label.js");
exports.parseLinkDestination = __webpack_require__(/*! ./parse_link_destination */ "./node_modules/markdown-it/lib/helpers/parse_link_destination.js");
exports.parseLinkTitle = __webpack_require__(/*! ./parse_link_title */ "./node_modules/markdown-it/lib/helpers/parse_link_title.js");


/***/ }),

/***/ "./node_modules/markdown-it/lib/helpers/parse_link_destination.js":
/*!************************************************************************!*\
  !*** ./node_modules/markdown-it/lib/helpers/parse_link_destination.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Parse link destination
//



var unescapeAll = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").unescapeAll;


module.exports = function parseLinkDestination(str, pos, max) {
  var code, level,
      lines = 0,
      start = pos,
      result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ''
      };

  if (str.charCodeAt(pos) === 0x3C /* < */) {
    pos++;
    while (pos < max) {
      code = str.charCodeAt(pos);
      if (code === 0x0A /* \n */) { return result; }
      if (code === 0x3C /* < */) { return result; }
      if (code === 0x3E /* > */) {
        result.pos = pos + 1;
        result.str = unescapeAll(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      }
      if (code === 0x5C /* \ */ && pos + 1 < max) {
        pos += 2;
        continue;
      }

      pos++;
    }

    // no closing '>'
    return result;
  }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = str.charCodeAt(pos);

    if (code === 0x20) { break; }

    // ascii control characters
    if (code < 0x20 || code === 0x7F) { break; }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      if (str.charCodeAt(pos + 1) === 0x20) { break; }
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
      level++;
      if (level > 32) { return result; }
    }

    if (code === 0x29 /* ) */) {
      if (level === 0) { break; }
      level--;
    }

    pos++;
  }

  if (start === pos) { return result; }
  if (level !== 0) { return result; }

  result.str = unescapeAll(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/helpers/parse_link_label.js":
/*!******************************************************************!*\
  !*** ./node_modules/markdown-it/lib/helpers/parse_link_label.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
// Parse link label
//
// this function assumes that first character ("[") already matches;
// returns the end of the label
//


module.exports = function parseLinkLabel(state, start, disableNested) {
  var level, found, marker, prevPos,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos;

  state.pos = start + 1;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5D /* ] */) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }

    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 0x5B /* [ */) {
      if (prevPos === state.pos - 1) {
        // increase level if we find text `[`, which is not a part of any token
        level++;
      } else if (disableNested) {
        state.pos = oldPos;
        return -1;
      }
    }
  }

  if (found) {
    labelEnd = state.pos;
  }

  // restore old state
  state.pos = oldPos;

  return labelEnd;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/helpers/parse_link_title.js":
/*!******************************************************************!*\
  !*** ./node_modules/markdown-it/lib/helpers/parse_link_title.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Parse link title
//



var unescapeAll = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").unescapeAll;


module.exports = function parseLinkTitle(str, pos, max) {
  var code,
      marker,
      lines = 0,
      start = pos,
      result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ''
      };

  if (pos >= max) { return result; }

  marker = str.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return result; }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) { marker = 0x29; }

  while (pos < max) {
    code = str.charCodeAt(pos);
    if (code === marker) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code === 0x28 /* ( */ && marker === 0x29 /* ) */) {
      return result;
    } else if (code === 0x0A) {
      lines++;
    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }

    pos++;
  }

  return result;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/markdown-it/lib/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Main parser class




var utils        = __webpack_require__(/*! ./common/utils */ "./node_modules/markdown-it/lib/common/utils.js");
var helpers      = __webpack_require__(/*! ./helpers */ "./node_modules/markdown-it/lib/helpers/index.js");
var Renderer     = __webpack_require__(/*! ./renderer */ "./node_modules/markdown-it/lib/renderer.js");
var ParserCore   = __webpack_require__(/*! ./parser_core */ "./node_modules/markdown-it/lib/parser_core.js");
var ParserBlock  = __webpack_require__(/*! ./parser_block */ "./node_modules/markdown-it/lib/parser_block.js");
var ParserInline = __webpack_require__(/*! ./parser_inline */ "./node_modules/markdown-it/lib/parser_inline.js");
var LinkifyIt    = __webpack_require__(/*! linkify-it */ "./node_modules/linkify-it/index.js");
var mdurl        = __webpack_require__(/*! mdurl */ "./node_modules/mdurl/index.js");
var punycode     = __webpack_require__(/*! punycode */ "../node_modules/punycode/punycode.es6.js");


var config = {
  default: __webpack_require__(/*! ./presets/default */ "./node_modules/markdown-it/lib/presets/default.js"),
  zero: __webpack_require__(/*! ./presets/zero */ "./node_modules/markdown-it/lib/presets/zero.js"),
  commonmark: __webpack_require__(/*! ./presets/commonmark */ "./node_modules/markdown-it/lib/presets/commonmark.js")
};

////////////////////////////////////////////////////////////////////////////////
//
// This validator can prohibit more than really needed to prevent XSS. It's a
// tradeoff to keep code simple and to be secure by default.
//
// If you need different setup - override validator method as you wish. Or
// replace it with dummy function and use external sanitizer.
//

var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

function validateLink(url) {
  // url should be normalized at this point, and existing entities are decoded
  var str = url.trim().toLowerCase();

  return BAD_PROTO_RE.test(str) ? (GOOD_DATA_RE.test(str) ? true : false) : true;
}

////////////////////////////////////////////////////////////////////////////////


var RECODE_HOSTNAME_FOR = [ 'http:', 'https:', 'mailto:' ];

function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) { /**/ }
    }
  }

  return mdurl.encode(mdurl.format(parsed));
}

function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) { /**/ }
    }
  }

  // add '%' to exclude list because of https://github.com/markdown-it/markdown-it/issues/720
  return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + '%');
}


/**
 * class MarkdownIt
 *
 * Main parser/renderer class.
 *
 * ##### Usage
 *
 * ```javascript
 * // node.js, "classic" way:
 * var MarkdownIt = require('markdown-it'),
 *     md = new MarkdownIt();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // node.js, the same, but with sugar:
 * var md = require('markdown-it')();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // browser without AMD, added to "window" on script load
 * // Note, there are no dash.
 * var md = window.markdownit();
 * var result = md.render('# markdown-it rulezz!');
 * ```
 *
 * Single line rendering, without paragraph wrap:
 *
 * ```javascript
 * var md = require('markdown-it')();
 * var result = md.renderInline('__markdown-it__ rulezz!');
 * ```
 **/

/**
 * new MarkdownIt([presetName, options])
 * - presetName (String): optional, `commonmark` / `zero`
 * - options (Object)
 *
 * Creates parser instanse with given config. Can be called without `new`.
 *
 * ##### presetName
 *
 * MarkdownIt provides named presets as a convenience to quickly
 * enable/disable active syntax rules and options for common use cases.
 *
 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
 *   similar to GFM, used when no preset name given. Enables all available rules,
 *   but still without html, typographer & autolinker.
 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
 *   For example, when you need only `bold` and `italic` markup and nothing else.
 *
 * ##### options:
 *
 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
 *   That's not safe! You may need external sanitizer to protect output from XSS.
 *   It's better to extend features via plugins, instead of enabling HTML.
 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
 *   world you will need HTML output.
 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
 *   Can be useful for external highlighters.
 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
 *   quotes beautification (smartquotes).
 * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
 *   pairs, when typographer enabled and smartquotes on. For example, you can
 *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
 *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
 *   return empty string if the source was not changed and should be escaped
 *   externaly. If result starts with <pre... internal wrapper is skipped.
 *
 * ##### Example
 *
 * ```javascript
 * // commonmark mode
 * var md = require('markdown-it')('commonmark');
 *
 * // default mode
 * var md = require('markdown-it')();
 *
 * // enable everything
 * var md = require('markdown-it')({
 *   html: true,
 *   linkify: true,
 *   typographer: true
 * });
 * ```
 *
 * ##### Syntax highlighting
 *
 * ```js
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return hljs.highlight(str, { language: lang, ignoreIllegals: true }).value;
 *       } catch (__) {}
 *     }
 *
 *     return ''; // use external default escaping
 *   }
 * });
 * ```
 *
 * Or with full wrapper override (if you need assign class to `<pre>`):
 *
 * ```javascript
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * // Actual default values
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return '<pre class="hljs"><code>' +
 *                hljs.highlight(str, { language: lang, ignoreIllegals: true }).value +
 *                '</code></pre>';
 *       } catch (__) {}
 *     }
 *
 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
 *   }
 * });
 * ```
 *
 **/
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }

  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = 'default';
    }
  }

  /**
   * MarkdownIt#inline -> ParserInline
   *
   * Instance of [[ParserInline]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.inline = new ParserInline();

  /**
   * MarkdownIt#block -> ParserBlock
   *
   * Instance of [[ParserBlock]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.block = new ParserBlock();

  /**
   * MarkdownIt#core -> Core
   *
   * Instance of [[Core]] chain executor. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.core = new ParserCore();

  /**
   * MarkdownIt#renderer -> Renderer
   *
   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules['my_token'] = myToken
   * ```
   *
   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
   **/
  this.renderer = new Renderer();

  /**
   * MarkdownIt#linkify -> LinkifyIt
   *
   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
   * rule.
   **/
  this.linkify = new LinkifyIt();

  /**
   * MarkdownIt#validateLink(url) -> Boolean
   *
   * Link validation function. CommonMark allows too much in links. By default
   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
   * except some embedded image types.
   *
   * You can change this behaviour:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * // enable everything
   * md.validateLink = function () { return true; }
   * ```
   **/
  this.validateLink = validateLink;

  /**
   * MarkdownIt#normalizeLink(url) -> String
   *
   * Function used to encode link url to a machine-readable format,
   * which includes url-encoding, punycode, etc.
   **/
  this.normalizeLink = normalizeLink;

  /**
   * MarkdownIt#normalizeLinkText(url) -> String
   *
   * Function used to decode link url to a human-readable format`
   **/
  this.normalizeLinkText = normalizeLinkText;


  // Expose utils & helpers for easy acces from plugins

  /**
   * MarkdownIt#utils -> utils
   *
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
   **/
  this.utils = utils;

  /**
   * MarkdownIt#helpers -> helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/
  this.helpers = utils.assign({}, helpers);


  this.options = {};
  this.configure(presetName);

  if (options) { this.set(options); }
}


/** chainable
 * MarkdownIt.set(options)
 *
 * Set parser options (in the same format as in constructor). Probably, you
 * will never need it, but you can change options after constructor call.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .set({ html: true, breaks: true })
 *             .set({ typographer, true });
 * ```
 *
 * __Note:__ To achieve the best possible performance, don't modify a
 * `markdown-it` instance options on the fly. If you need multiple configurations
 * it's best to create multiple instances and initialize each with separate
 * config.
 **/
MarkdownIt.prototype.set = function (options) {
  utils.assign(this.options, options);
  return this;
};


/** chainable, internal
 * MarkdownIt.configure(presets)
 *
 * Batch load of all options and compenent settings. This is internal method,
 * and you probably will not need it. But if you will - see available presets
 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
 *
 * We strongly recommend to use presets instead of direct config loads. That
 * will give better compatibility with next versions.
 **/
MarkdownIt.prototype.configure = function (presets) {
  var self = this, presetName;

  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) { throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name'); }
  }

  if (!presets) { throw new Error('Wrong `markdown-it` preset, can\'t be empty'); }

  if (presets.options) { self.set(presets.options); }

  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};


/** chainable
 * MarkdownIt.enable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to enable
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable list or rules. It will automatically find appropriate components,
 * containing rules with given names. If rule not found, and `ignoreInvalid`
 * not set - throws exception.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .enable(['sub', 'sup'])
 *             .disable('smartquotes');
 * ```
 **/
MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) { list = [ list ]; }

  [ 'core', 'block', 'inline' ].forEach(function (chain) {
    result = result.concat(this[chain].ruler.enable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.enable(list, true));

  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
  }

  return this;
};


/** chainable
 * MarkdownIt.disable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * The same as [[MarkdownIt.enable]], but turn specified rules off.
 **/
MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) { list = [ list ]; }

  [ 'core', 'block', 'inline' ].forEach(function (chain) {
    result = result.concat(this[chain].ruler.disable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.disable(list, true));

  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
  }
  return this;
};


/** chainable
 * MarkdownIt.use(plugin, params)
 *
 * Load specified plugin with given params into current parser instance.
 * It's just a sugar to call `plugin(md, params)` with curring.
 *
 * ##### Example
 *
 * ```javascript
 * var iterator = require('markdown-it-for-inline');
 * var md = require('markdown-it')()
 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
 *             });
 * ```
 **/
MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
  var args = [ this ].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};


/** internal
 * MarkdownIt.parse(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Parse input string and return list of block tokens (special token type
 * "inline" will contain list of inline tokens). You should not call this
 * method directly, until you write custom renderer (for example, to produce
 * AST).
 *
 * `env` is used to pass data between "distributed" rules and return additional
 * metadata like reference info, needed for the renderer. It also can be used to
 * inject data in specific cases. Usually, you will be ok to pass `{}`,
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== 'string') {
    throw new Error('Input data should be a String');
  }

  var state = new this.core.State(src, this, env);

  this.core.process(state);

  return state.tokens;
};


/**
 * MarkdownIt.render(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Render markdown string into html. It does all magic for you :).
 *
 * `env` can be used to inject additional metadata (`{}` by default).
 * But you will not need it with high probability. See also comment
 * in [[MarkdownIt.parse]].
 **/
MarkdownIt.prototype.render = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parse(src, env), this.options, env);
};


/** internal
 * MarkdownIt.parseInline(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
 * block tokens list with the single `inline` element, containing parsed inline
 * tokens in `children` property. Also updates `env` object.
 **/
MarkdownIt.prototype.parseInline = function (src, env) {
  var state = new this.core.State(src, this, env);

  state.inlineMode = true;
  this.core.process(state);

  return state.tokens;
};


/**
 * MarkdownIt.renderInline(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
 * will NOT be wrapped into `<p>` tags.
 **/
MarkdownIt.prototype.renderInline = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parseInline(src, env), this.options, env);
};


module.exports = MarkdownIt;


/***/ }),

/***/ "./node_modules/markdown-it/lib/parser_block.js":
/*!******************************************************!*\
  !*** ./node_modules/markdown-it/lib/parser_block.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/** internal
 * class ParserBlock
 *
 * Block-level tokenizer.
 **/



var Ruler           = __webpack_require__(/*! ./ruler */ "./node_modules/markdown-it/lib/ruler.js");


var _rules = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  [ 'table',      __webpack_require__(/*! ./rules_block/table */ "./node_modules/markdown-it/lib/rules_block/table.js"),      [ 'paragraph', 'reference' ] ],
  [ 'code',       __webpack_require__(/*! ./rules_block/code */ "./node_modules/markdown-it/lib/rules_block/code.js") ],
  [ 'fence',      __webpack_require__(/*! ./rules_block/fence */ "./node_modules/markdown-it/lib/rules_block/fence.js"),      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
  [ 'blockquote', __webpack_require__(/*! ./rules_block/blockquote */ "./node_modules/markdown-it/lib/rules_block/blockquote.js"), [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
  [ 'hr',         __webpack_require__(/*! ./rules_block/hr */ "./node_modules/markdown-it/lib/rules_block/hr.js"),         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
  [ 'list',       __webpack_require__(/*! ./rules_block/list */ "./node_modules/markdown-it/lib/rules_block/list.js"),       [ 'paragraph', 'reference', 'blockquote' ] ],
  [ 'reference',  __webpack_require__(/*! ./rules_block/reference */ "./node_modules/markdown-it/lib/rules_block/reference.js") ],
  [ 'html_block', __webpack_require__(/*! ./rules_block/html_block */ "./node_modules/markdown-it/lib/rules_block/html_block.js"), [ 'paragraph', 'reference', 'blockquote' ] ],
  [ 'heading',    __webpack_require__(/*! ./rules_block/heading */ "./node_modules/markdown-it/lib/rules_block/heading.js"),    [ 'paragraph', 'reference', 'blockquote' ] ],
  [ 'lheading',   __webpack_require__(/*! ./rules_block/lheading */ "./node_modules/markdown-it/lib/rules_block/lheading.js") ],
  [ 'paragraph',  __webpack_require__(/*! ./rules_block/paragraph */ "./node_modules/markdown-it/lib/rules_block/paragraph.js") ]
];


/**
 * new ParserBlock()
 **/
function ParserBlock() {
  /**
   * ParserBlock#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
  }
}


// Generate tokens for input range
//
ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var ok, i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      line = startLine,
      hasEmptyLines = false,
      maxNesting = state.md.options.maxNesting;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) { break; }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.sCount[line] < state.blkIndent) { break; }

    // If nesting level exceeded - skip tail to the end. That's not ordinary
    // situation and we should not care about content.
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) { break; }
    }

    // set state.tight if we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};


/**
 * ParserBlock.parse(str, md, env, outTokens)
 *
 * Process input string and push block tokens into `outTokens`
 **/
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) { return; }

  state = new this.State(src, md, env, outTokens);

  this.tokenize(state, state.line, state.lineMax);
};


ParserBlock.prototype.State = __webpack_require__(/*! ./rules_block/state_block */ "./node_modules/markdown-it/lib/rules_block/state_block.js");


module.exports = ParserBlock;


/***/ }),

/***/ "./node_modules/markdown-it/lib/parser_core.js":
/*!*****************************************************!*\
  !*** ./node_modules/markdown-it/lib/parser_core.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/** internal
 * class Core
 *
 * Top-level rules executor. Glues block/inline parsers and does intermediate
 * transformations.
 **/



var Ruler  = __webpack_require__(/*! ./ruler */ "./node_modules/markdown-it/lib/ruler.js");


var _rules = [
  [ 'normalize',      __webpack_require__(/*! ./rules_core/normalize */ "./node_modules/markdown-it/lib/rules_core/normalize.js")      ],
  [ 'block',          __webpack_require__(/*! ./rules_core/block */ "./node_modules/markdown-it/lib/rules_core/block.js")          ],
  [ 'inline',         __webpack_require__(/*! ./rules_core/inline */ "./node_modules/markdown-it/lib/rules_core/inline.js")         ],
  [ 'linkify',        __webpack_require__(/*! ./rules_core/linkify */ "./node_modules/markdown-it/lib/rules_core/linkify.js")        ],
  [ 'replacements',   __webpack_require__(/*! ./rules_core/replacements */ "./node_modules/markdown-it/lib/rules_core/replacements.js")   ],
  [ 'smartquotes',    __webpack_require__(/*! ./rules_core/smartquotes */ "./node_modules/markdown-it/lib/rules_core/smartquotes.js")    ]
];


/**
 * new Core()
 **/
function Core() {
  /**
   * Core#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}


/**
 * Core.process(state)
 *
 * Executes core chain rules.
 **/
Core.prototype.process = function (state) {
  var i, l, rules;

  rules = this.ruler.getRules('');

  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

Core.prototype.State = __webpack_require__(/*! ./rules_core/state_core */ "./node_modules/markdown-it/lib/rules_core/state_core.js");


module.exports = Core;


/***/ }),

/***/ "./node_modules/markdown-it/lib/parser_inline.js":
/*!*******************************************************!*\
  !*** ./node_modules/markdown-it/lib/parser_inline.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/** internal
 * class ParserInline
 *
 * Tokenizes paragraph content.
 **/



var Ruler           = __webpack_require__(/*! ./ruler */ "./node_modules/markdown-it/lib/ruler.js");


////////////////////////////////////////////////////////////////////////////////
// Parser rules

var _rules = [
  [ 'text',            __webpack_require__(/*! ./rules_inline/text */ "./node_modules/markdown-it/lib/rules_inline/text.js") ],
  [ 'newline',         __webpack_require__(/*! ./rules_inline/newline */ "./node_modules/markdown-it/lib/rules_inline/newline.js") ],
  [ 'escape',          __webpack_require__(/*! ./rules_inline/escape */ "./node_modules/markdown-it/lib/rules_inline/escape.js") ],
  [ 'backticks',       __webpack_require__(/*! ./rules_inline/backticks */ "./node_modules/markdown-it/lib/rules_inline/backticks.js") ],
  [ 'strikethrough',   __webpack_require__(/*! ./rules_inline/strikethrough */ "./node_modules/markdown-it/lib/rules_inline/strikethrough.js").tokenize ],
  [ 'emphasis',        __webpack_require__(/*! ./rules_inline/emphasis */ "./node_modules/markdown-it/lib/rules_inline/emphasis.js").tokenize ],
  [ 'link',            __webpack_require__(/*! ./rules_inline/link */ "./node_modules/markdown-it/lib/rules_inline/link.js") ],
  [ 'image',           __webpack_require__(/*! ./rules_inline/image */ "./node_modules/markdown-it/lib/rules_inline/image.js") ],
  [ 'autolink',        __webpack_require__(/*! ./rules_inline/autolink */ "./node_modules/markdown-it/lib/rules_inline/autolink.js") ],
  [ 'html_inline',     __webpack_require__(/*! ./rules_inline/html_inline */ "./node_modules/markdown-it/lib/rules_inline/html_inline.js") ],
  [ 'entity',          __webpack_require__(/*! ./rules_inline/entity */ "./node_modules/markdown-it/lib/rules_inline/entity.js") ]
];

var _rules2 = [
  [ 'balance_pairs',   __webpack_require__(/*! ./rules_inline/balance_pairs */ "./node_modules/markdown-it/lib/rules_inline/balance_pairs.js") ],
  [ 'strikethrough',   __webpack_require__(/*! ./rules_inline/strikethrough */ "./node_modules/markdown-it/lib/rules_inline/strikethrough.js").postProcess ],
  [ 'emphasis',        __webpack_require__(/*! ./rules_inline/emphasis */ "./node_modules/markdown-it/lib/rules_inline/emphasis.js").postProcess ],
  [ 'text_collapse',   __webpack_require__(/*! ./rules_inline/text_collapse */ "./node_modules/markdown-it/lib/rules_inline/text_collapse.js") ]
];


/**
 * new ParserInline()
 **/
function ParserInline() {
  var i;

  /**
   * ParserInline#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
  this.ruler = new Ruler();

  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -> Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler();

  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}


// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
ParserInline.prototype.skipToken = function (state) {
  var ok, i, pos = state.pos,
      rules = this.ruler.getRules(''),
      len = rules.length,
      maxNesting = state.md.options.maxNesting,
      cache = state.cache;


  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos];
    return;
  }

  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It's harmless to do here, because no tokens are created. But ideally,
      // we'd need a separate private state variable for this purpose.
      //
      state.level++;
      ok = rules[i](state, true);
      state.level--;

      if (ok) { break; }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax;
  }

  if (!ok) { state.pos++; }
  cache[pos] = state.pos;
};


// Generate tokens for input range
//
ParserInline.prototype.tokenize = function (state) {
  var ok, i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      end = state.posMax,
      maxNesting = state.md.options.maxNesting;

  while (state.pos < end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true

    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) { break; }
      }
    }

    if (ok) {
      if (state.pos >= end) { break; }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};


/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);

  this.tokenize(state);

  rules = this.ruler2.getRules('');
  len = rules.length;

  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};


ParserInline.prototype.State = __webpack_require__(/*! ./rules_inline/state_inline */ "./node_modules/markdown-it/lib/rules_inline/state_inline.js");


module.exports = ParserInline;


/***/ }),

/***/ "./node_modules/markdown-it/lib/presets/commonmark.js":
/*!************************************************************!*\
  !*** ./node_modules/markdown-it/lib/presets/commonmark.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
// Commonmark default options




module.exports = {
  options: {
    html:         true,         // Enable HTML tags in source
    xhtmlOut:     true,         // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   20            // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: [
        'normalize',
        'block',
        'inline'
      ]
    },

    block: {
      rules: [
        'blockquote',
        'code',
        'fence',
        'heading',
        'hr',
        'html_block',
        'lheading',
        'list',
        'reference',
        'paragraph'
      ]
    },

    inline: {
      rules: [
        'autolink',
        'backticks',
        'emphasis',
        'entity',
        'escape',
        'html_inline',
        'image',
        'link',
        'newline',
        'text'
      ],
      rules2: [
        'balance_pairs',
        'emphasis',
        'text_collapse'
      ]
    }
  }
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/presets/default.js":
/*!*********************************************************!*\
  !*** ./node_modules/markdown-it/lib/presets/default.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
// markdown-it default options




module.exports = {
  options: {
    html:         false,        // Enable HTML tags in source
    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   100            // Internal protection, recursion limit
  },

  components: {

    core: {},
    block: {},
    inline: {}
  }
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/presets/zero.js":
/*!******************************************************!*\
  !*** ./node_modules/markdown-it/lib/presets/zero.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
// "Zero" preset, with nothing enabled. Useful for manual configuring of simple
// modes. For example, to parse bold/italic only.




module.exports = {
  options: {
    html:         false,        // Enable HTML tags in source
    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   20            // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: [
        'normalize',
        'block',
        'inline'
      ]
    },

    block: {
      rules: [
        'paragraph'
      ]
    },

    inline: {
      rules: [
        'text'
      ],
      rules2: [
        'balance_pairs',
        'text_collapse'
      ]
    }
  }
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/renderer.js":
/*!**************************************************!*\
  !*** ./node_modules/markdown-it/lib/renderer.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * class Renderer
 *
 * Generates HTML from parsed token stream. Each instance has independent
 * copy of rules. Those can be rewritten with ease. Also, you can add new
 * rules if you create plugin and adds new token types.
 **/



var assign          = __webpack_require__(/*! ./common/utils */ "./node_modules/markdown-it/lib/common/utils.js").assign;
var unescapeAll     = __webpack_require__(/*! ./common/utils */ "./node_modules/markdown-it/lib/common/utils.js").unescapeAll;
var escapeHtml      = __webpack_require__(/*! ./common/utils */ "./node_modules/markdown-it/lib/common/utils.js").escapeHtml;


////////////////////////////////////////////////////////////////////////////////

var default_rules = {};


default_rules.code_inline = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return  '<code' + slf.renderAttrs(token) + '>' +
          escapeHtml(tokens[idx].content) +
          '</code>';
};


default_rules.code_block = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return  '<pre' + slf.renderAttrs(token) + '><code>' +
          escapeHtml(tokens[idx].content) +
          '</code></pre>\n';
};


default_rules.fence = function (tokens, idx, options, env, slf) {
  var token = tokens[idx],
      info = token.info ? unescapeAll(token.info).trim() : '',
      langName = '',
      langAttrs = '',
      highlighted, i, arr, tmpAttrs, tmpToken;

  if (info) {
    arr = info.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join('');
  }

  if (options.highlight) {
    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  if (highlighted.indexOf('<pre') === 0) {
    return highlighted + '\n';
  }

  // If language exists, inject class gently, without modifying original token.
  // May be, one day we will add .deepClone() for token and simplify this part, but
  // now we prefer to keep things local.
  if (info) {
    i        = token.attrIndex('class');
    tmpAttrs = token.attrs ? token.attrs.slice() : [];

    if (i < 0) {
      tmpAttrs.push([ 'class', options.langPrefix + langName ]);
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice();
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
    }

    // Fake token just to render attributes
    tmpToken = {
      attrs: tmpAttrs
    };

    return  '<pre><code' + slf.renderAttrs(tmpToken) + '>'
          + highlighted
          + '</code></pre>\n';
  }


  return  '<pre><code' + slf.renderAttrs(token) + '>'
        + highlighted
        + '</code></pre>\n';
};


default_rules.image = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  // "alt" attr MUST be set, even if empty. Because it's mandatory and
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex('alt')][1] =
    slf.renderInlineAsText(token.children, options, env);

  return slf.renderToken(tokens, idx, options);
};


default_rules.hardbreak = function (tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
default_rules.softbreak = function (tokens, idx, options /*, env */) {
  return options.breaks ? (options.xhtmlOut ? '<br />\n' : '<br>\n') : '\n';
};


default_rules.text = function (tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};


default_rules.html_block = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
default_rules.html_inline = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};


/**
 * new Renderer()
 *
 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
 **/
function Renderer() {

  /**
   * Renderer#rules -> Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.renderer.rules.strong_open  = function () { return '<b>'; };
   * md.renderer.rules.strong_close = function () { return '</b>'; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independent static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
  this.rules = assign({}, default_rules);
}


/**
 * Renderer.renderAttrs(token) -> String
 *
 * Render token attributes to string.
 **/
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  var i, l, result;

  if (!token.attrs) { return ''; }

  result = '';

  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }

  return result;
};


/**
 * Renderer.renderToken(tokens, idx, options) -> String
 * - tokens (Array): list of tokens
 * - idx (Numbed): token index to render
 * - options (Object): params of parser instance
 *
 * Default token renderer. Can be overriden by custom function
 * in [[Renderer#rules]].
 **/
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken,
      result = '',
      needLf = false,
      token = tokens[idx];

  // Tight list paragraphs
  if (token.hidden) {
    return '';
  }

  // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    >
  //
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += '\n';
  }

  // Add token name, e.g. `<img`
  result += (token.nesting === -1 ? '</' : '<') + token.tag;

  // Encode attributes, e.g. `<img src="foo"`
  result += this.renderAttrs(token);

  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
  if (token.nesting === 0 && options.xhtmlOut) {
    result += ' /';
  }

  // Check if we need to add a newline after this tag
  if (token.block) {
    needLf = true;

    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];

        if (nextToken.type === 'inline' || nextToken.hidden) {
          // Block-level tag containing an inline tag.
          //
          needLf = false;

        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
          //
          needLf = false;
        }
      }
    }
  }

  result += needLf ? '>\n' : '>';

  return result;
};


/**
 * Renderer.renderInline(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to render
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * The same as [[Renderer.render]], but for single token of `inline` type.
 **/
Renderer.prototype.renderInline = function (tokens, options, env) {
  var type,
      result = '',
      rules = this.rules;

  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }

  return result;
};


/** internal
 * Renderer.renderInlineAsText(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to render
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Special kludge for image `alt` attributes to conform CommonMark spec.
 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
 * instead of simple escaping.
 **/
Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
  var result = '';

  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === 'text') {
      result += tokens[i].content;
    } else if (tokens[i].type === 'image') {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    } else if (tokens[i].type === 'softbreak') {
      result += '\n';
    }
  }

  return result;
};


/**
 * Renderer.render(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to render
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Takes token stream and generates HTML. Probably, you will never need to call
 * this method directly.
 **/
Renderer.prototype.render = function (tokens, options, env) {
  var i, len, type,
      result = '',
      rules = this.rules;

  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== 'undefined') {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }

  return result;
};

module.exports = Renderer;


/***/ }),

/***/ "./node_modules/markdown-it/lib/ruler.js":
/*!***********************************************!*\
  !*** ./node_modules/markdown-it/lib/ruler.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
/**
 * class Ruler
 *
 * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
 * [[MarkdownIt#inline]] to manage sequences of functions (rules):
 *
 * - keep rules in defined order
 * - assign the name to each rule
 * - enable/disable rules
 * - add/replace rules
 * - allow assign rules to additional named chains (in the same)
 * - cacheing lists of active rules
 *
 * You will not need use this class directly until write plugins. For simple
 * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
 * [[MarkdownIt.use]].
 **/



/**
 * new Ruler()
 **/
function Ruler() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

////////////////////////////////////////////////////////////////////////////////
// Helper methods, should not be used directly


// Find rule index by name
//
Ruler.prototype.__find__ = function (name) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};


// Build rules lookup cache
//
Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [ '' ];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) { return; }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) { return; }

      if (chain && rule.alt.indexOf(chain) < 0) { return; }

      self.__cache__[chain].push(rule.fn);
    });
  });
};


/**
 * Ruler.at(name, fn [, options])
 * - name (String): rule name to replace.
 * - fn (Function): new rule function.
 * - options (Object): new rule options (not mandatory).
 *
 * Replace rule by name with new function & options. Throws error if name not
 * found.
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * Replace existing typographer replacement rule with new one:
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.at('replacements', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.at = function (name, fn, options) {
  var index = this.__find__(name);
  var opt = options || {};

  if (index === -1) { throw new Error('Parser rule not found: ' + name); }

  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};


/**
 * Ruler.before(beforeName, ruleName, fn [, options])
 * - beforeName (String): new rule will be added before this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain before one with given name. See also
 * [[Ruler.after]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt = options || {};

  if (index === -1) { throw new Error('Parser rule not found: ' + beforeName); }

  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};


/**
 * Ruler.after(afterName, ruleName, fn [, options])
 * - afterName (String): new rule will be added after this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain after one with given name. See also
 * [[Ruler.before]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt = options || {};

  if (index === -1) { throw new Error('Parser rule not found: ' + afterName); }

  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.push(ruleName, fn [, options])
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Push new rule to the end of chain. See also
 * [[Ruler.before]], [[Ruler.after]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.push('my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};


/**
 * Ruler.enable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to enable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.enable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) { list = [ list ]; }

  var result = [];

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) { return; }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};


/**
 * Ruler.enableOnly(list [, ignoreInvalid])
 * - list (String|Array): list of rule names to enable (whitelist).
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names, and disable everything else. If any rule name
 * not found - throw Error. Errors can be disabled by second param.
 *
 * See also [[Ruler.disable]], [[Ruler.enable]].
 **/
Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) { list = [ list ]; }

  this.__rules__.forEach(function (rule) { rule.enabled = false; });

  this.enable(list, ignoreInvalid);
};


/**
 * Ruler.disable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Disable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.disable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) { list = [ list ]; }

  var result = [];

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) { return; }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};


/**
 * Ruler.getRules(chainName) -> Array
 *
 * Return array of active functions (rules) for given chain name. It analyzes
 * rules configuration, compiles caches if not exists and returns result.
 *
 * Default chain name is `''` (empty string). It can't be skipped. That's
 * done intentionally, to keep signature monomorphic for high speed.
 **/
Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }

  // Chain can be empty, if rules disabled. But we still have to return Array.
  return this.__cache__[chainName] || [];
};

module.exports = Ruler;


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/blockquote.js":
/*!****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/blockquote.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Block quotes



var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;


module.exports = function blockquote(state, startLine, endLine, silent) {
  var adjustTab,
      ch,
      i,
      initial,
      l,
      lastLineEmpty,
      lines,
      nextLine,
      offset,
      oldBMarks,
      oldBSCount,
      oldIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      spaceAfterMarker,
      terminate,
      terminatorRules,
      token,
      isOutdented,
      oldLineMax = state.lineMax,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) { return true; }

  // set offset past spaces and ">"
  initial = offset = state.sCount[startLine] + 1;

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20 /* space */) {
    // ' >   test '
    //     ^ -- position start of line here:
    pos++;
    initial++;
    offset++;
    adjustTab = false;
    spaceAfterMarker = true;
  } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
    spaceAfterMarker = true;

    if ((state.bsCount[startLine] + offset) % 4 === 3) {
      // '  >\t  test '
      //       ^ -- position start of line here (tab has width===1)
      pos++;
      initial++;
      offset++;
      adjustTab = false;
    } else {
      // ' >\t  test '
      //    ^ -- position start of line here + shift bsCount slightly
      //         to make extra space appear
      adjustTab = true;
    }
  } else {
    spaceAfterMarker = false;
  }

  oldBMarks = [ state.bMarks[startLine] ];
  state.bMarks[startLine] = pos;

  while (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (isSpace(ch)) {
      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }

    pos++;
  }

  oldBSCount = [ state.bsCount[startLine] ];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);

  lastLineEmpty = pos >= max;

  oldSCount = [ state.sCount[startLine] ];
  state.sCount[startLine] = offset - initial;

  oldTShift = [ state.tShift[startLine] ];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.md.block.ruler.getRules('blockquote');

  oldParentType = state.parentType;
  state.parentType = 'blockquote';

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag:
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    // check if it's outdented, i.e. it's inside list item and indented
    // less than said list item:
    //
    // ```
    // 1. anything
    //    > current blockquote
    // 2. checking this line
    // ```
    isOutdented = state.sCount[nextLine] < state.blkIndent;

    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E/* > */ && !isOutdented) {
      // This line is inside the blockquote.

      // set offset past spaces and ">"
      initial = offset = state.sCount[nextLine] + 1;

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20 /* space */) {
        // ' >   test '
        //     ^ -- position start of line here:
        pos++;
        initial++;
        offset++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
        spaceAfterMarker = true;

        if ((state.bsCount[nextLine] + offset) % 4 === 3) {
          // '  >\t  test '
          //       ^ -- position start of line here (tab has width===1)
          pos++;
          initial++;
          offset++;
          adjustTab = false;
        } else {
          // ' >\t  test '
          //    ^ -- position start of line here + shift bsCount slightly
          //         to make extra space appear
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (isSpace(ch)) {
          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }

        pos++;
      }

      lastLineEmpty = pos >= max;

      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);

      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) { break; }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      // Quirk to enforce "hard termination mode" for paragraphs;
      // normally if you call `tokenize(state, startLine, nextLine)`,
      // paragraphs will look below nextLine for paragraph continuation,
      // but if blockquote is terminated by another tag, they shouldn't
      state.lineMax = nextLine;

      if (state.blkIndent !== 0) {
        // state.blkIndent was non-zero, we now set it to zero,
        // so we need to re-calculate all offsets to appear as
        // if indent wasn't changed
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }

      break;
    }

    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);

    // A negative indentation means that this is a paragraph continuation
    //
    state.sCount[nextLine] = -1;
  }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  token        = state.push('blockquote_open', 'blockquote', 1);
  token.markup = '>';
  token.map    = lines = [ startLine, 0 ];

  state.md.block.tokenize(state, startLine, nextLine);

  token        = state.push('blockquote_close', 'blockquote', -1);
  token.markup = '>';

  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;

  return true;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/code.js":
/*!**********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/code.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
// Code block (4 spaces padded)




module.exports = function code(state, startLine, endLine/*, silent*/) {
  var nextLine, last, token;

  if (state.sCount[startLine] - state.blkIndent < 4) { return false; }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = last;

  token         = state.push('code_block', 'code', 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + '\n';
  token.map     = [ startLine, state.line ];

  return true;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/fence.js":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/fence.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
// fences (``` lang, ~~~ lang)




module.exports = function fence(state, startLine, endLine, silent) {
  var marker, len, params, nextLine, mem, token, markup,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  if (pos + 3 > max) { return false; }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {
    return false;
  }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) { return false; }

  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);

  if (marker === 0x60 /* ` */) {
    if (params.indexOf(String.fromCharCode(marker)) >= 0) {
      return false;
    }
  }

  // Since start is found, we can report success here in validation mode
  if (silent) { return true; }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) { continue; }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) { continue; }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) { continue; }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.sCount[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);

  token         = state.push('fence', 'code', 0);
  token.info    = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup  = markup;
  token.map     = [ startLine, state.line ];

  return true;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/heading.js":
/*!*************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/heading.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// heading (#, ##, ...)



var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;


module.exports = function heading(state, startLine, endLine, silent) {
  var ch, level, tmp, token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  ch  = state.src.charCodeAt(pos);

  if (ch !== 0x23/* # */ || pos >= max) { return false; }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23/* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || (pos < max && !isSpace(ch))) { return false; }

  if (silent) { return true; }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }

  state.line = startLine + 1;

  token        = state.push('heading_open', 'h' + String(level), 1);
  token.markup = '########'.slice(0, level);
  token.map    = [ startLine, state.line ];

  token          = state.push('inline', '', 0);
  token.content  = state.src.slice(pos, max).trim();
  token.map      = [ startLine, state.line ];
  token.children = [];

  token        = state.push('heading_close', 'h' + String(level), -1);
  token.markup = '########'.slice(0, level);

  return true;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/hr.js":
/*!********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/hr.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Horizontal rule



var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;


module.exports = function hr(state, startLine, endLine, silent) {
  var marker, cnt, ch, token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A/* * */ &&
      marker !== 0x2D/* - */ &&
      marker !== 0x5F/* _ */) {
    return false;
  }

  // markers can be mixed with spaces, but there should be at least 3 of them

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) { return false; }
    if (ch === marker) { cnt++; }
  }

  if (cnt < 3) { return false; }

  if (silent) { return true; }

  state.line = startLine + 1;

  token        = state.push('hr', 'hr', 0);
  token.map    = [ startLine, state.line ];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

  return true;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/html_block.js":
/*!****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/html_block.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// HTML block




var block_names = __webpack_require__(/*! ../common/html_blocks */ "./node_modules/markdown-it/lib/common/html_blocks.js");
var HTML_OPEN_CLOSE_TAG_RE = __webpack_require__(/*! ../common/html_re */ "./node_modules/markdown-it/lib/common/html_re.js").HTML_OPEN_CLOSE_TAG_RE;

// An array of opening and corresponding closing sequences for html tags,
// last argument defines whether it can terminate a paragraph or not
//
var HTML_SEQUENCES = [
  [ /^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true ],
  [ /^<!--/,        /-->/,   true ],
  [ /^<\?/,         /\?>/,   true ],
  [ /^<![A-Z]/,     />/,     true ],
  [ /^<!\[CDATA\[/, /\]\]>/, true ],
  [ new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true ],
  [ new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'),  /^$/, false ]
];


module.exports = function html_block(state, startLine, endLine, silent) {
  var i, nextLine, token, lineText,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  if (!state.md.options.html) { return false; }

  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

  lineText = state.src.slice(pos, max);

  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) { break; }
  }

  if (i === HTML_SEQUENCES.length) { return false; }

  if (silent) {
    // true if this sequence can be a terminator, false otherwise
    return HTML_SEQUENCES[i][2];
  }

  nextLine = startLine + 1;

  // If we are here - we detected HTML block.
  // Let's roll down till block end.
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) { break; }

      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);

      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) { nextLine++; }
        break;
      }
    }
  }

  state.line = nextLine;

  token         = state.push('html_block', '', 0);
  token.map     = [ startLine, nextLine ];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

  return true;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/lheading.js":
/*!**************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/lheading.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
// lheading (---, ===)




module.exports = function lheading(state, startLine, endLine/*, silent*/) {
  var content, terminate, i, l, token, pos, max, level, marker,
      nextLine = startLine + 1, oldParentType,
      terminatorRules = state.md.block.ruler.getRules('paragraph');

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  oldParentType = state.parentType;
  state.parentType = 'paragraph'; // use paragraph to match terminatorRules

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }

    //
    // Check for underline in setext header
    //
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max) {
        marker = state.src.charCodeAt(pos);

        if (marker === 0x2D/* - */ || marker === 0x3D/* = */) {
          pos = state.skipChars(pos, marker);
          pos = state.skipSpaces(pos);

          if (pos >= max) {
            level = (marker === 0x3D/* = */ ? 1 : 2);
            break;
          }
        }
      }
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) { continue; }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }
  }

  if (!level) {
    // Didn't find valid underline
    return false;
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine + 1;

  token          = state.push('heading_open', 'h' + String(level), 1);
  token.markup   = String.fromCharCode(marker);
  token.map      = [ startLine, state.line ];

  token          = state.push('inline', '', 0);
  token.content  = content;
  token.map      = [ startLine, state.line - 1 ];
  token.children = [];

  token          = state.push('heading_close', 'h' + String(level), -1);
  token.markup   = String.fromCharCode(marker);

  state.parentType = oldParentType;

  return true;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/list.js":
/*!**********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/list.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Lists



var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;


// Search `[-+*][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max, ch;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A/* * */ &&
      marker !== 0x2D/* - */ &&
      marker !== 0x2B/* + */) {
    return -1;
  }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " -test " - is not a list item
      return -1;
    }
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      start = state.bMarks[startLine] + state.tShift[startLine],
      pos = start,
      max = state.eMarks[startLine];

  // List marker should have at least 2 chars (digit + dot)
  if (pos + 1 >= max) { return -1; }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }

  for (;;) {
    // EOL -> fail
    if (pos >= max) { return -1; }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {

      // List marker should have no more than 9 digits
      // (prevents integer overflow in browsers)
      if (pos - start >= 10) { return -1; }

      continue;
    }

    // found valid marker
    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {
      break;
    }

    return -1;
  }


  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " 1.test " - is not a list item
      return -1;
    }
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i, l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}


module.exports = function list(state, startLine, endLine, silent) {
  var ch,
      contentStart,
      i,
      indent,
      indentAfterMarker,
      initial,
      isOrdered,
      itemLines,
      l,
      listLines,
      listTokIdx,
      markerCharCode,
      markerValue,
      max,
      nextLine,
      offset,
      oldListIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      oldTight,
      pos,
      posAfterMarker,
      prevEmptyEnd,
      start,
      terminate,
      terminatorRules,
      token,
      isTerminatingParagraph = false,
      tight = true;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  // Special case:
  //  - item 1
  //   - item 2
  //    - item 3
  //     - item 4
  //      - this one is a paragraph continuation
  if (state.listIndent >= 0 &&
      state.sCount[startLine] - state.listIndent >= 4 &&
      state.sCount[startLine] < state.blkIndent) {
    return false;
  }

  // limit conditions when list can interrupt
  // a paragraph (validation mode only)
  if (silent && state.parentType === 'paragraph') {
    // Next list item should still terminate previous list item;
    //
    // This code can fail if plugins use blkIndent as well as lists,
    // but I hope the spec gets fixed long before that happens.
    //
    if (state.sCount[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.slice(start, posAfterMarker - 1));

    // If we're starting a new ordered list right after
    // a paragraph, it should start with 1.
    if (isTerminatingParagraph && markerValue !== 1) return false;

  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;

  } else {
    return false;
  }

  // If we're starting a new unordered list right after
  // a paragraph, first line should not be empty.
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
  }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) { return true; }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    token       = state.push('ordered_list_open', 'ol', 1);
    if (markerValue !== 1) {
      token.attrs = [ [ 'start', markerValue ] ];
    }

  } else {
    token       = state.push('bullet_list_open', 'ul', 1);
  }

  token.map    = listLines = [ startLine, 0 ];
  token.markup = String.fromCharCode(markerCharCode);

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules('list');

  oldParentType = state.parentType;
  state.parentType = 'list';

  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];

    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

    while (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 0x20) {
        offset++;
      } else {
        break;
      }

      pos++;
    }

    contentStart = pos;

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) { indentAfterMarker = 1; }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = initial + indentAfterMarker;

    // Run subparser & write tokens
    token        = state.push('list_item_open', 'li', 1);
    token.markup = String.fromCharCode(markerCharCode);
    token.map    = itemLines = [ startLine, 0 ];
    if (isOrdered) {
      token.info = state.src.slice(start, posAfterMarker - 1);
    }

    // change current state, then restore it after parser subcall
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldSCount = state.sCount[startLine];

    //  - example list
    // ^ listIndent position will be here
    //   ^ blkIndent position will be here
    //
    oldListIndent = state.listIndent;
    state.listIndent = state.blkIndent;
    state.blkIndent = indent;

    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;

    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      // workaround for this case
      // (list item is empty, list terminates before "foo"):
      // ~~~~~~~~
      //   -
      //
      //     foo
      // ~~~~~~~~
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = state.listIndent;
    state.listIndent = oldListIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldSCount;
    state.tight = oldTight;

    token        = state.push('list_item_close', 'li', -1);
    token.markup = String.fromCharCode(markerCharCode);

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) { break; }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.sCount[nextLine] < state.blkIndent) { break; }

    // if it's indented more than 3 spaces, it should be a code block
    if (state.sCount[startLine] - state.blkIndent >= 4) { break; }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) { break; }
      start = state.bMarks[nextLine] + state.tShift[nextLine];
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) { break; }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }
  }

  // Finalize list
  if (isOrdered) {
    token = state.push('ordered_list_close', 'ol', -1);
  } else {
    token = state.push('bullet_list_close', 'ul', -1);
  }
  token.markup = String.fromCharCode(markerCharCode);

  listLines[1] = nextLine;
  state.line = nextLine;

  state.parentType = oldParentType;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/paragraph.js":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/paragraph.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
// Paragraph




module.exports = function paragraph(state, startLine/*, endLine*/) {
  var content, terminate, i, l, token, oldParentType,
      nextLine = startLine + 1,
      terminatorRules = state.md.block.ruler.getRules('paragraph'),
      endLine = state.lineMax;

  oldParentType = state.parentType;
  state.parentType = 'paragraph';

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) { continue; }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;

  token          = state.push('paragraph_open', 'p', 1);
  token.map      = [ startLine, state.line ];

  token          = state.push('inline', '', 0);
  token.content  = content;
  token.map      = [ startLine, state.line ];
  token.children = [];

  token          = state.push('paragraph_close', 'p', -1);

  state.parentType = oldParentType;

  return true;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/reference.js":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/reference.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



var normalizeReference   = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").normalizeReference;
var isSpace              = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;


module.exports = function reference(state, startLine, _endLine, silent) {
  var ch,
      destEndPos,
      destEndLineNo,
      endLine,
      href,
      i,
      l,
      label,
      labelEnd,
      oldParentType,
      res,
      start,
      str,
      terminate,
      terminatorRules,
      title,
      lines = 0,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine],
      nextLine = startLine + 1;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false; }

  // Simple check to quickly interrupt scan on [link](url) at the start of line.
  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&
        state.src.charCodeAt(pos - 1) !== 0x5C/* \ */) {
      if (pos + 1 === max) { return false; }
      if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false; }
      break;
    }
  }

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  terminatorRules = state.md.block.ruler.getRules('reference');

  oldParentType = state.parentType;
  state.parentType = 'reference';

  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) { continue; }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }
  }

  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;

  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x5B /* [ */) {
      return false;
    } else if (ch === 0x5D /* ] */) {
      labelEnd = pos;
      break;
    } else if (ch === 0x0A /* \n */) {
      lines++;
    } else if (ch === 0x5C /* \ */) {
      pos++;
      if (pos < max && str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }
  }

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false; }

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  res = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) { return false; }

  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) { return false; }

  pos = res.pos;
  lines += res.lines;

  // save cursor state, we could require to rollback later
  destEndPos = pos;
  destEndLineNo = lines;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  res = state.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = '';
    pos = destEndPos;
    lines = destEndLineNo;
  }

  // skip trailing spaces until the rest of the line
  while (pos < max) {
    ch = str.charCodeAt(pos);
    if (!isSpace(ch)) { break; }
    pos++;
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    if (title) {
      // garbage at the end of the line after title,
      // but it could still be a valid reference if we roll back
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) { break; }
        pos++;
      }
    }
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    // garbage at the end of the line
    return false;
  }

  label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    // CommonMark 0.20 disallows empty labels
    return false;
  }

  // Reference can not terminate anything. This check is for safety only.
  /*istanbul ignore if*/
  if (silent) { return true; }

  if (typeof state.env.references === 'undefined') {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === 'undefined') {
    state.env.references[label] = { title: title, href: href };
  }

  state.parentType = oldParentType;

  state.line = startLine + lines + 1;
  return true;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/state_block.js":
/*!*****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/state_block.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Parser state class



var Token = __webpack_require__(/*! ../token */ "./node_modules/markdown-it/lib/token.js");
var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;


function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;

  this.src = src;

  // link to parser instance
  this.md     = md;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = [];  // line begin offsets for fast jumps
  this.eMarks = [];  // line end offsets for fast jumps
  this.tShift = [];  // offsets of the first non-space characters (tabs not expanded)
  this.sCount = [];  // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It's used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent  = 0; // required block content indent (for example, if we are
                       // inside a list, it would be positioned after list marker)
  this.line       = 0; // line index in src
  this.lineMax    = 0; // lines count
  this.tight      = false;  // loose/tight mode for lists
  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)
  this.listIndent = -1; // indent of the current list block (-1 if there isn't any)

  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
  // used in lists to determine if they interrupt a paragraph
  this.parentType = 'root';

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) { pos++; }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);

      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

// Push new token to "stream".
//
StateBlock.prototype.push = function (type, tag, nesting) {
  var token = new Token(type, tag, nesting);
  token.block = true;

  if (nesting < 0) this.level--; // closing tag
  token.level = this.level;
  if (nesting > 0) this.level++; // opening tag

  this.tokens.push(token);
  return token;
};

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;

  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) { break; }
  }
  return pos;
};

// Skip spaces from given position in reverse.
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) { return pos; }

  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) { return pos + 1; }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) { break; }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) { return pos; }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i, lineIndent, ch, first, last, queue, lineStart,
      line = begin;

  if (begin >= end) {
    return '';
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    while (first < last && lineIndent < indent) {
      ch = this.src.charCodeAt(first);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        // patched tShift masked characters to look like spaces (blockquotes, list markers)
        lineIndent++;
      } else {
        break;
      }

      first++;
    }

    if (lineIndent > indent) {
      // partially expanding tabs in code blocks, e.g '\t\tfoobar'
      // with indent=2 becomes '  \tfoobar'
      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }

  return queue.join('');
};

// re-export Token class to use in block rules
StateBlock.prototype.Token = Token;


module.exports = StateBlock;


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/table.js":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/table.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// GFM table, https://github.github.com/gfm/#tables-extension-



var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;


function getLine(state, line) {
  var pos = state.bMarks[line] + state.tShift[line],
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

function escapedSplit(str) {
  var result = [],
      pos = 0,
      max = str.length,
      ch,
      isEscaped = false,
      lastPos = 0,
      current = '';

  ch  = str.charCodeAt(pos);

  while (pos < max) {
    if (ch === 0x7c/* | */) {
      if (!isEscaped) {
        // pipe separating cells, '|'
        result.push(current + str.substring(lastPos, pos));
        current = '';
        lastPos = pos + 1;
      } else {
        // escaped pipe, '\|'
        current += str.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }

    isEscaped = (ch === 0x5c/* \ */);
    pos++;

    ch = str.charCodeAt(pos);
  }

  result.push(current + str.substring(lastPos));

  return result;
}


module.exports = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, l, nextLine, columns, columnCount, token,
      aligns, t, tableLines, tbodyLines, oldParentType, terminate,
      terminatorRules, firstCh, secondCh;

  // should have at least two lines
  if (startLine + 2 > endLine) { return false; }

  nextLine = startLine + 1;

  if (state.sCount[nextLine] < state.blkIndent) { return false; }

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[nextLine] - state.blkIndent >= 4) { return false; }

  // first character of the second line should be '|', '-', ':',
  // and no other characters are allowed but spaces;
  // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) { return false; }

  firstCh = state.src.charCodeAt(pos++);
  if (firstCh !== 0x7C/* | */ && firstCh !== 0x2D/* - */ && firstCh !== 0x3A/* : */) { return false; }

  if (pos >= state.eMarks[nextLine]) { return false; }

  secondCh = state.src.charCodeAt(pos++);
  if (secondCh !== 0x7C/* | */ && secondCh !== 0x2D/* - */ && secondCh !== 0x3A/* : */ && !isSpace(secondCh)) {
    return false;
  }

  // if first character is '-', then second character must not be a space
  // (due to parsing ambiguity with list)
  if (firstCh === 0x2D/* - */ && isSpace(secondCh)) { return false; }

  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);

    if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */ && !isSpace(ch)) { return false; }

    pos++;
  }

  lineText = getLine(state, startLine + 1);

  columns = lineText.split('|');
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t = columns[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) { return false; }
    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {
      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');
    } else if (t.charCodeAt(0) === 0x3A/* : */) {
      aligns.push('left');
    } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) { return false; }
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === '') columns.shift();
  if (columns.length && columns[columns.length - 1] === '') columns.pop();

  // header row will define an amount of columns in the entire table,
  // and align row should be exactly the same (the rest of the rows can differ)
  columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) { return false; }

  if (silent) { return true; }

  oldParentType = state.parentType;
  state.parentType = 'table';

  // use 'blockquote' lists for termination because it's
  // the most similar to tables
  terminatorRules = state.md.block.ruler.getRules('blockquote');

  token     = state.push('table_open', 'table', 1);
  token.map = tableLines = [ startLine, 0 ];

  token     = state.push('thead_open', 'thead', 1);
  token.map = [ startLine, startLine + 1 ];

  token     = state.push('tr_open', 'tr', 1);
  token.map = [ startLine, startLine + 1 ];

  for (i = 0; i < columns.length; i++) {
    token          = state.push('th_open', 'th', 1);
    if (aligns[i]) {
      token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];
    }

    token          = state.push('inline', '', 0);
    token.content  = columns[i].trim();
    token.children = [];

    token          = state.push('th_close', 'th', -1);
  }

  token     = state.push('tr_close', 'tr', -1);
  token     = state.push('thead_close', 'thead', -1);

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) { break; }

    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) { break; }
    lineText = getLine(state, nextLine).trim();
    if (!lineText) { break; }
    if (state.sCount[nextLine] - state.blkIndent >= 4) { break; }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === '') columns.shift();
    if (columns.length && columns[columns.length - 1] === '') columns.pop();

    if (nextLine === startLine + 2) {
      token     = state.push('tbody_open', 'tbody', 1);
      token.map = tbodyLines = [ startLine + 2, 0 ];
    }

    token     = state.push('tr_open', 'tr', 1);
    token.map = [ nextLine, nextLine + 1 ];

    for (i = 0; i < columnCount; i++) {
      token          = state.push('td_open', 'td', 1);
      if (aligns[i]) {
        token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];
      }

      token          = state.push('inline', '', 0);
      token.content  = columns[i] ? columns[i].trim() : '';
      token.children = [];

      token          = state.push('td_close', 'td', -1);
    }
    token = state.push('tr_close', 'tr', -1);
  }

  if (tbodyLines) {
    token = state.push('tbody_close', 'tbody', -1);
    tbodyLines[1] = nextLine;
  }

  token = state.push('table_close', 'table', -1);
  tableLines[1] = nextLine;

  state.parentType = oldParentType;
  state.line = nextLine;
  return true;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/block.js":
/*!**********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/block.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";



module.exports = function block(state) {
  var token;

  if (state.inlineMode) {
    token          = new state.Token('inline', '', 0);
    token.content  = state.src;
    token.map      = [ 0, 1 ];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/inline.js":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/inline.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function inline(state) {
  var tokens = state.tokens, tok, i, l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/linkify.js":
/*!************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/linkify.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Replace link-like texts with link nodes.
//
// Currently restricted by `md.validateLink()` to http/https/ftp
//



var arrayReplaceAt = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").arrayReplaceAt;


function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}


module.exports = function linkify(state) {
  var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos,
      level, htmlLinkLevel, url, fullUrl, urlText,
      blockTokens = state.tokens,
      links;

  if (!state.md.options.linkify) { return; }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline' ||
        !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }

    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];

      // Skip content of markdown links
      if (currentToken.type === 'link_close') {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (currentToken.type === 'html_inline') {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) { continue; }

      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

        text = currentToken.content;
        links = state.md.linkify.match(text);

        // Now split string to nodes
        nodes = [];
        level = currentToken.level;
        lastPos = 0;

        for (ln = 0; ln < links.length; ln++) {

          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) { continue; }

          urlText = links[ln].text;

          // Linkifier might send raw hostnames like "example.com", where url
          // starts with domain name. So we prepend http:// in those cases,
          // and remove it afterwards.
          //
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }

          pos = links[ln].index;

          if (pos > lastPos) {
            token         = new state.Token('text', '', 0);
            token.content = text.slice(lastPos, pos);
            token.level   = level;
            nodes.push(token);
          }

          token         = new state.Token('link_open', 'a', 1);
          token.attrs   = [ [ 'href', fullUrl ] ];
          token.level   = level++;
          token.markup  = 'linkify';
          token.info    = 'auto';
          nodes.push(token);

          token         = new state.Token('text', '', 0);
          token.content = urlText;
          token.level   = level;
          nodes.push(token);

          token         = new state.Token('link_close', 'a', -1);
          token.level   = --level;
          token.markup  = 'linkify';
          token.info    = 'auto';
          nodes.push(token);

          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text.length) {
          token         = new state.Token('text', '', 0);
          token.content = text.slice(lastPos);
          token.level   = level;
          nodes.push(token);
        }

        // replace current node
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/normalize.js":
/*!**************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/normalize.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
// Normalize input string




// https://spec.commonmark.org/0.29/#line-ending
var NEWLINES_RE  = /\r\n?|\n/g;
var NULL_RE      = /\0/g;


module.exports = function normalize(state) {
  var str;

  // Normalize newlines
  str = state.src.replace(NEWLINES_RE, '\n');

  // Replace NULL characters
  str = str.replace(NULL_RE, '\uFFFD');

  state.src = str;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/replacements.js":
/*!*****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/replacements.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
// Simple typographic replacements
//
// (c) (C) → ©
// (tm) (TM) → ™
// (r) (R) → ®
// +- → ±
// (p) (P) -> §
// ... → … (also ?.... → ?.., !.... → !..)
// ???????? → ???, !!!!! → !!!, `,,` → `,`
// -- → &ndash;, --- → &mdash;
//


// TODO:
// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
// - miltiplication 2 x 4 -> 2 × 4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

// Workaround for phantomjs - need regex without /g flag,
// or root check will fail every second time
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: '©',
  r: '®',
  p: '§',
  tm: '™'
};

function replaceFn(match, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}

function replace_scoped(inlineTokens) {
  var i, token, inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

function replace_rare(inlineTokens) {
  var i, token, inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content
          .replace(/\+-/g, '±')
          // .., ..., ....... -> …
          // but ?..... & !..... -> ?.. & !..
          .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..')
          .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
          // em-dash
          .replace(/(^|[^-])---(?=[^-]|$)/mg, '$1\u2014')
          // en-dash
          .replace(/(^|\s)--(?=\s|$)/mg, '$1\u2013')
          .replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, '$1\u2013');
      }
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}


module.exports = function replace(state) {
  var blkIdx;

  if (!state.md.options.typographer) { return; }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') { continue; }

    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }

    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }

  }
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/smartquotes.js":
/*!****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/smartquotes.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Convert straight quotation marks to typographic ones
//



var isWhiteSpace   = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isWhiteSpace;
var isPunctChar    = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isPunctChar;
var isMdAsciiPunct = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isMdAsciiPunct;

var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = '\u2019'; /* ’ */


function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}

function process_inlines(tokens, state) {
  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar,
      isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace,
      canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

  stack = [];

  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];

    thisLevel = tokens[i].level;

    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) { break; }
    }
    stack.length = j + 1;

    if (token.type !== 'text') { continue; }

    text = token.content;
    pos = 0;
    max = text.length;

    /*eslint no-labels:0,block-scoped-var:0*/
    OUTER:
    while (pos < max) {
      QUOTE_RE.lastIndex = pos;
      t = QUOTE_RE.exec(text);
      if (!t) { break; }

      canOpen = canClose = true;
      pos = t.index + 1;
      isSingle = (t[0] === "'");

      // Find previous character,
      // default to space if it's the beginning of the line
      //
      lastChar = 0x20;

      if (t.index - 1 >= 0) {
        lastChar = text.charCodeAt(t.index - 1);
      } else {
        for (j = i - 1; j >= 0; j--) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20
          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'

          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
          break;
        }
      }

      // Find next character,
      // default to space if it's the end of the line
      //
      nextChar = 0x20;

      if (pos < max) {
        nextChar = text.charCodeAt(pos);
      } else {
        for (j = i + 1; j < tokens.length; j++) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20
          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'

          nextChar = tokens[j].content.charCodeAt(0);
          break;
        }
      }

      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);

      if (isNextWhiteSpace) {
        canOpen = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          canOpen = false;
        }
      }

      if (isLastWhiteSpace) {
        canClose = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          canClose = false;
        }
      }

      if (nextChar === 0x22 /* " */ && t[0] === '"') {
        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
          // special case: 1"" - count first quote as an inch
          canClose = canOpen = false;
        }
      }

      if (canOpen && canClose) {
        // Replace quotes in the middle of punctuation sequence, but not
        // in the middle of the words, i.e.:
        //
        // 1. foo " bar " baz - not replaced
        // 2. foo-"-bar-"-baz - replaced
        // 3. foo"bar"baz     - not replaced
        //
        canOpen = isLastPunctChar;
        canClose = isNextPunctChar;
      }

      if (!canOpen && !canClose) {
        // middle of word
        if (isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
        continue;
      }

      if (canClose) {
        // this could be a closing quote, rewind the stack to get a match
        for (j = stack.length - 1; j >= 0; j--) {
          item = stack[j];
          if (stack[j].level < thisLevel) { break; }
          if (item.single === isSingle && stack[j].level === thisLevel) {
            item = stack[j];

            if (isSingle) {
              openQuote = state.md.options.quotes[2];
              closeQuote = state.md.options.quotes[3];
            } else {
              openQuote = state.md.options.quotes[0];
              closeQuote = state.md.options.quotes[1];
            }

            // replace token.content *before* tokens[item.token].content,
            // because, if they are pointing at the same token, replaceAt
            // could mess up indices when quote length != 1
            token.content = replaceAt(token.content, t.index, closeQuote);
            tokens[item.token].content = replaceAt(
              tokens[item.token].content, item.pos, openQuote);

            pos += closeQuote.length - 1;
            if (item.token === i) { pos += openQuote.length - 1; }

            text = token.content;
            max = text.length;

            stack.length = j;
            continue OUTER;
          }
        }
      }

      if (canOpen) {
        stack.push({
          token: i,
          pos: t.index,
          single: isSingle,
          level: thisLevel
        });
      } else if (canClose && isSingle) {
        token.content = replaceAt(token.content, t.index, APOSTROPHE);
      }
    }
  }
}


module.exports = function smartquotes(state) {
  /*eslint max-depth:0*/
  var blkIdx;

  if (!state.md.options.typographer) { return; }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline' ||
        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }

    process_inlines(state.tokens[blkIdx].children, state);
  }
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/state_core.js":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/state_core.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Core state object
//


var Token = __webpack_require__(/*! ../token */ "./node_modules/markdown-it/lib/token.js");


function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}

// re-export Token class to use in core rules
StateCore.prototype.Token = Token;


module.exports = StateCore;


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/autolink.js":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/autolink.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
// Process autolinks '<protocol:...>'




/*eslint max-len:0*/
var EMAIL_RE    = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;


module.exports = function autolink(state, silent) {
  var url, fullUrl, token, ch, start, max,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

  start = state.pos;
  max = state.posMax;

  for (;;) {
    if (++pos >= max) return false;

    ch = state.src.charCodeAt(pos);

    if (ch === 0x3C /* < */) return false;
    if (ch === 0x3E /* > */) break;
  }

  url = state.src.slice(start + 1, pos);

  if (AUTOLINK_RE.test(url)) {
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) { return false; }

    if (!silent) {
      token         = state.push('link_open', 'a', 1);
      token.attrs   = [ [ 'href', fullUrl ] ];
      token.markup  = 'autolink';
      token.info    = 'auto';

      token         = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token         = state.push('link_close', 'a', -1);
      token.markup  = 'autolink';
      token.info    = 'auto';
    }

    state.pos += url.length + 2;
    return true;
  }

  if (EMAIL_RE.test(url)) {
    fullUrl = state.md.normalizeLink('mailto:' + url);
    if (!state.md.validateLink(fullUrl)) { return false; }

    if (!silent) {
      token         = state.push('link_open', 'a', 1);
      token.attrs   = [ [ 'href', fullUrl ] ];
      token.markup  = 'autolink';
      token.info    = 'auto';

      token         = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token         = state.push('link_close', 'a', -1);
      token.markup  = 'autolink';
      token.info    = 'auto';
    }

    state.pos += url.length + 2;
    return true;
  }

  return false;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/backticks.js":
/*!****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/backticks.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
// Parse backticks




module.exports = function backtick(state, silent) {
  var start, max, marker, token, matchStart, matchEnd, openerLength, closerLength,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60/* ` */) { return false; }

  start = pos;
  pos++;
  max = state.posMax;

  // scan marker length
  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }

  marker = state.src.slice(start, pos);
  openerLength = marker.length;

  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
    if (!silent) state.pending += marker;
    state.pos += openerLength;
    return true;
  }

  matchStart = matchEnd = pos;

  // Nothing found in the cache, scan until the end of the line (or until marker is found)
  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    // scan marker length
    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }

    closerLength = matchEnd - matchStart;

    if (closerLength === openerLength) {
      // Found matching closer length.
      if (!silent) {
        token     = state.push('code_inline', 'code', 0);
        token.markup  = marker;
        token.content = state.src.slice(pos, matchStart)
          .replace(/\n/g, ' ')
          .replace(/^ (.+) $/, '$1');
      }
      state.pos = matchEnd;
      return true;
    }

    // Some different length found, put it in cache as upper limit of where closer can be found
    state.backticks[closerLength] = matchStart;
  }

  // Scanned through the end, didn't find anything
  state.backticksScanned = true;

  if (!silent) state.pending += marker;
  state.pos += openerLength;
  return true;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/balance_pairs.js":
/*!********************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/balance_pairs.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
// For each opening emphasis-like marker find a matching closing one
//



function processDelimiters(state, delimiters) {
  var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx,
      isOddMatch, lastJump,
      openersBottom = {},
      max = delimiters.length;

  if (!max) return;

  // headerIdx is the first delimiter of the current (where closer is) delimiter run
  var headerIdx = 0;
  var lastTokenIdx = -2; // needs any value lower than -1
  var jumps = [];

  for (closerIdx = 0; closerIdx < max; closerIdx++) {
    closer = delimiters[closerIdx];

    jumps.push(0);

    // markers belong to same delimiter run if:
    //  - they have adjacent tokens
    //  - AND markers are the same
    //
    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
      headerIdx = closerIdx;
    }

    lastTokenIdx = closer.token;

    // Length is only used for emphasis-specific "rule of 3",
    // if it's not defined (in strikethrough or 3rd party plugins),
    // we can default it to 0 to disable those checks.
    //
    closer.length = closer.length || 0;

    if (!closer.close) continue;

    // Previously calculated lower bounds (previous fails)
    // for each marker, each delimiter length modulo 3,
    // and for whether this closer can be an opener;
    // https://github.com/commonmark/cmark/commit/34250e12ccebdc6372b8b49c44fab57c72443460
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [ -1, -1, -1, -1, -1, -1 ];
    }

    minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length % 3)];

    openerIdx = headerIdx - jumps[headerIdx] - 1;

    newMinOpenerIdx = openerIdx;

    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
      opener = delimiters[openerIdx];

      if (opener.marker !== closer.marker) continue;

      if (opener.open && opener.end < 0) {

        isOddMatch = false;

        // from spec:
        //
        // If one of the delimiters can both open and close emphasis, then the
        // sum of the lengths of the delimiter runs containing the opening and
        // closing delimiters must not be a multiple of 3 unless both lengths
        // are multiples of 3.
        //
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }

        if (!isOddMatch) {
          // If previous delimiter cannot be an opener, we can safely skip
          // the entire sequence in future checks. This is required to make
          // sure algorithm has linear complexity (see *_*_*_*_*_... case).
          //
          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ?
            jumps[openerIdx - 1] + 1 :
            0;

          jumps[closerIdx] = closerIdx - openerIdx + lastJump;
          jumps[openerIdx] = lastJump;

          closer.open  = false;
          opener.end   = closerIdx;
          opener.close = false;
          newMinOpenerIdx = -1;
          // treat next token as start of run,
          // it optimizes skips in **<...>**a**<...>** pathological case
          lastTokenIdx = -2;
          break;
        }
      }
    }

    if (newMinOpenerIdx !== -1) {
      // If match for this delimiter run failed, we want to set lower bound for
      // future lookups. This is required to make sure algorithm has linear
      // complexity.
      //
      // See details here:
      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442
      //
      openersBottom[closer.marker][(closer.open ? 3 : 0) + ((closer.length || 0) % 3)] = newMinOpenerIdx;
    }
  }
}


module.exports = function link_pairs(state) {
  var curr,
      tokens_meta = state.tokens_meta,
      max = state.tokens_meta.length;

  processDelimiters(state, state.delimiters);

  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(state, tokens_meta[curr].delimiters);
    }
  }
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/emphasis.js":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/emphasis.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
// Process *this* and _that_
//



// Insert each marker as a separate text token, and add it to delimiter list
//
module.exports.tokenize = function emphasis(state, silent) {
  var i, scanned, token,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) { return false; }

  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) { return false; }

  scanned = state.scanDelims(state.pos, marker === 0x2A);

  for (i = 0; i < scanned.length; i++) {
    token         = state.push('text', '', 0);
    token.content = String.fromCharCode(marker);

    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: marker,

      // Total length of these series of delimiters.
      //
      length: scanned.length,

      // A position of the token this delimiter corresponds to.
      //
      token:  state.tokens.length - 1,

      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end:    -1,

      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open:   scanned.can_open,
      close:  scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};


function postProcess(state, delimiters) {
  var i,
      startDelim,
      endDelim,
      token,
      ch,
      isStrong,
      max = delimiters.length;

  for (i = max - 1; i >= 0; i--) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x5F/* _ */ && startDelim.marker !== 0x2A/* * */) {
      continue;
    }

    // Process only opening markers
    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    // If the previous delimiter has the same marker and is adjacent to this one,
    // merge those into one strong delimiter.
    //
    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
    //
    isStrong = i > 0 &&
               delimiters[i - 1].end === startDelim.end + 1 &&
               // check that first two markers match and adjacent
               delimiters[i - 1].marker === startDelim.marker &&
               delimiters[i - 1].token === startDelim.token - 1 &&
               // check that last two markers are adjacent (we can safely assume they match)
               delimiters[startDelim.end + 1].token === endDelim.token + 1;

    ch = String.fromCharCode(startDelim.marker);

    token         = state.tokens[startDelim.token];
    token.type    = isStrong ? 'strong_open' : 'em_open';
    token.tag     = isStrong ? 'strong' : 'em';
    token.nesting = 1;
    token.markup  = isStrong ? ch + ch : ch;
    token.content = '';

    token         = state.tokens[endDelim.token];
    token.type    = isStrong ? 'strong_close' : 'em_close';
    token.tag     = isStrong ? 'strong' : 'em';
    token.nesting = -1;
    token.markup  = isStrong ? ch + ch : ch;
    token.content = '';

    if (isStrong) {
      state.tokens[delimiters[i - 1].token].content = '';
      state.tokens[delimiters[startDelim.end + 1].token].content = '';
      i--;
    }
  }
}


// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function emphasis(state) {
  var curr,
      tokens_meta = state.tokens_meta,
      max = state.tokens_meta.length;

  postProcess(state, state.delimiters);

  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters);
    }
  }
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/entity.js":
/*!*************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/entity.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Process html entity - &#123;, &#xAF;, &quot;, ...



var entities          = __webpack_require__(/*! ../common/entities */ "./node_modules/markdown-it/lib/common/entities.js");
var has               = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").has;
var isValidEntityCode = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isValidEntityCode;
var fromCodePoint     = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").fromCodePoint;


var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;


module.exports = function entity(state, silent) {
  var ch, code, match, pos = state.pos, max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
      match = state.src.slice(pos).match(DIGITAL_RE);
      if (match) {
        if (!silent) {
          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
        }
        state.pos += match[0].length;
        return true;
      }
    } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) { state.pending += entities[match[1]]; }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) { state.pending += '&'; }
  state.pos++;
  return true;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/escape.js":
/*!*************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/escape.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Process escaped chars and hardbreaks



var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;

var ESCAPED = [];

for (var i = 0; i < 256; i++) { ESCAPED.push(0); }

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'
  .split('').forEach(function (ch) { ESCAPED[ch.charCodeAt(0)] = 1; });


module.exports = function escape(state, silent) {
  var ch, pos = state.pos, max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C/* \ */) { return false; }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) { state.pending += state.src[pos]; }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push('hardbreak', 'br', 0);
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) { break; }
        pos++;
      }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) { state.pending += '\\'; }
  state.pos++;
  return true;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/html_inline.js":
/*!******************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/html_inline.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Process html tags




var HTML_TAG_RE = __webpack_require__(/*! ../common/html_re */ "./node_modules/markdown-it/lib/common/html_re.js").HTML_TAG_RE;


function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);
}


module.exports = function html_inline(state, silent) {
  var ch, match, max, token,
      pos = state.pos;

  if (!state.md.options.html) { return false; }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||
      pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21/* ! */ &&
      ch !== 0x3F/* ? */ &&
      ch !== 0x2F/* / */ &&
      !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) { return false; }

  if (!silent) {
    token         = state.push('html_inline', '', 0);
    token.content = state.src.slice(pos, pos + match[0].length);
  }
  state.pos += match[0].length;
  return true;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/image.js":
/*!************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/image.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Process ![image](<src> "title")



var normalizeReference   = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").normalizeReference;
var isSpace              = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;


module.exports = function image(state, silent) {
  var attrs,
      code,
      content,
      label,
      labelEnd,
      labelStart,
      pos,
      ref,
      res,
      title,
      token,
      tokens,
      start,
      href = '',
      oldPos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(state.pos) !== 0x21/* ! */) { return false; }
  if (state.src.charCodeAt(state.pos + 1) !== 0x5B/* [ */) { return false; }

  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) { return false; }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
    //
    // Inline link
    //

    // [link](  <href>  "title"  )
    //        ^^ skipping these spaces
    pos++;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (!isSpace(code) && code !== 0x0A) { break; }
    }
    if (pos >= max) { return false; }

    // [link](  <href>  "title"  )
    //          ^^^^^^ parsing link destination
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = '';
      }
    }

    // [link](  <href>  "title"  )
    //                ^^ skipping these spaces
    start = pos;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (!isSpace(code) && code !== 0x0A) { break; }
    }

    // [link](  <href>  "title"  )
    //                  ^^^^^^^ parsing link title
    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;

      // [link](  <href>  "title"  )
      //                         ^^ skipping these spaces
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) { break; }
      }
    } else {
      title = '';
    }

    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') { return false; }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) { label = state.src.slice(labelStart, labelEnd); }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);

    state.md.inline.parse(
      content,
      state.md,
      state.env,
      tokens = []
    );

    token          = state.push('image', 'img', 0);
    token.attrs    = attrs = [ [ 'src', href ], [ 'alt', '' ] ];
    token.children = tokens;
    token.content  = content;

    if (title) {
      attrs.push([ 'title', title ]);
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/link.js":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/link.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Process [link](<to> "stuff")



var normalizeReference   = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").normalizeReference;
var isSpace              = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;


module.exports = function link(state, silent) {
  var attrs,
      code,
      label,
      labelEnd,
      labelStart,
      pos,
      res,
      ref,
      token,
      href = '',
      title = '',
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      parseReference = true;

  if (state.src.charCodeAt(state.pos) !== 0x5B/* [ */) { return false; }

  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) { return false; }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
    //
    // Inline link
    //

    // might have found a valid shortcut link, disable reference parsing
    parseReference = false;

    // [link](  <href>  "title"  )
    //        ^^ skipping these spaces
    pos++;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (!isSpace(code) && code !== 0x0A) { break; }
    }
    if (pos >= max) { return false; }

    // [link](  <href>  "title"  )
    //          ^^^^^^ parsing link destination
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = '';
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) { break; }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) { break; }
        }
      }
    }

    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
      // parsing a valid shortcut link failed, fallback to reference
      parseReference = true;
    }
    pos++;
  }

  if (parseReference) {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') { return false; }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) { label = state.src.slice(labelStart, labelEnd); }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    token        = state.push('link_open', 'a', 1);
    token.attrs  = attrs = [ [ 'href', href ] ];
    if (title) {
      attrs.push([ 'title', title ]);
    }

    state.md.inline.tokenize(state);

    token        = state.push('link_close', 'a', -1);
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/newline.js":
/*!**************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/newline.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Proceess '\n'



var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;


module.exports = function newline(state, silent) {
  var pmax, max, ws, pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A/* \n */) { return false; }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        // Find whitespaces tail of pending chars.
        ws = pmax - 1;
        while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 0x20) ws--;

        state.pending = state.pending.slice(0, ws);
        state.push('hardbreak', 'br', 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push('softbreak', 'br', 0);
      }

    } else {
      state.push('softbreak', 'br', 0);
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && isSpace(state.src.charCodeAt(pos))) { pos++; }

  state.pos = pos;
  return true;
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/state_inline.js":
/*!*******************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/state_inline.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Inline parser state




var Token          = __webpack_require__(/*! ../token */ "./node_modules/markdown-it/lib/token.js");
var isWhiteSpace   = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isWhiteSpace;
var isPunctChar    = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isPunctChar;
var isMdAsciiPunct = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isMdAsciiPunct;


function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);

  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  // Stores { start: end } pairs. Useful for backtrack
  // optimization of pairs parse (emphasis, strikes).
  this.cache = {};

  // List of emphasis-like delimiters for current tag
  this.delimiters = [];

  // Stack of delimiter lists for upper level tags
  this._prev_delimiters = [];

  // backtick length => last seen position
  this.backticks = {};
  this.backticksScanned = false;
}


// Flush pending text
//
StateInline.prototype.pushPending = function () {
  var token = new Token('text', '', 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = '';
  return token;
};


// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }

  var token = new Token(type, tag, nesting);
  var token_meta = null;

  if (nesting < 0) {
    // closing tag
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }

  token.level = this.level;

  if (nesting > 0) {
    // opening tag
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = { delimiters: this.delimiters };
  }

  this.pendingLevel = this.level;
  this.tokens.push(token);
  this.tokens_meta.push(token_meta);
  return token;
};


// Scan a sequence of emphasis-like markers, and determine whether
// it can start an emphasis sequence or end an emphasis sequence.
//
//  - start - position to scan from (it should point at a valid marker);
//  - canSplitWord - determine if these markers can be found inside a word
//
StateInline.prototype.scanDelims = function (start, canSplitWord) {
  var pos = start, lastChar, nextChar, count, can_open, can_close,
      isLastWhiteSpace, isLastPunctChar,
      isNextWhiteSpace, isNextPunctChar,
      left_flanking = true,
      right_flanking = true,
      max = this.posMax,
      marker = this.src.charCodeAt(start);

  // treat beginning of the line as a whitespace
  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++; }

  count = pos - start;

  // treat end of the line as a whitespace
  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;

  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);

  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }

  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }

  if (!canSplitWord) {
    can_open  = left_flanking  && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking  || isNextPunctChar);
  } else {
    can_open  = left_flanking;
    can_close = right_flanking;
  }

  return {
    can_open:  can_open,
    can_close: can_close,
    length:    count
  };
};


// re-export Token class to use in block rules
StateInline.prototype.Token = Token;


module.exports = StateInline;


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/strikethrough.js":
/*!********************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/strikethrough.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
// ~~strike through~~
//



// Insert each marker as a separate text token, and add it to delimiter list
//
module.exports.tokenize = function strikethrough(state, silent) {
  var i, scanned, token, len, ch,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) { return false; }

  if (marker !== 0x7E/* ~ */) { return false; }

  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker);

  if (len < 2) { return false; }

  if (len % 2) {
    token         = state.push('text', '', 0);
    token.content = ch;
    len--;
  }

  for (i = 0; i < len; i += 2) {
    token         = state.push('text', '', 0);
    token.content = ch + ch;

    state.delimiters.push({
      marker: marker,
      length: 0,     // disable "rule of 3" length checks meant for emphasis
      token:  state.tokens.length - 1,
      end:    -1,
      open:   scanned.can_open,
      close:  scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};


function postProcess(state, delimiters) {
  var i, j,
      startDelim,
      endDelim,
      token,
      loneMarkers = [],
      max = delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x7E/* ~ */) {
      continue;
    }

    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    token         = state.tokens[startDelim.token];
    token.type    = 's_open';
    token.tag     = 's';
    token.nesting = 1;
    token.markup  = '~~';
    token.content = '';

    token         = state.tokens[endDelim.token];
    token.type    = 's_close';
    token.tag     = 's';
    token.nesting = -1;
    token.markup  = '~~';
    token.content = '';

    if (state.tokens[endDelim.token - 1].type === 'text' &&
        state.tokens[endDelim.token - 1].content === '~') {

      loneMarkers.push(endDelim.token - 1);
    }
  }

  // If a marker sequence has an odd number of characters, it's splitted
  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
  // start of the sequence.
  //
  // So, we have to move all those markers after subsequent s_close tags.
  //
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;

    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
      j++;
    }

    j--;

    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
}


// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function strikethrough(state) {
  var curr,
      tokens_meta = state.tokens_meta,
      max = state.tokens_meta.length;

  postProcess(state, state.delimiters);

  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters);
    }
  }
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/text.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
// Skip text characters for text token, place those to pending buffer
// and increment current pos




// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A/* \n */:
    case 0x21/* ! */:
    case 0x23/* # */:
    case 0x24/* $ */:
    case 0x25/* % */:
    case 0x26/* & */:
    case 0x2A/* * */:
    case 0x2B/* + */:
    case 0x2D/* - */:
    case 0x3A/* : */:
    case 0x3C/* < */:
    case 0x3D/* = */:
    case 0x3E/* > */:
    case 0x40/* @ */:
    case 0x5B/* [ */:
    case 0x5C/* \ */:
    case 0x5D/* ] */:
    case 0x5E/* ^ */:
    case 0x5F/* _ */:
    case 0x60/* ` */:
    case 0x7B/* { */:
    case 0x7D/* } */:
    case 0x7E/* ~ */:
      return true;
    default:
      return false;
  }
}

module.exports = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) { return false; }

  if (!silent) { state.pending += state.src.slice(state.pos, pos); }

  state.pos = pos;

  return true;
};

// Alternative implementation, for memory.
//
// It costs 10% of performance, but allows extend terminators list, if place it
// to `ParcerInline` property. Probably, will switch to it sometime, such
// flexibility required.

/*
var TERMINATOR_RE = /[\n!#$%&*+\-:<=>@[\\\]^_`{}~]/;

module.exports = function text(state, silent) {
  var pos = state.pos,
      idx = state.src.slice(pos).search(TERMINATOR_RE);

  // first char is terminator -> empty text
  if (idx === 0) { return false; }

  // no terminator -> text till end of string
  if (idx < 0) {
    if (!silent) { state.pending += state.src.slice(pos); }
    state.pos = state.src.length;
    return true;
  }

  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }

  state.pos += idx;

  return true;
};*/


/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/text_collapse.js":
/*!********************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/text_collapse.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
// Clean up tokens after emphasis and strikethrough postprocessing:
// merge adjacent text nodes into one and re-calculate all token levels
//
// This is necessary because initially emphasis delimiter markers (*, _, ~)
// are treated as their own separate text tokens. Then emphasis rule either
// leaves them as text (needed to merge with adjacent text) or turns them
// into opening/closing tags (which messes up levels inside).
//



module.exports = function text_collapse(state) {
  var curr, last,
      level = 0,
      tokens = state.tokens,
      max = state.tokens.length;

  for (curr = last = 0; curr < max; curr++) {
    // re-calculate levels after emphasis/strikethrough turns some text nodes
    // into opening/closing tags
    if (tokens[curr].nesting < 0) level--; // closing tag
    tokens[curr].level = level;
    if (tokens[curr].nesting > 0) level++; // opening tag

    if (tokens[curr].type === 'text' &&
        curr + 1 < max &&
        tokens[curr + 1].type === 'text') {

      // collapse two adjacent text nodes
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) { tokens[last] = tokens[curr]; }

      last++;
    }
  }

  if (curr !== last) {
    tokens.length = last;
  }
};


/***/ }),

/***/ "./node_modules/markdown-it/lib/token.js":
/*!***********************************************!*\
  !*** ./node_modules/markdown-it/lib/token.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
// Token class




/**
 * class Token
 **/

/**
 * new Token(type, tag, nesting)
 *
 * Create new token and fill passed properties.
 **/
function Token(type, tag, nesting) {
  /**
   * Token#type -> String
   *
   * Type of the token (string, e.g. "paragraph_open")
   **/
  this.type     = type;

  /**
   * Token#tag -> String
   *
   * html tag name, e.g. "p"
   **/
  this.tag      = tag;

  /**
   * Token#attrs -> Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs    = null;

  /**
   * Token#map -> Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map      = null;

  /**
   * Token#nesting -> Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting  = nesting;

  /**
   * Token#level -> Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level    = 0;

  /**
   * Token#children -> Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -> String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content  = '';

  /**
   * Token#markup -> String
   *
   * '*' or '_' for emphasis, fence string for fence, etc.
   **/
  this.markup   = '';

  /**
   * Token#info -> String
   *
   * Additional information:
   *
   * - Info string for "fence" tokens
   * - The value "auto" for autolink "link_open" and "link_close" tokens
   * - The string value of the item marker for ordered-list "list_item_open" tokens
   **/
  this.info     = '';

  /**
   * Token#meta -> Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta     = null;

  /**
   * Token#block -> Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block    = false;

  /**
   * Token#hidden -> Boolean
   *
   * If it's true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden   = false;
}


/**
 * Token.attrIndex(name) -> Number
 *
 * Search attribute index by name.
 **/
Token.prototype.attrIndex = function attrIndex(name) {
  var attrs, i, len;

  if (!this.attrs) { return -1; }

  attrs = this.attrs;

  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) { return i; }
  }
  return -1;
};


/**
 * Token.attrPush(attrData)
 *
 * Add `[ name, value ]` attribute to list. Init attrs if necessary
 **/
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [ attrData ];
  }
};


/**
 * Token.attrSet(name, value)
 *
 * Set `name` attribute to `value`. Override old value if exists.
 **/
Token.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name),
      attrData = [ name, value ];

  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};


/**
 * Token.attrGet(name)
 *
 * Get the value of attribute `name`, or null if it does not exist.
 **/
Token.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name), value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};


/**
 * Token.attrJoin(name, value)
 *
 * Join value to existing attribute via space. Or create new attribute if not
 * exists. Useful to operate with token classes.
 **/
Token.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);

  if (idx < 0) {
    this.attrPush([ name, value ]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
  }
};


module.exports = Token;


/***/ }),

/***/ "./node_modules/mdurl/decode.js":
/*!**************************************!*\
  !*** ./node_modules/mdurl/decode.js ***!
  \**************************************/
/***/ ((module) => {

"use strict";




/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i, ch, cache = decodeCache[exclude];
  if (cache) { return cache; }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
}


// Decode percent-encoded string.
//
function decode(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
    var i, l, b1, b2, b3, b4, chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);

          if (chr < 0x80) {
            result += '\ufffd\ufffd';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);

          if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {
            result += '\ufffd\ufffd\ufffd';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\ufffd\ufffd\ufffd\ufffd';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\ufffd';
    }

    return result;
  });
}


decode.defaultChars   = ';/?:@&=+$,#';
decode.componentChars = '';


module.exports = decode;


/***/ }),

/***/ "./node_modules/mdurl/encode.js":
/*!**************************************!*\
  !*** ./node_modules/mdurl/encode.js ***!
  \**************************************/
/***/ ((module) => {

"use strict";




var encodeCache = {};


// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i, ch, cache = encodeCache[exclude];
  if (cache) { return cache; }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}


// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i, l, code, nextCode, cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped  = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars   = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";


module.exports = encode;


/***/ }),

/***/ "./node_modules/mdurl/format.js":
/*!**************************************!*\
  !*** ./node_modules/mdurl/format.js ***!
  \**************************************/
/***/ ((module) => {

"use strict";




module.exports = function format(url) {
  var result = '';

  result += url.protocol || '';
  result += url.slashes ? '//' : '';
  result += url.auth ? url.auth + '@' : '';

  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    // ipv6 address
    result += '[' + url.hostname + ']';
  } else {
    result += url.hostname || '';
  }

  result += url.port ? ':' + url.port : '';
  result += url.pathname || '';
  result += url.search || '';
  result += url.hash || '';

  return result;
};


/***/ }),

/***/ "./node_modules/mdurl/index.js":
/*!*************************************!*\
  !*** ./node_modules/mdurl/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



module.exports.encode = __webpack_require__(/*! ./encode */ "./node_modules/mdurl/encode.js");
module.exports.decode = __webpack_require__(/*! ./decode */ "./node_modules/mdurl/decode.js");
module.exports.format = __webpack_require__(/*! ./format */ "./node_modules/mdurl/format.js");
module.exports.parse = __webpack_require__(/*! ./parse */ "./node_modules/mdurl/parse.js");


/***/ }),

/***/ "./node_modules/mdurl/parse.js":
/*!*************************************!*\
  !*** ./node_modules/mdurl/parse.js ***!
  \*************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



//
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//


function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = [ '<', '>', '"', '`', ' ', '\r', '\n', '\t' ],

    // RFC 2396: characters not allowed for various reasons.
    unwise = [ '{', '}', '|', '\\', '^', '`' ].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = [ '\'' ].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = [ '%', '/', '?', ';', '#' ].concat(autoEscape),
    hostEndingChars = [ '/', '?', '#' ],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    /* eslint-disable no-script-url */
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    };
    /* eslint-enable no-script-url */

function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) { return url; }

  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, slashesDenoteHost) {
  var i, l, lowerProto, hec, slashes,
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }

    if (rest[hostEnd - 1] === ':') { hostEnd--; }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost(host);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) { continue; }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    }

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) { this.pathname = rest; }
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '';
  }

  return this;
};

Url.prototype.parseHost = function(host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) { this.hostname = host; }
};

module.exports = urlParse;


/***/ }),

/***/ "./node_modules/uc.micro/categories/Cc/regex.js":
/*!******************************************************!*\
  !*** ./node_modules/uc.micro/categories/Cc/regex.js ***!
  \******************************************************/
/***/ ((module) => {

module.exports=/[\0-\x1F\x7F-\x9F]/

/***/ }),

/***/ "./node_modules/uc.micro/categories/Cf/regex.js":
/*!******************************************************!*\
  !*** ./node_modules/uc.micro/categories/Cf/regex.js ***!
  \******************************************************/
/***/ ((module) => {

module.exports=/[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/

/***/ }),

/***/ "./node_modules/uc.micro/categories/P/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uc.micro/categories/P/regex.js ***!
  \*****************************************************/
/***/ ((module) => {

module.exports=/[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/

/***/ }),

/***/ "./node_modules/uc.micro/categories/Z/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uc.micro/categories/Z/regex.js ***!
  \*****************************************************/
/***/ ((module) => {

module.exports=/[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/

/***/ }),

/***/ "./node_modules/uc.micro/index.js":
/*!****************************************!*\
  !*** ./node_modules/uc.micro/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.Any = __webpack_require__(/*! ./properties/Any/regex */ "./node_modules/uc.micro/properties/Any/regex.js");
exports.Cc = __webpack_require__(/*! ./categories/Cc/regex */ "./node_modules/uc.micro/categories/Cc/regex.js");
exports.Cf = __webpack_require__(/*! ./categories/Cf/regex */ "./node_modules/uc.micro/categories/Cf/regex.js");
exports.P = __webpack_require__(/*! ./categories/P/regex */ "./node_modules/uc.micro/categories/P/regex.js");
exports.Z = __webpack_require__(/*! ./categories/Z/regex */ "./node_modules/uc.micro/categories/Z/regex.js");


/***/ }),

/***/ "./node_modules/uc.micro/properties/Any/regex.js":
/*!*******************************************************!*\
  !*** ./node_modules/uc.micro/properties/Any/regex.js ***!
  \*******************************************************/
/***/ ((module) => {

module.exports=/[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/

/***/ }),

/***/ "../adaptivecards/lib/activity-request.js":
/*!************************************************!*\
  !*** ../adaptivecards/lib/activity-request.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoginRequestResponse = exports.ErrorResponse = exports.SuccessResponse = exports.ActivityResponse = exports.ActivityRequestError = exports.ActivityRequestTrigger = void 0;
var ActivityRequestTrigger;
(function (ActivityRequestTrigger) {
    ActivityRequestTrigger["Automatic"] = "automatic";
    ActivityRequestTrigger["Manual"] = "manual";
})(ActivityRequestTrigger = exports.ActivityRequestTrigger || (exports.ActivityRequestTrigger = {}));
var ActivityRequestError = /** @class */ (function () {
    function ActivityRequestError(code, message) {
        this.code = code;
        this.message = message;
    }
    return ActivityRequestError;
}());
exports.ActivityRequestError = ActivityRequestError;
var ActivityResponse = /** @class */ (function () {
    function ActivityResponse(request) {
        this.request = request;
    }
    return ActivityResponse;
}());
exports.ActivityResponse = ActivityResponse;
var SuccessResponse = /** @class */ (function (_super) {
    __extends(SuccessResponse, _super);
    function SuccessResponse(request, rawContent) {
        var _this = _super.call(this, request) || this;
        _this.request = request;
        _this.rawContent = rawContent;
        return _this;
    }
    return SuccessResponse;
}(ActivityResponse));
exports.SuccessResponse = SuccessResponse;
var ErrorResponse = /** @class */ (function (_super) {
    __extends(ErrorResponse, _super);
    function ErrorResponse(request, error) {
        var _this = _super.call(this, request) || this;
        _this.request = request;
        _this.error = error;
        return _this;
    }
    return ErrorResponse;
}(ActivityResponse));
exports.ErrorResponse = ErrorResponse;
var LoginRequestResponse = /** @class */ (function (_super) {
    __extends(LoginRequestResponse, _super);
    function LoginRequestResponse(request, auth) {
        var _this = _super.call(this, request) || this;
        _this.request = request;
        _this._auth = auth;
        for (var _i = 0, _a = _this._auth.buttons; _i < _a.length; _i++) {
            var button = _a[_i];
            if (button.type === "signin" && button.value !== undefined) {
                try {
                    new URL(button.value);
                    _this.signinButton = button;
                    break;
                }
                catch (e) {
                    // Ignore parsing error
                }
            }
        }
        return _this;
    }
    Object.defineProperty(LoginRequestResponse.prototype, "tokenExchangeResource", {
        get: function () {
            return this._auth.tokenExchangeResource;
        },
        enumerable: false,
        configurable: true
    });
    return LoginRequestResponse;
}(ActivityResponse));
exports.LoginRequestResponse = LoginRequestResponse;
//# sourceMappingURL=activity-request.js.map

/***/ }),

/***/ "../adaptivecards/lib/adaptive-applet.js":
/*!***********************************************!*\
  !*** ../adaptivecards/lib/adaptive-applet.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdaptiveApplet = void 0;
// Copyright (C) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var Enums = __webpack_require__(/*! ./enums */ "../adaptivecards/lib/enums.js");
var Utils = __webpack_require__(/*! ./utils */ "../adaptivecards/lib/utils.js");
var shared_1 = __webpack_require__(/*! ./shared */ "../adaptivecards/lib/shared.js");
var activity_request_1 = __webpack_require__(/*! ./activity-request */ "../adaptivecards/lib/activity-request.js");
var strings_1 = __webpack_require__(/*! ./strings */ "../adaptivecards/lib/strings.js");
var card_elements_1 = __webpack_require__(/*! ./card-elements */ "../adaptivecards/lib/card-elements.js");
var serialization_1 = __webpack_require__(/*! ./serialization */ "../adaptivecards/lib/serialization.js");
function logEvent(level, message) {
    var optionalParams = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        optionalParams[_i - 2] = arguments[_i];
    }
    if (shared_1.GlobalSettings.applets.logEnabled) {
        if (shared_1.GlobalSettings.applets.onLogEvent) {
            shared_1.GlobalSettings.applets.onLogEvent(level, message, optionalParams);
        }
        else {
            /* eslint-disable no-console */
            switch (level) {
                case Enums.LogLevel.Warning:
                    console.warn(message, optionalParams);
                    break;
                case Enums.LogLevel.Error:
                    console.error(message, optionalParams);
                    break;
                default:
                    console.log(message, optionalParams);
                    break;
            }
            /* eslint-enable no-console */
        }
    }
}
var ActivityRequest = /** @class */ (function () {
    function ActivityRequest(action, trigger, consecutiveRefreshes) {
        this.action = action;
        this.trigger = trigger;
        this.consecutiveRefreshes = consecutiveRefreshes;
        this.attemptNumber = 0;
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    ActivityRequest.prototype.retryAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.onSend) {
                    this.onSend(this);
                }
                return [2 /*return*/];
            });
        });
    };
    return ActivityRequest;
}());
var AdaptiveApplet = /** @class */ (function () {
    function AdaptiveApplet() {
        this._allowAutomaticCardUpdate = false;
        this.renderedElement = document.createElement("div");
        this.renderedElement.className = "aaf-cardHost";
        this.renderedElement.style.position = "relative";
        this.renderedElement.style.display = "flex";
        this.renderedElement.style.flexDirection = "column";
        this._cardHostElement = document.createElement("div");
        this._refreshButtonHostElement = document.createElement("div");
        this._refreshButtonHostElement.className = "aaf-refreshButtonHost";
        this._refreshButtonHostElement.style.display = "none";
        this.renderedElement.appendChild(this._cardHostElement);
        this.renderedElement.appendChild(this._refreshButtonHostElement);
    }
    AdaptiveApplet.prototype.displayCard = function (card) {
        if (card.renderedElement) {
            Utils.clearElementChildren(this._cardHostElement);
            this._refreshButtonHostElement.style.display = "none";
            this._cardHostElement.appendChild(card.renderedElement);
        }
        else {
            throw new Error("displayCard: undefined card.");
        }
    };
    AdaptiveApplet.prototype.showManualRefreshButton = function (refreshAction) {
        var _this = this;
        var displayBuiltInManualRefreshButton = this.onShowManualRefreshButton
            ? this.onShowManualRefreshButton(this)
            : true;
        if (displayBuiltInManualRefreshButton) {
            this._refreshButtonHostElement.style.display = "none";
            var renderedRefreshButton = undefined;
            if (this.onRenderManualRefreshButton) {
                renderedRefreshButton = this.onRenderManualRefreshButton(this);
            }
            else {
                var message = strings_1.Strings.runtime.refreshThisCard();
                if (shared_1.GlobalSettings.applets.refresh.mode === Enums.RefreshMode.Automatic) {
                    var autoRefreshPausedMessage = strings_1.Strings.runtime.automaticRefreshPaused();
                    if (autoRefreshPausedMessage[autoRefreshPausedMessage.length - 1] !== " ") {
                        autoRefreshPausedMessage += " ";
                    }
                    message = strings_1.Strings.runtime.clckToRestartAutomaticRefresh();
                }
                var cardPayload = {
                    type: "AdaptiveCard",
                    version: "1.2",
                    body: [
                        {
                            type: "RichTextBlock",
                            horizontalAlignment: "right",
                            inlines: [
                                {
                                    type: "TextRun",
                                    text: message,
                                    selectAction: {
                                        type: "Action.Submit",
                                        id: "refreshCard"
                                    }
                                }
                            ]
                        }
                    ]
                };
                var card = new card_elements_1.AdaptiveCard();
                card.parse(cardPayload, new card_elements_1.SerializationContext(serialization_1.Versions.v1_2));
                card.onExecuteAction = function (action) {
                    if (action.id === "refreshCard") {
                        Utils.clearElementChildren(_this._refreshButtonHostElement);
                        _this.internalExecuteAction(refreshAction, activity_request_1.ActivityRequestTrigger.Automatic, 0);
                    }
                };
                renderedRefreshButton = card.render();
            }
            if (renderedRefreshButton) {
                Utils.clearElementChildren(this._refreshButtonHostElement);
                this._refreshButtonHostElement.appendChild(renderedRefreshButton);
                this._refreshButtonHostElement.style.removeProperty("display");
            }
        }
    };
    AdaptiveApplet.prototype.createActivityRequest = function (action, trigger, consecutiveRefreshes) {
        var _this = this;
        if (this.card) {
            var request_1 = new ActivityRequest(action, trigger, consecutiveRefreshes);
            request_1.onSend = function (sender) {
                sender.attemptNumber++;
                void _this.internalSendActivityRequestAsync(request_1);
            };
            var cancel = this.onPrepareActivityRequest
                ? !this.onPrepareActivityRequest(this, request_1, action)
                : false;
            return cancel ? undefined : request_1;
        }
        else {
            throw new Error("createActivityRequest: no card has been set.");
        }
    };
    AdaptiveApplet.prototype.createMagicCodeInputCard = function (attemptNumber) {
        var payload = {
            type: "AdaptiveCard",
            version: "1.0",
            body: [
                {
                    type: "TextBlock",
                    color: "attention",
                    text: attemptNumber === 1 ? undefined : "That didn't work... let's try again.",
                    wrap: true,
                    horizontalAlignment: "center"
                },
                {
                    type: "TextBlock",
                    text: 'Please login in the popup. You will obtain a magic code. Paste that code below and select "Submit"',
                    wrap: true,
                    horizontalAlignment: "center"
                },
                {
                    type: "Input.Text",
                    id: "magicCode",
                    placeholder: "Enter magic code"
                },
                {
                    type: "ActionSet",
                    horizontalAlignment: "center",
                    actions: [
                        {
                            type: "Action.Submit",
                            id: AdaptiveApplet._submitMagicCodeActionId,
                            title: "Submit"
                        },
                        {
                            type: "Action.Submit",
                            id: AdaptiveApplet._cancelMagicCodeAuthActionId,
                            title: "Cancel"
                        }
                    ]
                }
            ]
        };
        var card = new card_elements_1.AdaptiveCard();
        card.parse(payload);
        return card;
    };
    AdaptiveApplet.prototype.cancelAutomaticRefresh = function () {
        if (this._allowAutomaticCardUpdate) {
            logEvent(Enums.LogLevel.Warning, "Automatic card refresh has been cancelled as a result of the user interacting with the card.");
        }
        this._allowAutomaticCardUpdate = false;
    };
    AdaptiveApplet.prototype.createSerializationContext = function () {
        return this.onCreateSerializationContext
            ? this.onCreateSerializationContext(this)
            : new card_elements_1.SerializationContext();
    };
    AdaptiveApplet.prototype.internalSetCard = function (payload, consecutiveRefreshes) {
        var _this = this;
        if (typeof payload === "object" && payload["type"] === "AdaptiveCard") {
            this._cardPayload = payload;
        }
        if (this._cardPayload) {
            try {
                var card = new card_elements_1.AdaptiveCard();
                if (this.hostConfig) {
                    card.hostConfig = this.hostConfig;
                }
                var serializationContext = this.createSerializationContext();
                card.parse(this._cardPayload, serializationContext);
                var doChangeCard = this.onCardChanging
                    ? this.onCardChanging(this, this._cardPayload)
                    : true;
                if (doChangeCard) {
                    this._card = card;
                    if (this._card.authentication &&
                        this._card.authentication.tokenExchangeResource &&
                        this.onPrefetchSSOToken) {
                        this.onPrefetchSSOToken(this, this._card.authentication.tokenExchangeResource);
                    }
                    this._card.onExecuteAction = function (action) {
                        // If the user takes an action, cancel any pending automatic refresh
                        _this.cancelAutomaticRefresh();
                        _this.internalExecuteAction(action, activity_request_1.ActivityRequestTrigger.Manual, 0);
                    };
                    this._card.onInputValueChanged = function (_input) {
                        // If the user modifies an input, cancel any pending automatic refresh
                        _this.cancelAutomaticRefresh();
                    };
                    this._card.render();
                    if (this._card.renderedElement) {
                        this.displayCard(this._card);
                        if (this.onCardChanged) {
                            this.onCardChanged(this);
                        }
                        if (this._card.refresh) {
                            if (shared_1.GlobalSettings.applets.refresh.mode ===
                                Enums.RefreshMode.Automatic &&
                                consecutiveRefreshes <
                                    shared_1.GlobalSettings.applets.refresh
                                        .maximumConsecutiveAutomaticRefreshes) {
                                if (shared_1.GlobalSettings.applets.refresh.timeBetweenAutomaticRefreshes <=
                                    0) {
                                    logEvent(Enums.LogLevel.Info, "Triggering automatic card refresh number " +
                                        (consecutiveRefreshes + 1));
                                    this.internalExecuteAction(this._card.refresh.action, activity_request_1.ActivityRequestTrigger.Automatic, consecutiveRefreshes + 1);
                                }
                                else {
                                    logEvent(Enums.LogLevel.Info, "Scheduling automatic card refresh number " +
                                        (consecutiveRefreshes + 1) +
                                        " in " +
                                        shared_1.GlobalSettings.applets.refresh
                                            .timeBetweenAutomaticRefreshes +
                                        "ms");
                                    var action_1 = this._card.refresh.action;
                                    this._allowAutomaticCardUpdate = true;
                                    window.setTimeout(function () {
                                        if (_this._allowAutomaticCardUpdate) {
                                            _this.internalExecuteAction(action_1, activity_request_1.ActivityRequestTrigger.Automatic, consecutiveRefreshes + 1);
                                        }
                                    }, shared_1.GlobalSettings.applets.refresh.timeBetweenAutomaticRefreshes);
                                }
                            }
                            else if (shared_1.GlobalSettings.applets.refresh.mode !== Enums.RefreshMode.Disabled) {
                                if (consecutiveRefreshes > 0) {
                                    logEvent(Enums.LogLevel.Warning, "Stopping automatic refreshes after " +
                                        consecutiveRefreshes +
                                        " consecutive refreshes.");
                                }
                                else {
                                    logEvent(Enums.LogLevel.Warning, "The card has a refresh section, but automatic refreshes are disabled.");
                                }
                                if (shared_1.GlobalSettings.applets.refresh
                                    .allowManualRefreshesAfterAutomaticRefreshes ||
                                    shared_1.GlobalSettings.applets.refresh.mode === Enums.RefreshMode.Manual) {
                                    logEvent(Enums.LogLevel.Info, "Showing manual refresh button.");
                                    this.showManualRefreshButton(this._card.refresh.action);
                                }
                            }
                        }
                    }
                }
            }
            catch (error) {
                // Ignore all errors
                logEvent(Enums.LogLevel.Error, "setCard: " + error);
            }
        }
    };
    AdaptiveApplet.prototype.internalExecuteAction = function (action, trigger, consecutiveRefreshes) {
        if (action instanceof card_elements_1.ExecuteAction) {
            if (this.channelAdapter) {
                var request = this.createActivityRequest(action, trigger, consecutiveRefreshes);
                if (request) {
                    void request.retryAsync();
                }
            }
            else {
                throw new Error("internalExecuteAction: No channel adapter set.");
            }
        }
        if (this.onAction) {
            this.onAction(this, action);
        }
    };
    AdaptiveApplet.prototype.createProgressOverlay = function (request) {
        if (!this._progressOverlay) {
            if (this.onCreateProgressOverlay) {
                this._progressOverlay = this.onCreateProgressOverlay(this, request);
            }
            else {
                this._progressOverlay = document.createElement("div");
                this._progressOverlay.className = "aaf-progress-overlay";
                var spinner = document.createElement("div");
                spinner.className = "aaf-spinner";
                spinner.style.width = "28px";
                spinner.style.height = "28px";
                this._progressOverlay.appendChild(spinner);
            }
        }
        return this._progressOverlay;
    };
    AdaptiveApplet.prototype.removeProgressOverlay = function (request) {
        if (this.onRemoveProgressOverlay) {
            this.onRemoveProgressOverlay(this, request);
        }
        if (this._progressOverlay !== undefined) {
            this.renderedElement.removeChild(this._progressOverlay);
            this._progressOverlay = undefined;
        }
    };
    AdaptiveApplet.prototype.activityRequestSucceeded = function (response, parsedContent) {
        if (this.onActivityRequestSucceeded) {
            this.onActivityRequestSucceeded(this, response, parsedContent);
        }
    };
    AdaptiveApplet.prototype.activityRequestFailed = function (response) {
        return this.onActivityRequestFailed
            ? this.onActivityRequestFailed(this, response)
            : shared_1.GlobalSettings.applets.defaultTimeBetweenRetryAttempts;
    };
    AdaptiveApplet.prototype.showAuthCodeInputDialog = function (request) {
        var _this = this;
        var showBuiltInAuthCodeInputCard = this.onShowAuthCodeInputDialog
            ? this.onShowAuthCodeInputDialog(this, request)
            : true;
        if (showBuiltInAuthCodeInputCard) {
            var authCodeInputCard = this.createMagicCodeInputCard(request.attemptNumber);
            authCodeInputCard.render();
            authCodeInputCard.onExecuteAction = function (submitMagicCodeAction) {
                if (_this.card && submitMagicCodeAction instanceof card_elements_1.SubmitAction) {
                    switch (submitMagicCodeAction.id) {
                        case AdaptiveApplet._submitMagicCodeActionId:
                            var authCode = undefined;
                            if (submitMagicCodeAction.data &&
                                typeof submitMagicCodeAction.data["magicCode"] === "string") {
                                authCode = submitMagicCodeAction.data["magicCode"];
                            }
                            if (authCode) {
                                _this.displayCard(_this.card);
                                request.authCode = authCode;
                                void request.retryAsync();
                            }
                            else {
                                alert("Please enter the magic code you received.");
                            }
                            break;
                        case AdaptiveApplet._cancelMagicCodeAuthActionId:
                            logEvent(Enums.LogLevel.Warning, "Authentication cancelled by user.");
                            _this.displayCard(_this.card);
                            break;
                        default:
                            logEvent(Enums.LogLevel.Error, "Unexpected action taken from magic code input card (id = " +
                                submitMagicCodeAction.id +
                                ")");
                            alert(strings_1.Strings.magicCodeInputCard.somethingWentWrong());
                            break;
                    }
                }
            };
            this.displayCard(authCodeInputCard);
        }
    };
    AdaptiveApplet.prototype.internalSendActivityRequestAsync = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var overlay, done, _loop_1, this_1, state_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.channelAdapter) {
                            throw new Error("internalSendActivityRequestAsync: channelAdapter is not set.");
                        }
                        overlay = this.createProgressOverlay(request);
                        if (overlay !== undefined) {
                            this.renderedElement.appendChild(overlay);
                        }
                        done = false;
                        _loop_1 = function () {
                            var response, error_1, parsedContent, retryIn_1, attemptOAuth, left, top_1;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        response = undefined;
                                        if (request.attemptNumber === 1) {
                                            logEvent(Enums.LogLevel.Info, "Sending activity request to channel (attempt " + request.attemptNumber + ")");
                                        }
                                        else {
                                            logEvent(Enums.LogLevel.Info, "Re-sending activity request to channel (attempt " + request.attemptNumber + ")");
                                        }
                                        _b.label = 1;
                                    case 1:
                                        _b.trys.push([1, 3, , 4]);
                                        return [4 /*yield*/, this_1.channelAdapter.sendRequestAsync(request)];
                                    case 2:
                                        response = _b.sent();
                                        return [3 /*break*/, 4];
                                    case 3:
                                        error_1 = _b.sent();
                                        logEvent(Enums.LogLevel.Error, "Activity request failed: " + error_1);
                                        this_1.removeProgressOverlay(request);
                                        done = true;
                                        return [3 /*break*/, 4];
                                    case 4:
                                        if (!response) return [3 /*break*/, 10];
                                        if (!(response instanceof activity_request_1.SuccessResponse)) return [3 /*break*/, 5];
                                        this_1.removeProgressOverlay(request);
                                        if (response.rawContent === undefined) {
                                            throw new Error("internalSendActivityRequestAsync: Action.Execute result is undefined");
                                        }
                                        parsedContent = response.rawContent;
                                        try {
                                            parsedContent = JSON.parse(response.rawContent);
                                        }
                                        catch (_c) {
                                            // Leave parseContent as is
                                        }
                                        if (typeof parsedContent === "string") {
                                            logEvent(Enums.LogLevel.Info, "The activity request returned a string after " +
                                                request.attemptNumber +
                                                " attempt(s).");
                                            this_1.activityRequestSucceeded(response, parsedContent);
                                        }
                                        else if (typeof parsedContent === "object" &&
                                            parsedContent["type"] === "AdaptiveCard") {
                                            logEvent(Enums.LogLevel.Info, "The activity request returned an Adaptive Card after " +
                                                request.attemptNumber +
                                                " attempt(s).");
                                            this_1.internalSetCard(parsedContent, request.consecutiveRefreshes);
                                            this_1.activityRequestSucceeded(response, this_1.card);
                                        }
                                        else {
                                            throw new Error("internalSendActivityRequestAsync: Action.Execute result is of unsupported type (" +
                                                typeof response.rawContent +
                                                ")");
                                        }
                                        done = true;
                                        return [3 /*break*/, 10];
                                    case 5:
                                        if (!(response instanceof activity_request_1.ErrorResponse)) return [3 /*break*/, 9];
                                        retryIn_1 = this_1.activityRequestFailed(response);
                                        if (!(retryIn_1 >= 0 &&
                                            request.attemptNumber < shared_1.GlobalSettings.applets.maximumRetryAttempts)) return [3 /*break*/, 7];
                                        logEvent(Enums.LogLevel.Warning, "Activity request failed: ".concat(response.error.message, ". Retrying in ").concat(retryIn_1, "ms"));
                                        request.attemptNumber++;
                                        return [4 /*yield*/, new Promise(function (resolve, _reject) {
                                                window.setTimeout(function () {
                                                    resolve();
                                                }, retryIn_1);
                                            })];
                                    case 6:
                                        _b.sent();
                                        return [3 /*break*/, 8];
                                    case 7:
                                        logEvent(Enums.LogLevel.Error, "Activity request failed: ".concat(response.error.message, ". Giving up after ").concat(request.attemptNumber, " attempt(s)"));
                                        this_1.removeProgressOverlay(request);
                                        done = true;
                                        _b.label = 8;
                                    case 8: return [3 /*break*/, 10];
                                    case 9:
                                        if (response instanceof activity_request_1.LoginRequestResponse) {
                                            logEvent(Enums.LogLevel.Info, "The activity request returned a LoginRequestResponse after " +
                                                request.attemptNumber +
                                                " attempt(s).");
                                            if (request.attemptNumber <= shared_1.GlobalSettings.applets.maximumRetryAttempts) {
                                                attemptOAuth = true;
                                                if (response.tokenExchangeResource && this_1.onSSOTokenNeeded) {
                                                    // Attempt to use SSO. The host will return true if it can handle SSO, in which case
                                                    // we bypass OAuth
                                                    attemptOAuth = !this_1.onSSOTokenNeeded(this_1, request, response.tokenExchangeResource);
                                                }
                                                if (attemptOAuth) {
                                                    // Attempt to use OAuth
                                                    this_1.removeProgressOverlay(request);
                                                    if (response.signinButton === undefined) {
                                                        throw new Error("internalSendActivityRequestAsync: the login request doesn't contain a valid signin URL.");
                                                    }
                                                    logEvent(Enums.LogLevel.Info, "Login required at " + response.signinButton.value);
                                                    if (this_1.onShowSigninPrompt) {
                                                        // Bypass the built-in auth prompt if the host app handles it
                                                        this_1.onShowSigninPrompt(this_1, request, response.signinButton);
                                                    }
                                                    else {
                                                        this_1.showAuthCodeInputDialog(request);
                                                        left = window.screenX +
                                                            (window.outerWidth - shared_1.GlobalSettings.applets.authPromptWidth) /
                                                                2;
                                                        top_1 = window.screenY +
                                                            (window.outerHeight - shared_1.GlobalSettings.applets.authPromptHeight) /
                                                                2;
                                                        window.open(response.signinButton.value, response.signinButton.title
                                                            ? response.signinButton.title
                                                            : "Sign in", "width=".concat(shared_1.GlobalSettings.applets.authPromptWidth, ",height=").concat(shared_1.GlobalSettings.applets.authPromptHeight, ",left=").concat(left, ",top=").concat(top_1));
                                                    }
                                                }
                                            }
                                            else {
                                                logEvent(Enums.LogLevel.Error, "Authentication failed. Giving up after " +
                                                    request.attemptNumber +
                                                    " attempt(s)");
                                                alert(strings_1.Strings.magicCodeInputCard.authenticationFailed());
                                            }
                                            return [2 /*return*/, "break"];
                                        }
                                        else {
                                            throw new Error("Unhandled response type: " + JSON.stringify(response));
                                        }
                                        _b.label = 10;
                                    case 10: return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        _a.label = 1;
                    case 1:
                        if (!!done) return [3 /*break*/, 3];
                        return [5 /*yield**/, _loop_1()];
                    case 2:
                        state_1 = _a.sent();
                        if (state_1 === "break")
                            return [3 /*break*/, 3];
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    AdaptiveApplet.prototype.refreshCard = function () {
        if (this._card && this._card.refresh) {
            this.internalExecuteAction(this._card.refresh.action, activity_request_1.ActivityRequestTrigger.Manual, 0);
        }
    };
    AdaptiveApplet.prototype.setCard = function (payload) {
        this.internalSetCard(payload, 0);
    };
    Object.defineProperty(AdaptiveApplet.prototype, "card", {
        get: function () {
            return this._card;
        },
        enumerable: false,
        configurable: true
    });
    AdaptiveApplet._submitMagicCodeActionId = "submitMagicCode";
    AdaptiveApplet._cancelMagicCodeAuthActionId = "cancelMagicCodeAuth";
    return AdaptiveApplet;
}());
exports.AdaptiveApplet = AdaptiveApplet;
//# sourceMappingURL=adaptive-applet.js.map

/***/ }),

/***/ "../adaptivecards/lib/adaptivecards.js":
/*!*********************************************!*\
  !*** ../adaptivecards/lib/adaptivecards.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__exportStar(__webpack_require__(/*! ./strings */ "../adaptivecards/lib/strings.js"), exports);
__exportStar(__webpack_require__(/*! ./enums */ "../adaptivecards/lib/enums.js"), exports);
__exportStar(__webpack_require__(/*! ./shared */ "../adaptivecards/lib/shared.js"), exports);
__exportStar(__webpack_require__(/*! ./utils */ "../adaptivecards/lib/utils.js"), exports);
__exportStar(__webpack_require__(/*! ./serialization */ "../adaptivecards/lib/serialization.js"), exports);
__exportStar(__webpack_require__(/*! ./host-capabilities */ "../adaptivecards/lib/host-capabilities.js"), exports);
__exportStar(__webpack_require__(/*! ./host-config */ "../adaptivecards/lib/host-config.js"), exports);
__exportStar(__webpack_require__(/*! ./registry */ "../adaptivecards/lib/registry.js"), exports);
__exportStar(__webpack_require__(/*! ./card-object */ "../adaptivecards/lib/card-object.js"), exports);
__exportStar(__webpack_require__(/*! ./card-elements */ "../adaptivecards/lib/card-elements.js"), exports);
__exportStar(__webpack_require__(/*! ./table */ "../adaptivecards/lib/table.js"), exports);
__exportStar(__webpack_require__(/*! ./channel-adapter */ "../adaptivecards/lib/channel-adapter.js"), exports);
__exportStar(__webpack_require__(/*! ./activity-request */ "../adaptivecards/lib/activity-request.js"), exports);
__exportStar(__webpack_require__(/*! ./adaptive-applet */ "../adaptivecards/lib/adaptive-applet.js"), exports);
//# sourceMappingURL=adaptivecards.js.map

/***/ }),

/***/ "../adaptivecards/lib/card-elements.js":
/*!*********************************************!*\
  !*** ../adaptivecards/lib/card-elements.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContainerWithActions = exports.ColumnSet = exports.Column = exports.Container = exports.BackgroundImage = exports.ContainerBase = exports.StylableCardElementContainer = exports.ContainerStyleProperty = exports.ActionSet = exports.ShowCardAction = exports.HttpAction = exports.HttpHeader = exports.ToggleVisibilityAction = exports.OpenUrlAction = exports.ExecuteAction = exports.SubmitAction = exports.SubmitActionBase = exports.Action = exports.TimeInput = exports.TimeProperty = exports.DateInput = exports.NumberInput = exports.ChoiceSetInput = exports.Choice = exports.ToggleInput = exports.TextInput = exports.Input = exports.Media = exports.YouTubePlayer = exports.DailymotionPlayer = exports.VimeoPlayer = exports.IFrameMediaMediaPlayer = exports.CustomMediaPlayer = exports.HTML5MediaPlayer = exports.MediaPlayer = exports.MediaSource = exports.CaptionSource = exports.ContentSource = exports.ImageSet = exports.CardElementContainer = exports.Image = exports.FactSet = exports.Fact = exports.RichTextBlock = exports.TextRun = exports.TextBlock = exports.BaseTextBlock = exports.ActionProperty = exports.CardElement = exports.renderSeparation = void 0;
exports.SerializationContext = exports.AdaptiveCard = exports.Authentication = exports.TokenExchangeResource = exports.AuthCardButton = exports.RefreshDefinition = exports.RefreshActionProperty = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var Enums = __webpack_require__(/*! ./enums */ "../adaptivecards/lib/enums.js");
var shared_1 = __webpack_require__(/*! ./shared */ "../adaptivecards/lib/shared.js");
var Utils = __webpack_require__(/*! ./utils */ "../adaptivecards/lib/utils.js");
var host_config_1 = __webpack_require__(/*! ./host-config */ "../adaptivecards/lib/host-config.js");
var TextFormatters = __webpack_require__(/*! ./text-formatters */ "../adaptivecards/lib/text-formatters.js");
var card_object_1 = __webpack_require__(/*! ./card-object */ "../adaptivecards/lib/card-object.js");
var serialization_1 = __webpack_require__(/*! ./serialization */ "../adaptivecards/lib/serialization.js");
var registry_1 = __webpack_require__(/*! ./registry */ "../adaptivecards/lib/registry.js");
var strings_1 = __webpack_require__(/*! ./strings */ "../adaptivecards/lib/strings.js");
var controls_1 = __webpack_require__(/*! ./controls */ "../adaptivecards/lib/controls/index.js");
function clearElement(element) {
    var _a, _b;
    var trustedHtml = (typeof window === 'undefined') ? "" : ((_b = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.emptyHTML) !== null && _b !== void 0 ? _b : "");
    element.innerHTML = trustedHtml;
}
function renderSeparation(hostConfig, separationDefinition, orientation) {
    if (separationDefinition.spacing > 0 ||
        (separationDefinition.lineThickness && separationDefinition.lineThickness > 0)) {
        var separator = document.createElement("div");
        separator.className = hostConfig.makeCssClassName("ac-" +
            (orientation === Enums.Orientation.Horizontal ? "horizontal" : "vertical") +
            "-separator");
        separator.setAttribute("aria-hidden", "true");
        var color = separationDefinition.lineColor
            ? Utils.stringToCssColor(separationDefinition.lineColor)
            : "";
        if (orientation === Enums.Orientation.Horizontal) {
            if (separationDefinition.lineThickness) {
                separator.style.paddingTop = separationDefinition.spacing / 2 + "px";
                separator.style.marginBottom = separationDefinition.spacing / 2 + "px";
                separator.style.borderBottom =
                    separationDefinition.lineThickness + "px solid " + color;
            }
            else {
                separator.style.height = separationDefinition.spacing + "px";
            }
        }
        else {
            if (separationDefinition.lineThickness) {
                separator.style.paddingLeft = separationDefinition.spacing / 2 + "px";
                separator.style.marginRight = separationDefinition.spacing / 2 + "px";
                separator.style.borderRight =
                    separationDefinition.lineThickness + "px solid " + color;
            }
            else {
                separator.style.width = separationDefinition.spacing + "px";
            }
        }
        separator.style.overflow = "hidden";
        separator.style.flex = "0 0 auto";
        return separator;
    }
    else {
        return undefined;
    }
}
exports.renderSeparation = renderSeparation;
var CardElement = /** @class */ (function (_super) {
    __extends(CardElement, _super);
    function CardElement() {
        //#region Schema
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._truncatedDueToOverflow = false;
        return _this;
    }
    Object.defineProperty(CardElement.prototype, "lang", {
        get: function () {
            var lang = this.getValue(CardElement.langProperty);
            if (lang) {
                return lang;
            }
            else {
                if (this.parent) {
                    return this.parent.lang;
                }
                else {
                    return undefined;
                }
            }
        },
        set: function (value) {
            this.setValue(CardElement.langProperty, value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CardElement.prototype, "isVisible", {
        get: function () {
            return this.getValue(CardElement.isVisibleProperty);
        },
        set: function (value) {
            // If the element is going to be hidden, reset any changes that were due
            // to overflow truncation (this ensures that if the element is later
            // un-hidden it has the right content)
            if (shared_1.GlobalSettings.useAdvancedCardBottomTruncation && !value) {
                this.undoOverflowTruncation();
            }
            if (this.isVisible !== value) {
                this.setValue(CardElement.isVisibleProperty, value);
                this.updateRenderedElementVisibility();
                if (this._renderedElement) {
                    raiseElementVisibilityChangedEvent(this);
                }
            }
            if (this._renderedElement) {
                this._renderedElement.setAttribute("aria-expanded", value.toString());
            }
        },
        enumerable: false,
        configurable: true
    });
    CardElement.prototype.internalRenderSeparator = function () {
        var renderedSeparator = renderSeparation(this.hostConfig, {
            spacing: this.hostConfig.getEffectiveSpacing(this.spacing),
            lineThickness: this.separator ? this.hostConfig.separator.lineThickness : undefined,
            lineColor: this.separator ? this.hostConfig.separator.lineColor : undefined
        }, this.separatorOrientation);
        if (shared_1.GlobalSettings.alwaysBleedSeparators &&
            renderedSeparator &&
            this.separatorOrientation === Enums.Orientation.Horizontal) {
            // Adjust separator's margins if the option to always bleed separators is turned on
            var parentContainer = this.getParentContainer();
            if (parentContainer && parentContainer.getEffectivePadding()) {
                var parentPhysicalPadding = this.hostConfig.paddingDefinitionToSpacingDefinition(parentContainer.getEffectivePadding());
                renderedSeparator.style.marginLeft = "-" + parentPhysicalPadding.left + "px";
                renderedSeparator.style.marginRight = "-" + parentPhysicalPadding.right + "px";
            }
        }
        return renderedSeparator;
    };
    CardElement.prototype.updateRenderedElementVisibility = function () {
        var displayMode = this.isDesignMode() || this.isVisible
            ? this._defaultRenderedElementDisplayMode
            : "none";
        if (this._renderedElement) {
            if (displayMode) {
                this._renderedElement.style.display = displayMode;
            }
            else {
                this._renderedElement.style.removeProperty("display");
            }
        }
        if (this._separatorElement) {
            if (this.parent && this.parent.isFirstElement(this)) {
                this._separatorElement.style.display = "none";
            }
            else {
                if (displayMode) {
                    this._separatorElement.style.display = displayMode;
                }
                else {
                    this._separatorElement.style.removeProperty("display");
                }
            }
        }
    };
    CardElement.prototype.hideElementDueToOverflow = function () {
        if (this._renderedElement && this.isVisible) {
            this._renderedElement.style.visibility = "hidden";
            this.isVisible = false;
            raiseElementVisibilityChangedEvent(this, false);
        }
    };
    CardElement.prototype.showElementHiddenDueToOverflow = function () {
        if (this._renderedElement && !this.isVisible) {
            this._renderedElement.style.removeProperty("visibility");
            this.isVisible = true;
            raiseElementVisibilityChangedEvent(this, false);
        }
    };
    // Marked private to emulate internal access
    CardElement.prototype.handleOverflow = function (maxHeight) {
        if (this.isVisible || this.isHiddenDueToOverflow()) {
            var handled = this.truncateOverflow(maxHeight);
            // Even if we were unable to truncate the element to fit this time,
            // it still could have been previously truncated
            this._truncatedDueToOverflow = handled || this._truncatedDueToOverflow;
            if (!handled) {
                this.hideElementDueToOverflow();
            }
            else if (handled && !this.isVisible) {
                this.showElementHiddenDueToOverflow();
            }
        }
    };
    // Marked private to emulate internal access
    CardElement.prototype.resetOverflow = function () {
        var sizeChanged = false;
        if (this._truncatedDueToOverflow) {
            this.undoOverflowTruncation();
            this._truncatedDueToOverflow = false;
            sizeChanged = true;
        }
        if (this.isHiddenDueToOverflow()) {
            this.showElementHiddenDueToOverflow();
        }
        return sizeChanged;
    };
    CardElement.prototype.getDefaultSerializationContext = function () {
        return new SerializationContext();
    };
    CardElement.prototype.createPlaceholderElement = function () {
        var styleDefinition = this.getEffectiveStyleDefinition();
        var foregroundCssColor = Utils.stringToCssColor(styleDefinition.foregroundColors.default.subtle);
        var element = document.createElement("div");
        element.style.border = "1px dashed " + foregroundCssColor;
        element.style.padding = "4px";
        element.style.minHeight = "32px";
        element.style.fontSize = "10px";
        if (foregroundCssColor) {
            element.style.color = foregroundCssColor;
        }
        element.innerText = "Empty " + this.getJsonTypeName();
        return element;
    };
    CardElement.prototype.adjustRenderedElementSize = function (renderedElement) {
        if (this.height === "auto") {
            renderedElement.style.flex = "0 0 auto";
        }
        else {
            renderedElement.style.flex = "1 1 auto";
        }
    };
    CardElement.prototype.isDisplayed = function () {
        return (this._renderedElement !== undefined &&
            this.isVisible &&
            this._renderedElement.offsetHeight > 0);
    };
    CardElement.prototype.overrideInternalRender = function () {
        return this.internalRender();
    };
    CardElement.prototype.applyPadding = function () {
        if (this.separatorElement && this.separatorOrientation === Enums.Orientation.Horizontal) {
            if (shared_1.GlobalSettings.alwaysBleedSeparators && !this.isBleeding()) {
                var padding = new shared_1.PaddingDefinition();
                this.getImmediateSurroundingPadding(padding);
                var physicalPadding = this.hostConfig.paddingDefinitionToSpacingDefinition(padding);
                this.separatorElement.style.marginLeft = "-" + physicalPadding.left + "px";
                this.separatorElement.style.marginRight = "-" + physicalPadding.right + "px";
            }
            else {
                this.separatorElement.style.marginRight = "0";
                this.separatorElement.style.marginLeft = "0";
            }
        }
    };
    /*
     * Called when this element overflows the bottom of the card.
     * maxHeight will be the amount of space still available on the card (0 if
     * the element is fully off the card).
     */
    CardElement.prototype.truncateOverflow = function (_maxHeight) {
        // Child implementations should return true if the element handled
        // the truncation request such that its content fits within maxHeight,
        // false if the element should fall back to being hidden
        return false;
    };
    /*
     * This should reverse any changes performed in truncateOverflow().
     */
    CardElement.prototype.undoOverflowTruncation = function () {
        return;
    };
    CardElement.prototype.getDefaultPadding = function () {
        return new shared_1.PaddingDefinition();
    };
    CardElement.prototype.getHasBackground = function (ignoreBackgroundImages) {
        if (ignoreBackgroundImages === void 0) { ignoreBackgroundImages = false; }
        return false;
    };
    CardElement.prototype.getHasBorder = function () {
        return false;
    };
    CardElement.prototype.getPadding = function () {
        return this._padding;
    };
    CardElement.prototype.setPadding = function (value) {
        this._padding = value;
    };
    CardElement.prototype.shouldSerialize = function (context) {
        return context.elementRegistry.findByName(this.getJsonTypeName()) !== undefined;
    };
    Object.defineProperty(CardElement.prototype, "useDefaultSizing", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CardElement.prototype, "separatorOrientation", {
        get: function () {
            return Enums.Orientation.Horizontal;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CardElement.prototype, "defaultStyle", {
        get: function () {
            return Enums.ContainerStyle.Default;
        },
        enumerable: false,
        configurable: true
    });
    CardElement.prototype.parse = function (source, context) {
        _super.prototype.parse.call(this, source, context ? context : new SerializationContext());
    };
    CardElement.prototype.asString = function () {
        return "";
    };
    CardElement.prototype.isBleeding = function () {
        return false;
    };
    CardElement.prototype.getEffectiveStyle = function () {
        if (this.parent) {
            return this.parent.getEffectiveStyle();
        }
        return this.defaultStyle;
    };
    CardElement.prototype.getEffectiveStyleDefinition = function () {
        return this.hostConfig.containerStyles.getStyleByName(this.getEffectiveStyle());
    };
    CardElement.prototype.getEffectiveTextStyleDefinition = function () {
        if (this.parent) {
            return this.parent.getEffectiveTextStyleDefinition();
        }
        return this.hostConfig.textStyles.default;
    };
    CardElement.prototype.getForbiddenActionTypes = function () {
        return [];
    };
    CardElement.prototype.getImmediateSurroundingPadding = function (result, processTop, processRight, processBottom, processLeft) {
        if (processTop === void 0) { processTop = true; }
        if (processRight === void 0) { processRight = true; }
        if (processBottom === void 0) { processBottom = true; }
        if (processLeft === void 0) { processLeft = true; }
        if (this.parent) {
            var doProcessTop = processTop && this.parent.isTopElement(this);
            var doProcessRight = processRight && this.parent.isRightMostElement(this);
            var doProcessBottom = processBottom && this.parent.isBottomElement(this);
            var doProcessLeft = processLeft && this.parent.isLeftMostElement(this);
            var effectivePadding = this.parent.getEffectivePadding();
            if (effectivePadding) {
                if (doProcessTop && effectivePadding.top !== Enums.Spacing.None) {
                    result.top = effectivePadding.top;
                    doProcessTop = false;
                }
                if (doProcessRight && effectivePadding.right !== Enums.Spacing.None) {
                    result.right = effectivePadding.right;
                    doProcessRight = false;
                }
                if (doProcessBottom && effectivePadding.bottom !== Enums.Spacing.None) {
                    result.bottom = effectivePadding.bottom;
                    doProcessBottom = false;
                }
                if (doProcessLeft && effectivePadding.left !== Enums.Spacing.None) {
                    result.left = effectivePadding.left;
                    doProcessLeft = false;
                }
            }
            if (doProcessTop || doProcessRight || doProcessBottom || doProcessLeft) {
                this.parent.getImmediateSurroundingPadding(result, doProcessTop, doProcessRight, doProcessBottom, doProcessLeft);
            }
        }
    };
    CardElement.prototype.getActionCount = function () {
        return 0;
    };
    CardElement.prototype.getActionAt = function (index) {
        throw new Error(strings_1.Strings.errors.indexOutOfRange(index));
    };
    CardElement.prototype.indexOfAction = function (action) {
        for (var i = 0; i < this.getActionCount(); i++) {
            if (this.getActionAt(i) === action) {
                return i;
            }
        }
        return -1;
    };
    CardElement.prototype.remove = function () {
        if (this.parent && this.parent instanceof CardElementContainer) {
            return this.parent.removeItem(this);
        }
        return false;
    };
    CardElement.prototype.render = function () {
        this._renderedElement = this.overrideInternalRender();
        this._separatorElement = this.internalRenderSeparator();
        if (this._renderedElement) {
            if (this.id) {
                this._renderedElement.id = this.id;
            }
            if (this.customCssSelector) {
                this._renderedElement.classList.add(this.customCssSelector);
            }
            this._renderedElement.style.boxSizing = "border-box";
            this._defaultRenderedElementDisplayMode = this._renderedElement.style.display
                ? this._renderedElement.style.display
                : undefined;
            this.adjustRenderedElementSize(this._renderedElement);
            this.updateLayout(false);
        }
        else if (this.isDesignMode()) {
            this._renderedElement = this.createPlaceholderElement();
        }
        this.getRootElement().updateActionsEnabledState();
        return this._renderedElement;
    };
    CardElement.prototype.updateLayout = function (_processChildren) {
        if (_processChildren === void 0) { _processChildren = true; }
        this.updateRenderedElementVisibility();
        this.applyPadding();
    };
    CardElement.prototype.updateActionsEnabledState = function () {
        var allActions = this.getRootElement().getAllActions();
        for (var _i = 0, allActions_1 = allActions; _i < allActions_1.length; _i++) {
            var action = allActions_1[_i];
            action.updateEnabledState();
        }
    };
    CardElement.prototype.indexOf = function (_cardElement) {
        return -1;
    };
    CardElement.prototype.isDesignMode = function () {
        var rootElement = this.getRootElement();
        return rootElement instanceof AdaptiveCard && rootElement.designMode;
    };
    CardElement.prototype.isFirstElement = function (_element) {
        return true;
    };
    CardElement.prototype.isLastElement = function (_element) {
        return true;
    };
    CardElement.prototype.isAtTheVeryLeft = function () {
        return this.parent
            ? this.parent.isLeftMostElement(this) && this.parent.isAtTheVeryLeft()
            : true;
    };
    CardElement.prototype.isAtTheVeryRight = function () {
        return this.parent
            ? this.parent.isRightMostElement(this) && this.parent.isAtTheVeryRight()
            : true;
    };
    CardElement.prototype.isAtTheVeryTop = function () {
        return this.parent
            ? this.parent.isFirstElement(this) && this.parent.isAtTheVeryTop()
            : true;
    };
    CardElement.prototype.isAtTheVeryBottom = function () {
        return this.parent
            ? this.parent.isLastElement(this) && this.parent.isAtTheVeryBottom()
            : true;
    };
    CardElement.prototype.isBleedingAtTop = function () {
        return false;
    };
    CardElement.prototype.isBleedingAtBottom = function () {
        return false;
    };
    CardElement.prototype.isLeftMostElement = function (_element) {
        return true;
    };
    CardElement.prototype.isRightMostElement = function (_element) {
        return true;
    };
    CardElement.prototype.isTopElement = function (element) {
        return this.isFirstElement(element);
    };
    CardElement.prototype.isBottomElement = function (element) {
        return this.isLastElement(element);
    };
    CardElement.prototype.isHiddenDueToOverflow = function () {
        return (this._renderedElement !== undefined &&
            this._renderedElement.style.visibility === "hidden");
    };
    CardElement.prototype.getRootElement = function () {
        return this.getRootObject();
    };
    CardElement.prototype.getParentContainer = function () {
        var currentElement = this.parent;
        while (currentElement) {
            if (currentElement instanceof Container) {
                return currentElement;
            }
            currentElement = currentElement.parent;
        }
        return undefined;
    };
    CardElement.prototype.getAllInputs = function (processActions) {
        if (processActions === void 0) { processActions = true; }
        return [];
    };
    CardElement.prototype.getAllActions = function () {
        var result = [];
        for (var i = 0; i < this.getActionCount(); i++) {
            var action = this.getActionAt(i);
            if (action) {
                result.push(action);
            }
        }
        return result;
    };
    CardElement.prototype.getResourceInformation = function () {
        return [];
    };
    CardElement.prototype.getElementById = function (id) {
        return this.id === id ? this : undefined;
    };
    CardElement.prototype.getActionById = function (_id) {
        return undefined;
    };
    CardElement.prototype.getEffectivePadding = function () {
        var padding = this.getPadding();
        return padding ? padding : this.getDefaultPadding();
    };
    CardElement.prototype.getEffectiveHorizontalAlignment = function () {
        if (this.horizontalAlignment !== undefined) {
            return this.horizontalAlignment;
        }
        if (this.parent) {
            return this.parent.getEffectiveHorizontalAlignment();
        }
        return Enums.HorizontalAlignment.Left;
    };
    Object.defineProperty(CardElement.prototype, "hostConfig", {
        get: function () {
            if (this._hostConfig) {
                return this._hostConfig;
            }
            else {
                if (this.parent) {
                    return this.parent.hostConfig;
                }
                else {
                    return host_config_1.defaultHostConfig;
                }
            }
        },
        set: function (value) {
            this._hostConfig = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CardElement.prototype, "index", {
        get: function () {
            if (this.parent) {
                return this.parent.indexOf(this);
            }
            else {
                return 0;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CardElement.prototype, "isInteractive", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CardElement.prototype, "isStandalone", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CardElement.prototype, "isInline", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CardElement.prototype, "hasVisibleSeparator", {
        get: function () {
            if (this.parent && this.separatorElement) {
                return !this.parent.isFirstElement(this) && (this.isVisible || this.isDesignMode());
            }
            else {
                return false;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CardElement.prototype, "separatorElement", {
        get: function () {
            return this._separatorElement;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CardElement.prototype, "parent", {
        get: function () {
            return this._parent;
        },
        enumerable: false,
        configurable: true
    });
    CardElement.prototype.getElementSingletonBehavior = function () {
        return registry_1.ElementSingletonBehavior.NotAllowed;
    };
    CardElement.langProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_1, "lang", true, /^[a-z]{2,3}$/gi);
    CardElement.isVisibleProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_2, "isVisible", true);
    CardElement.separatorProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_0, "separator", false);
    CardElement.heightProperty = new serialization_1.ValueSetProperty(serialization_1.Versions.v1_1, "height", [{ value: "auto" }, { value: "stretch" }], "auto");
    CardElement.horizontalAlignmentProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_0, "horizontalAlignment", Enums.HorizontalAlignment);
    CardElement.spacingProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_0, "spacing", Enums.Spacing, Enums.Spacing.Default);
    __decorate([
        (0, serialization_1.property)(CardElement.horizontalAlignmentProperty)
    ], CardElement.prototype, "horizontalAlignment", void 0);
    __decorate([
        (0, serialization_1.property)(CardElement.spacingProperty)
    ], CardElement.prototype, "spacing", void 0);
    __decorate([
        (0, serialization_1.property)(CardElement.separatorProperty)
    ], CardElement.prototype, "separator", void 0);
    __decorate([
        (0, serialization_1.property)(CardElement.heightProperty)
    ], CardElement.prototype, "height", void 0);
    __decorate([
        (0, serialization_1.property)(CardElement.langProperty)
    ], CardElement.prototype, "lang", null);
    __decorate([
        (0, serialization_1.property)(CardElement.isVisibleProperty)
    ], CardElement.prototype, "isVisible", null);
    return CardElement;
}(card_object_1.CardObject));
exports.CardElement = CardElement;
var ActionProperty = /** @class */ (function (_super) {
    __extends(ActionProperty, _super);
    function ActionProperty(targetVersion, name, forbiddenActionTypes) {
        if (forbiddenActionTypes === void 0) { forbiddenActionTypes = []; }
        var _this = _super.call(this, targetVersion, name, undefined) || this;
        _this.targetVersion = targetVersion;
        _this.name = name;
        _this.forbiddenActionTypes = forbiddenActionTypes;
        return _this;
    }
    ActionProperty.prototype.parse = function (sender, source, context) {
        var parent = sender;
        return context.parseAction(parent, source[this.name], this.forbiddenActionTypes, parent.isDesignMode());
    };
    ActionProperty.prototype.toJSON = function (sender, target, value, context) {
        context.serializeValue(target, this.name, value ? value.toJSON(context) : undefined, undefined, true);
    };
    return ActionProperty;
}(serialization_1.PropertyDefinition));
exports.ActionProperty = ActionProperty;
var BaseTextBlock = /** @class */ (function (_super) {
    __extends(BaseTextBlock, _super);
    function BaseTextBlock(text) {
        var _this = _super.call(this) || this;
        _this.ariaHidden = false;
        if (text) {
            _this.text = text;
        }
        return _this;
    }
    BaseTextBlock.prototype.populateSchema = function (schema) {
        _super.prototype.populateSchema.call(this, schema);
        // selectAction is declared on BaseTextBlock but is only exposed on TextRun,
        // so the property is removed from the BaseTextBlock schema.
        schema.remove(BaseTextBlock.selectActionProperty);
    };
    Object.defineProperty(BaseTextBlock.prototype, "text", {
        get: function () {
            return this.getValue(BaseTextBlock.textProperty);
        },
        set: function (value) {
            this.setText(value);
        },
        enumerable: false,
        configurable: true
    });
    //#endregion
    BaseTextBlock.prototype.getFontSize = function (fontType) {
        switch (this.effectiveSize) {
            case Enums.TextSize.Small:
                return fontType.fontSizes.small;
            case Enums.TextSize.Medium:
                return fontType.fontSizes.medium;
            case Enums.TextSize.Large:
                return fontType.fontSizes.large;
            case Enums.TextSize.ExtraLarge:
                return fontType.fontSizes.extraLarge;
            default:
                return fontType.fontSizes.default;
        }
    };
    BaseTextBlock.prototype.getColorDefinition = function (colorSet, color) {
        switch (color) {
            case Enums.TextColor.Accent:
                return colorSet.accent;
            case Enums.TextColor.Dark:
                return colorSet.dark;
            case Enums.TextColor.Light:
                return colorSet.light;
            case Enums.TextColor.Good:
                return colorSet.good;
            case Enums.TextColor.Warning:
                return colorSet.warning;
            case Enums.TextColor.Attention:
                return colorSet.attention;
            default:
                return colorSet.default;
        }
    };
    BaseTextBlock.prototype.setText = function (value) {
        this.setValue(BaseTextBlock.textProperty, value);
    };
    BaseTextBlock.prototype.init = function (textDefinition) {
        this.size = textDefinition.size;
        this.weight = textDefinition.weight;
        this.color = textDefinition.color;
        this.isSubtle = textDefinition.isSubtle;
    };
    BaseTextBlock.prototype.asString = function () {
        return this.text;
    };
    BaseTextBlock.prototype.applyStylesTo = function (targetElement) {
        var fontType = this.hostConfig.getFontTypeDefinition(this.effectiveFontType);
        if (fontType.fontFamily) {
            targetElement.style.fontFamily = fontType.fontFamily;
        }
        var fontSize;
        switch (this.effectiveSize) {
            case Enums.TextSize.Small:
                fontSize = fontType.fontSizes.small;
                break;
            case Enums.TextSize.Medium:
                fontSize = fontType.fontSizes.medium;
                break;
            case Enums.TextSize.Large:
                fontSize = fontType.fontSizes.large;
                break;
            case Enums.TextSize.ExtraLarge:
                fontSize = fontType.fontSizes.extraLarge;
                break;
            default:
                fontSize = fontType.fontSizes.default;
                break;
        }
        targetElement.style.fontSize = fontSize + "px";
        var colorDefinition = this.getColorDefinition(this.getEffectiveStyleDefinition().foregroundColors, this.effectiveColor);
        var targetColor = Utils.stringToCssColor(this.effectiveIsSubtle ? colorDefinition.subtle : colorDefinition.default);
        if (targetColor) {
            targetElement.style.color = targetColor;
        }
        var fontWeight;
        switch (this.effectiveWeight) {
            case Enums.TextWeight.Lighter:
                fontWeight = fontType.fontWeights.lighter;
                break;
            case Enums.TextWeight.Bolder:
                fontWeight = fontType.fontWeights.bolder;
                break;
            default:
                fontWeight = fontType.fontWeights.default;
                break;
        }
        targetElement.style.fontWeight = fontWeight.toString();
        if (this.ariaHidden) {
            targetElement.setAttribute("aria-hidden", "true");
        }
    };
    BaseTextBlock.prototype.getAllActions = function () {
        var result = _super.prototype.getAllActions.call(this);
        if (this.selectAction) {
            result.push(this.selectAction);
        }
        return result;
    };
    Object.defineProperty(BaseTextBlock.prototype, "effectiveColor", {
        get: function () {
            return this.color !== undefined ? this.color : this.getEffectiveTextStyleDefinition().color;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseTextBlock.prototype, "effectiveFontType", {
        get: function () {
            return this.fontType !== undefined
                ? this.fontType
                : this.getEffectiveTextStyleDefinition().fontType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseTextBlock.prototype, "effectiveIsSubtle", {
        get: function () {
            return this.isSubtle !== undefined
                ? this.isSubtle
                : this.getEffectiveTextStyleDefinition().isSubtle;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseTextBlock.prototype, "effectiveSize", {
        get: function () {
            return this.size !== undefined ? this.size : this.getEffectiveTextStyleDefinition().size;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseTextBlock.prototype, "effectiveWeight", {
        get: function () {
            return this.weight !== undefined
                ? this.weight
                : this.getEffectiveTextStyleDefinition().weight;
        },
        enumerable: false,
        configurable: true
    });
    //#region Schema
    BaseTextBlock.textProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "text", true);
    BaseTextBlock.sizeProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_0, "size", Enums.TextSize);
    BaseTextBlock.weightProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_0, "weight", Enums.TextWeight);
    BaseTextBlock.colorProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_0, "color", Enums.TextColor);
    BaseTextBlock.isSubtleProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_0, "isSubtle");
    BaseTextBlock.fontTypeProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_2, "fontType", Enums.FontType);
    BaseTextBlock.selectActionProperty = new ActionProperty(serialization_1.Versions.v1_1, "selectAction", [
        "Action.ShowCard"
    ]);
    __decorate([
        (0, serialization_1.property)(BaseTextBlock.sizeProperty)
    ], BaseTextBlock.prototype, "size", void 0);
    __decorate([
        (0, serialization_1.property)(BaseTextBlock.weightProperty)
    ], BaseTextBlock.prototype, "weight", void 0);
    __decorate([
        (0, serialization_1.property)(BaseTextBlock.colorProperty)
    ], BaseTextBlock.prototype, "color", void 0);
    __decorate([
        (0, serialization_1.property)(BaseTextBlock.fontTypeProperty)
    ], BaseTextBlock.prototype, "fontType", void 0);
    __decorate([
        (0, serialization_1.property)(BaseTextBlock.isSubtleProperty)
    ], BaseTextBlock.prototype, "isSubtle", void 0);
    __decorate([
        (0, serialization_1.property)(BaseTextBlock.textProperty)
    ], BaseTextBlock.prototype, "text", null);
    __decorate([
        (0, serialization_1.property)(BaseTextBlock.selectActionProperty)
    ], BaseTextBlock.prototype, "selectAction", void 0);
    return BaseTextBlock;
}(CardElement));
exports.BaseTextBlock = BaseTextBlock;
var TextBlock = /** @class */ (function (_super) {
    __extends(TextBlock, _super);
    function TextBlock() {
        //#region Schema
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.wrap = false;
        _this._treatAsPlainText = true;
        _this.useMarkdown = true;
        return _this;
    }
    TextBlock.prototype.restoreOriginalContent = function () {
        var _a, _b;
        if (this.renderedElement !== undefined) {
            if (this.maxLines && this.maxLines > 0) {
                this.renderedElement.style.maxHeight =
                    this._computedLineHeight * this.maxLines + "px";
            }
            var originalHtml = (_b = (_a = TextBlock._ttRoundtripPolicy) === null || _a === void 0 ? void 0 : _a.createHTML(this._originalInnerHtml)) !== null && _b !== void 0 ? _b : this._originalInnerHtml;
            this.renderedElement.innerHTML = originalHtml;
        }
    };
    TextBlock.prototype.truncateIfSupported = function (maxHeight) {
        if (this.renderedElement !== undefined) {
            // For now, only truncate TextBlocks that contain just a single
            // paragraph -- since the maxLines calculation doesn't take into
            // account Markdown lists
            var children = this.renderedElement.children;
            var isTextOnly = !children.length;
            var truncationSupported = isTextOnly ||
                (children.length === 1 && children[0].tagName.toLowerCase() === "p" && !children[0].children.length);
            if (truncationSupported) {
                var element = isTextOnly ? this.renderedElement : children[0];
                Utils.truncateText(element, maxHeight, this._computedLineHeight);
                return true;
            }
        }
        return false;
    };
    TextBlock.prototype.setText = function (value) {
        _super.prototype.setText.call(this, value);
        this._processedText = undefined;
    };
    TextBlock.prototype.internalRender = function () {
        var _this = this;
        var _a, _b;
        this._processedText = undefined;
        if (this.text) {
            var preProcessedText = this.preProcessPropertyValue(BaseTextBlock.textProperty);
            var hostConfig = this.hostConfig;
            var element = void 0;
            if (this.forElementId) {
                var labelElement = document.createElement("label");
                labelElement.htmlFor = this.forElementId;
                element = labelElement;
            }
            else {
                element = document.createElement("div");
            }
            element.classList.add(hostConfig.makeCssClassName("ac-textBlock"));
            element.style.overflow = "hidden";
            this.applyStylesTo(element);
            if (this.style === "heading") {
                element.setAttribute("role", "heading");
                var headingLevel = this.hostConfig.textBlock.headingLevel;
                if (headingLevel !== undefined && headingLevel > 0) {
                    element.setAttribute("aria-level", headingLevel.toString());
                }
            }
            if (this.selectAction && hostConfig.supportsInteractivity) {
                element.onclick = function (e) {
                    if (_this.selectAction && _this.selectAction.isEffectivelyEnabled()) {
                        e.preventDefault();
                        e.cancelBubble = true;
                        _this.selectAction.execute();
                    }
                };
                this.selectAction.setupElementForAccessibility(element);
                if (this.selectAction.isEffectivelyEnabled()) {
                    element.classList.add(hostConfig.makeCssClassName("ac-selectable"));
                }
            }
            if (!this._processedText) {
                this._treatAsPlainText = true;
                var formattedText = TextFormatters.formatText(this.lang, preProcessedText);
                if (this.useMarkdown && formattedText) {
                    if (shared_1.GlobalSettings.allowMarkForTextHighlighting) {
                        formattedText = formattedText
                            .replace(/<mark>/g, "===")
                            .replace(/<\/mark>/g, "/==/");
                    }
                    var markdownProcessingResult = AdaptiveCard.applyMarkdown(formattedText);
                    if (markdownProcessingResult.didProcess &&
                        markdownProcessingResult.outputHtml) {
                        this._processedText = markdownProcessingResult.outputHtml;
                        this._treatAsPlainText = false;
                        // Only process <mark> tag if markdown processing was applied because
                        // markdown processing is also responsible for sanitizing the input string
                        if (shared_1.GlobalSettings.allowMarkForTextHighlighting && this._processedText) {
                            var markStyle = "";
                            var effectiveStyle = this.getEffectiveStyleDefinition();
                            if (effectiveStyle.highlightBackgroundColor) {
                                markStyle +=
                                    "background-color: " +
                                        effectiveStyle.highlightBackgroundColor +
                                        ";";
                            }
                            if (effectiveStyle.highlightForegroundColor) {
                                markStyle +=
                                    "color: " + effectiveStyle.highlightForegroundColor + ";";
                            }
                            if (markStyle) {
                                markStyle = 'style="' + markStyle + '"';
                            }
                            this._processedText = this._processedText
                                .replace(/===/g, "<mark " + markStyle + ">")
                                .replace(/\/==\//g, "</mark>");
                        }
                    }
                    else {
                        this._processedText = formattedText;
                        this._treatAsPlainText = true;
                    }
                }
                else {
                    this._processedText = formattedText;
                    this._treatAsPlainText = true;
                }
            }
            if (!this._processedText) {
                this._processedText = "";
            }
            if (this._treatAsPlainText) {
                element.innerText = this._processedText;
            }
            else {
                var processedHtml = (_b = (_a = TextBlock._ttMarkdownPolicy) === null || _a === void 0 ? void 0 : _a.createHTML(this._processedText)) !== null && _b !== void 0 ? _b : this._processedText;
                element.innerHTML = processedHtml;
            }
            if (element.firstElementChild instanceof HTMLElement) {
                var firstElementChild = element.firstElementChild;
                firstElementChild.style.marginTop = "0px";
                firstElementChild.style.width = "100%";
                if (!this.wrap) {
                    firstElementChild.style.overflow = "hidden";
                    firstElementChild.style.textOverflow = "ellipsis";
                }
            }
            if (element.lastElementChild instanceof HTMLElement) {
                element.lastElementChild.style.marginBottom = "0px";
            }
            var anchors = element.getElementsByTagName("a");
            var _loop_1 = function (anchor) {
                anchor.classList.add(hostConfig.makeCssClassName("ac-anchor"));
                anchor.target = "_blank";
                anchor.onclick = function (e) {
                    if (raiseAnchorClickedEvent(_this, anchor, e)) {
                        e.preventDefault();
                        e.cancelBubble = true;
                    }
                };
                anchor.oncontextmenu = function (e) {
                    if (raiseAnchorClickedEvent(_this, anchor, e)) {
                        e.preventDefault();
                        e.cancelBubble = true;
                        return false;
                    }
                    return true;
                };
            };
            for (var _i = 0, _c = Array.from(anchors); _i < _c.length; _i++) {
                var anchor = _c[_i];
                _loop_1(anchor);
            }
            if (this.wrap) {
                element.style.wordWrap = "break-word";
                if (this.maxLines && this.maxLines > 0) {
                    element.style.overflow = "hidden";
                    if (Utils.isInternetExplorer() || !shared_1.GlobalSettings.useWebkitLineClamp) {
                        element.style.maxHeight = this._computedLineHeight * this.maxLines + "px";
                    }
                    else {
                        // While non standard, --webkit-line-clamp works in every browser (except IE)
                        // and is a great solution to support the maxLines feature with ellipsis
                        // truncation. With --webkit-line-clamp there is need to use explicit line heights
                        element.style.removeProperty("line-height");
                        element.style.display = "-webkit-box";
                        element.style.webkitBoxOrient = "vertical";
                        element.style.webkitLineClamp = this.maxLines.toString();
                    }
                }
            }
            else {
                element.style.whiteSpace = "nowrap";
                element.style.textOverflow = "ellipsis";
            }
            if (shared_1.GlobalSettings.useAdvancedTextBlockTruncation ||
                shared_1.GlobalSettings.useAdvancedCardBottomTruncation) {
                this._originalInnerHtml = element.innerHTML;
            }
            return element;
        }
        else {
            return undefined;
        }
    };
    TextBlock.prototype.truncateOverflow = function (maxHeight) {
        if (maxHeight >= this._computedLineHeight) {
            return this.truncateIfSupported(maxHeight);
        }
        return false;
    };
    TextBlock.prototype.undoOverflowTruncation = function () {
        this.restoreOriginalContent();
        if (shared_1.GlobalSettings.useAdvancedTextBlockTruncation && this.maxLines) {
            var maxHeight = this._computedLineHeight * this.maxLines;
            this.truncateIfSupported(maxHeight);
        }
    };
    TextBlock.prototype.applyStylesTo = function (targetElement) {
        _super.prototype.applyStylesTo.call(this, targetElement);
        switch (this.getEffectiveHorizontalAlignment()) {
            case Enums.HorizontalAlignment.Center:
                targetElement.style.textAlign = "center";
                break;
            case Enums.HorizontalAlignment.Right:
                targetElement.style.textAlign = "end";
                break;
            default:
                targetElement.style.textAlign = "start";
                break;
        }
        var lineHeights = this.hostConfig.lineHeights;
        if (lineHeights) {
            switch (this.effectiveSize) {
                case Enums.TextSize.Small:
                    this._computedLineHeight = lineHeights.small;
                    break;
                case Enums.TextSize.Medium:
                    this._computedLineHeight = lineHeights.medium;
                    break;
                case Enums.TextSize.Large:
                    this._computedLineHeight = lineHeights.large;
                    break;
                case Enums.TextSize.ExtraLarge:
                    this._computedLineHeight = lineHeights.extraLarge;
                    break;
                default:
                    this._computedLineHeight = lineHeights.default;
                    break;
            }
        }
        else {
            // Looks like 1.33 is the magic number to compute line-height
            // from font size.
            this._computedLineHeight =
                this.getFontSize(this.hostConfig.getFontTypeDefinition(this.effectiveFontType)) *
                    1.33;
        }
        targetElement.style.lineHeight = this._computedLineHeight + "px";
    };
    TextBlock.prototype.getJsonTypeName = function () {
        return "TextBlock";
    };
    TextBlock.prototype.getEffectiveTextStyleDefinition = function () {
        if (this.style) {
            return this.hostConfig.textStyles.getStyleByName(this.style);
        }
        return _super.prototype.getEffectiveTextStyleDefinition.call(this);
    };
    TextBlock.prototype.updateLayout = function (processChildren) {
        if (processChildren === void 0) { processChildren = false; }
        _super.prototype.updateLayout.call(this, processChildren);
        if (shared_1.GlobalSettings.useAdvancedTextBlockTruncation && this.maxLines && this.isDisplayed()) {
            // Reset the element's innerHTML in case the available room for
            // content has increased
            this.restoreOriginalContent();
            this.truncateIfSupported(this._computedLineHeight * this.maxLines);
        }
    };
    var _a, _b;
    TextBlock.wrapProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_0, "wrap", false);
    TextBlock.maxLinesProperty = new serialization_1.NumProperty(serialization_1.Versions.v1_0, "maxLines");
    TextBlock.styleProperty = new serialization_1.ValueSetProperty(serialization_1.Versions.v1_5, "style", [
        { value: "default" },
        { value: "columnHeader" },
        { value: "heading" }
    ]);
    // Markdown processing is handled outside of Adaptive Cards. It's up to the host to ensure that markdown is safely
    // processed.
    TextBlock._ttMarkdownPolicy = (typeof window === 'undefined') ? undefined : (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy("adaptivecards#markdownPassthroughPolicy", { createHTML: function (value) { return value; } });
    // When "advanced" truncation is enabled (see GlobalSettings.useAdvancedCardBottomTruncation and
    // GlobalSettings.useAdvancedTextBlockTruncation), we store the original pre-truncation content in
    // _originalInnerHtml so that we can restore/recalculate truncation later if space availability has changed (see
    // TextBlock.restoreOriginalContent())
    TextBlock._ttRoundtripPolicy = (typeof window === 'undefined') ? undefined : (_b = window.trustedTypes) === null || _b === void 0 ? void 0 : _b.createPolicy("adaptivecards#restoreContentsPolicy", { createHTML: function (value) { return value; } });
    __decorate([
        (0, serialization_1.property)(TextBlock.wrapProperty)
    ], TextBlock.prototype, "wrap", void 0);
    __decorate([
        (0, serialization_1.property)(TextBlock.maxLinesProperty)
    ], TextBlock.prototype, "maxLines", void 0);
    __decorate([
        (0, serialization_1.property)(TextBlock.styleProperty)
    ], TextBlock.prototype, "style", void 0);
    return TextBlock;
}(BaseTextBlock));
exports.TextBlock = TextBlock;
var TextRun = /** @class */ (function (_super) {
    __extends(TextRun, _super);
    function TextRun() {
        //#region Schema
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.italic = false;
        _this.strikethrough = false;
        _this.highlight = false;
        _this.underline = false;
        return _this;
    }
    TextRun.prototype.populateSchema = function (schema) {
        _super.prototype.populateSchema.call(this, schema);
        schema.add(BaseTextBlock.selectActionProperty);
    };
    //#endregion
    TextRun.prototype.internalRender = function () {
        var _this = this;
        if (this.text) {
            var preProcessedText = this.preProcessPropertyValue(BaseTextBlock.textProperty);
            var hostConfig = this.hostConfig;
            var formattedText = TextFormatters.formatText(this.lang, preProcessedText);
            if (!formattedText) {
                formattedText = "";
            }
            var element = document.createElement("span");
            element.classList.add(hostConfig.makeCssClassName("ac-textRun"));
            this.applyStylesTo(element);
            if (this.selectAction && hostConfig.supportsInteractivity) {
                var anchor = document.createElement("a");
                anchor.classList.add(hostConfig.makeCssClassName("ac-anchor"));
                var href = this.selectAction.getHref();
                anchor.href = href ? href : "";
                anchor.target = "_blank";
                anchor.onclick = function (e) {
                    if (_this.selectAction && _this.selectAction.isEffectivelyEnabled()) {
                        e.preventDefault();
                        e.cancelBubble = true;
                        _this.selectAction.execute();
                    }
                };
                this.selectAction.setupElementForAccessibility(anchor);
                anchor.innerText = formattedText;
                element.appendChild(anchor);
            }
            else {
                element.innerText = formattedText;
            }
            return element;
        }
        else {
            return undefined;
        }
    };
    TextRun.prototype.applyStylesTo = function (targetElement) {
        _super.prototype.applyStylesTo.call(this, targetElement);
        if (this.italic) {
            targetElement.style.fontStyle = "italic";
        }
        if (this.strikethrough) {
            targetElement.style.textDecoration = "line-through";
        }
        if (this.highlight) {
            var colorDefinition = this.getColorDefinition(this.getEffectiveStyleDefinition().foregroundColors, this.effectiveColor);
            var backgroundColor = Utils.stringToCssColor(this.effectiveIsSubtle
                ? colorDefinition.highlightColors.subtle
                : colorDefinition.highlightColors.default);
            if (backgroundColor) {
                targetElement.style.backgroundColor = backgroundColor;
            }
        }
        if (this.underline) {
            targetElement.style.textDecoration = "underline";
        }
    };
    TextRun.prototype.getJsonTypeName = function () {
        return "TextRun";
    };
    Object.defineProperty(TextRun.prototype, "isStandalone", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextRun.prototype, "isInline", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    TextRun.italicProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_2, "italic", false);
    TextRun.strikethroughProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_2, "strikethrough", false);
    TextRun.highlightProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_2, "highlight", false);
    TextRun.underlineProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_3, "underline", false);
    __decorate([
        (0, serialization_1.property)(TextRun.italicProperty)
    ], TextRun.prototype, "italic", void 0);
    __decorate([
        (0, serialization_1.property)(TextRun.strikethroughProperty)
    ], TextRun.prototype, "strikethrough", void 0);
    __decorate([
        (0, serialization_1.property)(TextRun.highlightProperty)
    ], TextRun.prototype, "highlight", void 0);
    __decorate([
        (0, serialization_1.property)(TextRun.underlineProperty)
    ], TextRun.prototype, "underline", void 0);
    return TextRun;
}(BaseTextBlock));
exports.TextRun = TextRun;
var RichTextBlock = /** @class */ (function (_super) {
    __extends(RichTextBlock, _super);
    function RichTextBlock() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._inlines = [];
        return _this;
    }
    RichTextBlock.prototype.internalAddInline = function (inline, forceAdd) {
        if (forceAdd === void 0) { forceAdd = false; }
        if (!inline.isInline) {
            throw new Error(strings_1.Strings.errors.elementCannotBeUsedAsInline());
        }
        var doAdd = inline.parent === undefined || forceAdd;
        if (!doAdd && inline.parent !== this) {
            throw new Error(strings_1.Strings.errors.inlineAlreadyParented());
        }
        else {
            inline.setParent(this);
            this._inlines.push(inline);
        }
    };
    RichTextBlock.prototype.internalParse = function (source, context) {
        _super.prototype.internalParse.call(this, source, context);
        this._inlines = [];
        if (Array.isArray(source["inlines"])) {
            for (var _i = 0, _a = source["inlines"]; _i < _a.length; _i++) {
                var jsonInline = _a[_i];
                var inline = void 0;
                if (typeof jsonInline === "string") {
                    var textRun = new TextRun();
                    textRun.text = jsonInline;
                    inline = textRun;
                }
                else {
                    // No fallback for inlines in 1.2
                    inline = context.parseElement(this, jsonInline, [], false);
                }
                if (inline) {
                    this.internalAddInline(inline, true);
                }
            }
        }
    };
    RichTextBlock.prototype.internalToJSON = function (target, context) {
        _super.prototype.internalToJSON.call(this, target, context);
        if (this._inlines.length > 0) {
            var jsonInlines = [];
            for (var _i = 0, _a = this._inlines; _i < _a.length; _i++) {
                var inline = _a[_i];
                jsonInlines.push(inline.toJSON(context));
            }
            context.serializeValue(target, "inlines", jsonInlines);
        }
    };
    RichTextBlock.prototype.internalRender = function () {
        if (this._inlines.length > 0) {
            var element = void 0;
            if (this.forElementId) {
                var labelElement = document.createElement("label");
                labelElement.htmlFor = this.forElementId;
                element = labelElement;
            }
            else {
                element = document.createElement("div");
            }
            element.className = this.hostConfig.makeCssClassName("ac-richTextBlock");
            switch (this.getEffectiveHorizontalAlignment()) {
                case Enums.HorizontalAlignment.Center:
                    element.style.textAlign = "center";
                    break;
                case Enums.HorizontalAlignment.Right:
                    element.style.textAlign = "end";
                    break;
                default:
                    element.style.textAlign = "start";
                    break;
            }
            var renderedInlines = 0;
            for (var _i = 0, _a = this._inlines; _i < _a.length; _i++) {
                var inline = _a[_i];
                var renderedInline = inline.render();
                if (renderedInline) {
                    element.appendChild(renderedInline);
                    renderedInlines++;
                }
            }
            if (renderedInlines > 0) {
                return element;
            }
        }
        return undefined;
    };
    RichTextBlock.prototype.asString = function () {
        var result = "";
        for (var _i = 0, _a = this._inlines; _i < _a.length; _i++) {
            var inline = _a[_i];
            result += inline.asString();
        }
        return result;
    };
    RichTextBlock.prototype.getJsonTypeName = function () {
        return "RichTextBlock";
    };
    RichTextBlock.prototype.getInlineCount = function () {
        return this._inlines.length;
    };
    RichTextBlock.prototype.getInlineAt = function (index) {
        if (index >= 0 && index < this._inlines.length) {
            return this._inlines[index];
        }
        else {
            throw new Error(strings_1.Strings.errors.indexOutOfRange(index));
        }
    };
    RichTextBlock.prototype.addInline = function (inline) {
        if (typeof inline === "string") {
            this.internalAddInline(new TextRun(inline));
        }
        else {
            this.internalAddInline(inline);
        }
    };
    RichTextBlock.prototype.removeInline = function (inline) {
        var index = this._inlines.indexOf(inline);
        if (index >= 0) {
            this._inlines[index].setParent(undefined);
            this._inlines.splice(index, 1);
            return true;
        }
        return false;
    };
    return RichTextBlock;
}(CardElement));
exports.RichTextBlock = RichTextBlock;
var Fact = /** @class */ (function (_super) {
    __extends(Fact, _super);
    function Fact(name, value) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this.value = value;
        return _this;
    }
    //#endregion
    Fact.prototype.getSchemaKey = function () {
        return "Fact";
    };
    //#region Schema
    Fact.titleProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "title");
    Fact.valueProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "value");
    __decorate([
        (0, serialization_1.property)(Fact.titleProperty)
    ], Fact.prototype, "name", void 0);
    __decorate([
        (0, serialization_1.property)(Fact.valueProperty)
    ], Fact.prototype, "value", void 0);
    return Fact;
}(serialization_1.SerializableObject));
exports.Fact = Fact;
var FactSet = /** @class */ (function (_super) {
    __extends(FactSet, _super);
    function FactSet() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(FactSet.prototype, "useDefaultSizing", {
        //#endregion
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    FactSet.prototype.internalRender = function () {
        var element = undefined;
        var hostConfig = this.hostConfig;
        if (this.facts.length > 0) {
            element = document.createElement("table");
            element.style.borderWidth = "0px";
            element.style.borderSpacing = "0px";
            element.style.borderStyle = "none";
            element.style.borderCollapse = "collapse";
            element.style.display = "block";
            element.style.overflow = "hidden";
            element.classList.add(hostConfig.makeCssClassName("ac-factset"));
            element.setAttribute("role", "presentation");
            for (var i = 0; i < this.facts.length; i++) {
                var trElement = document.createElement("tr");
                if (i > 0) {
                    trElement.style.marginTop = hostConfig.factSet.spacing + "px";
                }
                // Title column
                var tdElement = document.createElement("td");
                tdElement.style.padding = "0";
                tdElement.classList.add(hostConfig.makeCssClassName("ac-fact-title"));
                if (hostConfig.factSet.title.maxWidth) {
                    tdElement.style.maxWidth = hostConfig.factSet.title.maxWidth + "px";
                }
                tdElement.style.verticalAlign = "top";
                var textBlock = new TextBlock();
                textBlock.setParent(this);
                textBlock.text =
                    !this.facts[i].name && this.isDesignMode() ? "Title" : this.facts[i].name;
                textBlock.size = hostConfig.factSet.title.size;
                textBlock.color = hostConfig.factSet.title.color;
                textBlock.isSubtle = hostConfig.factSet.title.isSubtle;
                textBlock.weight = hostConfig.factSet.title.weight;
                textBlock.wrap = hostConfig.factSet.title.wrap;
                textBlock.spacing = Enums.Spacing.None;
                Utils.appendChild(tdElement, textBlock.render());
                Utils.appendChild(trElement, tdElement);
                // Spacer column
                tdElement = document.createElement("td");
                tdElement.style.width = "10px";
                Utils.appendChild(trElement, tdElement);
                // Value column
                tdElement = document.createElement("td");
                tdElement.style.padding = "0";
                tdElement.style.verticalAlign = "top";
                tdElement.classList.add(hostConfig.makeCssClassName("ac-fact-value"));
                textBlock = new TextBlock();
                textBlock.setParent(this);
                textBlock.text = this.facts[i].value;
                textBlock.size = hostConfig.factSet.value.size;
                textBlock.color = hostConfig.factSet.value.color;
                textBlock.isSubtle = hostConfig.factSet.value.isSubtle;
                textBlock.weight = hostConfig.factSet.value.weight;
                textBlock.wrap = hostConfig.factSet.value.wrap;
                textBlock.spacing = Enums.Spacing.None;
                Utils.appendChild(tdElement, textBlock.render());
                Utils.appendChild(trElement, tdElement);
                Utils.appendChild(element, trElement);
            }
        }
        return element;
    };
    FactSet.prototype.getJsonTypeName = function () {
        return "FactSet";
    };
    //#region Schema
    FactSet.factsProperty = new serialization_1.SerializableObjectCollectionProperty(serialization_1.Versions.v1_0, "facts", Fact);
    __decorate([
        (0, serialization_1.property)(FactSet.factsProperty)
    ], FactSet.prototype, "facts", void 0);
    return FactSet;
}(CardElement));
exports.FactSet = FactSet;
var ImageDimensionProperty = /** @class */ (function (_super) {
    __extends(ImageDimensionProperty, _super);
    function ImageDimensionProperty(targetVersion, name, internalName, fallbackProperty) {
        var _this = _super.call(this, targetVersion, name) || this;
        _this.targetVersion = targetVersion;
        _this.name = name;
        _this.internalName = internalName;
        _this.fallbackProperty = fallbackProperty;
        return _this;
    }
    ImageDimensionProperty.prototype.getInternalName = function () {
        return this.internalName;
    };
    ImageDimensionProperty.prototype.parse = function (sender, source, context) {
        var result = undefined;
        var sourceValue = source[this.name];
        if (sourceValue === undefined) {
            return this.defaultValue;
        }
        var isValid = false;
        if (typeof sourceValue === "string") {
            try {
                var size = shared_1.SizeAndUnit.parse(sourceValue, true);
                if (size.unit === Enums.SizeUnit.Pixel) {
                    result = size.physicalSize;
                    isValid = true;
                }
            }
            catch (_a) {
                // Swallow the exception
            }
            // If the source value isn't valid per this property definition,
            // check its validity per the fallback property, if specified
            if (!isValid && this.fallbackProperty) {
                isValid = this.fallbackProperty.isValidValue(sourceValue, context);
            }
        }
        if (!isValid) {
            context.logParseEvent(sender, Enums.ValidationEvent.InvalidPropertyValue, strings_1.Strings.errors.invalidPropertyValue(sourceValue, this.name));
        }
        return result;
    };
    ImageDimensionProperty.prototype.toJSON = function (sender, target, value, context) {
        context.serializeValue(target, this.name, typeof value === "number" && !isNaN(value) ? value + "px" : undefined);
    };
    return ImageDimensionProperty;
}(serialization_1.PropertyDefinition));
var Image = /** @class */ (function (_super) {
    __extends(Image, _super);
    function Image() {
        //#region Schema
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.size = Enums.Size.Auto;
        _this.style = Enums.ImageStyle.Default;
        return _this;
    }
    Image.prototype.populateSchema = function (schema) {
        _super.prototype.populateSchema.call(this, schema);
        schema.remove(CardElement.heightProperty);
    };
    //#endregion
    Image.prototype.applySize = function (element) {
        if (this.pixelWidth || this.pixelHeight) {
            if (this.pixelWidth) {
                element.style.width = this.pixelWidth + "px";
            }
            if (this.pixelHeight) {
                element.style.height = this.pixelHeight + "px";
            }
        }
        else {
            if (this.maxHeight) {
                // If the image is constrained in height, we set its height property and
                // auto and stretch are ignored (default to medium). THis is necessary for
                // ImageSet which uses a maximum image height as opposed to the cards width
                // as a constraining dimension
                switch (this.size) {
                    case Enums.Size.Small:
                        element.style.height = this.hostConfig.imageSizes.small + "px";
                        break;
                    case Enums.Size.Large:
                        element.style.height = this.hostConfig.imageSizes.large + "px";
                        break;
                    default:
                        element.style.height = this.hostConfig.imageSizes.medium + "px";
                        break;
                }
                element.style.maxHeight = this.maxHeight + "px";
            }
            else {
                switch (this.size) {
                    case Enums.Size.Stretch:
                        element.style.width = "100%";
                        break;
                    case Enums.Size.Auto:
                        element.style.maxWidth = "100%";
                        break;
                    case Enums.Size.Small:
                        element.style.width = this.hostConfig.imageSizes.small + "px";
                        break;
                    case Enums.Size.Large:
                        element.style.width = this.hostConfig.imageSizes.large + "px";
                        break;
                    case Enums.Size.Medium:
                        element.style.width = this.hostConfig.imageSizes.medium + "px";
                        break;
                }
                element.style.maxHeight = "100%";
            }
        }
    };
    Object.defineProperty(Image.prototype, "useDefaultSizing", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    Image.prototype.internalRender = function () {
        var _this = this;
        var element = undefined;
        if (this.url) {
            element = document.createElement("div");
            element.style.display = "flex";
            element.style.alignItems = "flex-start";
            // Cache hostConfig to avoid walking the parent hierarchy multiple times
            var hostConfig = this.hostConfig;
            switch (this.getEffectiveHorizontalAlignment()) {
                case Enums.HorizontalAlignment.Center:
                    element.style.justifyContent = "center";
                    break;
                case Enums.HorizontalAlignment.Right:
                    element.style.justifyContent = "flex-end";
                    break;
                default:
                    element.style.justifyContent = "flex-start";
                    break;
            }
            var imageElement = document.createElement("img");
            imageElement.onload = function (_e) {
                raiseImageLoadedEvent(_this);
            };
            imageElement.onerror = function (_e) {
                if (_this.renderedElement) {
                    var card = _this.getRootElement();
                    _this.renderedElement;
                    if (card && card.designMode) {
                        var errorElement = document.createElement("div");
                        errorElement.style.display = "flex";
                        errorElement.style.alignItems = "center";
                        errorElement.style.justifyContent = "center";
                        errorElement.style.backgroundColor = "#EEEEEE";
                        errorElement.style.color = "black";
                        errorElement.innerText = ":-(";
                        errorElement.style.padding = "10px";
                        _this.applySize(errorElement);
                        _this.renderedElement.appendChild(errorElement);
                    }
                }
                raiseImageLoadedEvent(_this);
            };
            imageElement.style.minWidth = "0";
            imageElement.classList.add(hostConfig.makeCssClassName("ac-image"));
            if (this.selectAction && hostConfig.supportsInteractivity) {
                imageElement.onkeypress = function (e) {
                    if (_this.selectAction &&
                        _this.selectAction.isEffectivelyEnabled() &&
                        (e.code === "Enter" || e.code === "Space")) {
                        // enter or space pressed
                        e.preventDefault();
                        e.cancelBubble = true;
                        _this.selectAction.execute();
                    }
                };
                imageElement.onclick = function (e) {
                    if (_this.selectAction && _this.selectAction.isEffectivelyEnabled()) {
                        e.preventDefault();
                        e.cancelBubble = true;
                        _this.selectAction.execute();
                    }
                };
                this.selectAction.setupElementForAccessibility(imageElement);
                if (this.selectAction.isEffectivelyEnabled()) {
                    imageElement.classList.add(hostConfig.makeCssClassName("ac-selectable"));
                }
            }
            this.applySize(imageElement);
            if (this.style === Enums.ImageStyle.Person) {
                imageElement.style.borderRadius = "50%";
                imageElement.style.backgroundPosition = "50% 50%";
                imageElement.style.backgroundRepeat = "no-repeat";
            }
            var backgroundColor = Utils.stringToCssColor(this.backgroundColor);
            if (backgroundColor) {
                imageElement.style.backgroundColor = backgroundColor;
            }
            imageElement.src = this.preProcessPropertyValue(Image.urlProperty);
            var altTextProperty = this.preProcessPropertyValue(Image.altTextProperty);
            if (altTextProperty) {
                imageElement.alt = altTextProperty;
            }
            element.appendChild(imageElement);
        }
        return element;
    };
    Image.prototype.getJsonTypeName = function () {
        return "Image";
    };
    Image.prototype.getAllActions = function () {
        var result = _super.prototype.getAllActions.call(this);
        if (this.selectAction) {
            result.push(this.selectAction);
        }
        return result;
    };
    Image.prototype.getActionById = function (id) {
        var result = _super.prototype.getActionById.call(this, id);
        if (!result && this.selectAction) {
            result = this.selectAction.getActionById(id);
        }
        return result;
    };
    Image.prototype.getResourceInformation = function () {
        return this.url ? [{ url: this.url, mimeType: "image" }] : [];
    };
    Image.urlProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "url");
    Image.altTextProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "altText");
    Image.backgroundColorProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_1, "backgroundColor");
    Image.styleProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_0, "style", Enums.ImageStyle, Enums.ImageStyle.Default);
    Image.sizeProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_0, "size", Enums.Size, Enums.Size.Auto);
    Image.pixelWidthProperty = new ImageDimensionProperty(serialization_1.Versions.v1_1, "width", "pixelWidth");
    Image.pixelHeightProperty = new ImageDimensionProperty(serialization_1.Versions.v1_1, "height", "pixelHeight", CardElement.heightProperty);
    Image.selectActionProperty = new ActionProperty(serialization_1.Versions.v1_1, "selectAction", [
        "Action.ShowCard"
    ]);
    __decorate([
        (0, serialization_1.property)(Image.urlProperty)
    ], Image.prototype, "url", void 0);
    __decorate([
        (0, serialization_1.property)(Image.altTextProperty)
    ], Image.prototype, "altText", void 0);
    __decorate([
        (0, serialization_1.property)(Image.backgroundColorProperty)
    ], Image.prototype, "backgroundColor", void 0);
    __decorate([
        (0, serialization_1.property)(Image.sizeProperty)
    ], Image.prototype, "size", void 0);
    __decorate([
        (0, serialization_1.property)(Image.styleProperty)
    ], Image.prototype, "style", void 0);
    __decorate([
        (0, serialization_1.property)(Image.pixelWidthProperty)
    ], Image.prototype, "pixelWidth", void 0);
    __decorate([
        (0, serialization_1.property)(Image.pixelHeightProperty)
    ], Image.prototype, "pixelHeight", void 0);
    __decorate([
        (0, serialization_1.property)(Image.selectActionProperty)
    ], Image.prototype, "selectAction", void 0);
    return Image;
}(CardElement));
exports.Image = Image;
var CardElementContainer = /** @class */ (function (_super) {
    __extends(CardElementContainer, _super);
    function CardElementContainer() {
        //#region Schema
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowVerticalOverflow = false;
        return _this;
    }
    CardElementContainer.prototype.populateSchema = function (schema) {
        _super.prototype.populateSchema.call(this, schema);
        if (!this.isSelectable) {
            schema.remove(CardElementContainer.selectActionProperty);
        }
    };
    //#endregion
    CardElementContainer.prototype.isElementAllowed = function (element) {
        return this.hostConfig.supportsInteractivity || !element.isInteractive;
    };
    CardElementContainer.prototype.applyPadding = function () {
        _super.prototype.applyPadding.call(this);
        if (!this.renderedElement) {
            return;
        }
        var physicalPadding = new shared_1.SpacingDefinition();
        if (this.getEffectivePadding()) {
            physicalPadding = this.hostConfig.paddingDefinitionToSpacingDefinition(this.getEffectivePadding());
        }
        this.renderedElement.style.paddingTop = physicalPadding.top + "px";
        this.renderedElement.style.paddingRight = physicalPadding.right + "px";
        this.renderedElement.style.paddingBottom = physicalPadding.bottom + "px";
        this.renderedElement.style.paddingLeft = physicalPadding.left + "px";
        this.renderedElement.style.marginRight = "0";
        this.renderedElement.style.marginLeft = "0";
    };
    Object.defineProperty(CardElementContainer.prototype, "isSelectable", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    // This function is kept but return [] when removing Carousel from code
    CardElementContainer.prototype.forbiddenChildElements = function () {
        return [];
    };
    CardElementContainer.prototype.releaseDOMResources = function () {
        _super.prototype.releaseDOMResources.call(this);
        for (var i = 0; i < this.getItemCount(); i++) {
            this.getItemAt(i).releaseDOMResources();
        }
    };
    CardElementContainer.prototype.internalValidateProperties = function (context) {
        _super.prototype.internalValidateProperties.call(this, context);
        for (var i = 0; i < this.getItemCount(); i++) {
            var item = this.getItemAt(i);
            if (!this.hostConfig.supportsInteractivity && item.isInteractive) {
                context.addFailure(this, Enums.ValidationEvent.InteractivityNotAllowed, strings_1.Strings.errors.interactivityNotAllowed());
            }
            if (!this.isElementAllowed(item)) {
                context.addFailure(this, Enums.ValidationEvent.InteractivityNotAllowed, strings_1.Strings.errors.elementTypeNotAllowed(item.getJsonTypeName()));
            }
            item.internalValidateProperties(context);
        }
        if (this._selectAction) {
            this._selectAction.internalValidateProperties(context);
        }
    };
    CardElementContainer.prototype.render = function () {
        var _this = this;
        var element = _super.prototype.render.call(this);
        if (element) {
            var hostConfig = this.hostConfig;
            if (this.allowVerticalOverflow) {
                element.style.overflowX = "hidden";
                element.style.overflowY = "auto";
            }
            if (element &&
                this.isSelectable &&
                this._selectAction &&
                hostConfig.supportsInteractivity) {
                element.onclick = function (e) {
                    if (_this._selectAction && _this._selectAction.isEffectivelyEnabled()) {
                        e.preventDefault();
                        e.cancelBubble = true;
                        _this._selectAction.execute();
                    }
                };
                element.onkeypress = function (e) {
                    if (_this._selectAction &&
                        _this._selectAction.isEffectivelyEnabled() &&
                        (e.code === "Enter" || e.code === "Space")) {
                        // Enter or space pressed
                        e.preventDefault();
                        e.cancelBubble = true;
                        _this._selectAction.execute();
                    }
                };
                this._selectAction.setupElementForAccessibility(element);
                if (this._selectAction.isEffectivelyEnabled()) {
                    element.classList.add(hostConfig.makeCssClassName("ac-selectable"));
                }
            }
        }
        return element;
    };
    CardElementContainer.prototype.updateLayout = function (processChildren) {
        if (processChildren === void 0) { processChildren = true; }
        _super.prototype.updateLayout.call(this, processChildren);
        if (processChildren) {
            for (var i = 0; i < this.getItemCount(); i++) {
                this.getItemAt(i).updateLayout();
            }
        }
    };
    CardElementContainer.prototype.getAllInputs = function (processActions) {
        if (processActions === void 0) { processActions = true; }
        var result = [];
        for (var i = 0; i < this.getItemCount(); i++) {
            result.push.apply(result, this.getItemAt(i).getAllInputs(processActions));
        }
        return result;
    };
    CardElementContainer.prototype.getAllActions = function () {
        var result = _super.prototype.getAllActions.call(this);
        for (var i = 0; i < this.getItemCount(); i++) {
            result.push.apply(result, this.getItemAt(i).getAllActions());
        }
        if (this._selectAction) {
            result.push(this._selectAction);
        }
        return result;
    };
    CardElementContainer.prototype.getResourceInformation = function () {
        var result = [];
        for (var i = 0; i < this.getItemCount(); i++) {
            result.push.apply(result, this.getItemAt(i).getResourceInformation());
        }
        return result;
    };
    CardElementContainer.prototype.getElementById = function (id) {
        var result = _super.prototype.getElementById.call(this, id);
        if (!result) {
            for (var i = 0; i < this.getItemCount(); i++) {
                result = this.getItemAt(i).getElementById(id);
                if (result) {
                    break;
                }
            }
        }
        return result;
    };
    /**
     * @inheritdoc
     */
    CardElementContainer.prototype.findDOMNodeOwner = function (node) {
        var _a;
        var target = undefined;
        for (var i = 0; i < this.getItemCount(); i++) {
            // recur through child elements
            target = this.getItemAt(i).findDOMNodeOwner(node);
            if (target) {
                return target;
            }
        }
        // If not found in children, check the actions
        for (var i = 0; i < this.getActionCount(); i++) {
            target = (_a = this.getActionAt(i)) === null || _a === void 0 ? void 0 : _a.findDOMNodeOwner(node);
            if (target) {
                return target;
            }
        }
        // if not found in children or actions, defer to parent implementation
        return _super.prototype.findDOMNodeOwner.call(this, node);
    };
    CardElementContainer.selectActionProperty = new ActionProperty(serialization_1.Versions.v1_1, "selectAction", [
        "Action.ShowCard"
    ]);
    __decorate([
        (0, serialization_1.property)(CardElementContainer.selectActionProperty)
    ], CardElementContainer.prototype, "_selectAction", void 0);
    return CardElementContainer;
}(CardElement));
exports.CardElementContainer = CardElementContainer;
var ImageSet = /** @class */ (function (_super) {
    __extends(ImageSet, _super);
    function ImageSet() {
        //#region Schema
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._images = [];
        _this.imageSize = Enums.ImageSize.Medium;
        return _this;
    }
    //#endregion
    ImageSet.prototype.internalRender = function () {
        var element = undefined;
        if (this._images.length > 0) {
            element = document.createElement("div");
            element.style.display = "flex";
            element.style.flexWrap = "wrap";
            for (var _i = 0, _a = this._images; _i < _a.length; _i++) {
                var image = _a[_i];
                switch (this.imageSize) {
                    case Enums.ImageSize.Small:
                        image.size = Enums.Size.Small;
                        break;
                    case Enums.ImageSize.Large:
                        image.size = Enums.Size.Large;
                        break;
                    default:
                        image.size = Enums.Size.Medium;
                        break;
                }
                image.maxHeight = this.hostConfig.imageSet.maxImageHeight;
                var renderedImage = image.render();
                if (renderedImage) {
                    renderedImage.style.display = "inline-flex";
                    renderedImage.style.margin = "0px";
                    renderedImage.style.marginRight = "10px";
                    Utils.appendChild(element, renderedImage);
                }
            }
        }
        return element;
    };
    ImageSet.prototype.getItemCount = function () {
        return this._images.length;
    };
    ImageSet.prototype.getItemAt = function (index) {
        return this._images[index];
    };
    ImageSet.prototype.getFirstVisibleRenderedItem = function () {
        return this._images && this._images.length > 0 ? this._images[0] : undefined;
    };
    ImageSet.prototype.getLastVisibleRenderedItem = function () {
        return this._images && this._images.length > 0
            ? this._images[this._images.length - 1]
            : undefined;
    };
    ImageSet.prototype.removeItem = function (item) {
        if (item instanceof Image) {
            var itemIndex = this._images.indexOf(item);
            if (itemIndex >= 0) {
                this._images.splice(itemIndex, 1);
                item.setParent(undefined);
                this.updateLayout();
                return true;
            }
        }
        return false;
    };
    ImageSet.prototype.getJsonTypeName = function () {
        return "ImageSet";
    };
    ImageSet.prototype.addImage = function (image) {
        if (!image.parent) {
            this._images.push(image);
            image.setParent(this);
        }
        else {
            throw new Error("This image already belongs to another ImageSet");
        }
    };
    ImageSet.prototype.indexOf = function (cardElement) {
        return cardElement instanceof Image ? this._images.indexOf(cardElement) : -1;
    };
    ImageSet.imagesProperty = new serialization_1.SerializableObjectCollectionProperty(serialization_1.Versions.v1_0, "images", Image, function (sender, item) {
        item.setParent(sender);
    });
    ImageSet.imageSizeProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_0, "imageSize", Enums.ImageSize, Enums.ImageSize.Medium);
    __decorate([
        (0, serialization_1.property)(ImageSet.imagesProperty)
    ], ImageSet.prototype, "_images", void 0);
    __decorate([
        (0, serialization_1.property)(ImageSet.imageSizeProperty)
    ], ImageSet.prototype, "imageSize", void 0);
    return ImageSet;
}(CardElementContainer));
exports.ImageSet = ImageSet;
var ContentSource = /** @class */ (function (_super) {
    __extends(ContentSource, _super);
    //#endregion
    function ContentSource(url, mimeType) {
        var _this = _super.call(this) || this;
        _this.url = url;
        _this.mimeType = mimeType;
        return _this;
    }
    ContentSource.prototype.isValid = function () {
        return this.mimeType && this.url ? true : false;
    };
    //#region Schema
    ContentSource.mimeTypeProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_1, "mimeType");
    ContentSource.urlProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_1, "url");
    __decorate([
        (0, serialization_1.property)(ContentSource.mimeTypeProperty)
    ], ContentSource.prototype, "mimeType", void 0);
    __decorate([
        (0, serialization_1.property)(ContentSource.urlProperty)
    ], ContentSource.prototype, "url", void 0);
    return ContentSource;
}(serialization_1.SerializableObject));
exports.ContentSource = ContentSource;
var CaptionSource = /** @class */ (function (_super) {
    __extends(CaptionSource, _super);
    //#endregion
    function CaptionSource(url, mimeType, label) {
        var _this = _super.call(this, url, mimeType) || this;
        _this.label = label;
        return _this;
    }
    CaptionSource.prototype.getSchemaKey = function () {
        return "CaptionSource";
    };
    CaptionSource.prototype.render = function () {
        var result = undefined;
        if (this.isValid()) {
            result = document.createElement("track");
            result.src = this.url;
            result.kind = "captions";
            result.label = this.label;
        }
        return result;
    };
    //#region Schema
    CaptionSource.labelProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_6, "label");
    __decorate([
        (0, serialization_1.property)(CaptionSource.labelProperty)
    ], CaptionSource.prototype, "label", void 0);
    return CaptionSource;
}(ContentSource));
exports.CaptionSource = CaptionSource;
var MediaSource = /** @class */ (function (_super) {
    __extends(MediaSource, _super);
    function MediaSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MediaSource.prototype.getSchemaKey = function () {
        return "MediaSource";
    };
    MediaSource.prototype.render = function () {
        var result = undefined;
        if (this.isValid()) {
            result = document.createElement("source");
            result.src = this.url;
            result.type = this.mimeType;
        }
        return result;
    };
    return MediaSource;
}(ContentSource));
exports.MediaSource = MediaSource;
var MediaPlayer = /** @class */ (function () {
    function MediaPlayer() {
    }
    MediaPlayer.prototype.play = function () {
        // Do nothing in base implementation
    };
    Object.defineProperty(MediaPlayer.prototype, "posterUrl", {
        get: function () {
            return this._posterUrl;
        },
        set: function (value) {
            this._posterUrl = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MediaPlayer.prototype, "selectedMediaType", {
        get: function () {
            return undefined;
        },
        enumerable: false,
        configurable: true
    });
    return MediaPlayer;
}());
exports.MediaPlayer = MediaPlayer;
var HTML5MediaPlayer = /** @class */ (function (_super) {
    __extends(HTML5MediaPlayer, _super);
    function HTML5MediaPlayer(owner) {
        var _this = _super.call(this) || this;
        _this.owner = owner;
        _this._selectedSources = [];
        _this._captionSources = [];
        _this.processSources();
        return _this;
    }
    HTML5MediaPlayer.prototype.processSources = function () {
        var _a;
        this._selectedSources = [];
        this._captionSources = [];
        this._selectedMediaType = undefined;
        for (var _i = 0, _b = this.owner.sources; _i < _b.length; _i++) {
            var source = _b[_i];
            var mimeComponents = source.mimeType ? source.mimeType.split("/") : [];
            if (mimeComponents.length === 2) {
                if (!this._selectedMediaType) {
                    var index = HTML5MediaPlayer.supportedMediaTypes.indexOf(mimeComponents[0]);
                    if (index >= 0) {
                        this._selectedMediaType = HTML5MediaPlayer.supportedMediaTypes[index];
                    }
                }
                if (mimeComponents[0] === this._selectedMediaType) {
                    this._selectedSources.push(source);
                }
            }
        }
        (_a = this._captionSources).push.apply(_a, this.owner.captionSources);
    };
    HTML5MediaPlayer.prototype.canPlay = function () {
        return this._selectedSources.length > 0;
    };
    HTML5MediaPlayer.prototype.fetchVideoDetails = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/];
            });
        });
    };
    HTML5MediaPlayer.prototype.render = function () {
        if (this._selectedMediaType === "video") {
            this._mediaElement = document.createElement("video");
        }
        else {
            this._mediaElement = document.createElement("audio");
        }
        this._mediaElement.setAttribute("aria-label", this.owner.altText ? this.owner.altText : strings_1.Strings.defaults.mediaPlayerAriaLabel());
        this._mediaElement.setAttribute("webkit-playsinline", "");
        this._mediaElement.setAttribute("playsinline", "");
        // We enable crossorigin for cases where the caption file has a different domain than
        // the video file. If the caption file lives in a different domain than the video file
        // and crossorigin is not set, then the caption file will fail to load.
        this._mediaElement.setAttribute("crossorigin", "");
        this._mediaElement.autoplay = true;
        this._mediaElement.controls = true;
        if (Utils.isMobileOS()) {
            this._mediaElement.muted = true;
        }
        this._mediaElement.preload = "none";
        this._mediaElement.style.width = "100%";
        for (var _i = 0, _a = this.owner.sources; _i < _a.length; _i++) {
            var source = _a[_i];
            var renderedSource = source.render();
            Utils.appendChild(this._mediaElement, renderedSource);
        }
        for (var _b = 0, _c = this.owner.captionSources; _b < _c.length; _b++) {
            var captionSource = _c[_b];
            if (captionSource.mimeType == "vtt") {
                var renderedCaptionSource = captionSource.render();
                Utils.appendChild(this._mediaElement, renderedCaptionSource);
            }
        }
        return this._mediaElement;
    };
    HTML5MediaPlayer.prototype.play = function () {
        if (this._mediaElement) {
            this._mediaElement.play();
        }
    };
    Object.defineProperty(HTML5MediaPlayer.prototype, "selectedMediaType", {
        get: function () {
            return this._selectedMediaType;
        },
        enumerable: false,
        configurable: true
    });
    HTML5MediaPlayer.supportedMediaTypes = ["audio", "video"];
    return HTML5MediaPlayer;
}(MediaPlayer));
exports.HTML5MediaPlayer = HTML5MediaPlayer;
var CustomMediaPlayer = /** @class */ (function (_super) {
    __extends(CustomMediaPlayer, _super);
    function CustomMediaPlayer(matches) {
        return _super.call(this) || this;
    }
    return CustomMediaPlayer;
}(MediaPlayer));
exports.CustomMediaPlayer = CustomMediaPlayer;
var IFrameMediaMediaPlayer = /** @class */ (function (_super) {
    __extends(IFrameMediaMediaPlayer, _super);
    function IFrameMediaMediaPlayer(matches, iFrameTitle) {
        var _this = _super.call(this, matches) || this;
        _this.iFrameTitle = iFrameTitle;
        if (matches.length >= 2) {
            _this._videoId = matches[1];
        }
        return _this;
    }
    IFrameMediaMediaPlayer.prototype.canPlay = function () {
        return this._videoId !== undefined;
    };
    IFrameMediaMediaPlayer.prototype.render = function () {
        var container = document.createElement("div");
        container.style.position = "relative";
        container.style.width = "100%";
        container.style.height = "0";
        container.style.paddingBottom = "56.25%";
        var iFrame = document.createElement("iframe");
        iFrame.style.position = "absolute";
        iFrame.style.top = "0";
        iFrame.style.left = "0";
        iFrame.style.width = "100%";
        iFrame.style.height = "100%";
        iFrame.src = this.getEmbedVideoUrl();
        iFrame.frameBorder = "0";
        if (this.iFrameTitle) {
            iFrame.title = this.iFrameTitle;
        }
        iFrame.allow =
            "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
        iFrame.allowFullscreen = true;
        container.appendChild(iFrame);
        return container;
    };
    Object.defineProperty(IFrameMediaMediaPlayer.prototype, "videoId", {
        get: function () {
            return this._videoId;
        },
        enumerable: false,
        configurable: true
    });
    return IFrameMediaMediaPlayer;
}(CustomMediaPlayer));
exports.IFrameMediaMediaPlayer = IFrameMediaMediaPlayer;
var VimeoPlayer = /** @class */ (function (_super) {
    __extends(VimeoPlayer, _super);
    function VimeoPlayer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    VimeoPlayer.prototype.fetchVideoDetails = function () {
        return __awaiter(this, void 0, void 0, function () {
            var oEmbedUrl, response, json;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        oEmbedUrl = "https://vimeo.com/api/oembed.json?url=".concat(this.getEmbedVideoUrl());
                        return [4 /*yield*/, fetch(oEmbedUrl)];
                    case 1:
                        response = _a.sent();
                        if (!response.ok) return [3 /*break*/, 3];
                        return [4 /*yield*/, response.json()];
                    case 2:
                        json = _a.sent();
                        this.posterUrl = json["thumbnail_url"];
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    VimeoPlayer.prototype.getEmbedVideoUrl = function () {
        return "https://player.vimeo.com/video/".concat(this.videoId, "?autoplay=1");
    };
    return VimeoPlayer;
}(IFrameMediaMediaPlayer));
exports.VimeoPlayer = VimeoPlayer;
var DailymotionPlayer = /** @class */ (function (_super) {
    __extends(DailymotionPlayer, _super);
    function DailymotionPlayer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DailymotionPlayer.prototype.fetchVideoDetails = function () {
        return __awaiter(this, void 0, void 0, function () {
            var apiUrl, response, json;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        apiUrl = "https://api.dailymotion.com/video/".concat(this.videoId, "?fields=thumbnail_720_url");
                        return [4 /*yield*/, fetch(apiUrl)];
                    case 1:
                        response = _a.sent();
                        if (!response.ok) return [3 /*break*/, 3];
                        return [4 /*yield*/, response.json()];
                    case 2:
                        json = _a.sent();
                        this.posterUrl = json["thumbnail_720_url"];
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    DailymotionPlayer.prototype.getEmbedVideoUrl = function () {
        return "https://www.dailymotion.com/embed/video/".concat(this.videoId, "?autoplay=1");
    };
    return DailymotionPlayer;
}(IFrameMediaMediaPlayer));
exports.DailymotionPlayer = DailymotionPlayer;
var YouTubePlayer = /** @class */ (function (_super) {
    __extends(YouTubePlayer, _super);
    function YouTubePlayer(matches, iFrameTitle) {
        var _this = _super.call(this, matches, iFrameTitle) || this;
        _this.iFrameTitle = iFrameTitle;
        if (matches.length >= 3 && matches[2] !== undefined) {
            _this._startTimeIndex = parseInt(matches[2]);
        }
        return _this;
    }
    YouTubePlayer.prototype.fetchVideoDetails = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.posterUrl = this.videoId
                    ? "https://img.youtube.com/vi/".concat(this.videoId, "/maxresdefault.jpg")
                    : undefined;
                return [2 /*return*/];
            });
        });
    };
    YouTubePlayer.prototype.getEmbedVideoUrl = function () {
        var url = "https://www.youtube.com/embed/".concat(this.videoId, "?autoplay=1");
        if (this._startTimeIndex !== undefined) {
            url += "&start=".concat(this._startTimeIndex);
        }
        return url;
    };
    return YouTubePlayer;
}(IFrameMediaMediaPlayer));
exports.YouTubePlayer = YouTubePlayer;
var Media = /** @class */ (function (_super) {
    __extends(Media, _super);
    function Media() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.sources = [];
        _this.captionSources = [];
        return _this;
    }
    Media.prototype.createMediaPlayer = function () {
        for (var _i = 0, _a = Media.customMediaPlayers; _i < _a.length; _i++) {
            var provider = _a[_i];
            for (var _b = 0, _c = this.sources; _b < _c.length; _b++) {
                var source = _c[_b];
                if (source.url) {
                    for (var _d = 0, _f = provider.urlPatterns; _d < _f.length; _d++) {
                        var pattern = _f[_d];
                        var matches = pattern.exec(source.url);
                        if (matches !== null) {
                            return provider.createMediaPlayer(matches);
                        }
                    }
                }
            }
        }
        return new HTML5MediaPlayer(this);
    };
    Media.prototype.handlePlayButtonInvoke = function (event) {
        if (this.hostConfig.media.allowInlinePlayback) {
            event.preventDefault();
            event.cancelBubble = true;
            if (this.renderedElement) {
                var mediaPlayerElement = this._mediaPlayer.render();
                clearElement(this.renderedElement);
                this.renderedElement.appendChild(mediaPlayerElement);
                this._mediaPlayer.play();
                mediaPlayerElement.focus();
            }
        }
        else {
            if (Media.onPlay) {
                event.preventDefault();
                event.cancelBubble = true;
                Media.onPlay(this);
            }
        }
    };
    Media.prototype.displayPoster = function () {
        return __awaiter(this, void 0, void 0, function () {
            var playButtonArrowWidth, playButtonArrowHeight, posterRootElement_1, posterUrl, posterImageElement_1, playButtonOuterElement, playButtonInnerElement, playButtonContainer;
            var _this = this;
            return __generator(this, function (_a) {
                if (this.renderedElement) {
                    playButtonArrowWidth = 12;
                    playButtonArrowHeight = 15;
                    posterRootElement_1 = document.createElement("div");
                    posterRootElement_1.className = this.hostConfig.makeCssClassName("ac-media-poster");
                    posterRootElement_1.setAttribute("role", "contentinfo");
                    posterRootElement_1.setAttribute("aria-label", this.altText ? this.altText : strings_1.Strings.defaults.mediaPlayerAriaLabel());
                    posterRootElement_1.style.position = "relative";
                    posterRootElement_1.style.display = "flex";
                    posterUrl = this.poster ? this.poster : this._mediaPlayer.posterUrl;
                    if (!posterUrl) {
                        posterUrl = this.hostConfig.media.defaultPoster;
                    }
                    if (posterUrl) {
                        posterImageElement_1 = document.createElement("img");
                        posterImageElement_1.style.width = "100%";
                        posterImageElement_1.style.height = "100%";
                        posterImageElement_1.setAttribute("role", "presentation");
                        posterImageElement_1.onerror = function (_e) {
                            if (posterImageElement_1.parentNode) {
                                posterImageElement_1.parentNode.removeChild(posterImageElement_1);
                            }
                            posterRootElement_1.classList.add("empty");
                            posterRootElement_1.style.minHeight = "150px";
                        };
                        posterImageElement_1.src = posterUrl;
                        posterRootElement_1.appendChild(posterImageElement_1);
                    }
                    else {
                        posterRootElement_1.classList.add("empty");
                        posterRootElement_1.style.minHeight = "150px";
                    }
                    if (this.hostConfig.supportsInteractivity && this._mediaPlayer.canPlay()) {
                        playButtonOuterElement = document.createElement("div");
                        playButtonOuterElement.tabIndex = 0;
                        playButtonOuterElement.setAttribute("role", "button");
                        playButtonOuterElement.setAttribute("aria-label", strings_1.Strings.defaults.mediaPlayerPlayMedia());
                        playButtonOuterElement.className =
                            this.hostConfig.makeCssClassName("ac-media-playButton");
                        playButtonOuterElement.style.display = "flex";
                        playButtonOuterElement.style.alignItems = "center";
                        playButtonOuterElement.style.justifyContent = "center";
                        playButtonOuterElement.onclick = function (e) {
                            _this.handlePlayButtonInvoke(e);
                        };
                        playButtonOuterElement.onkeypress = function (e) {
                            if (e.code === "Enter" || e.code === "Space") {
                                // space or enter
                                _this.handlePlayButtonInvoke(e);
                            }
                        };
                        playButtonInnerElement = document.createElement("div");
                        playButtonInnerElement.className = this.hostConfig.makeCssClassName("ac-media-playButton-arrow");
                        playButtonInnerElement.style.width = playButtonArrowWidth + "px";
                        playButtonInnerElement.style.height = playButtonArrowHeight + "px";
                        playButtonInnerElement.style.borderTopWidth = playButtonArrowHeight / 2 + "px";
                        playButtonInnerElement.style.borderBottomWidth = playButtonArrowHeight / 2 + "px";
                        playButtonInnerElement.style.borderLeftWidth = playButtonArrowWidth + "px";
                        playButtonInnerElement.style.borderRightWidth = "0";
                        playButtonInnerElement.style.borderStyle = "solid";
                        playButtonInnerElement.style.borderTopColor = "transparent";
                        playButtonInnerElement.style.borderRightColor = "transparent";
                        playButtonInnerElement.style.borderBottomColor = "transparent";
                        playButtonInnerElement.style.transform =
                            "translate(" + playButtonArrowWidth / 10 + "px,0px)";
                        playButtonOuterElement.appendChild(playButtonInnerElement);
                        playButtonContainer = document.createElement("div");
                        playButtonContainer.style.position = "absolute";
                        playButtonContainer.style.left = "0";
                        playButtonContainer.style.top = "0";
                        playButtonContainer.style.width = "100%";
                        playButtonContainer.style.height = "100%";
                        playButtonContainer.style.display = "flex";
                        playButtonContainer.style.justifyContent = "center";
                        playButtonContainer.style.alignItems = "center";
                        playButtonContainer.appendChild(playButtonOuterElement);
                        posterRootElement_1.appendChild(playButtonContainer);
                    }
                    clearElement(this.renderedElement);
                    this.renderedElement.appendChild(posterRootElement_1);
                }
                return [2 /*return*/];
            });
        });
    };
    Media.prototype.internalRender = function () {
        var element = document.createElement("div");
        element.className = this.hostConfig.makeCssClassName("ac-media");
        return element;
    };
    Media.prototype.render = function () {
        var _this = this;
        var result = _super.prototype.render.call(this);
        if (result) {
            this._mediaPlayer = this.createMediaPlayer();
            this._mediaPlayer.fetchVideoDetails().then(function () { return _this.displayPoster(); });
        }
        return result;
    };
    Media.prototype.releaseDOMResources = function () {
        _super.prototype.releaseDOMResources.call(this);
        this.displayPoster();
    };
    Media.prototype.getJsonTypeName = function () {
        return "Media";
    };
    Media.prototype.getResourceInformation = function () {
        var result = [];
        if (this._mediaPlayer) {
            var posterUrl = this.poster ? this.poster : this.hostConfig.media.defaultPoster;
            if (posterUrl) {
                result.push({ url: posterUrl, mimeType: "image" });
            }
        }
        for (var _i = 0, _a = this.sources; _i < _a.length; _i++) {
            var mediaSource = _a[_i];
            if (mediaSource.isValid()) {
                result.push({
                    /* eslint-disable @typescript-eslint/no-unnecessary-type-assertion -- `mediaSource.url` is of type `string | undefined`, but is validated by `isValid()` call */
                    url: mediaSource.url,
                    mimeType: mediaSource.mimeType
                    /* eslint-enable @typescript-eslint/no-unnecessary-type-assertion */
                });
            }
        }
        for (var _b = 0, _c = this.captionSources; _b < _c.length; _b++) {
            var captionSource = _c[_b];
            if (captionSource.isValid()) {
                result.push({
                    /* eslint-disable @typescript-eslint/no-unnecessary-type-assertion -- `captionSource.url` is of type `string | undefined`, but is validated by `isValid()` call */
                    url: captionSource.url,
                    mimeType: captionSource.mimeType
                    /* eslint-enable @typescript-eslint/no-unnecessary-type-assertion */
                });
            }
        }
        return result;
    };
    Object.defineProperty(Media.prototype, "selectedMediaType", {
        get: function () {
            return this._mediaPlayer.selectedMediaType;
        },
        enumerable: false,
        configurable: true
    });
    Media.customMediaPlayers = [
        {
            urlPatterns: [
                /^(?:https?:\/\/)?(?:www.)?youtube.com\/watch\?(?=.*v=([\w\d-_]+))(?=(?:.*t=(\d+))?).*/gi,
                /^(?:https?:\/\/)?youtu.be\/([\w\d-_]+)(?:\?t=(\d+))?/gi
            ],
            createMediaPlayer: function (matches) {
                return new YouTubePlayer(matches, strings_1.Strings.defaults.youTubeVideoPlayer());
            }
        },
        {
            urlPatterns: [/^(?:https?:\/\/)?vimeo.com\/([\w\d-_]+).*/gi],
            createMediaPlayer: function (matches) {
                return new VimeoPlayer(matches, strings_1.Strings.defaults.vimeoVideoPlayer());
            }
        },
        {
            urlPatterns: [/^(?:https?:\/\/)?(?:www.)?dailymotion.com\/video\/([\w\d-_]+).*/gi],
            createMediaPlayer: function (matches) {
                return new DailymotionPlayer(matches, strings_1.Strings.defaults.dailymotionVideoPlayer());
            }
        }
    ];
    //#region Schema
    Media.sourcesProperty = new serialization_1.SerializableObjectCollectionProperty(serialization_1.Versions.v1_1, "sources", MediaSource);
    Media.captionSourcesProperty = new serialization_1.SerializableObjectCollectionProperty(serialization_1.Versions.v1_6, "captionSources", CaptionSource);
    Media.posterProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_1, "poster");
    Media.altTextProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_1, "altText");
    __decorate([
        (0, serialization_1.property)(Media.sourcesProperty)
    ], Media.prototype, "sources", void 0);
    __decorate([
        (0, serialization_1.property)(Media.captionSourcesProperty)
    ], Media.prototype, "captionSources", void 0);
    __decorate([
        (0, serialization_1.property)(Media.posterProperty)
    ], Media.prototype, "poster", void 0);
    __decorate([
        (0, serialization_1.property)(Media.altTextProperty)
    ], Media.prototype, "altText", void 0);
    return Media;
}(CardElement));
exports.Media = Media;
var Input = /** @class */ (function (_super) {
    __extends(Input, _super);
    function Input() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Input.prototype.getAllLabelIds = function () {
        var labelIds = [];
        if (this.labelledBy) {
            labelIds.push(this.labelledBy);
        }
        if (this._renderedLabelElement) {
            labelIds.push(this._renderedLabelElement.id);
        }
        if (this._renderedErrorMessageElement) {
            labelIds.push(this._renderedErrorMessageElement.id);
        }
        return labelIds;
    };
    Input.prototype.updateInputControlAriaLabelledBy = function () {
        if (this._renderedInputControlElement) {
            var labelIds = this.getAllLabelIds();
            if (labelIds.length > 0) {
                this._renderedInputControlElement.setAttribute("aria-labelledby", labelIds.join(" "));
            }
            else {
                this._renderedInputControlElement.removeAttribute("aria-labelledby");
            }
        }
    };
    Object.defineProperty(Input.prototype, "isNullable", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Input.prototype, "renderedInputControlElement", {
        get: function () {
            return this._renderedInputControlElement;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Input.prototype, "inputControlContainerElement", {
        get: function () {
            return this._inputControlContainerElement;
        },
        enumerable: false,
        configurable: true
    });
    Input.prototype.overrideInternalRender = function () {
        var hostConfig = this.hostConfig;
        this._outerContainerElement = document.createElement("div");
        this._outerContainerElement.style.display = "flex";
        this._outerContainerElement.style.flexDirection = "column";
        var renderedInputControlId = Utils.generateUniqueId();
        if (this.label) {
            var labelRichTextBlock = new RichTextBlock();
            labelRichTextBlock.setParent(this);
            labelRichTextBlock.forElementId = renderedInputControlId;
            var labelInline = new TextRun(this.label);
            labelRichTextBlock.addInline(labelInline);
            if (this.isRequired) {
                labelInline.init(hostConfig.inputs.label.requiredInputs);
                var isRequiredCueInline = new TextRun(hostConfig.inputs.label.requiredInputs.suffix);
                isRequiredCueInline.color = hostConfig.inputs.label.requiredInputs.suffixColor;
                isRequiredCueInline.ariaHidden = true;
                labelRichTextBlock.addInline(isRequiredCueInline);
            }
            else {
                labelInline.init(hostConfig.inputs.label.optionalInputs);
            }
            this._renderedLabelElement = labelRichTextBlock.render();
            if (this._renderedLabelElement) {
                this._renderedLabelElement.id = Utils.generateUniqueId();
                this._renderedLabelElement.style.marginBottom =
                    hostConfig.getEffectiveSpacing(hostConfig.inputs.label.inputSpacing) + "px";
                this._outerContainerElement.appendChild(this._renderedLabelElement);
            }
        }
        this._inputControlContainerElement = document.createElement("div");
        this._inputControlContainerElement.className =
            hostConfig.makeCssClassName("ac-input-container");
        this._inputControlContainerElement.style.display = "flex";
        if (this.height === "stretch") {
            this._inputControlContainerElement.style.alignItems = "stretch";
            this._inputControlContainerElement.style.flex = "1 1 auto";
        }
        this._renderedInputControlElement = this.internalRender();
        if (this._renderedInputControlElement) {
            this._renderedInputControlElement.id = renderedInputControlId;
            this._renderedInputControlElement.style.minWidth = "0px";
            if (this.isNullable && this.isRequired) {
                this._renderedInputControlElement.setAttribute("aria-required", "true");
                this._renderedInputControlElement.classList.add(hostConfig.makeCssClassName("ac-input-required"));
            }
            this._inputControlContainerElement.appendChild(this._renderedInputControlElement);
            this._outerContainerElement.appendChild(this._inputControlContainerElement);
            this.updateInputControlAriaLabelledBy();
            return this._outerContainerElement;
        }
        this.resetDirtyState();
        return undefined;
    };
    Input.prototype.valueChanged = function () {
        this.getRootElement().updateActionsEnabledState();
        if (this.isValid()) {
            this.resetValidationFailureCue();
        }
        if (this.onValueChanged) {
            this.onValueChanged(this);
        }
        raiseInputValueChangedEvent(this);
    };
    Input.prototype.resetValidationFailureCue = function () {
        if (this.renderedInputControlElement) {
            this.renderedInputControlElement.classList.remove(this.hostConfig.makeCssClassName("ac-input-validation-failed"));
            this.updateInputControlAriaLabelledBy();
            if (this._renderedErrorMessageElement) {
                this._outerContainerElement.removeChild(this._renderedErrorMessageElement);
                this._renderedErrorMessageElement = undefined;
            }
        }
    };
    Input.prototype.showValidationErrorMessage = function () {
        if (this.renderedElement &&
            this.errorMessage &&
            shared_1.GlobalSettings.displayInputValidationErrors) {
            var errorMessageTextBlock = new TextBlock();
            errorMessageTextBlock.setParent(this);
            errorMessageTextBlock.text = this.errorMessage;
            errorMessageTextBlock.wrap = true;
            errorMessageTextBlock.init(this.hostConfig.inputs.errorMessage);
            this._renderedErrorMessageElement = errorMessageTextBlock.render();
            if (this._renderedErrorMessageElement) {
                this._renderedErrorMessageElement.id = Utils.generateUniqueId();
                this._outerContainerElement.appendChild(this._renderedErrorMessageElement);
                this.updateInputControlAriaLabelledBy();
            }
        }
    };
    Input.prototype.focus = function () {
        if (this._renderedInputControlElement) {
            this._renderedInputControlElement.focus();
        }
    };
    Input.prototype.isValid = function () {
        return true;
    };
    Input.prototype.isDirty = function () {
        return this.value !== this._oldValue;
    };
    Input.prototype.resetDirtyState = function () {
        this._oldValue = this.value;
    };
    Input.prototype.internalValidateProperties = function (context) {
        _super.prototype.internalValidateProperties.call(this, context);
        if (!this.id) {
            context.addFailure(this, Enums.ValidationEvent.PropertyCantBeNull, strings_1.Strings.errors.inputsMustHaveUniqueId());
        }
        if (this.isRequired) {
            if (!this.label) {
                context.addFailure(this, Enums.ValidationEvent.RequiredInputsShouldHaveLabel, "Required inputs should have a label");
            }
            if (!this.errorMessage) {
                context.addFailure(this, Enums.ValidationEvent.RequiredInputsShouldHaveErrorMessage, "Required inputs should have an error message");
            }
        }
    };
    Input.prototype.validateValue = function () {
        this.resetValidationFailureCue();
        var result = this.isRequired ? this.isSet() && this.isValid() : this.isValid();
        if (!result && this.renderedInputControlElement) {
            this.renderedInputControlElement.classList.add(this.hostConfig.makeCssClassName("ac-input-validation-failed"));
            this.showValidationErrorMessage();
        }
        return result;
    };
    Input.prototype.getAllInputs = function (processActions) {
        if (processActions === void 0) { processActions = true; }
        return [this];
    };
    Input.prototype.render = function () {
        var result = _super.prototype.render.call(this);
        this.resetDirtyState();
        return result;
    };
    Object.defineProperty(Input.prototype, "isInteractive", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    //#region Schema
    Input.labelProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_3, "label", true);
    Input.isRequiredProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_3, "isRequired", false);
    Input.errorMessageProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_3, "errorMessage", true);
    __decorate([
        (0, serialization_1.property)(Input.labelProperty)
    ], Input.prototype, "label", void 0);
    __decorate([
        (0, serialization_1.property)(Input.isRequiredProperty)
    ], Input.prototype, "isRequired", void 0);
    __decorate([
        (0, serialization_1.property)(Input.errorMessageProperty)
    ], Input.prototype, "errorMessage", void 0);
    return Input;
}(CardElement));
exports.Input = Input;
var TextInput = /** @class */ (function (_super) {
    __extends(TextInput, _super);
    function TextInput() {
        //#region Schema
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isMultiline = false;
        _this.style = Enums.InputTextStyle.Text;
        return _this;
    }
    //#endregion
    TextInput.prototype.setupInput = function (input) {
        var _this = this;
        input.style.flex = "1 1 auto";
        input.tabIndex = this.isDesignMode() ? -1 : 0;
        if (this.placeholder) {
            input.placeholder = this.placeholder;
            input.setAttribute("aria-label", this.placeholder);
        }
        if (this.defaultValue) {
            input.value = this.defaultValue;
        }
        if (this.maxLength && this.maxLength > 0) {
            input.maxLength = this.maxLength;
        }
        input.oninput = function () {
            _this.valueChanged();
        };
        input.onkeypress = function (e) {
            // Ctrl+Enter pressed
            if (e.ctrlKey &&
                e.code === "Enter" &&
                _this.inlineAction &&
                _this.inlineAction.isEffectivelyEnabled()) {
                _this.inlineAction.execute();
            }
        };
    };
    TextInput.prototype.internalRender = function () {
        var result;
        if (this.isMultiline && this.style !== Enums.InputTextStyle.Password) {
            result = document.createElement("textarea");
            result.className = this.hostConfig.makeCssClassName("ac-input", "ac-textInput", "ac-multiline");
            if (this.height === "stretch") {
                result.style.height = "initial";
            }
        }
        else {
            result = document.createElement("input");
            result.className = this.hostConfig.makeCssClassName("ac-input", "ac-textInput");
            result.type = Enums.InputTextStyle[this.style].toLowerCase();
        }
        this.setupInput(result);
        return result;
    };
    TextInput.prototype.overrideInternalRender = function () {
        var _this = this;
        var renderedInputControl = _super.prototype.overrideInternalRender.call(this);
        if (this.inlineAction) {
            var button_1 = document.createElement("button");
            button_1.className = this.hostConfig.makeCssClassName(this.inlineAction.isEffectivelyEnabled()
                ? "ac-inlineActionButton"
                : "ac-inlineActionButton-disabled");
            button_1.onclick = function (e) {
                if (_this.inlineAction && _this.inlineAction.isEffectivelyEnabled()) {
                    e.preventDefault();
                    e.cancelBubble = true;
                    _this.inlineAction.execute();
                }
            };
            if (this.inlineAction.iconUrl) {
                button_1.classList.add("iconOnly");
                var icon_1 = document.createElement("img");
                icon_1.style.height = "100%";
                icon_1.setAttribute("role", "presentation");
                // The below trick is necessary as a workaround in Chrome where the icon is initially displayed
                // at its native size then resized to 100% of the button's height. This cfreates an unpleasant
                // flicker. On top of that, Chrome's flex implementation fails to prperly re-layout the button
                // after the image has loaded and been gicven its final size. The below trick also fixes that.
                icon_1.style.display = "none";
                icon_1.onload = function () {
                    icon_1.style.removeProperty("display");
                };
                icon_1.onerror = function () {
                    button_1.removeChild(icon_1);
                    button_1.classList.remove("iconOnly");
                    button_1.classList.add("textOnly");
                    button_1.textContent =
                        _this.inlineAction && _this.inlineAction.title
                            ? _this.inlineAction.title
                            : strings_1.Strings.defaults.inlineActionTitle();
                };
                icon_1.src = this.inlineAction.iconUrl;
                button_1.appendChild(icon_1);
                button_1.title = this.inlineAction.title
                    ? this.inlineAction.title
                    : strings_1.Strings.defaults.inlineActionTitle();
            }
            else {
                button_1.classList.add("textOnly");
                button_1.textContent = this.inlineAction.title
                    ? this.inlineAction.title
                    : strings_1.Strings.defaults.inlineActionTitle();
            }
            this.inlineAction.setupElementForAccessibility(button_1, true);
            button_1.style.marginLeft = "8px";
            this.inputControlContainerElement.appendChild(button_1);
        }
        return renderedInputControl;
    };
    TextInput.prototype.getJsonTypeName = function () {
        return "Input.Text";
    };
    TextInput.prototype.getAllActions = function () {
        var result = _super.prototype.getAllActions.call(this);
        if (this.inlineAction) {
            result.push(this.inlineAction);
        }
        return result;
    };
    TextInput.prototype.getActionById = function (id) {
        var result = _super.prototype.getActionById.call(this, id);
        if (!result && this.inlineAction) {
            result = this.inlineAction.getActionById(id);
        }
        return result;
    };
    TextInput.prototype.isSet = function () {
        return this.value ? true : false;
    };
    TextInput.prototype.isValid = function () {
        if (!this.value) {
            return true;
        }
        if (this.regex) {
            return new RegExp(this.regex, "g").test(this.value);
        }
        return true;
    };
    Object.defineProperty(TextInput.prototype, "value", {
        get: function () {
            if (this.renderedInputControlElement) {
                if (this.isMultiline) {
                    return this.renderedInputControlElement.value;
                }
                else {
                    return this.renderedInputControlElement.value;
                }
            }
            else {
                return undefined;
            }
        },
        enumerable: false,
        configurable: true
    });
    TextInput.valueProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "value");
    TextInput.maxLengthProperty = new serialization_1.NumProperty(serialization_1.Versions.v1_0, "maxLength");
    TextInput.isMultilineProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_0, "isMultiline", false);
    TextInput.placeholderProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "placeholder");
    TextInput.styleProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_0, "style", Enums.InputTextStyle, Enums.InputTextStyle.Text, [
        { value: Enums.InputTextStyle.Text },
        { value: Enums.InputTextStyle.Tel },
        { value: Enums.InputTextStyle.Url },
        { value: Enums.InputTextStyle.Email },
        { value: Enums.InputTextStyle.Password, targetVersion: serialization_1.Versions.v1_5 }
    ]);
    TextInput.inlineActionProperty = new ActionProperty(serialization_1.Versions.v1_0, "inlineAction", [
        "Action.ShowCard"
    ]);
    TextInput.regexProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_3, "regex", true);
    __decorate([
        (0, serialization_1.property)(TextInput.valueProperty)
    ], TextInput.prototype, "defaultValue", void 0);
    __decorate([
        (0, serialization_1.property)(TextInput.maxLengthProperty)
    ], TextInput.prototype, "maxLength", void 0);
    __decorate([
        (0, serialization_1.property)(TextInput.isMultilineProperty)
    ], TextInput.prototype, "isMultiline", void 0);
    __decorate([
        (0, serialization_1.property)(TextInput.placeholderProperty)
    ], TextInput.prototype, "placeholder", void 0);
    __decorate([
        (0, serialization_1.property)(TextInput.styleProperty)
    ], TextInput.prototype, "style", void 0);
    __decorate([
        (0, serialization_1.property)(TextInput.inlineActionProperty)
    ], TextInput.prototype, "inlineAction", void 0);
    __decorate([
        (0, serialization_1.property)(TextInput.regexProperty)
    ], TextInput.prototype, "regex", void 0);
    return TextInput;
}(Input));
exports.TextInput = TextInput;
var ToggleInput = /** @class */ (function (_super) {
    __extends(ToggleInput, _super);
    function ToggleInput() {
        //#region Schema
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.valueOn = "true";
        _this.valueOff = "false";
        _this.wrap = false;
        return _this;
    }
    ToggleInput.prototype.updateInputControlAriaLabelledBy = function () {
        if (this._checkboxInputElement) {
            var joinedLabelIds = this.getAllLabelIds().join(" ");
            if (this._checkboxInputLabelElement && this._checkboxInputLabelElement.id) {
                joinedLabelIds += " " + this._checkboxInputLabelElement.id;
            }
            if (joinedLabelIds) {
                this._checkboxInputElement.setAttribute("aria-labelledby", joinedLabelIds);
            }
            else {
                this._checkboxInputElement.removeAttribute("aria-labelledby");
            }
        }
    };
    ToggleInput.prototype.internalRender = function () {
        var _this = this;
        var element = document.createElement("div");
        element.className = this.hostConfig.makeCssClassName("ac-input", "ac-toggleInput");
        element.style.width = "100%";
        element.style.display = "flex";
        element.style.alignItems = "center";
        this._checkboxInputElement = document.createElement("input");
        this._checkboxInputElement.id = Utils.generateUniqueId();
        this._checkboxInputElement.type = "checkbox";
        this._checkboxInputElement.style.display = "inline-block";
        this._checkboxInputElement.style.verticalAlign = "middle";
        this._checkboxInputElement.style.margin = "0";
        this._checkboxInputElement.style.flex = "0 0 auto";
        if (this.title) {
            this._checkboxInputElement.setAttribute("aria-label", this.title);
        }
        if (this.isRequired) {
            this._checkboxInputElement.setAttribute("aria-required", "true");
        }
        this._checkboxInputElement.tabIndex = this.isDesignMode() ? -1 : 0;
        if (this.defaultValue === this.valueOn) {
            this._checkboxInputElement.checked = true;
        }
        this._oldCheckboxValue = this._checkboxInputElement.checked;
        this._checkboxInputElement.onchange = function () {
            _this.valueChanged();
        };
        Utils.appendChild(element, this._checkboxInputElement);
        if (this.title || this.isDesignMode()) {
            var label = new TextBlock();
            label.setParent(this);
            label.forElementId = this._checkboxInputElement.id;
            label.hostConfig = this.hostConfig;
            label.text = !this.title ? this.getJsonTypeName() : this.title;
            label.useMarkdown = shared_1.GlobalSettings.useMarkdownInRadioButtonAndCheckbox;
            label.wrap = this.wrap;
            this._checkboxInputLabelElement = label.render();
            if (this._checkboxInputLabelElement) {
                this._checkboxInputLabelElement.id = Utils.generateUniqueId();
                this._checkboxInputLabelElement.style.display = "inline-block";
                this._checkboxInputLabelElement.style.flex = "1 1 auto";
                this._checkboxInputLabelElement.style.marginLeft = "6px";
                this._checkboxInputLabelElement.style.verticalAlign = "middle";
                var spacerElement = document.createElement("div");
                spacerElement.style.width = "6px";
                Utils.appendChild(element, spacerElement);
                Utils.appendChild(element, this._checkboxInputLabelElement);
            }
        }
        return element;
    };
    Object.defineProperty(ToggleInput.prototype, "isNullable", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    ToggleInput.prototype.getJsonTypeName = function () {
        return "Input.Toggle";
    };
    ToggleInput.prototype.focus = function () {
        if (this._checkboxInputElement) {
            this._checkboxInputElement.focus();
        }
    };
    ToggleInput.prototype.isSet = function () {
        if (this.isRequired) {
            return this.value === this.valueOn;
        }
        return this.value ? true : false;
    };
    ToggleInput.prototype.isDirty = function () {
        return this._checkboxInputElement
            ? this._checkboxInputElement.checked !== this._oldCheckboxValue
            : false;
    };
    Object.defineProperty(ToggleInput.prototype, "value", {
        get: function () {
            if (this._checkboxInputElement) {
                return this._checkboxInputElement.checked ? this.valueOn : this.valueOff;
            }
            else {
                return undefined;
            }
        },
        enumerable: false,
        configurable: true
    });
    ToggleInput.valueProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "value");
    ToggleInput.titleProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "title");
    ToggleInput.valueOnProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "valueOn", true, undefined, "true", function (sender) {
        return "true";
    });
    ToggleInput.valueOffProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "valueOff", true, undefined, "false", function (sender) {
        return "false";
    });
    ToggleInput.wrapProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_2, "wrap", false);
    __decorate([
        (0, serialization_1.property)(ToggleInput.valueProperty)
    ], ToggleInput.prototype, "defaultValue", void 0);
    __decorate([
        (0, serialization_1.property)(ToggleInput.titleProperty)
    ], ToggleInput.prototype, "title", void 0);
    __decorate([
        (0, serialization_1.property)(ToggleInput.valueOnProperty)
    ], ToggleInput.prototype, "valueOn", void 0);
    __decorate([
        (0, serialization_1.property)(ToggleInput.valueOffProperty)
    ], ToggleInput.prototype, "valueOff", void 0);
    __decorate([
        (0, serialization_1.property)(ToggleInput.wrapProperty)
    ], ToggleInput.prototype, "wrap", void 0);
    return ToggleInput;
}(Input));
exports.ToggleInput = ToggleInput;
var Choice = /** @class */ (function (_super) {
    __extends(Choice, _super);
    function Choice(title, value) {
        var _this = _super.call(this) || this;
        _this.title = title;
        _this.value = value;
        return _this;
    }
    //#endregion
    Choice.prototype.getSchemaKey = function () {
        return "Choice";
    };
    //#region Schema
    Choice.titleProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "title");
    Choice.valueProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "value");
    __decorate([
        (0, serialization_1.property)(Choice.titleProperty)
    ], Choice.prototype, "title", void 0);
    __decorate([
        (0, serialization_1.property)(Choice.valueProperty)
    ], Choice.prototype, "value", void 0);
    return Choice;
}(serialization_1.SerializableObject));
exports.Choice = Choice;
var ChoiceSetInput = /** @class */ (function (_super) {
    __extends(ChoiceSetInput, _super);
    function ChoiceSetInput() {
        //#region Schema
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isMultiSelect = false;
        _this.wrap = false;
        _this.choices = [];
        return _this;
    }
    Object.defineProperty(ChoiceSetInput.prototype, "isCompact", {
        get: function () {
            return !this.style || this.style === "compact";
        },
        set: function (value) {
            this.style = value ? undefined : "expanded";
        },
        enumerable: false,
        configurable: true
    });
    ChoiceSetInput.getUniqueCategoryName = function () {
        var uniqueCategoryName = "__ac-category" + ChoiceSetInput._uniqueCategoryCounter;
        ChoiceSetInput._uniqueCategoryCounter++;
        return uniqueCategoryName;
    };
    // Make sure `aria-current` is applied to the currently-selected item
    ChoiceSetInput.prototype.internalApplyAriaCurrent = function () {
        if (this._selectElement) {
            var options = this._selectElement.options;
            if (options) {
                for (var _i = 0, _a = Array.from(options); _i < _a.length; _i++) {
                    var option = _a[_i];
                    if (option.selected) {
                        option.setAttribute("aria-current", "true");
                    }
                    else {
                        option.removeAttribute("aria-current");
                    }
                }
            }
        }
    };
    ChoiceSetInput.prototype.renderCompoundInput = function (cssClassName, type, defaultValues) {
        var _this = this;
        var element = document.createElement("div");
        element.className = this.hostConfig.makeCssClassName("ac-input", cssClassName);
        element.style.width = "100%";
        element.tabIndex = this.isDesignMode() ? -1 : 0;
        this._toggleInputs = [];
        this._labels = [];
        for (var _i = 0, _a = this.choices; _i < _a.length; _i++) {
            var choice = _a[_i];
            var input = document.createElement("input");
            input.id = Utils.generateUniqueId();
            input.type = type;
            input.style.margin = "0";
            input.style.display = "inline-block";
            input.style.verticalAlign = "middle";
            input.style.flex = "0 0 auto";
            input.name = this.id ? this.id : this._uniqueCategoryName;
            if (this.isRequired) {
                input.setAttribute("aria-required", "true");
            }
            input.tabIndex = this.isDesignMode() ? -1 : 0;
            if (choice.value) {
                input.value = choice.value;
            }
            if (choice.title) {
                input.setAttribute("aria-label", choice.title);
            }
            if (defaultValues && choice.value) {
                if (defaultValues.indexOf(choice.value) >= 0) {
                    input.checked = true;
                }
            }
            input.onchange = function () {
                _this.valueChanged();
            };
            this._toggleInputs.push(input);
            var compoundInput = document.createElement("div");
            compoundInput.style.display = "flex";
            compoundInput.style.alignItems = "center";
            Utils.appendChild(compoundInput, input);
            var label = new TextBlock();
            label.setParent(this);
            label.forElementId = input.id;
            label.hostConfig = this.hostConfig;
            label.text = choice.title ? choice.title : "Choice " + this._toggleInputs.length;
            label.useMarkdown = shared_1.GlobalSettings.useMarkdownInRadioButtonAndCheckbox;
            label.wrap = this.wrap;
            var labelElement = label.render();
            this._labels.push(labelElement);
            if (labelElement) {
                labelElement.id = Utils.generateUniqueId();
                labelElement.style.display = "inline-block";
                labelElement.style.flex = "1 1 auto";
                labelElement.style.marginLeft = "6px";
                labelElement.style.verticalAlign = "middle";
                var spacerElement = document.createElement("div");
                spacerElement.style.width = "6px";
                Utils.appendChild(compoundInput, spacerElement);
                Utils.appendChild(compoundInput, labelElement);
            }
            Utils.appendChild(element, compoundInput);
        }
        return element;
    };
    ChoiceSetInput.prototype.updateInputControlAriaLabelledBy = function () {
        if ((this.isMultiSelect || this.style === "expanded") &&
            this._toggleInputs &&
            this._labels) {
            var labelIds = this.getAllLabelIds();
            for (var i = 0; i < this._toggleInputs.length; i++) {
                var joinedLabelIds = labelIds.join(" ");
                var label = this._labels[i];
                if (label && label.id) {
                    joinedLabelIds += " " + label.id;
                }
                if (joinedLabelIds) {
                    this._toggleInputs[i].setAttribute("aria-labelledby", joinedLabelIds);
                }
                else {
                    this._toggleInputs[i].removeAttribute("aria-labelledby");
                }
            }
        }
        else {
            _super.prototype.updateInputControlAriaLabelledBy.call(this);
        }
    };
    ChoiceSetInput.prototype.internalRender = function () {
        var _this = this;
        this._uniqueCategoryName = ChoiceSetInput.getUniqueCategoryName();
        if (this.isMultiSelect) {
            // Render as a list of toggle inputs
            return this.renderCompoundInput("ac-choiceSetInput-multiSelect", "checkbox", this.defaultValue
                ? this.defaultValue.split(this.hostConfig.choiceSetInputValueSeparator)
                : undefined);
        }
        else {
            if (this.style === "expanded") {
                // Render as a series of radio buttons
                return this.renderCompoundInput("ac-choiceSetInput-expanded", "radio", this.defaultValue ? [this.defaultValue] : undefined);
            }
            else if (this.style === "filtered") {
                // Render as a text input coupled with a datalist
                var inputContainer = document.createElement("div");
                inputContainer.style.width = "100%";
                this._textInput = document.createElement("input");
                this._textInput.className = this.hostConfig.makeCssClassName("ac-input", "ac-multichoiceInput", "ac-choiceSetInput-filtered");
                this._textInput.type = "text";
                this._textInput.style.width = "100%";
                this._textInput.oninput = function () {
                    _this.valueChanged();
                    if (_this._textInput) {
                        // Remove aria-label when value is not empty so narration software doesn't
                        // read the placeholder
                        if (_this.value) {
                            _this._textInput.removeAttribute("placeholder");
                            _this._textInput.removeAttribute("aria-label");
                        }
                        else if (_this.placeholder) {
                            _this._textInput.placeholder = _this.placeholder;
                            _this._textInput.setAttribute("aria-label", _this.placeholder);
                        }
                    }
                };
                if (this.defaultValue) {
                    this._textInput.value = this.defaultValue;
                }
                if (this.placeholder && !this._textInput.value) {
                    this._textInput.placeholder = this.placeholder;
                    this._textInput.setAttribute("aria-label", this.placeholder);
                }
                this._textInput.tabIndex = this.isDesignMode() ? -1 : 0;
                var dataList = document.createElement("datalist");
                dataList.id = Utils.generateUniqueId();
                for (var _i = 0, _a = this.choices; _i < _a.length; _i++) {
                    var choice = _a[_i];
                    var option = document.createElement("option");
                    // To fix https://stackoverflow.com/questions/29882361/show-datalist-labels-but-submit-the-actual-value
                    // value is mapped to choice.title other than choice.value
                    if (choice.title) {
                        option.value = choice.title;
                        option.setAttribute("aria-label", choice.title);
                    }
                    option.tabIndex = this.isDesignMode() ? -1 : 0;
                    dataList.appendChild(option);
                }
                this._textInput.setAttribute("list", dataList.id);
                inputContainer.append(this._textInput, dataList);
                return inputContainer;
            }
            else {
                // Render as a combo box
                this._selectElement = document.createElement("select");
                this._selectElement.className = this.hostConfig.makeCssClassName("ac-input", "ac-multichoiceInput", "ac-choiceSetInput-compact");
                this._selectElement.style.width = "100%";
                this._selectElement.tabIndex = this.isDesignMode() ? -1 : 0;
                var placeholderOption = document.createElement("option");
                placeholderOption.selected = true;
                placeholderOption.disabled = true;
                placeholderOption.hidden = true;
                placeholderOption.value = "";
                if (this.placeholder) {
                    placeholderOption.text = this.placeholder;
                }
                Utils.appendChild(this._selectElement, placeholderOption);
                for (var _b = 0, _c = this.choices; _b < _c.length; _b++) {
                    var choice = _c[_b];
                    var option = document.createElement("option");
                    option.value = choice.value;
                    if (choice.title) {
                        option.text = choice.title;
                        option.setAttribute("aria-label", choice.title);
                    }
                    option.tabIndex = this.isDesignMode() ? -1 : 0;
                    if (choice.value === this.defaultValue) {
                        option.selected = true;
                    }
                    Utils.appendChild(this._selectElement, option);
                }
                this._selectElement.onchange = function () {
                    _this.internalApplyAriaCurrent();
                    _this.valueChanged();
                };
                this.internalApplyAriaCurrent();
                return this._selectElement;
            }
        }
    };
    ChoiceSetInput.prototype.getJsonTypeName = function () {
        return "Input.ChoiceSet";
    };
    ChoiceSetInput.prototype.focus = function () {
        if (this._toggleInputs && (this.isMultiSelect || this.style === "expanded")) {
            if (this._toggleInputs.length > 0) {
                this._toggleInputs[0].focus();
            }
        }
        else if (this._textInput) {
            this._textInput.focus();
        }
        else {
            _super.prototype.focus.call(this);
        }
    };
    ChoiceSetInput.prototype.internalValidateProperties = function (context) {
        _super.prototype.internalValidateProperties.call(this, context);
        if (this.choices.length === 0) {
            context.addFailure(this, Enums.ValidationEvent.CollectionCantBeEmpty, strings_1.Strings.errors.choiceSetMustHaveAtLeastOneChoice());
        }
        for (var _i = 0, _a = this.choices; _i < _a.length; _i++) {
            var choice = _a[_i];
            if (!choice.title || !choice.value) {
                context.addFailure(this, Enums.ValidationEvent.PropertyCantBeNull, strings_1.Strings.errors.choiceSetChoicesMustHaveTitleAndValue());
            }
        }
    };
    ChoiceSetInput.prototype.isSet = function () {
        return this.value ? true : false;
    };
    ChoiceSetInput.prototype.isValid = function () {
        if (this._textInput) {
            if (this.value === "" || this.value === this.placeholder) {
                return true;
            }
            for (var _i = 0, _a = this.choices; _i < _a.length; _i++) {
                var choice = _a[_i];
                if (this.value === choice.value) {
                    return true;
                }
            }
            return false;
        }
        return _super.prototype.isValid.call(this);
    };
    Object.defineProperty(ChoiceSetInput.prototype, "value", {
        get: function () {
            if (!this.isMultiSelect) {
                if (this._selectElement) {
                    return this._selectElement.selectedIndex > 0
                        ? this._selectElement.value
                        : undefined;
                }
                else if (this._textInput) {
                    for (var _i = 0, _a = this.choices; _i < _a.length; _i++) {
                        var choice = _a[_i];
                        if (choice.title && this._textInput.value === choice.title) {
                            return choice.value;
                        }
                    }
                    return this._textInput.value;
                }
                else if (this._toggleInputs && this._toggleInputs.length > 0) {
                    for (var _b = 0, _c = this._toggleInputs; _b < _c.length; _b++) {
                        var toggleInput = _c[_b];
                        if (toggleInput.checked) {
                            return toggleInput.value;
                        }
                    }
                }
                return undefined;
            }
            else {
                if (!this._toggleInputs || this._toggleInputs.length === 0) {
                    return undefined;
                }
                var result = "";
                for (var _d = 0, _f = this._toggleInputs; _d < _f.length; _d++) {
                    var toggleInput = _f[_d];
                    if (toggleInput.checked) {
                        if (result !== "") {
                            result += this.hostConfig.choiceSetInputValueSeparator;
                        }
                        result += toggleInput.value;
                    }
                }
                return result ? result : undefined;
            }
        },
        enumerable: false,
        configurable: true
    });
    ChoiceSetInput.valueProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "value");
    ChoiceSetInput.choicesProperty = new serialization_1.SerializableObjectCollectionProperty(serialization_1.Versions.v1_0, "choices", Choice);
    ChoiceSetInput.styleProperty = new serialization_1.ValueSetProperty(serialization_1.Versions.v1_0, "style", [
        { value: "compact" },
        { value: "expanded" },
        { value: "filtered", targetVersion: serialization_1.Versions.v1_5 }
    ], "compact");
    ChoiceSetInput.isMultiSelectProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_0, "isMultiSelect", false);
    ChoiceSetInput.placeholderProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "placeholder");
    ChoiceSetInput.wrapProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_2, "wrap", false);
    //#endregion
    ChoiceSetInput._uniqueCategoryCounter = 0;
    __decorate([
        (0, serialization_1.property)(ChoiceSetInput.valueProperty)
    ], ChoiceSetInput.prototype, "defaultValue", void 0);
    __decorate([
        (0, serialization_1.property)(ChoiceSetInput.styleProperty)
    ], ChoiceSetInput.prototype, "style", void 0);
    __decorate([
        (0, serialization_1.property)(ChoiceSetInput.isMultiSelectProperty)
    ], ChoiceSetInput.prototype, "isMultiSelect", void 0);
    __decorate([
        (0, serialization_1.property)(ChoiceSetInput.placeholderProperty)
    ], ChoiceSetInput.prototype, "placeholder", void 0);
    __decorate([
        (0, serialization_1.property)(ChoiceSetInput.wrapProperty)
    ], ChoiceSetInput.prototype, "wrap", void 0);
    __decorate([
        (0, serialization_1.property)(ChoiceSetInput.choicesProperty)
    ], ChoiceSetInput.prototype, "choices", void 0);
    return ChoiceSetInput;
}(Input));
exports.ChoiceSetInput = ChoiceSetInput;
var NumberInput = /** @class */ (function (_super) {
    __extends(NumberInput, _super);
    function NumberInput() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NumberInput.prototype.internalRender = function () {
        var _this = this;
        this._numberInputElement = document.createElement("input");
        this._numberInputElement.setAttribute("type", "number");
        if (this.min !== undefined) {
            this._numberInputElement.setAttribute("min", this.min.toString());
        }
        if (this.max !== undefined) {
            this._numberInputElement.setAttribute("max", this.max.toString());
        }
        this._numberInputElement.className = this.hostConfig.makeCssClassName("ac-input", "ac-numberInput");
        this._numberInputElement.style.width = "100%";
        this._numberInputElement.tabIndex = this.isDesignMode() ? -1 : 0;
        if (this.defaultValue !== undefined) {
            this._numberInputElement.valueAsNumber = this.defaultValue;
        }
        if (this.placeholder) {
            this._numberInputElement.placeholder = this.placeholder;
            this._numberInputElement.setAttribute("aria-label", this.placeholder);
        }
        this._numberInputElement.oninput = function () {
            _this.valueChanged();
        };
        return this._numberInputElement;
    };
    NumberInput.prototype.getJsonTypeName = function () {
        return "Input.Number";
    };
    NumberInput.prototype.isSet = function () {
        return this.value !== undefined && !isNaN(this.value);
    };
    NumberInput.prototype.isValid = function () {
        if (this.value === undefined) {
            return !this.isRequired;
        }
        var result = true;
        if (this.min !== undefined) {
            result = result && this.value >= this.min;
        }
        if (this.max !== undefined) {
            result = result && this.value <= this.max;
        }
        return result;
    };
    Object.defineProperty(NumberInput.prototype, "value", {
        get: function () {
            return this._numberInputElement ? this._numberInputElement.valueAsNumber : undefined;
        },
        set: function (value) {
            if (value && this._numberInputElement) {
                this._numberInputElement.value = value.toString();
            }
        },
        enumerable: false,
        configurable: true
    });
    //#region Schema
    NumberInput.valueProperty = new serialization_1.NumProperty(serialization_1.Versions.v1_0, "value");
    NumberInput.placeholderProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "placeholder");
    NumberInput.minProperty = new serialization_1.NumProperty(serialization_1.Versions.v1_0, "min");
    NumberInput.maxProperty = new serialization_1.NumProperty(serialization_1.Versions.v1_0, "max");
    __decorate([
        (0, serialization_1.property)(NumberInput.valueProperty)
    ], NumberInput.prototype, "defaultValue", void 0);
    __decorate([
        (0, serialization_1.property)(NumberInput.minProperty)
    ], NumberInput.prototype, "min", void 0);
    __decorate([
        (0, serialization_1.property)(NumberInput.maxProperty)
    ], NumberInput.prototype, "max", void 0);
    __decorate([
        (0, serialization_1.property)(NumberInput.placeholderProperty)
    ], NumberInput.prototype, "placeholder", void 0);
    return NumberInput;
}(Input));
exports.NumberInput = NumberInput;
var DateInput = /** @class */ (function (_super) {
    __extends(DateInput, _super);
    function DateInput() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DateInput.prototype.internalRender = function () {
        var _this = this;
        this._dateInputElement = document.createElement("input");
        this._dateInputElement.setAttribute("type", "date");
        if (this.min) {
            this._dateInputElement.setAttribute("min", this.min);
        }
        if (this.max) {
            this._dateInputElement.setAttribute("max", this.max);
        }
        if (this.placeholder) {
            this._dateInputElement.placeholder = this.placeholder;
            this._dateInputElement.setAttribute("aria-label", this.placeholder);
        }
        this._dateInputElement.tabIndex = this.isDesignMode() ? -1 : 0;
        this._dateInputElement.className = this.hostConfig.makeCssClassName("ac-input", "ac-dateInput");
        this._dateInputElement.style.width = "100%";
        this._dateInputElement.oninput = function () {
            _this.valueChanged();
        };
        if (this.defaultValue) {
            this._dateInputElement.value = this.defaultValue;
        }
        return this._dateInputElement;
    };
    DateInput.prototype.getJsonTypeName = function () {
        return "Input.Date";
    };
    DateInput.prototype.isSet = function () {
        return this.value ? true : false;
    };
    DateInput.prototype.isValid = function () {
        if (!this.value) {
            return !this.isRequired;
        }
        var valueAsDate = new Date(this.value);
        var result = true;
        if (this.min) {
            var minDate = new Date(this.min);
            result = result && valueAsDate >= minDate;
        }
        if (this.max) {
            var maxDate = new Date(this.max);
            result = result && valueAsDate <= maxDate;
        }
        return result;
    };
    Object.defineProperty(DateInput.prototype, "value", {
        get: function () {
            return this._dateInputElement ? this._dateInputElement.value : undefined;
        },
        enumerable: false,
        configurable: true
    });
    //#region Schema
    DateInput.valueProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "value");
    DateInput.placeholderProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "placeholder");
    DateInput.minProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "min");
    DateInput.maxProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "max");
    __decorate([
        (0, serialization_1.property)(DateInput.valueProperty)
    ], DateInput.prototype, "defaultValue", void 0);
    __decorate([
        (0, serialization_1.property)(DateInput.minProperty)
    ], DateInput.prototype, "min", void 0);
    __decorate([
        (0, serialization_1.property)(DateInput.maxProperty)
    ], DateInput.prototype, "max", void 0);
    __decorate([
        (0, serialization_1.property)(DateInput.placeholderProperty)
    ], DateInput.prototype, "placeholder", void 0);
    return DateInput;
}(Input));
exports.DateInput = DateInput;
var TimeProperty = /** @class */ (function (_super) {
    __extends(TimeProperty, _super);
    function TimeProperty(targetVersion, name) {
        var _this = _super.call(this, targetVersion, name, function (sender, prop, source, context) {
            var value = source[prop.name];
            if (typeof value === "string" && value && /^[0-9]{2}:[0-9]{2}$/.test(value)) {
                return value;
            }
            return undefined;
        }, function (sender, prop, target, value, context) {
            context.serializeValue(target, prop.name, value);
        }) || this;
        _this.targetVersion = targetVersion;
        _this.name = name;
        return _this;
    }
    return TimeProperty;
}(serialization_1.CustomProperty));
exports.TimeProperty = TimeProperty;
var TimeInput = /** @class */ (function (_super) {
    __extends(TimeInput, _super);
    function TimeInput() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeInput.convertTimeStringToDate = function (timeString) {
        return new Date("1973-09-04T" + timeString + ":00Z");
    };
    TimeInput.prototype.internalRender = function () {
        var _this = this;
        this._timeInputElement = document.createElement("input");
        this._timeInputElement.setAttribute("type", "time");
        if (this.min) {
            this._timeInputElement.setAttribute("min", this.min);
        }
        if (this.max) {
            this._timeInputElement.setAttribute("max", this.max);
        }
        this._timeInputElement.className = this.hostConfig.makeCssClassName("ac-input", "ac-timeInput");
        this._timeInputElement.style.width = "100%";
        this._timeInputElement.oninput = function () {
            _this.valueChanged();
        };
        if (this.placeholder) {
            this._timeInputElement.placeholder = this.placeholder;
            this._timeInputElement.setAttribute("aria-label", this.placeholder);
        }
        this._timeInputElement.tabIndex = this.isDesignMode() ? -1 : 0;
        if (this.defaultValue) {
            this._timeInputElement.value = this.defaultValue;
        }
        return this._timeInputElement;
    };
    TimeInput.prototype.getJsonTypeName = function () {
        return "Input.Time";
    };
    TimeInput.prototype.isSet = function () {
        return this.value ? true : false;
    };
    TimeInput.prototype.isValid = function () {
        if (!this.value) {
            return !this.isRequired;
        }
        var valueAsDate = TimeInput.convertTimeStringToDate(this.value);
        var result = true;
        if (this.min) {
            var minDate = TimeInput.convertTimeStringToDate(this.min);
            result = result && valueAsDate >= minDate;
        }
        if (this.max) {
            var maxDate = TimeInput.convertTimeStringToDate(this.max);
            result = result && valueAsDate <= maxDate;
        }
        return result;
    };
    Object.defineProperty(TimeInput.prototype, "value", {
        get: function () {
            return this._timeInputElement ? this._timeInputElement.value : undefined;
        },
        enumerable: false,
        configurable: true
    });
    //#region Schema
    TimeInput.valueProperty = new TimeProperty(serialization_1.Versions.v1_0, "value");
    TimeInput.placeholderProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "placeholder");
    TimeInput.minProperty = new TimeProperty(serialization_1.Versions.v1_0, "min");
    TimeInput.maxProperty = new TimeProperty(serialization_1.Versions.v1_0, "max");
    __decorate([
        (0, serialization_1.property)(TimeInput.valueProperty)
    ], TimeInput.prototype, "defaultValue", void 0);
    __decorate([
        (0, serialization_1.property)(TimeInput.minProperty)
    ], TimeInput.prototype, "min", void 0);
    __decorate([
        (0, serialization_1.property)(TimeInput.maxProperty)
    ], TimeInput.prototype, "max", void 0);
    __decorate([
        (0, serialization_1.property)(TimeInput.placeholderProperty)
    ], TimeInput.prototype, "placeholder", void 0);
    return TimeInput;
}(Input));
exports.TimeInput = TimeInput;
var Action = /** @class */ (function (_super) {
    __extends(Action, _super);
    function Action() {
        //#region Schema
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.style = Enums.ActionStyle.Default;
        _this.mode = Enums.ActionMode.Primary;
        _this._state = 0 /* Normal */;
        _this._isFocusable = true;
        return _this;
    }
    //#endregion
    Action.prototype.renderButtonContent = function () {
        if (this.renderedElement) {
            // Cache hostConfig for perf
            var hostConfig = this.hostConfig;
            var titleElement = document.createElement("div");
            titleElement.style.overflow = "hidden";
            titleElement.style.textOverflow = "ellipsis";
            if (!(hostConfig.actions.iconPlacement === Enums.ActionIconPlacement.AboveTitle ||
                hostConfig.actions.allowTitleToWrap)) {
                titleElement.style.whiteSpace = "nowrap";
            }
            if (this.title) {
                titleElement.innerText = this.title;
            }
            if (!this.iconUrl) {
                this.renderedElement.classList.add("noIcon");
                this.renderedElement.appendChild(titleElement);
            }
            else {
                var iconElement = document.createElement("img");
                iconElement.src = this.iconUrl;
                iconElement.style.width = hostConfig.actions.iconSize + "px";
                iconElement.style.height = hostConfig.actions.iconSize + "px";
                iconElement.style.flex = "0 0 auto";
                if (hostConfig.actions.iconPlacement === Enums.ActionIconPlacement.AboveTitle) {
                    this.renderedElement.classList.add("iconAbove");
                    this.renderedElement.style.flexDirection = "column";
                    if (this.title) {
                        iconElement.style.marginBottom = "6px";
                    }
                }
                else {
                    this.renderedElement.classList.add("iconLeft");
                    iconElement.style.maxHeight = "100%";
                    if (this.title) {
                        iconElement.style.marginRight = "6px";
                    }
                }
                this.renderedElement.appendChild(iconElement);
                this.renderedElement.appendChild(titleElement);
            }
        }
    };
    Action.prototype.getParentContainer = function () {
        if (this.parent instanceof Container) {
            return this.parent;
        }
        return this.parent ? this.parent.getParentContainer() : undefined;
    };
    Action.prototype.isDesignMode = function () {
        var rootElement = this.getRootObject();
        return rootElement instanceof CardElement && rootElement.isDesignMode();
    };
    Action.prototype.updateCssClasses = function () {
        var _a, _b;
        if (this.parent && this.renderedElement) {
            var hostConfig = this.parent.hostConfig;
            this.renderedElement.className = hostConfig.makeCssClassName(this.isEffectivelyEnabled() ? "ac-pushButton" : "ac-pushButton-disabled");
            var parentContainer = this.getParentContainer();
            if (parentContainer) {
                var parentContainerStyle = parentContainer.getEffectiveStyle();
                if (parentContainerStyle) {
                    this.renderedElement.classList.add("style-" + parentContainerStyle);
                }
            }
            this.renderedElement.tabIndex = !this.isDesignMode() && this.isFocusable ? 0 : -1;
            switch (this._state) {
                case 0 /* Normal */:
                    // No additional classes needed
                    break;
                case 1 /* Expanded */:
                    this.renderedElement.classList.add(hostConfig.makeCssClassName("expanded"));
                    break;
                case 2 /* Subdued */:
                    this.renderedElement.classList.add(hostConfig.makeCssClassName("subdued"));
                    break;
            }
            if (this.style && this.isEffectivelyEnabled()) {
                if (this.style === Enums.ActionStyle.Positive) {
                    (_a = this.renderedElement.classList).add.apply(_a, hostConfig.makeCssClassNames("primary", "style-positive"));
                }
                else {
                    (_b = this.renderedElement.classList).add.apply(_b, hostConfig.makeCssClassNames("style-" + this.style.toLowerCase()));
                }
            }
        }
    };
    Action.prototype.getDefaultSerializationContext = function () {
        return new SerializationContext();
    };
    Action.prototype.internalGetReferencedInputs = function () {
        return {};
    };
    Action.prototype.internalPrepareForExecution = function (_inputs) {
        // Do nothing in base implementation
    };
    Action.prototype.internalValidateInputs = function (referencedInputs) {
        var result = [];
        if (referencedInputs) {
            for (var _i = 0, _a = Object.keys(referencedInputs); _i < _a.length; _i++) {
                var key = _a[_i];
                var input = referencedInputs[key];
                if (!input.validateValue()) {
                    result.push(input);
                }
            }
        }
        return result;
    };
    Action.prototype.shouldSerialize = function (context) {
        return context.actionRegistry.findByName(this.getJsonTypeName()) !== undefined;
    };
    Action.prototype.raiseExecuteActionEvent = function () {
        if (this.onExecute) {
            this.onExecute(this);
        }
        raiseExecuteActionEvent(this);
    };
    Action.prototype.internalAfterExecute = function () {
        var rootObject = this.getRootObject();
        if (rootObject instanceof CardElement) {
            rootObject.updateActionsEnabledState();
        }
    };
    Action.prototype.getHref = function () {
        return "";
    };
    Action.prototype.getAriaRole = function () {
        return "button";
    };
    Action.prototype.setupElementForAccessibility = function (element, promoteTooltipToLabel) {
        if (promoteTooltipToLabel === void 0) { promoteTooltipToLabel = false; }
        element.tabIndex = this.isEffectivelyEnabled() && !this.isDesignMode() ? 0 : -1;
        element.setAttribute("role", this.getAriaRole());
        if (element instanceof HTMLButtonElement) {
            element.disabled = !this.isEffectivelyEnabled();
        }
        if (!this.isEffectivelyEnabled()) {
            element.setAttribute("aria-disabled", "true");
        }
        else {
            element.removeAttribute("aria-disabled");
            element.classList.add(this.hostConfig.makeCssClassName("ac-selectable"));
        }
        if (this.title) {
            element.setAttribute("aria-label", this.title);
            element.title = this.title;
        }
        else {
            element.removeAttribute("aria-label");
            element.removeAttribute("title");
        }
        if (this.tooltip) {
            var targetAriaAttribute = promoteTooltipToLabel
                ? this.title
                    ? "aria-description"
                    : "aria-label"
                : "aria-description";
            element.setAttribute(targetAriaAttribute, this.tooltip);
            element.title = this.tooltip;
        }
    };
    Action.prototype.parse = function (source, context) {
        return _super.prototype.parse.call(this, source, context ? context : new SerializationContext());
    };
    Action.prototype.render = function () {
        var _this = this;
        var buttonElement = document.createElement("button");
        buttonElement.type = "button";
        buttonElement.style.display = "flex";
        buttonElement.style.alignItems = "center";
        buttonElement.style.justifyContent = "center";
        buttonElement.onclick = function (e) {
            if (_this.isEffectivelyEnabled()) {
                e.preventDefault();
                e.cancelBubble = true;
                _this.execute();
            }
        };
        this._renderedElement = buttonElement;
        this.renderButtonContent();
        this.updateCssClasses();
        this.setupElementForAccessibility(buttonElement);
    };
    Action.prototype.execute = function () {
        if (this._actionCollection) {
            this._actionCollection.actionExecuted(this);
        }
        this.raiseExecuteActionEvent();
        this.internalAfterExecute();
    };
    Action.prototype.prepareForExecution = function () {
        var referencedInputs = this.getReferencedInputs();
        var invalidInputs = this.internalValidateInputs(referencedInputs);
        if (invalidInputs.length > 0) {
            invalidInputs[0].focus();
            return false;
        }
        this.internalPrepareForExecution(referencedInputs);
        return true;
    };
    Action.prototype.remove = function () {
        if (this._actionCollection) {
            return this._actionCollection.removeAction(this);
        }
        return false;
    };
    Action.prototype.getAllInputs = function (processActions) {
        if (processActions === void 0) { processActions = true; }
        return [];
    };
    Action.prototype.getAllActions = function () {
        return [this];
    };
    Action.prototype.getResourceInformation = function () {
        return this.iconUrl ? [{ url: this.iconUrl, mimeType: "image" }] : [];
    };
    Action.prototype.getActionById = function (id) {
        return this.id === id ? this : undefined;
    };
    Action.prototype.getReferencedInputs = function () {
        return this.internalGetReferencedInputs();
    };
    /**
     * Validates the inputs associated with this action.
     *
     * @returns A list of inputs that failed validation, or an empty array if no input failed validation.
     */
    Action.prototype.validateInputs = function () {
        return this.internalValidateInputs(this.getReferencedInputs());
    };
    Action.prototype.updateEnabledState = function () {
        // Do nothing in base implementation
    };
    Action.prototype.isEffectivelyEnabled = function () {
        return this.isEnabled;
    };
    Object.defineProperty(Action.prototype, "isPrimary", {
        get: function () {
            return this.style === Enums.ActionStyle.Positive;
        },
        set: function (value) {
            if (value) {
                this.style = Enums.ActionStyle.Positive;
            }
            else {
                if (this.style === Enums.ActionStyle.Positive) {
                    this.style = Enums.ActionStyle.Default;
                }
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Action.prototype, "hostConfig", {
        get: function () {
            return this.parent ? this.parent.hostConfig : host_config_1.defaultHostConfig;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Action.prototype, "parent", {
        get: function () {
            return this._parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Action.prototype, "state", {
        get: function () {
            return this._state;
        },
        set: function (value) {
            if (this._state !== value) {
                this._state = value;
                this.updateCssClasses();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Action.prototype, "isFocusable", {
        get: function () {
            return this._isFocusable;
        },
        set: function (value) {
            if (this._isFocusable !== value) {
                this._isFocusable = value;
                this.updateCssClasses();
            }
        },
        enumerable: false,
        configurable: true
    });
    Action.titleProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "title");
    Action.iconUrlProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_1, "iconUrl");
    Action.styleProperty = new serialization_1.ValueSetProperty(serialization_1.Versions.v1_2, "style", [
        { value: Enums.ActionStyle.Default },
        { value: Enums.ActionStyle.Positive },
        { value: Enums.ActionStyle.Destructive }
    ], Enums.ActionStyle.Default);
    Action.modeProperty = new serialization_1.ValueSetProperty(serialization_1.Versions.v1_5, "mode", [{ value: Enums.ActionMode.Primary }, { value: Enums.ActionMode.Secondary }], Enums.ActionMode.Primary);
    Action.tooltipProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_5, "tooltip");
    Action.isEnabledProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_5, "isEnabled", true);
    __decorate([
        (0, serialization_1.property)(Action.titleProperty)
    ], Action.prototype, "title", void 0);
    __decorate([
        (0, serialization_1.property)(Action.iconUrlProperty)
    ], Action.prototype, "iconUrl", void 0);
    __decorate([
        (0, serialization_1.property)(Action.styleProperty)
    ], Action.prototype, "style", void 0);
    __decorate([
        (0, serialization_1.property)(Action.modeProperty)
    ], Action.prototype, "mode", void 0);
    __decorate([
        (0, serialization_1.property)(Action.tooltipProperty)
    ], Action.prototype, "tooltip", void 0);
    __decorate([
        (0, serialization_1.property)(Action.isEnabledProperty)
    ], Action.prototype, "isEnabled", void 0);
    return Action;
}(card_object_1.CardObject));
exports.Action = Action;
var SubmitActionBase = /** @class */ (function (_super) {
    __extends(SubmitActionBase, _super);
    function SubmitActionBase() {
        //#region Schema
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.disabledUnlessAssociatedInputsChange = false;
        //#endregion
        _this._isPrepared = false;
        _this._areReferencedInputsDirty = false;
        return _this;
    }
    SubmitActionBase.prototype.internalGetReferencedInputs = function () {
        var result = {};
        if (this.associatedInputs !== "none") {
            var current = this.parent;
            var inputs = [];
            while (current) {
                inputs.push.apply(inputs, current.getAllInputs(false));
                current = current.parent;
            }
            for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
                var input = inputs_1[_i];
                if (input.id) {
                    result[input.id] = input;
                }
            }
        }
        return result;
    };
    SubmitActionBase.prototype.internalPrepareForExecution = function (inputs) {
        if (this._originalData) {
            this._processedData = JSON.parse(JSON.stringify(this._originalData));
        }
        else {
            this._processedData = {};
        }
        if (this._processedData && inputs) {
            for (var _i = 0, _a = Object.keys(inputs); _i < _a.length; _i++) {
                var key = _a[_i];
                var input = inputs[key];
                if (input.id && input.isSet()) {
                    this._processedData[input.id] =
                        typeof input.value === "string" ? input.value : input.value.toString();
                }
            }
        }
        this._isPrepared = true;
    };
    SubmitActionBase.prototype.internalAfterExecute = function () {
        if (shared_1.GlobalSettings.resetInputsDirtyStateAfterActionExecution) {
            this.resetReferencedInputsDirtyState();
        }
    };
    SubmitActionBase.prototype.resetReferencedInputsDirtyState = function () {
        var referencedInputs = this.getReferencedInputs();
        this._areReferencedInputsDirty = false;
        if (referencedInputs) {
            for (var _i = 0, _a = Object.keys(referencedInputs); _i < _a.length; _i++) {
                var key = _a[_i];
                var input = referencedInputs[key];
                input.resetDirtyState();
            }
        }
    };
    SubmitActionBase.prototype.updateEnabledState = function () {
        this._areReferencedInputsDirty = false;
        var referencedInputs = this.getReferencedInputs();
        if (referencedInputs) {
            for (var _i = 0, _a = Object.keys(referencedInputs); _i < _a.length; _i++) {
                var key = _a[_i];
                var input = referencedInputs[key];
                if (input.isDirty()) {
                    this._areReferencedInputsDirty = true;
                    break;
                }
            }
        }
        this.updateCssClasses();
        if (this._renderedElement) {
            this.setupElementForAccessibility(this._renderedElement);
        }
    };
    SubmitActionBase.prototype.isEffectivelyEnabled = function () {
        var result = _super.prototype.isEffectivelyEnabled.call(this);
        return this.disabledUnlessAssociatedInputsChange
            ? result && this._areReferencedInputsDirty
            : result;
    };
    Object.defineProperty(SubmitActionBase.prototype, "data", {
        get: function () {
            return this._isPrepared ? this._processedData : this._originalData;
        },
        set: function (value) {
            this._originalData = value;
            this._isPrepared = false;
        },
        enumerable: false,
        configurable: true
    });
    SubmitActionBase.dataProperty = new serialization_1.PropertyDefinition(serialization_1.Versions.v1_0, "data");
    SubmitActionBase.associatedInputsProperty = new serialization_1.CustomProperty(serialization_1.Versions.v1_3, "associatedInputs", function (sender, prop, source, context) {
        var value = source[prop.name];
        if (value !== undefined && typeof value === "string") {
            return value.toLowerCase() === "none" ? "none" : "auto";
        }
        return undefined;
    }, function (sender, prop, target, value, context) {
        context.serializeValue(target, prop.name, value);
    });
    SubmitActionBase.disabledUnlessAssociatedInputsChangeProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_6, "disabledUnlessAssociatedInputsChange", false);
    __decorate([
        (0, serialization_1.property)(SubmitActionBase.dataProperty)
    ], SubmitActionBase.prototype, "_originalData", void 0);
    __decorate([
        (0, serialization_1.property)(SubmitActionBase.associatedInputsProperty)
    ], SubmitActionBase.prototype, "associatedInputs", void 0);
    __decorate([
        (0, serialization_1.property)(SubmitActionBase.disabledUnlessAssociatedInputsChangeProperty)
    ], SubmitActionBase.prototype, "disabledUnlessAssociatedInputsChange", void 0);
    return SubmitActionBase;
}(Action));
exports.SubmitActionBase = SubmitActionBase;
var SubmitAction = /** @class */ (function (_super) {
    __extends(SubmitAction, _super);
    function SubmitAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SubmitAction.prototype.getJsonTypeName = function () {
        return SubmitAction.JsonTypeName;
    };
    // Note the "weird" way this field is declared is to work around a breaking
    // change introduced in TS 3.1 wrt d.ts generation. DO NOT CHANGE
    SubmitAction.JsonTypeName = "Action.Submit";
    return SubmitAction;
}(SubmitActionBase));
exports.SubmitAction = SubmitAction;
var ExecuteAction = /** @class */ (function (_super) {
    __extends(ExecuteAction, _super);
    function ExecuteAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    //#endregion
    ExecuteAction.prototype.getJsonTypeName = function () {
        return ExecuteAction.JsonTypeName;
    };
    // Note the "weird" way this field is declared is to work around a breaking
    // change introduced in TS 3.1 wrt d.ts generation. DO NOT CHANGE
    ExecuteAction.JsonTypeName = "Action.Execute";
    //#region Schema
    ExecuteAction.verbProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_4, "verb");
    __decorate([
        (0, serialization_1.property)(ExecuteAction.verbProperty)
    ], ExecuteAction.prototype, "verb", void 0);
    return ExecuteAction;
}(SubmitActionBase));
exports.ExecuteAction = ExecuteAction;
var OpenUrlAction = /** @class */ (function (_super) {
    __extends(OpenUrlAction, _super);
    function OpenUrlAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OpenUrlAction.prototype.getJsonTypeName = function () {
        return OpenUrlAction.JsonTypeName;
    };
    OpenUrlAction.prototype.getAriaRole = function () {
        return "link";
    };
    OpenUrlAction.prototype.internalValidateProperties = function (context) {
        _super.prototype.internalValidateProperties.call(this, context);
        if (!this.url) {
            context.addFailure(this, Enums.ValidationEvent.PropertyCantBeNull, strings_1.Strings.errors.propertyMustBeSet("url"));
        }
    };
    OpenUrlAction.prototype.getHref = function () {
        return this.url;
    };
    //#region Schema
    OpenUrlAction.urlProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "url");
    //#endregion
    // Note the "weird" way this field is declared is to work around a breaking
    // change introduced in TS 3.1 wrt d.ts generation. DO NOT CHANGE
    OpenUrlAction.JsonTypeName = "Action.OpenUrl";
    __decorate([
        (0, serialization_1.property)(OpenUrlAction.urlProperty)
    ], OpenUrlAction.prototype, "url", void 0);
    return OpenUrlAction;
}(Action));
exports.OpenUrlAction = OpenUrlAction;
var ToggleVisibilityAction = /** @class */ (function (_super) {
    __extends(ToggleVisibilityAction, _super);
    function ToggleVisibilityAction() {
        //#region Schema
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.targetElements = {};
        return _this;
    }
    ToggleVisibilityAction.prototype.updateAriaControlsAttribute = function () {
        // apply aria labels to make it clear which elements this action will toggle
        if (this.targetElements) {
            var elementIds = Object.keys(this.targetElements);
            if (this._renderedElement) {
                if (elementIds.length > 0) {
                    this._renderedElement.setAttribute("aria-controls", elementIds.join(" "));
                }
                else {
                    this._renderedElement.removeAttribute("aria-controls");
                }
            }
        }
    };
    ToggleVisibilityAction.prototype.internalValidateProperties = function (context) {
        _super.prototype.internalValidateProperties.call(this, context);
        if (!this.targetElements) {
            context.addFailure(this, Enums.ValidationEvent.PropertyCantBeNull, strings_1.Strings.errors.propertyMustBeSet("targetElements"));
        }
    };
    ToggleVisibilityAction.prototype.getJsonTypeName = function () {
        return ToggleVisibilityAction.JsonTypeName;
    };
    ToggleVisibilityAction.prototype.render = function () {
        _super.prototype.render.call(this);
        this.updateAriaControlsAttribute();
    };
    ToggleVisibilityAction.prototype.execute = function () {
        _super.prototype.execute.call(this);
        if (this.parent) {
            for (var _i = 0, _a = Object.keys(this.targetElements); _i < _a.length; _i++) {
                var elementId = _a[_i];
                var targetElement = this.parent.getRootElement().getElementById(elementId);
                if (targetElement) {
                    if (typeof this.targetElements[elementId] === "boolean") {
                        targetElement.isVisible = this.targetElements[elementId];
                    }
                    else {
                        targetElement.isVisible = !targetElement.isVisible;
                    }
                }
            }
        }
    };
    ToggleVisibilityAction.prototype.addTargetElement = function (elementId, isVisible) {
        if (isVisible === void 0) { isVisible = undefined; }
        this.targetElements[elementId] = isVisible;
        this.updateAriaControlsAttribute();
    };
    ToggleVisibilityAction.prototype.removeTargetElement = function (elementId) {
        delete this.targetElements[elementId];
        this.updateAriaControlsAttribute();
    };
    ToggleVisibilityAction.targetElementsProperty = new serialization_1.CustomProperty(serialization_1.Versions.v1_2, "targetElements", function (sender, prop, source, context) {
        var result = {};
        if (Array.isArray(source[prop.name])) {
            for (var _i = 0, _a = source[prop.name]; _i < _a.length; _i++) {
                var item = _a[_i];
                if (typeof item === "string") {
                    result[item] = undefined;
                }
                else if (typeof item === "object") {
                    var elementId = item["elementId"];
                    if (typeof elementId === "string") {
                        result[elementId] = Utils.parseBool(item["isVisible"]);
                    }
                }
            }
        }
        return result;
    }, function (sender, prop, target, value, context) {
        var targetElements = [];
        for (var _i = 0, _a = Object.keys(value); _i < _a.length; _i++) {
            var id = _a[_i];
            if (typeof value[id] === "boolean") {
                targetElements.push({
                    elementId: id,
                    isVisible: value[id]
                });
            }
            else {
                targetElements.push(id);
            }
        }
        context.serializeArray(target, prop.name, targetElements);
    }, {}, function (sender) {
        return {};
    });
    //#endregion
    // Note the "weird" way this field is declared is to work around a breaking
    // change introduced in TS 3.1 wrt d.ts generation. DO NOT CHANGE
    ToggleVisibilityAction.JsonTypeName = "Action.ToggleVisibility";
    __decorate([
        (0, serialization_1.property)(ToggleVisibilityAction.targetElementsProperty)
    ], ToggleVisibilityAction.prototype, "targetElements", void 0);
    return ToggleVisibilityAction;
}(Action));
exports.ToggleVisibilityAction = ToggleVisibilityAction;
var StringWithSubstitutionProperty = /** @class */ (function (_super) {
    __extends(StringWithSubstitutionProperty, _super);
    function StringWithSubstitutionProperty(targetVersion, name) {
        var _this = _super.call(this, targetVersion, name, undefined, function () {
            return new shared_1.StringWithSubstitutions();
        }) || this;
        _this.targetVersion = targetVersion;
        _this.name = name;
        return _this;
    }
    StringWithSubstitutionProperty.prototype.parse = function (sender, source, context) {
        var result = new shared_1.StringWithSubstitutions();
        result.set(Utils.parseString(source[this.name]));
        return result;
    };
    StringWithSubstitutionProperty.prototype.toJSON = function (sender, target, value, context) {
        context.serializeValue(target, this.name, value.getOriginal());
    };
    return StringWithSubstitutionProperty;
}(serialization_1.PropertyDefinition));
var HttpHeader = /** @class */ (function (_super) {
    __extends(HttpHeader, _super);
    //#endregion
    function HttpHeader(name, value) {
        if (name === void 0) { name = ""; }
        if (value === void 0) { value = ""; }
        var _this = _super.call(this) || this;
        _this.name = name;
        _this.value = value;
        return _this;
    }
    HttpHeader.prototype.getSchemaKey = function () {
        return "HttpHeader";
    };
    HttpHeader.prototype.getReferencedInputs = function (inputs, referencedInputs) {
        this._value.getReferencedInputs(inputs, referencedInputs);
    };
    HttpHeader.prototype.prepareForExecution = function (inputs) {
        this._value.substituteInputValues(inputs, shared_1.ContentTypes.applicationXWwwFormUrlencoded);
    };
    Object.defineProperty(HttpHeader.prototype, "value", {
        get: function () {
            return this._value.get();
        },
        set: function (newValue) {
            this._value.set(newValue);
        },
        enumerable: false,
        configurable: true
    });
    //#region Schema
    HttpHeader.nameProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "name");
    HttpHeader.valueProperty = new StringWithSubstitutionProperty(serialization_1.Versions.v1_0, "value");
    __decorate([
        (0, serialization_1.property)(HttpHeader.nameProperty)
    ], HttpHeader.prototype, "name", void 0);
    __decorate([
        (0, serialization_1.property)(HttpHeader.valueProperty)
    ], HttpHeader.prototype, "_value", void 0);
    return HttpHeader;
}(serialization_1.SerializableObject));
exports.HttpHeader = HttpHeader;
var HttpAction = /** @class */ (function (_super) {
    __extends(HttpAction, _super);
    function HttpAction() {
        //#region Schema
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._ignoreInputValidation = false;
        return _this;
    }
    HttpAction.prototype.internalGetReferencedInputs = function () {
        var allInputs = this.parent ? this.parent.getRootElement().getAllInputs() : [];
        var result = {};
        this._url.getReferencedInputs(allInputs, result);
        for (var _i = 0, _a = this.headers; _i < _a.length; _i++) {
            var header = _a[_i];
            header.getReferencedInputs(allInputs, result);
        }
        this._body.getReferencedInputs(allInputs, result);
        return result;
    };
    HttpAction.prototype.internalPrepareForExecution = function (inputs) {
        if (inputs) {
            this._url.substituteInputValues(inputs, shared_1.ContentTypes.applicationXWwwFormUrlencoded);
            var contentType = shared_1.ContentTypes.applicationJson;
            for (var _i = 0, _a = this.headers; _i < _a.length; _i++) {
                var header = _a[_i];
                header.prepareForExecution(inputs);
                if (header.name && header.name.toLowerCase() === "content-type") {
                    contentType = header.value;
                }
            }
            this._body.substituteInputValues(inputs, contentType);
        }
    };
    HttpAction.prototype.getJsonTypeName = function () {
        return HttpAction.JsonTypeName;
    };
    HttpAction.prototype.internalValidateProperties = function (context) {
        _super.prototype.internalValidateProperties.call(this, context);
        if (!this.url) {
            context.addFailure(this, Enums.ValidationEvent.PropertyCantBeNull, strings_1.Strings.errors.propertyMustBeSet("url"));
        }
        if (this.headers.length > 0) {
            for (var _i = 0, _a = this.headers; _i < _a.length; _i++) {
                var header = _a[_i];
                if (!header.name) {
                    context.addFailure(this, Enums.ValidationEvent.PropertyCantBeNull, strings_1.Strings.errors.actionHttpHeadersMustHaveNameAndValue());
                }
            }
        }
    };
    Object.defineProperty(HttpAction.prototype, "ignoreInputValidation", {
        get: function () {
            return this._ignoreInputValidation;
        },
        set: function (value) {
            this._ignoreInputValidation = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HttpAction.prototype, "url", {
        get: function () {
            return this._url.get();
        },
        set: function (value) {
            this._url.set(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HttpAction.prototype, "body", {
        get: function () {
            return this._body.get();
        },
        set: function (value) {
            this._body.set(value);
        },
        enumerable: false,
        configurable: true
    });
    HttpAction.urlProperty = new StringWithSubstitutionProperty(serialization_1.Versions.v1_0, "url");
    HttpAction.bodyProperty = new StringWithSubstitutionProperty(serialization_1.Versions.v1_0, "body");
    HttpAction.methodProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "method");
    HttpAction.headersProperty = new serialization_1.SerializableObjectCollectionProperty(serialization_1.Versions.v1_0, "headers", HttpHeader);
    HttpAction.ignoreInputValidationProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_3, "ignoreInputValidation", false);
    //#endregion
    // Note the "weird" way this field is declared is to work around a breaking
    // change introduced in TS 3.1 wrt d.ts generation. DO NOT CHANGE
    HttpAction.JsonTypeName = "Action.Http";
    __decorate([
        (0, serialization_1.property)(HttpAction.urlProperty)
    ], HttpAction.prototype, "_url", void 0);
    __decorate([
        (0, serialization_1.property)(HttpAction.bodyProperty)
    ], HttpAction.prototype, "_body", void 0);
    __decorate([
        (0, serialization_1.property)(HttpAction.methodProperty)
    ], HttpAction.prototype, "method", void 0);
    __decorate([
        (0, serialization_1.property)(HttpAction.headersProperty)
    ], HttpAction.prototype, "headers", void 0);
    __decorate([
        (0, serialization_1.property)(HttpAction.ignoreInputValidationProperty)
    ], HttpAction.prototype, "_ignoreInputValidation", void 0);
    return HttpAction;
}(Action));
exports.HttpAction = HttpAction;
var ShowCardAction = /** @class */ (function (_super) {
    __extends(ShowCardAction, _super);
    function ShowCardAction() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.card = new InlineAdaptiveCard();
        return _this;
    }
    ShowCardAction.prototype.updateCssClasses = function () {
        _super.prototype.updateCssClasses.call(this);
        if (this.renderedElement) {
            var effectiveHostConfig = this.parent ? this.parent.hostConfig : host_config_1.defaultHostConfig;
            this.renderedElement.classList.add(effectiveHostConfig.makeCssClassName("expandable"));
            this.renderedElement.setAttribute("aria-expanded", (this.state === 1 /* Expanded */).toString());
        }
    };
    ShowCardAction.prototype.internalParse = function (source, context) {
        _super.prototype.internalParse.call(this, source, context);
        var jsonCard = source["card"];
        if (jsonCard) {
            this.card.parse(jsonCard, context);
        }
        else {
            context.logParseEvent(this, Enums.ValidationEvent.PropertyCantBeNull, strings_1.Strings.errors.showCardMustHaveCard());
        }
    };
    ShowCardAction.prototype.internalToJSON = function (target, context) {
        _super.prototype.internalToJSON.call(this, target, context);
        if (this.card) {
            context.serializeValue(target, "card", this.card.toJSON(context));
        }
    };
    ShowCardAction.prototype.raiseExecuteActionEvent = function () {
        if (this.hostConfig.actions.showCard.actionMode === Enums.ShowCardActionMode.Popup) {
            // Only raise the event in Popup mode.
            _super.prototype.raiseExecuteActionEvent.call(this);
        }
    };
    ShowCardAction.prototype.releaseDOMResources = function () {
        _super.prototype.releaseDOMResources.call(this);
        this.card.releaseDOMResources();
    };
    ShowCardAction.prototype.getJsonTypeName = function () {
        return ShowCardAction.JsonTypeName;
    };
    ShowCardAction.prototype.internalValidateProperties = function (context) {
        _super.prototype.internalValidateProperties.call(this, context);
        this.card.internalValidateProperties(context);
    };
    ShowCardAction.prototype.setParent = function (value) {
        _super.prototype.setParent.call(this, value);
        this.card.setParent(value);
    };
    ShowCardAction.prototype.getAllInputs = function (processActions) {
        if (processActions === void 0) { processActions = true; }
        return this.card.getAllInputs(processActions);
    };
    ShowCardAction.prototype.getAllActions = function () {
        var result = _super.prototype.getAllActions.call(this);
        result.push.apply(result, this.card.getAllActions());
        return result;
    };
    ShowCardAction.prototype.getResourceInformation = function () {
        var result = _super.prototype.getResourceInformation.call(this);
        result.push.apply(result, this.card.getResourceInformation());
        return result;
    };
    ShowCardAction.prototype.getActionById = function (id) {
        var result = _super.prototype.getActionById.call(this, id);
        if (!result) {
            result = this.card.getActionById(id);
        }
        return result;
    };
    // Note the "weird" way this field is declared is to work around a breaking
    // change introduced in TS 3.1 wrt d.ts generation. DO NOT CHANGE
    ShowCardAction.JsonTypeName = "Action.ShowCard";
    return ShowCardAction;
}(Action));
exports.ShowCardAction = ShowCardAction;
var OverflowAction = /** @class */ (function (_super) {
    __extends(OverflowAction, _super);
    function OverflowAction(actions) {
        var _this = _super.call(this) || this;
        _this._actions = actions;
        _this.title = strings_1.Strings.defaults.overflowButtonText();
        return _this;
    }
    OverflowAction.prototype.getActions = function () {
        return this._actions;
    };
    OverflowAction.prototype.getAllActions = function () {
        var result = _super.prototype.getAllActions.call(this);
        result.push.apply(result, this._actions);
        return result;
    };
    OverflowAction.prototype.getJsonTypeName = function () {
        return ShowCardAction.JsonTypeName;
    };
    OverflowAction.prototype.execute = function () {
        var _this = this;
        var _a;
        var shouldDisplayPopupMenu = !raiseDisplayOverflowActionMenuEvent(this, this.renderedElement);
        if (shouldDisplayPopupMenu && this.renderedElement) {
            var contextMenu_1 = new controls_1.PopupMenu();
            contextMenu_1.hostConfig = this.hostConfig;
            var _loop_2 = function (i) {
                var menuItem = new controls_1.MenuItem(i.toString(), (_a = this_1._actions[i].title) !== null && _a !== void 0 ? _a : "");
                menuItem.isEnabled = this_1._actions[i].isEnabled;
                menuItem.onClick = function () {
                    var actionToExecute = _this._actions[i];
                    contextMenu_1.closePopup(false);
                    if (actionToExecute.isEnabled) {
                        actionToExecute.execute();
                    }
                };
                contextMenu_1.items.add(menuItem);
            };
            var this_1 = this;
            for (var i = 0; i < this._actions.length; i++) {
                _loop_2(i);
            }
            contextMenu_1.popup(this.renderedElement);
        }
    };
    OverflowAction.JsonTypeName = "Action.Overflow";
    return OverflowAction;
}(Action));
var ActionCollection = /** @class */ (function () {
    function ActionCollection(owner) {
        this._items = [];
        this._renderedActions = [];
        this._owner = owner;
    }
    ActionCollection.prototype.isActionAllowed = function (action) {
        var forbiddenTypes = this._owner.getForbiddenActionTypes();
        if (forbiddenTypes) {
            for (var _i = 0, forbiddenTypes_1 = forbiddenTypes; _i < forbiddenTypes_1.length; _i++) {
                var forbiddenType = forbiddenTypes_1[_i];
                if (action.constructor === forbiddenType) {
                    return false;
                }
            }
        }
        return true;
    };
    ActionCollection.prototype.refreshContainer = function () {
        clearElement(this._actionCardContainer);
        if (!this._actionCard) {
            this._actionCardContainer.style.marginTop = "0px";
            return;
        }
        this._actionCardContainer.style.marginTop =
            this.renderedActionCount > 0
                ? this._owner.hostConfig.actions.showCard.inlineTopMargin + "px"
                : "0px";
        var padding = this._owner.getEffectivePadding();
        this._owner.getImmediateSurroundingPadding(padding);
        var physicalPadding = this._owner.hostConfig.paddingDefinitionToSpacingDefinition(padding);
        if (this._actionCard) {
            this._actionCard.style.paddingLeft = physicalPadding.left + "px";
            this._actionCard.style.paddingRight = physicalPadding.right + "px";
            this._actionCard.style.marginLeft = "-" + physicalPadding.left + "px";
            this._actionCard.style.marginRight = "-" + physicalPadding.right + "px";
            if (physicalPadding.bottom !== 0 && !this._owner.isDesignMode()) {
                this._actionCard.style.paddingBottom = physicalPadding.bottom + "px";
                this._actionCard.style.marginBottom = "-" + physicalPadding.bottom + "px";
            }
            Utils.appendChild(this._actionCardContainer, this._actionCard);
        }
    };
    ActionCollection.prototype.layoutChanged = function () {
        this._owner.getRootElement().updateLayout();
    };
    ActionCollection.prototype.showActionCard = function (action, suppressStyle, raiseEvent) {
        if (suppressStyle === void 0) { suppressStyle = false; }
        if (raiseEvent === void 0) { raiseEvent = true; }
        action.card.suppressStyle = suppressStyle;
        // Always re-render a ShowCard action in design mode; reuse already rendered ShowCard (if available) otherwise
        var renderedCard = action.card.renderedElement && !this._owner.isDesignMode()
            ? action.card.renderedElement
            : action.card.render();
        this._actionCard = renderedCard;
        this._expandedAction = action;
        this.refreshContainer();
        if (raiseEvent) {
            this.layoutChanged();
            raiseInlineCardExpandedEvent(action, true);
        }
    };
    ActionCollection.prototype.collapseExpandedAction = function () {
        for (var _i = 0, _a = this._renderedActions; _i < _a.length; _i++) {
            var action = _a[_i];
            action.state = 0 /* Normal */;
        }
        var previouslyExpandedAction = this._expandedAction;
        this._expandedAction = undefined;
        this._actionCard = undefined;
        this.refreshContainer();
        if (previouslyExpandedAction) {
            this.layoutChanged();
            raiseInlineCardExpandedEvent(previouslyExpandedAction, false);
        }
    };
    ActionCollection.prototype.expandShowCardAction = function (action, raiseEvent) {
        var _this = this;
        var afterSelectedAction = false;
        for (var _i = 0, _a = this._renderedActions; _i < _a.length; _i++) {
            var renderedAction = _a[_i];
            // Remove actions after selected action from tabOrder if the actions are oriented horizontally, to skip focus directly to expanded card
            if (this._owner.hostConfig.actions.actionsOrientation == Enums.Orientation.Horizontal &&
                afterSelectedAction) {
                renderedAction.isFocusable = false;
            }
            if (renderedAction !== action) {
                renderedAction.state = 2 /* Subdued */;
            }
            else {
                renderedAction.state = 1 /* Expanded */;
                afterSelectedAction = true;
                if (renderedAction.renderedElement) {
                    renderedAction.renderedElement.onblur = function (_e) {
                        for (var _i = 0, _a = _this._renderedActions; _i < _a.length; _i++) {
                            var ra = _a[_i];
                            ra.isFocusable = true;
                        }
                    };
                }
            }
        }
        this.showActionCard(action, !(this._owner.isAtTheVeryLeft() && this._owner.isAtTheVeryRight()), raiseEvent);
    };
    ActionCollection.prototype.releaseDOMResources = function () {
        for (var _i = 0, _a = this._renderedActions; _i < _a.length; _i++) {
            var action = _a[_i];
            action.releaseDOMResources();
        }
    };
    ActionCollection.prototype.actionExecuted = function (action) {
        if (!(action instanceof ShowCardAction)) {
            this.collapseExpandedAction();
        }
        else {
            if (action === this._expandedAction) {
                this.collapseExpandedAction();
            }
            else if (this._owner.hostConfig.actions.showCard.actionMode ===
                Enums.ShowCardActionMode.Inline) {
                this.expandShowCardAction(action, true);
            }
        }
    };
    ActionCollection.prototype.parse = function (source, context) {
        this.clear();
        if (Array.isArray(source)) {
            for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {
                var jsonAction = source_1[_i];
                var forbiddenActions = [];
                // If the action owner is a ContainerWithActions, we should check for forbidden actions
                if (this._owner instanceof ContainerWithActions) {
                    forbiddenActions = this._owner.getForbiddenActionNames();
                }
                var action = context.parseAction(this._owner, jsonAction, forbiddenActions, !this._owner.isDesignMode());
                if (action) {
                    this.addAction(action);
                }
            }
        }
    };
    ActionCollection.prototype.toJSON = function (target, propertyName, context) {
        context.serializeArray(target, propertyName, this._items);
    };
    ActionCollection.prototype.getActionAt = function (id) {
        return this._items[id];
    };
    ActionCollection.prototype.getActionCount = function () {
        return this._items.length;
    };
    ActionCollection.prototype.getActionById = function (id) {
        var result = undefined;
        for (var _i = 0, _a = this._items; _i < _a.length; _i++) {
            var item = _a[_i];
            result = item.getActionById(id);
            if (result) {
                break;
            }
        }
        return result;
    };
    ActionCollection.prototype.validateProperties = function (context) {
        if (this._owner.hostConfig.actions.maxActions &&
            this._items.length > this._owner.hostConfig.actions.maxActions) {
            context.addFailure(this._owner, Enums.ValidationEvent.TooManyActions, strings_1.Strings.errors.tooManyActions(this._owner.hostConfig.actions.maxActions));
        }
        if (this._items.length > 0 && !this._owner.hostConfig.supportsInteractivity) {
            context.addFailure(this._owner, Enums.ValidationEvent.InteractivityNotAllowed, strings_1.Strings.errors.interactivityNotAllowed());
        }
        for (var _i = 0, _a = this._items; _i < _a.length; _i++) {
            var item = _a[_i];
            if (!this.isActionAllowed(item)) {
                context.addFailure(this._owner, Enums.ValidationEvent.ActionTypeNotAllowed, strings_1.Strings.errors.actionTypeNotAllowed(item.getJsonTypeName()));
            }
            item.internalValidateProperties(context);
        }
    };
    ActionCollection.prototype.render = function (orientation) {
        // Cache hostConfig for better perf
        var hostConfig = this._owner.hostConfig;
        if (!hostConfig.supportsInteractivity) {
            return undefined;
        }
        var element = document.createElement("div");
        var maxActions = hostConfig.actions.maxActions
            ? Math.min(hostConfig.actions.maxActions, this._items.length)
            : this._items.length;
        this._actionCardContainer = document.createElement("div");
        this._renderedActions = [];
        if (hostConfig.actions.preExpandSingleShowCardAction &&
            maxActions === 1 &&
            this._items[0] instanceof ShowCardAction &&
            this.isActionAllowed(this._items[0])) {
            this.showActionCard(this._items[0], true);
            this._renderedActions.push(this._items[0]);
        }
        else {
            var buttonStrip = document.createElement("div");
            buttonStrip.className = hostConfig.makeCssClassName("ac-actionSet");
            buttonStrip.style.display = "flex";
            if (orientation === Enums.Orientation.Horizontal) {
                buttonStrip.style.flexDirection = "row";
                if (this._owner.horizontalAlignment &&
                    hostConfig.actions.actionAlignment !== Enums.ActionAlignment.Stretch) {
                    switch (this._owner.horizontalAlignment) {
                        case Enums.HorizontalAlignment.Center:
                            buttonStrip.style.justifyContent = "center";
                            break;
                        case Enums.HorizontalAlignment.Right:
                            buttonStrip.style.justifyContent = "flex-end";
                            break;
                        default:
                            buttonStrip.style.justifyContent = "flex-start";
                            break;
                    }
                }
                else {
                    switch (hostConfig.actions.actionAlignment) {
                        case Enums.ActionAlignment.Center:
                            buttonStrip.style.justifyContent = "center";
                            break;
                        case Enums.ActionAlignment.Right:
                            buttonStrip.style.justifyContent = "flex-end";
                            break;
                        default:
                            buttonStrip.style.justifyContent = "flex-start";
                            break;
                    }
                }
            }
            else {
                buttonStrip.style.flexDirection = "column";
                if (this._owner.horizontalAlignment &&
                    hostConfig.actions.actionAlignment !== Enums.ActionAlignment.Stretch) {
                    switch (this._owner.horizontalAlignment) {
                        case Enums.HorizontalAlignment.Center:
                            buttonStrip.style.alignItems = "center";
                            break;
                        case Enums.HorizontalAlignment.Right:
                            buttonStrip.style.alignItems = "flex-end";
                            break;
                        default:
                            buttonStrip.style.alignItems = "flex-start";
                            break;
                    }
                }
                else {
                    switch (hostConfig.actions.actionAlignment) {
                        case Enums.ActionAlignment.Center:
                            buttonStrip.style.alignItems = "center";
                            break;
                        case Enums.ActionAlignment.Right:
                            buttonStrip.style.alignItems = "flex-end";
                            break;
                        case Enums.ActionAlignment.Stretch:
                            buttonStrip.style.alignItems = "stretch";
                            break;
                        default:
                            buttonStrip.style.alignItems = "flex-start";
                            break;
                    }
                }
            }
            var allowedActions = this._items.filter(this.isActionAllowed.bind(this));
            var primaryActions_1 = [];
            var secondaryActions_1 = [];
            if (!this._owner.isDesignMode()) {
                allowedActions.forEach(function (action) {
                    return action.mode === Enums.ActionMode.Secondary
                        ? secondaryActions_1.push(action)
                        : primaryActions_1.push(action);
                });
                // If primaryActions.length > maxActions, extra actions are moved to overflow
                var overflowPrimaryActions = primaryActions_1.splice(hostConfig.actions.maxActions);
                if (shared_1.GlobalSettings.allowMoreThanMaxActionsInOverflowMenu) {
                    secondaryActions_1.push.apply(secondaryActions_1, overflowPrimaryActions);
                }
                var shouldRenderOverflowActionButton = true;
                if (secondaryActions_1.length > 0) {
                    if (!this._overflowAction) {
                        this._overflowAction = new OverflowAction(secondaryActions_1);
                        this._overflowAction.setParent(this._owner);
                        this._overflowAction["_actionCollection"] = this;
                    }
                    var isRootAction = this._owner instanceof AdaptiveCard && !this._owner.parent;
                    shouldRenderOverflowActionButton = !raiseRenderOverflowActionsEvent(this._overflowAction, isRootAction);
                }
                if (this._overflowAction && shouldRenderOverflowActionButton) {
                    primaryActions_1.push(this._overflowAction);
                }
            }
            else {
                primaryActions_1 = allowedActions;
            }
            for (var i = 0; i < primaryActions_1.length; i++) {
                var action = primaryActions_1[i];
                action.render();
                if (action.renderedElement) {
                    if (hostConfig.actions.actionsOrientation === Enums.Orientation.Horizontal &&
                        hostConfig.actions.actionAlignment === Enums.ActionAlignment.Stretch) {
                        action.renderedElement.style.flex = "0 1 100%";
                    }
                    else {
                        action.renderedElement.style.flex = "0 1 auto";
                    }
                    buttonStrip.appendChild(action.renderedElement);
                    this._renderedActions.push(action);
                    if (i < primaryActions_1.length - 1 && hostConfig.actions.buttonSpacing > 0) {
                        var spacer = document.createElement("div");
                        if (orientation === Enums.Orientation.Horizontal) {
                            spacer.style.flex = "0 0 auto";
                            spacer.style.width = hostConfig.actions.buttonSpacing + "px";
                        }
                        else {
                            spacer.style.height = hostConfig.actions.buttonSpacing + "px";
                        }
                        Utils.appendChild(buttonStrip, spacer);
                    }
                }
            }
            var buttonStripContainer = document.createElement("div");
            buttonStripContainer.style.overflow = "hidden";
            buttonStripContainer.appendChild(buttonStrip);
            Utils.appendChild(element, buttonStripContainer);
        }
        Utils.appendChild(element, this._actionCardContainer);
        for (var _i = 0, _a = this._renderedActions; _i < _a.length; _i++) {
            var renderedAction = _a[_i];
            if (renderedAction.state === 1 /* Expanded */) {
                this.expandShowCardAction(renderedAction, false);
                break;
            }
        }
        return this._renderedActions.length > 0 ? element : undefined;
    };
    ActionCollection.prototype.addAction = function (action) {
        if (!action) {
            throw new Error("The action parameter cannot be null.");
        }
        if ((!action.parent || action.parent === this._owner) && this._items.indexOf(action) < 0) {
            this._items.push(action);
            if (!action.parent) {
                action.setParent(this._owner);
            }
            action["_actionCollection"] = this;
        }
        else {
            throw new Error(strings_1.Strings.errors.actionAlreadyParented());
        }
    };
    ActionCollection.prototype.removeAction = function (action) {
        if (this.expandedAction && this._expandedAction === action) {
            this.collapseExpandedAction();
        }
        var actionIndex = this._items.indexOf(action);
        if (actionIndex >= 0) {
            this._items.splice(actionIndex, 1);
            action.setParent(undefined);
            action["_actionCollection"] = undefined;
            for (var i = 0; i < this._renderedActions.length; i++) {
                if (this._renderedActions[i] === action) {
                    this._renderedActions.splice(i, 1);
                    break;
                }
            }
            return true;
        }
        return false;
    };
    ActionCollection.prototype.clear = function () {
        this._items = [];
        this._renderedActions = [];
        this._expandedAction = undefined;
    };
    ActionCollection.prototype.getAllInputs = function (processActions) {
        if (processActions === void 0) { processActions = true; }
        var result = [];
        if (processActions) {
            for (var _i = 0, _a = this._items; _i < _a.length; _i++) {
                var action = _a[_i];
                result.push.apply(result, action.getAllInputs());
            }
        }
        return result;
    };
    ActionCollection.prototype.getResourceInformation = function () {
        var result = [];
        for (var _i = 0, _a = this._items; _i < _a.length; _i++) {
            var action = _a[_i];
            result.push.apply(result, action.getResourceInformation());
        }
        return result;
    };
    Object.defineProperty(ActionCollection.prototype, "renderedActionCount", {
        get: function () {
            return this._renderedActions.length;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ActionCollection.prototype, "expandedAction", {
        get: function () {
            return this._expandedAction;
        },
        enumerable: false,
        configurable: true
    });
    return ActionCollection;
}());
var ActionSet = /** @class */ (function (_super) {
    __extends(ActionSet, _super);
    function ActionSet() {
        var _this = _super.call(this) || this;
        _this._actionCollection = new ActionCollection(_this);
        return _this;
    }
    ActionSet.prototype.internalParse = function (source, context) {
        _super.prototype.internalParse.call(this, source, context);
        this._actionCollection.parse(source["actions"], context);
    };
    ActionSet.prototype.internalToJSON = function (target, context) {
        _super.prototype.internalToJSON.call(this, target, context);
        this._actionCollection.toJSON(target, "actions", context);
    };
    ActionSet.prototype.internalRender = function () {
        return this._actionCollection.render(this.orientation !== undefined
            ? this.orientation
            : this.hostConfig.actions.actionsOrientation);
    };
    ActionSet.prototype.releaseDOMResources = function () {
        _super.prototype.releaseDOMResources.call(this);
        this._actionCollection.releaseDOMResources();
    };
    ActionSet.prototype.isBleedingAtBottom = function () {
        if (this._actionCollection.renderedActionCount === 0) {
            return _super.prototype.isBleedingAtBottom.call(this);
        }
        else {
            if (this._actionCollection.getActionCount() === 1) {
                return (this._actionCollection.expandedAction !== undefined &&
                    !this.hostConfig.actions.preExpandSingleShowCardAction);
            }
            else {
                return this._actionCollection.expandedAction !== undefined;
            }
        }
    };
    ActionSet.prototype.getJsonTypeName = function () {
        return "ActionSet";
    };
    ActionSet.prototype.getActionCount = function () {
        return this._actionCollection.getActionCount();
    };
    ActionSet.prototype.getActionAt = function (index) {
        if (index >= 0 && index < this.getActionCount()) {
            return this._actionCollection.getActionAt(index);
        }
        else {
            return _super.prototype.getActionAt.call(this, index);
        }
    };
    ActionSet.prototype.getActionById = function (id) {
        var result = this._actionCollection.getActionById(id);
        return result ? result : _super.prototype.getActionById.call(this, id);
    };
    ActionSet.prototype.getAllActions = function () {
        var result = _super.prototype.getAllActions.call(this);
        for (var i = 0; i < this.getActionCount(); i++) {
            var action = this.getActionAt(i);
            if (action) {
                result.push(action);
            }
        }
        return result;
    };
    ActionSet.prototype.internalValidateProperties = function (context) {
        _super.prototype.internalValidateProperties.call(this, context);
        this._actionCollection.validateProperties(context);
    };
    ActionSet.prototype.addAction = function (action) {
        this._actionCollection.addAction(action);
    };
    ActionSet.prototype.getAllInputs = function (processActions) {
        if (processActions === void 0) { processActions = true; }
        return processActions ? this._actionCollection.getAllInputs() : [];
    };
    ActionSet.prototype.getResourceInformation = function () {
        return this._actionCollection.getResourceInformation();
    };
    /**
     * @inheritdoc
     */
    ActionSet.prototype.findDOMNodeOwner = function (node) {
        var target = undefined;
        for (var i = 0; i < this.getActionCount(); i++) {
            var action = this.getActionAt(i);
            if (action) {
                // recur through each Action
                target = action.findDOMNodeOwner(node);
                if (target) {
                    return target;
                }
            }
        }
        // if not found in any Action, defer to parent implementation
        return _super.prototype.findDOMNodeOwner.call(this, node);
    };
    Object.defineProperty(ActionSet.prototype, "isInteractive", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    //#region Schema
    ActionSet.orientationProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_1, "orientation", Enums.Orientation);
    __decorate([
        (0, serialization_1.property)(ActionSet.orientationProperty)
    ], ActionSet.prototype, "orientation", void 0);
    return ActionSet;
}(CardElement));
exports.ActionSet = ActionSet;
var ContainerStyleProperty = /** @class */ (function (_super) {
    __extends(ContainerStyleProperty, _super);
    function ContainerStyleProperty(targetVersion, name, defaultValue, onGetInitialValue) {
        var _this = _super.call(this, targetVersion, name, [
            { value: Enums.ContainerStyle.Default },
            { value: Enums.ContainerStyle.Emphasis },
            { targetVersion: serialization_1.Versions.v1_2, value: Enums.ContainerStyle.Accent },
            { targetVersion: serialization_1.Versions.v1_2, value: Enums.ContainerStyle.Good },
            { targetVersion: serialization_1.Versions.v1_2, value: Enums.ContainerStyle.Attention },
            { targetVersion: serialization_1.Versions.v1_2, value: Enums.ContainerStyle.Warning }
        ], defaultValue, onGetInitialValue) || this;
        _this.targetVersion = targetVersion;
        _this.name = name;
        _this.defaultValue = defaultValue;
        _this.onGetInitialValue = onGetInitialValue;
        return _this;
    }
    return ContainerStyleProperty;
}(serialization_1.ValueSetProperty));
exports.ContainerStyleProperty = ContainerStyleProperty;
var StylableCardElementContainer = /** @class */ (function (_super) {
    __extends(StylableCardElementContainer, _super);
    function StylableCardElementContainer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(StylableCardElementContainer.prototype, "style", {
        get: function () {
            if (this.allowCustomStyle) {
                var style = this.getValue(StylableCardElementContainer.styleProperty);
                if (style && this.hostConfig.containerStyles.getStyleByName(style)) {
                    return style;
                }
            }
            return undefined;
        },
        set: function (value) {
            this.setValue(StylableCardElementContainer.styleProperty, value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StylableCardElementContainer.prototype, "allowCustomStyle", {
        //#endregion
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StylableCardElementContainer.prototype, "hasExplicitStyle", {
        get: function () {
            return this.getValue(StylableCardElementContainer.styleProperty) !== undefined;
        },
        enumerable: false,
        configurable: true
    });
    StylableCardElementContainer.prototype.applyBorder = function () {
        // No border in base implementation
    };
    StylableCardElementContainer.prototype.applyBackground = function () {
        if (this.renderedElement) {
            var styleDefinition = this.hostConfig.containerStyles.getStyleByName(this.style, this.hostConfig.containerStyles.getStyleByName(this.defaultStyle));
            if (styleDefinition.backgroundColor) {
                var bgColor = Utils.stringToCssColor(styleDefinition.backgroundColor);
                if (bgColor) {
                    this.renderedElement.style.backgroundColor = bgColor;
                }
            }
        }
    };
    StylableCardElementContainer.prototype.applyPadding = function () {
        _super.prototype.applyPadding.call(this);
        if (!this.renderedElement) {
            return;
        }
        var physicalPadding = new shared_1.SpacingDefinition();
        if (this.getEffectivePadding()) {
            physicalPadding = this.hostConfig.paddingDefinitionToSpacingDefinition(this.getEffectivePadding());
        }
        this.renderedElement.style.paddingTop = physicalPadding.top + "px";
        this.renderedElement.style.paddingRight = physicalPadding.right + "px";
        this.renderedElement.style.paddingBottom = physicalPadding.bottom + "px";
        this.renderedElement.style.paddingLeft = physicalPadding.left + "px";
        if (this.isBleeding()) {
            // Bleed into the first parent that does have padding
            var padding = new shared_1.PaddingDefinition();
            this.getImmediateSurroundingPadding(padding);
            var surroundingPadding = this.hostConfig.paddingDefinitionToSpacingDefinition(padding);
            this.renderedElement.style.marginRight = "-" + surroundingPadding.right + "px";
            this.renderedElement.style.marginLeft = "-" + surroundingPadding.left + "px";
            if (!this.isDesignMode()) {
                this.renderedElement.style.marginTop = "-" + surroundingPadding.top + "px";
                this.renderedElement.style.marginBottom = "-" + surroundingPadding.bottom + "px";
            }
            if (this.separatorElement &&
                this.separatorOrientation === Enums.Orientation.Horizontal) {
                this.separatorElement.style.marginLeft = "-" + surroundingPadding.left + "px";
                this.separatorElement.style.marginRight = "-" + surroundingPadding.right + "px";
            }
        }
        else {
            this.renderedElement.style.marginRight = "0";
            this.renderedElement.style.marginLeft = "0";
            this.renderedElement.style.marginTop = "0";
            this.renderedElement.style.marginBottom = "0";
            if (this.separatorElement &&
                this.separatorOrientation === Enums.Orientation.Horizontal) {
                this.separatorElement.style.marginRight = "0";
                this.separatorElement.style.marginLeft = "0";
            }
        }
    };
    StylableCardElementContainer.prototype.getHasBackground = function (ignoreBackgroundImages) {
        if (ignoreBackgroundImages === void 0) { ignoreBackgroundImages = false; }
        var currentElement = this.parent;
        while (currentElement) {
            var currentElementHasBackgroundImage = false;
            if (ignoreBackgroundImages) {
                currentElementHasBackgroundImage = false;
            }
            else {
                currentElementHasBackgroundImage =
                    currentElement instanceof Container
                        ? currentElement.backgroundImage.isValid()
                        : false;
            }
            if (currentElement instanceof StylableCardElementContainer) {
                if (this.hasExplicitStyle &&
                    (currentElement.getEffectiveStyle() !== this.getEffectiveStyle() ||
                        currentElementHasBackgroundImage)) {
                    return true;
                }
            }
            currentElement = currentElement.parent;
        }
        return false;
    };
    StylableCardElementContainer.prototype.getDefaultPadding = function () {
        return this.getHasBackground() || this.getHasBorder()
            ? new shared_1.PaddingDefinition(Enums.Spacing.Padding, Enums.Spacing.Padding, Enums.Spacing.Padding, Enums.Spacing.Padding)
            : _super.prototype.getDefaultPadding.call(this);
    };
    StylableCardElementContainer.prototype.internalValidateProperties = function (context) {
        _super.prototype.internalValidateProperties.call(this, context);
        var explicitStyle = this.getValue(StylableCardElementContainer.styleProperty);
        if (explicitStyle !== undefined) {
            var styleDefinition = this.hostConfig.containerStyles.getStyleByName(explicitStyle);
            if (!styleDefinition) {
                context.addFailure(this, Enums.ValidationEvent.InvalidPropertyValue, strings_1.Strings.errors.invalidPropertyValue(explicitStyle, "style"));
            }
        }
    };
    StylableCardElementContainer.prototype.render = function () {
        var renderedElement = _super.prototype.render.call(this);
        if (renderedElement && this.getHasBackground()) {
            this.applyBackground();
        }
        this.applyBorder();
        return renderedElement;
    };
    StylableCardElementContainer.prototype.getEffectiveStyle = function () {
        var effectiveStyle = this.style;
        return effectiveStyle ? effectiveStyle : _super.prototype.getEffectiveStyle.call(this);
    };
    //#region Schema
    StylableCardElementContainer.styleProperty = new ContainerStyleProperty(serialization_1.Versions.v1_0, "style");
    __decorate([
        (0, serialization_1.property)(StylableCardElementContainer.styleProperty)
    ], StylableCardElementContainer.prototype, "style", null);
    return StylableCardElementContainer;
}(CardElementContainer));
exports.StylableCardElementContainer = StylableCardElementContainer;
var ContainerBase = /** @class */ (function (_super) {
    __extends(ContainerBase, _super);
    function ContainerBase() {
        //#region Schema
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._bleed = false;
        return _this;
    }
    //#endregion
    ContainerBase.prototype.adjustRenderedElementSize = function (renderedElement) {
        _super.prototype.adjustRenderedElementSize.call(this, renderedElement);
        if (this.minPixelHeight) {
            renderedElement.style.minHeight = this.minPixelHeight + "px";
        }
    };
    ContainerBase.prototype.getHasExpandedAction = function () {
        return false;
    };
    ContainerBase.prototype.getBleed = function () {
        return this._bleed;
    };
    ContainerBase.prototype.setBleed = function (value) {
        this._bleed = value;
    };
    Object.defineProperty(ContainerBase.prototype, "renderedActionCount", {
        get: function () {
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    ContainerBase.prototype.isBleeding = function () {
        return (this.getHasBackground() || this.hostConfig.alwaysAllowBleed) && this.getBleed();
    };
    ContainerBase.bleedProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_2, "bleed", false);
    ContainerBase.minHeightProperty = new serialization_1.PixelSizeProperty(serialization_1.Versions.v1_2, "minHeight");
    __decorate([
        (0, serialization_1.property)(ContainerBase.bleedProperty)
    ], ContainerBase.prototype, "_bleed", void 0);
    __decorate([
        (0, serialization_1.property)(ContainerBase.minHeightProperty)
    ], ContainerBase.prototype, "minPixelHeight", void 0);
    return ContainerBase;
}(StylableCardElementContainer));
exports.ContainerBase = ContainerBase;
var BackgroundImage = /** @class */ (function (_super) {
    __extends(BackgroundImage, _super);
    function BackgroundImage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    //#endregion
    BackgroundImage.prototype.getSchemaKey = function () {
        return "BackgroundImage";
    };
    BackgroundImage.prototype.internalParse = function (source, context) {
        if (typeof source === "string") {
            this.resetDefaultValues();
            this.url = source;
        }
        else {
            return _super.prototype.internalParse.call(this, source, context);
        }
    };
    BackgroundImage.prototype.apply = function (element) {
        if (this.url && element.renderedElement) {
            element.renderedElement.style.backgroundImage =
                "url('" +
                    element.preProcessPropertyValue(BackgroundImage.urlProperty, this.url) +
                    "')";
            switch (this.fillMode) {
                case Enums.FillMode.Repeat:
                    element.renderedElement.style.backgroundRepeat = "repeat";
                    break;
                case Enums.FillMode.RepeatHorizontally:
                    element.renderedElement.style.backgroundRepeat = "repeat-x";
                    break;
                case Enums.FillMode.RepeatVertically:
                    element.renderedElement.style.backgroundRepeat = "repeat-y";
                    break;
                case Enums.FillMode.Cover:
                default:
                    element.renderedElement.style.backgroundRepeat = "no-repeat";
                    element.renderedElement.style.backgroundSize = "cover";
                    break;
            }
            switch (this.horizontalAlignment) {
                case Enums.HorizontalAlignment.Left:
                    break;
                case Enums.HorizontalAlignment.Center:
                    element.renderedElement.style.backgroundPositionX = "center";
                    break;
                case Enums.HorizontalAlignment.Right:
                    element.renderedElement.style.backgroundPositionX = "right";
                    break;
            }
            switch (this.verticalAlignment) {
                case Enums.VerticalAlignment.Top:
                    break;
                case Enums.VerticalAlignment.Center:
                    element.renderedElement.style.backgroundPositionY = "center";
                    break;
                case Enums.VerticalAlignment.Bottom:
                    element.renderedElement.style.backgroundPositionY = "bottom";
                    break;
            }
        }
    };
    BackgroundImage.prototype.isValid = function () {
        return this.url ? true : false;
    };
    //#region Schema
    BackgroundImage.urlProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "url");
    BackgroundImage.fillModeProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_2, "fillMode", Enums.FillMode, Enums.FillMode.Cover);
    BackgroundImage.horizontalAlignmentProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_2, "horizontalAlignment", Enums.HorizontalAlignment, Enums.HorizontalAlignment.Left);
    BackgroundImage.verticalAlignmentProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_2, "verticalAlignment", Enums.VerticalAlignment, Enums.VerticalAlignment.Top);
    __decorate([
        (0, serialization_1.property)(BackgroundImage.urlProperty)
    ], BackgroundImage.prototype, "url", void 0);
    __decorate([
        (0, serialization_1.property)(BackgroundImage.fillModeProperty)
    ], BackgroundImage.prototype, "fillMode", void 0);
    __decorate([
        (0, serialization_1.property)(BackgroundImage.horizontalAlignmentProperty)
    ], BackgroundImage.prototype, "horizontalAlignment", void 0);
    __decorate([
        (0, serialization_1.property)(BackgroundImage.verticalAlignmentProperty)
    ], BackgroundImage.prototype, "verticalAlignment", void 0);
    return BackgroundImage;
}(serialization_1.SerializableObject));
exports.BackgroundImage = BackgroundImage;
var Container = /** @class */ (function (_super) {
    __extends(Container, _super);
    function Container() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        //#endregion
        _this._items = [];
        _this._renderedItems = [];
        return _this;
    }
    Object.defineProperty(Container.prototype, "backgroundImage", {
        get: function () {
            return this.getValue(Container.backgroundImageProperty);
        },
        enumerable: false,
        configurable: true
    });
    Container.prototype.insertItemAt = function (item, index, forceInsert) {
        if (!item.parent || forceInsert) {
            if (item.isStandalone) {
                if (index < 0 || index >= this._items.length) {
                    this._items.push(item);
                }
                else {
                    this._items.splice(index, 0, item);
                }
                item.setParent(this);
            }
            else {
                throw new Error(strings_1.Strings.errors.elementTypeNotStandalone(item.getJsonTypeName()));
            }
        }
        else {
            throw new Error(strings_1.Strings.errors.elementAlreadyParented());
        }
    };
    Container.prototype.getItemsCollectionPropertyName = function () {
        return "items";
    };
    Container.prototype.applyBackground = function () {
        if (this.backgroundImage.isValid() && this.renderedElement) {
            this.backgroundImage.apply(this);
        }
        _super.prototype.applyBackground.call(this);
    };
    Container.prototype.applyRTL = function (element) {
        if (this.rtl !== undefined) {
            element.dir = this.rtl ? "rtl" : "ltr";
        }
    };
    Container.prototype.internalRender = function () {
        this._renderedItems = [];
        // Cache hostConfig to avoid walking the parent hierarchy several times
        var hostConfig = this.hostConfig;
        var element = document.createElement("div");
        this.applyRTL(element);
        element.classList.add(hostConfig.makeCssClassName("ac-container"));
        element.style.display = "flex";
        element.style.flexDirection = "column";
        if (shared_1.GlobalSettings.useAdvancedCardBottomTruncation) {
            // Forces the container to be at least as tall as its content.
            //
            // Fixes a quirk in Chrome where, for nested flex elements, the
            // inner element's height would never exceed the outer element's
            // height. This caused overflow truncation to break -- containers
            // would always be measured as not overflowing, since their heights
            // were constrained by their parents as opposed to truly reflecting
            // the height of their content.
            //
            // See the "Browser Rendering Notes" section of this answer:
            // https://stackoverflow.com/questions/36247140/why-doesnt-flex-item-shrink-past-content-size
            element.style.minHeight = "-webkit-min-content";
        }
        switch (this.getEffectiveVerticalContentAlignment()) {
            case Enums.VerticalAlignment.Center:
                element.style.justifyContent = "center";
                break;
            case Enums.VerticalAlignment.Bottom:
                element.style.justifyContent = "flex-end";
                break;
            default:
                element.style.justifyContent = "flex-start";
                break;
        }
        if (this._items.length > 0) {
            for (var _i = 0, _a = this._items; _i < _a.length; _i++) {
                var item = _a[_i];
                var renderedItem = this.isElementAllowed(item) ? item.render() : undefined;
                if (renderedItem) {
                    if (this._renderedItems.length > 0 && item.separatorElement) {
                        item.separatorElement.style.flex = "0 0 auto";
                        Utils.appendChild(element, item.separatorElement);
                    }
                    Utils.appendChild(element, renderedItem);
                    this._renderedItems.push(item);
                }
            }
        }
        else {
            if (this.isDesignMode()) {
                var placeholderElement = this.createPlaceholderElement();
                placeholderElement.style.width = "100%";
                placeholderElement.style.height = "100%";
                element.appendChild(placeholderElement);
            }
        }
        return element;
    };
    Container.prototype.truncateOverflow = function (maxHeight) {
        if (this.renderedElement) {
            // Add 1 to account for rounding differences between browsers
            var boundary_1 = this.renderedElement.offsetTop + maxHeight + 1;
            var handleElement_1 = function (cardElement) {
                var elt = cardElement.renderedElement;
                if (elt) {
                    switch (Utils.getFitStatus(elt, boundary_1)) {
                        case Enums.ContainerFitStatus.FullyInContainer:
                            var sizeChanged = cardElement["resetOverflow"]();
                            // If the element's size changed after resetting content,
                            // we have to check if it still fits fully in the card
                            if (sizeChanged) {
                                handleElement_1(cardElement);
                            }
                            break;
                        case Enums.ContainerFitStatus.Overflowing:
                            var containerMaxHeight = boundary_1 - elt.offsetTop;
                            cardElement["handleOverflow"](containerMaxHeight);
                            break;
                        case Enums.ContainerFitStatus.FullyOutOfContainer:
                            cardElement["handleOverflow"](0);
                            break;
                    }
                }
            };
            for (var _i = 0, _a = this._items; _i < _a.length; _i++) {
                var item = _a[_i];
                handleElement_1(item);
            }
            return true;
        }
        return false;
    };
    Container.prototype.undoOverflowTruncation = function () {
        for (var _i = 0, _a = this._items; _i < _a.length; _i++) {
            var item = _a[_i];
            item["resetOverflow"]();
        }
    };
    Container.prototype.getHasBackground = function (ignoreBackgroundImages) {
        if (ignoreBackgroundImages === void 0) { ignoreBackgroundImages = false; }
        var result = ignoreBackgroundImages ? false : this.backgroundImage.isValid();
        return result || _super.prototype.getHasBackground.call(this, ignoreBackgroundImages);
    };
    Container.prototype.canHostSingletons = function () {
        return false;
    };
    Container.prototype.internalParse = function (source, context) {
        _super.prototype.internalParse.call(this, source, context);
        this.clear();
        this.setShouldFallback(false);
        var jsonItems = source[this.getItemsCollectionPropertyName()];
        if (!Array.isArray(jsonItems) &&
            typeof jsonItems === "object" &&
            this.canHostSingletons()) {
            var typeName = Utils.parseString(jsonItems["type"]);
            if (typeName) {
                var registration = context.elementRegistry.findByName(typeName);
                if ((registration === null || registration === void 0 ? void 0 : registration.singletonBehavior) !== registry_1.ElementSingletonBehavior.NotAllowed) {
                    var element = context.parseElement(this, jsonItems, [], !this.isDesignMode(), true);
                    if (element) {
                        this.insertItemAt(element, -1, true);
                    }
                }
            }
        }
        else if (Array.isArray(jsonItems)) {
            for (var _i = 0, jsonItems_1 = jsonItems; _i < jsonItems_1.length; _i++) {
                var item = jsonItems_1[_i];
                var element = context.parseElement(this, item, this.forbiddenChildElements(), !this.isDesignMode());
                if (element) {
                    this.insertItemAt(element, -1, true);
                }
            }
        }
    };
    Container.prototype.internalToJSON = function (target, context) {
        _super.prototype.internalToJSON.call(this, target, context);
        var collectionPropertyName = this.getItemsCollectionPropertyName();
        if (this._items.length === 1 &&
            this._items[0].getElementSingletonBehavior() === registry_1.ElementSingletonBehavior.Only) {
            // If the element is only allowed in a singleton context, parse it to an object instead of an array
            context.serializeValue(target, collectionPropertyName, this._items[0].toJSON(context));
        }
        else {
            context.serializeArray(target, collectionPropertyName, this._items);
        }
    };
    Object.defineProperty(Container.prototype, "isSelectable", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    Container.prototype.getEffectivePadding = function () {
        if (shared_1.GlobalSettings.removePaddingFromContainersWithBackgroundImage &&
            !this.getHasBackground(true)) {
            return new shared_1.PaddingDefinition();
        }
        return _super.prototype.getEffectivePadding.call(this);
    };
    Container.prototype.getEffectiveVerticalContentAlignment = function () {
        if (this.verticalContentAlignment !== undefined) {
            return this.verticalContentAlignment;
        }
        var parentContainer = this.getParentContainer();
        return parentContainer
            ? parentContainer.getEffectiveVerticalContentAlignment()
            : Enums.VerticalAlignment.Top;
    };
    Container.prototype.getItemCount = function () {
        return this._items.length;
    };
    Container.prototype.getItemAt = function (index) {
        return this._items[index];
    };
    Container.prototype.getFirstVisibleRenderedItem = function () {
        if (this.renderedElement && this._renderedItems && this._renderedItems.length > 0) {
            for (var _i = 0, _a = this._renderedItems; _i < _a.length; _i++) {
                var item = _a[_i];
                if (item.isVisible) {
                    return item;
                }
            }
        }
        return undefined;
    };
    Container.prototype.getLastVisibleRenderedItem = function () {
        if (this.renderedElement && this._renderedItems && this._renderedItems.length > 0) {
            for (var i = this._renderedItems.length - 1; i >= 0; i--) {
                if (this._renderedItems[i].isVisible) {
                    return this._renderedItems[i];
                }
            }
        }
        return undefined;
    };
    Container.prototype.getJsonTypeName = function () {
        return "Container";
    };
    Container.prototype.isFirstElement = function (element) {
        var designMode = this.isDesignMode();
        for (var _i = 0, _a = this._items; _i < _a.length; _i++) {
            var item = _a[_i];
            if (item.isVisible || designMode) {
                return item === element;
            }
        }
        return false;
    };
    Container.prototype.isLastElement = function (element) {
        var designMode = this.isDesignMode();
        for (var i = this._items.length - 1; i >= 0; i--) {
            if (this._items[i].isVisible || designMode) {
                return this._items[i] === element;
            }
        }
        return false;
    };
    Container.prototype.isRtl = function () {
        if (this.rtl !== undefined) {
            return this.rtl;
        }
        else {
            var parentContainer = this.getParentContainer();
            return parentContainer ? parentContainer.isRtl() : false;
        }
    };
    Container.prototype.isBleedingAtTop = function () {
        var firstRenderedItem = this.getFirstVisibleRenderedItem();
        return (this.isBleeding() || (firstRenderedItem ? firstRenderedItem.isBleedingAtTop() : false));
    };
    Container.prototype.isBleedingAtBottom = function () {
        var lastRenderedItem = this.getLastVisibleRenderedItem();
        return (this.isBleeding() ||
            (lastRenderedItem
                ? lastRenderedItem.isBleedingAtBottom() &&
                    lastRenderedItem.getEffectiveStyle() === this.getEffectiveStyle()
                : false));
    };
    Container.prototype.indexOf = function (cardElement) {
        return this._items.indexOf(cardElement);
    };
    Container.prototype.addItem = function (item) {
        this.insertItemAt(item, -1, false);
    };
    Container.prototype.insertItemBefore = function (item, insertBefore) {
        this.insertItemAt(item, this._items.indexOf(insertBefore), false);
    };
    Container.prototype.insertItemAfter = function (item, insertAfter) {
        this.insertItemAt(item, this._items.indexOf(insertAfter) + 1, false);
    };
    Container.prototype.removeItem = function (item) {
        var itemIndex = this._items.indexOf(item);
        if (itemIndex >= 0) {
            this._items.splice(itemIndex, 1);
            item.setParent(undefined);
            this.updateLayout();
            return true;
        }
        return false;
    };
    Container.prototype.clear = function () {
        this._items = [];
        this._renderedItems = [];
    };
    Container.prototype.getResourceInformation = function () {
        var result = _super.prototype.getResourceInformation.call(this);
        if (this.backgroundImage.isValid()) {
            result.push({
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion -- validated by `isValid()`
                url: this.backgroundImage.url,
                mimeType: "image"
            });
        }
        return result;
    };
    Container.prototype.getActionById = function (id) {
        var result = _super.prototype.getActionById.call(this, id);
        if (!result) {
            if (this.selectAction) {
                result = this.selectAction.getActionById(id);
            }
            if (!result) {
                for (var _i = 0, _a = this._items; _i < _a.length; _i++) {
                    var item = _a[_i];
                    result = item.getActionById(id);
                    if (result) {
                        break;
                    }
                }
            }
        }
        return result;
    };
    Object.defineProperty(Container.prototype, "padding", {
        get: function () {
            return this.getPadding();
        },
        set: function (value) {
            this.setPadding(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "selectAction", {
        get: function () {
            return this._selectAction;
        },
        set: function (value) {
            this._selectAction = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "bleed", {
        get: function () {
            return this.getBleed();
        },
        set: function (value) {
            this.setBleed(value);
        },
        enumerable: false,
        configurable: true
    });
    //#region Schema
    Container.backgroundImageProperty = new serialization_1.SerializableObjectProperty(serialization_1.Versions.v1_0, "backgroundImage", BackgroundImage);
    Container.verticalContentAlignmentProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_1, "verticalContentAlignment", Enums.VerticalAlignment);
    Container.rtlProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_0, "rtl");
    __decorate([
        (0, serialization_1.property)(Container.backgroundImageProperty)
    ], Container.prototype, "backgroundImage", null);
    __decorate([
        (0, serialization_1.property)(Container.verticalContentAlignmentProperty)
    ], Container.prototype, "verticalContentAlignment", void 0);
    __decorate([
        (0, serialization_1.property)(Container.rtlProperty)
    ], Container.prototype, "rtl", void 0);
    return Container;
}(ContainerBase));
exports.Container = Container;
var Column = /** @class */ (function (_super) {
    __extends(Column, _super);
    function Column(width) {
        if (width === void 0) { width = "stretch"; }
        var _this = _super.call(this) || this;
        _this.width = "stretch";
        //#endregion
        _this._computedWeight = 0;
        _this.width = width;
        return _this;
    }
    Column.prototype.adjustRenderedElementSize = function (renderedElement) {
        var minDesignTimeColumnHeight = 20;
        if (this.isDesignMode()) {
            renderedElement.style.minWidth = "20px";
            renderedElement.style.minHeight =
                (!this.minPixelHeight
                    ? minDesignTimeColumnHeight
                    : Math.max(this.minPixelHeight, minDesignTimeColumnHeight)) + "px";
        }
        else {
            renderedElement.style.minWidth = "0";
            if (this.minPixelHeight) {
                renderedElement.style.minHeight = this.minPixelHeight + "px";
            }
        }
        if (this.width === "auto") {
            renderedElement.style.flex = "0 1 auto";
        }
        else if (this.width === "stretch") {
            renderedElement.style.flex = "1 1 50px";
        }
        else if (this.width instanceof shared_1.SizeAndUnit) {
            if (this.width.unit === Enums.SizeUnit.Pixel) {
                renderedElement.style.flex = "0 0 auto";
                renderedElement.style.width = this.width.physicalSize + "px";
            }
            else {
                renderedElement.style.flex =
                    "1 1 " +
                        (this._computedWeight > 0 ? this._computedWeight : this.width.physicalSize) +
                        "%";
            }
        }
    };
    Column.prototype.shouldSerialize = function (_context) {
        return true;
    };
    Object.defineProperty(Column.prototype, "separatorOrientation", {
        get: function () {
            return Enums.Orientation.Vertical;
        },
        enumerable: false,
        configurable: true
    });
    Column.prototype.getJsonTypeName = function () {
        return "Column";
    };
    Object.defineProperty(Column.prototype, "hasVisibleSeparator", {
        get: function () {
            if (this.parent && this.parent instanceof ColumnSet) {
                return this.separatorElement !== undefined && !this.parent.isLeftMostElement(this);
            }
            else {
                return false;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Column.prototype, "isStandalone", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    //#region Schema
    Column.widthProperty = new serialization_1.CustomProperty(serialization_1.Versions.v1_0, "width", function (sender, prop, source, context) {
        var result = prop.defaultValue;
        var value = source[prop.name];
        var invalidWidth = false;
        if (typeof value === "number" && !isNaN(value)) {
            result = new shared_1.SizeAndUnit(value, Enums.SizeUnit.Weight);
        }
        else if (value === "auto" || value === "stretch") {
            result = value;
        }
        else if (typeof value === "string") {
            try {
                result = shared_1.SizeAndUnit.parse(value);
                if (result.unit === Enums.SizeUnit.Pixel &&
                    prop.targetVersion.compareTo(context.targetVersion) > 0) {
                    invalidWidth = true;
                }
            }
            catch (e) {
                invalidWidth = true;
            }
        }
        else {
            invalidWidth = true;
        }
        if (invalidWidth) {
            context.logParseEvent(sender, Enums.ValidationEvent.InvalidPropertyValue, strings_1.Strings.errors.invalidColumnWidth(value));
            result = "auto";
        }
        return result;
    }, function (sender, property, target, value, context) {
        if (value instanceof shared_1.SizeAndUnit) {
            if (value.unit === Enums.SizeUnit.Pixel) {
                context.serializeValue(target, "width", value.physicalSize + "px");
            }
            else {
                context.serializeNumber(target, "width", value.physicalSize);
            }
        }
        else {
            context.serializeValue(target, "width", value);
        }
    }, "stretch");
    __decorate([
        (0, serialization_1.property)(Column.widthProperty)
    ], Column.prototype, "width", void 0);
    return Column;
}(Container));
exports.Column = Column;
var ColumnSet = /** @class */ (function (_super) {
    __extends(ColumnSet, _super);
    function ColumnSet() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._columns = [];
        return _this;
    }
    ColumnSet.prototype.createColumnInstance = function (source, context) {
        return context.parseCardObject(this, source, [], !this.isDesignMode(), function (typeName) {
            return !typeName || typeName === "Column" ? new Column() : undefined;
        }, function (typeName, _errorType) {
            context.logParseEvent(undefined, Enums.ValidationEvent.ElementTypeNotAllowed, strings_1.Strings.errors.elementTypeNotAllowed(typeName));
        });
    };
    ColumnSet.prototype.internalRender = function () {
        this._renderedColumns = [];
        if (this._columns.length > 0) {
            // Cache hostConfig to avoid walking the parent hierarchy several times
            var hostConfig = this.hostConfig;
            var element = document.createElement("div");
            element.className = hostConfig.makeCssClassName("ac-columnSet");
            element.style.display = "flex";
            if (shared_1.GlobalSettings.useAdvancedCardBottomTruncation) {
                // See comment in Container.internalRender()
                element.style.minHeight = "-webkit-min-content";
            }
            switch (this.getEffectiveHorizontalAlignment()) {
                case Enums.HorizontalAlignment.Center:
                    element.style.justifyContent = "center";
                    break;
                case Enums.HorizontalAlignment.Right:
                    element.style.justifyContent = "flex-end";
                    break;
                default:
                    element.style.justifyContent = "flex-start";
                    break;
            }
            var totalWeight = 0;
            for (var _i = 0, _a = this._columns; _i < _a.length; _i++) {
                var column = _a[_i];
                if (column.width instanceof shared_1.SizeAndUnit &&
                    column.width.unit === Enums.SizeUnit.Weight) {
                    totalWeight += column.width.physicalSize;
                }
            }
            for (var _b = 0, _c = this._columns; _b < _c.length; _b++) {
                var column = _c[_b];
                if (column.width instanceof shared_1.SizeAndUnit &&
                    column.width.unit === Enums.SizeUnit.Weight &&
                    totalWeight > 0) {
                    var computedWeight = (100 / totalWeight) * column.width.physicalSize;
                    // Best way to emulate "internal" access I know of
                    column["_computedWeight"] = computedWeight;
                }
                var renderedColumn = column.render();
                if (renderedColumn) {
                    if (this._renderedColumns.length > 0 && column.separatorElement) {
                        column.separatorElement.style.flex = "0 0 auto";
                        Utils.appendChild(element, column.separatorElement);
                    }
                    Utils.appendChild(element, renderedColumn);
                    this._renderedColumns.push(column);
                }
            }
            return this._renderedColumns.length > 0 ? element : undefined;
        }
        else {
            return undefined;
        }
    };
    ColumnSet.prototype.truncateOverflow = function (maxHeight) {
        for (var _i = 0, _a = this._columns; _i < _a.length; _i++) {
            var column = _a[_i];
            column["handleOverflow"](maxHeight);
        }
        return true;
    };
    ColumnSet.prototype.undoOverflowTruncation = function () {
        for (var _i = 0, _a = this._columns; _i < _a.length; _i++) {
            var column = _a[_i];
            column["resetOverflow"]();
        }
    };
    Object.defineProperty(ColumnSet.prototype, "isSelectable", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    ColumnSet.prototype.internalParse = function (source, context) {
        _super.prototype.internalParse.call(this, source, context);
        this._columns = [];
        this._renderedColumns = [];
        var jsonColumns = source["columns"];
        if (Array.isArray(jsonColumns)) {
            for (var _i = 0, jsonColumns_1 = jsonColumns; _i < jsonColumns_1.length; _i++) {
                var item = jsonColumns_1[_i];
                var column = this.createColumnInstance(item, context);
                if (column) {
                    this._columns.push(column);
                }
            }
        }
    };
    ColumnSet.prototype.internalToJSON = function (target, context) {
        _super.prototype.internalToJSON.call(this, target, context);
        context.serializeArray(target, "columns", this._columns);
    };
    ColumnSet.prototype.isFirstElement = function (element) {
        for (var _i = 0, _a = this._columns; _i < _a.length; _i++) {
            var column = _a[_i];
            if (column.isVisible) {
                return column === element;
            }
        }
        return false;
    };
    ColumnSet.prototype.isBleedingAtTop = function () {
        if (this.isBleeding()) {
            return true;
        }
        if (this._renderedColumns && this._renderedColumns.length > 0) {
            for (var _i = 0, _a = this._columns; _i < _a.length; _i++) {
                var column = _a[_i];
                if (column.isBleedingAtTop()) {
                    return true;
                }
            }
        }
        return false;
    };
    ColumnSet.prototype.isBleedingAtBottom = function () {
        if (this.isBleeding()) {
            return true;
        }
        if (this._renderedColumns && this._renderedColumns.length > 0) {
            for (var _i = 0, _a = this._columns; _i < _a.length; _i++) {
                var column = _a[_i];
                if (column.isBleedingAtBottom()) {
                    return true;
                }
            }
        }
        return false;
    };
    ColumnSet.prototype.getItemCount = function () {
        return this._columns.length;
    };
    ColumnSet.prototype.getFirstVisibleRenderedItem = function () {
        if (this.renderedElement && this._renderedColumns && this._renderedColumns.length > 0) {
            return this._renderedColumns[0];
        }
        else {
            return undefined;
        }
    };
    ColumnSet.prototype.getLastVisibleRenderedItem = function () {
        if (this.renderedElement && this._renderedColumns && this._renderedColumns.length > 0) {
            return this._renderedColumns[this._renderedColumns.length - 1];
        }
        else {
            return undefined;
        }
    };
    ColumnSet.prototype.getColumnAt = function (index) {
        return this._columns[index];
    };
    ColumnSet.prototype.getItemAt = function (index) {
        return this.getColumnAt(index);
    };
    ColumnSet.prototype.getJsonTypeName = function () {
        return "ColumnSet";
    };
    ColumnSet.prototype.internalValidateProperties = function (context) {
        _super.prototype.internalValidateProperties.call(this, context);
        var weightedColumns = 0;
        var stretchedColumns = 0;
        for (var _i = 0, _a = this._columns; _i < _a.length; _i++) {
            var column = _a[_i];
            if (typeof column.width === "number") {
                weightedColumns++;
            }
            else if (column.width === "stretch") {
                stretchedColumns++;
            }
        }
        if (weightedColumns > 0 && stretchedColumns > 0) {
            context.addFailure(this, Enums.ValidationEvent.Hint, strings_1.Strings.hints.dontUseWeightedAndStrecthedColumnsInSameSet());
        }
    };
    ColumnSet.prototype.addColumn = function (column) {
        if (!column.parent) {
            this._columns.push(column);
            column.setParent(this);
        }
        else {
            throw new Error(strings_1.Strings.errors.columnAlreadyBelongsToAnotherSet());
        }
    };
    ColumnSet.prototype.removeItem = function (item) {
        if (item instanceof Column) {
            var itemIndex = this._columns.indexOf(item);
            if (itemIndex >= 0) {
                this._columns.splice(itemIndex, 1);
                item.setParent(undefined);
                this.updateLayout();
                return true;
            }
        }
        return false;
    };
    ColumnSet.prototype.indexOf = function (cardElement) {
        return cardElement instanceof Column ? this._columns.indexOf(cardElement) : -1;
    };
    ColumnSet.prototype.isLeftMostElement = function (element) {
        return this._columns.indexOf(element) === 0;
    };
    ColumnSet.prototype.isRightMostElement = function (element) {
        return this._columns.indexOf(element) === this._columns.length - 1;
    };
    ColumnSet.prototype.isTopElement = function (element) {
        return this._columns.indexOf(element) >= 0;
    };
    ColumnSet.prototype.isBottomElement = function (element) {
        return this._columns.indexOf(element) >= 0;
    };
    ColumnSet.prototype.getActionById = function (id) {
        var result = undefined;
        for (var _i = 0, _a = this._columns; _i < _a.length; _i++) {
            var column = _a[_i];
            result = column.getActionById(id);
            if (result) {
                break;
            }
        }
        return result;
    };
    Object.defineProperty(ColumnSet.prototype, "bleed", {
        get: function () {
            return this.getBleed();
        },
        set: function (value) {
            this.setBleed(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColumnSet.prototype, "padding", {
        get: function () {
            return this.getPadding();
        },
        set: function (value) {
            this.setPadding(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColumnSet.prototype, "selectAction", {
        get: function () {
            return this._selectAction;
        },
        set: function (value) {
            this._selectAction = value;
        },
        enumerable: false,
        configurable: true
    });
    return ColumnSet;
}(ContainerBase));
exports.ColumnSet = ColumnSet;
function raiseImageLoadedEvent(image) {
    var card = image.getRootElement();
    var onImageLoadedHandler = card && card.onImageLoaded ? card.onImageLoaded : AdaptiveCard.onImageLoaded;
    if (onImageLoadedHandler) {
        onImageLoadedHandler(image);
    }
}
function raiseAnchorClickedEvent(element, anchor, ev) {
    var card = element.getRootElement();
    var onAnchorClickedHandler = card && card.onAnchorClicked ? card.onAnchorClicked : AdaptiveCard.onAnchorClicked;
    return onAnchorClickedHandler !== undefined
        ? onAnchorClickedHandler(element, anchor, ev)
        : false;
}
function raiseExecuteActionEvent(action) {
    var card = action.parent ? action.parent.getRootElement() : undefined;
    var onExecuteActionHandler = card && card.onExecuteAction ? card.onExecuteAction : AdaptiveCard.onExecuteAction;
    if (action.prepareForExecution() && onExecuteActionHandler) {
        onExecuteActionHandler(action);
    }
}
function raiseInlineCardExpandedEvent(action, isExpanded) {
    var card = action.parent ? action.parent.getRootElement() : undefined;
    var onInlineCardExpandedHandler = card && card.onInlineCardExpanded
        ? card.onInlineCardExpanded
        : AdaptiveCard.onInlineCardExpanded;
    if (onInlineCardExpandedHandler) {
        onInlineCardExpandedHandler(action, isExpanded);
    }
}
function raiseInputValueChangedEvent(input) {
    var card = input.getRootElement();
    var onInputValueChangedHandler = card && card.onInputValueChanged
        ? card.onInputValueChanged
        : AdaptiveCard.onInputValueChanged;
    if (onInputValueChangedHandler) {
        onInputValueChangedHandler(input);
    }
}
function raiseElementVisibilityChangedEvent(element, shouldUpdateLayout) {
    if (shouldUpdateLayout === void 0) { shouldUpdateLayout = true; }
    var rootElement = element.getRootElement();
    if (shouldUpdateLayout) {
        rootElement.updateLayout();
    }
    var card = rootElement;
    var onElementVisibilityChangedHandler = card && card.onElementVisibilityChanged
        ? card.onElementVisibilityChanged
        : AdaptiveCard.onElementVisibilityChanged;
    if (onElementVisibilityChangedHandler !== undefined) {
        onElementVisibilityChangedHandler(element);
    }
}
/**
 * @returns return false to continue with default context menu; return true to skip SDK default context menu
 */
function raiseDisplayOverflowActionMenuEvent(action, target) {
    var card = action.parent ? action.parent.getRootElement() : undefined;
    var onDisplayOverflowActionMenuHandler = card && card.onDisplayOverflowActionMenu
        ? card.onDisplayOverflowActionMenu
        : AdaptiveCard.onDisplayOverflowActionMenu;
    return onDisplayOverflowActionMenuHandler !== undefined
        ? onDisplayOverflowActionMenuHandler(action.getActions(), target)
        : false;
}
/**
 * @returns return false to continue with default action button; return true to skip SDK default action button
 */
function raiseRenderOverflowActionsEvent(action, isAtRootLevelActions) {
    var card = action.parent ? action.parent.getRootElement() : undefined;
    var onRenderOverflowActionsHandler = card && card.onRenderOverflowActions
        ? card.onRenderOverflowActions
        : AdaptiveCard.onRenderOverflowActions;
    return onRenderOverflowActionsHandler !== undefined
        ? onRenderOverflowActionsHandler(action.getActions(), isAtRootLevelActions)
        : false;
}
var ContainerWithActions = /** @class */ (function (_super) {
    __extends(ContainerWithActions, _super);
    function ContainerWithActions() {
        var _this = _super.call(this) || this;
        _this._actionCollection = new ActionCollection(_this);
        return _this;
    }
    ContainerWithActions.prototype.internalParse = function (source, context) {
        _super.prototype.internalParse.call(this, source, context);
        this.parseActions(source, context);
    };
    ContainerWithActions.prototype.parseActions = function (source, context) {
        this._actionCollection.parse(source["actions"], context);
    };
    ContainerWithActions.prototype.internalToJSON = function (target, context) {
        _super.prototype.internalToJSON.call(this, target, context);
        this._actionCollection.toJSON(target, "actions", context);
    };
    ContainerWithActions.prototype.internalRender = function () {
        var element = _super.prototype.internalRender.call(this);
        if (element) {
            var renderedActions = this._actionCollection.render(this.hostConfig.actions.actionsOrientation);
            if (renderedActions) {
                Utils.appendChild(element, renderSeparation(this.hostConfig, {
                    spacing: this.hostConfig.getEffectiveSpacing(this.hostConfig.actions.spacing)
                }, Enums.Orientation.Horizontal));
                Utils.appendChild(element, renderedActions);
            }
            if (this.renderIfEmpty) {
                return element;
            }
            else {
                return element.children.length > 0 ? element : undefined;
            }
        }
        else {
            return undefined;
        }
    };
    ContainerWithActions.prototype.getHasExpandedAction = function () {
        if (this.renderedActionCount === 0) {
            return false;
        }
        else if (this.renderedActionCount === 1) {
            return (this._actionCollection.expandedAction !== undefined &&
                !this.hostConfig.actions.preExpandSingleShowCardAction);
        }
        else {
            return this._actionCollection.expandedAction !== undefined;
        }
    };
    Object.defineProperty(ContainerWithActions.prototype, "renderedActionCount", {
        get: function () {
            return this._actionCollection.renderedActionCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ContainerWithActions.prototype, "renderIfEmpty", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    ContainerWithActions.prototype.releaseDOMResources = function () {
        _super.prototype.releaseDOMResources.call(this);
        this._actionCollection.releaseDOMResources();
    };
    ContainerWithActions.prototype.getActionCount = function () {
        return this._actionCollection.getActionCount();
    };
    ContainerWithActions.prototype.getActionAt = function (index) {
        if (index >= 0 && index < this.getActionCount()) {
            return this._actionCollection.getActionAt(index);
        }
        else {
            return _super.prototype.getActionAt.call(this, index);
        }
    };
    ContainerWithActions.prototype.getActionById = function (id) {
        var result = this._actionCollection.getActionById(id);
        return result ? result : _super.prototype.getActionById.call(this, id);
    };
    ContainerWithActions.prototype.internalValidateProperties = function (context) {
        _super.prototype.internalValidateProperties.call(this, context);
        if (this._actionCollection) {
            this._actionCollection.validateProperties(context);
        }
    };
    ContainerWithActions.prototype.isLastElement = function (element) {
        return _super.prototype.isLastElement.call(this, element) && this._actionCollection.getActionCount() === 0;
    };
    ContainerWithActions.prototype.addAction = function (action) {
        this._actionCollection.addAction(action);
    };
    ContainerWithActions.prototype.clear = function () {
        _super.prototype.clear.call(this);
        this._actionCollection.clear();
    };
    ContainerWithActions.prototype.getAllInputs = function (processActions) {
        if (processActions === void 0) { processActions = true; }
        var result = _super.prototype.getAllInputs.call(this, processActions);
        if (processActions) {
            result.push.apply(result, this._actionCollection.getAllInputs(processActions));
        }
        return result;
    };
    ContainerWithActions.prototype.getResourceInformation = function () {
        var result = _super.prototype.getResourceInformation.call(this);
        result.push.apply(result, this._actionCollection.getResourceInformation());
        return result;
    };
    ContainerWithActions.prototype.isBleedingAtBottom = function () {
        if (this._actionCollection.renderedActionCount === 0) {
            return _super.prototype.isBleedingAtBottom.call(this);
        }
        else {
            if (this._actionCollection.getActionCount() === 1) {
                return (this._actionCollection.expandedAction !== undefined &&
                    !this.hostConfig.actions.preExpandSingleShowCardAction);
            }
            else {
                return this._actionCollection.expandedAction !== undefined;
            }
        }
    };
    ContainerWithActions.prototype.getForbiddenActionNames = function () {
        return [];
    };
    Object.defineProperty(ContainerWithActions.prototype, "isStandalone", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    return ContainerWithActions;
}(Container));
exports.ContainerWithActions = ContainerWithActions;
var RefreshActionProperty = /** @class */ (function (_super) {
    __extends(RefreshActionProperty, _super);
    function RefreshActionProperty(targetVersion, name) {
        var _this = _super.call(this, targetVersion, name, undefined) || this;
        _this.targetVersion = targetVersion;
        _this.name = name;
        return _this;
    }
    RefreshActionProperty.prototype.parse = function (sender, source, context) {
        var action = context.parseAction(sender.parent, source[this.name], [], false);
        if (action !== undefined) {
            if (action instanceof ExecuteAction) {
                return action;
            }
            context.logParseEvent(sender, Enums.ValidationEvent.ActionTypeNotAllowed, strings_1.Strings.errors.actionTypeNotAllowed(action.getJsonTypeName()));
        }
        context.logParseEvent(sender, Enums.ValidationEvent.PropertyCantBeNull, strings_1.Strings.errors.propertyMustBeSet("action"));
        return undefined;
    };
    RefreshActionProperty.prototype.toJSON = function (sender, target, value, context) {
        context.serializeValue(target, this.name, value ? value.toJSON(context) : undefined, undefined, true);
    };
    return RefreshActionProperty;
}(serialization_1.PropertyDefinition));
exports.RefreshActionProperty = RefreshActionProperty;
var RefreshDefinition = /** @class */ (function (_super) {
    __extends(RefreshDefinition, _super);
    function RefreshDefinition() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(RefreshDefinition.prototype, "action", {
        get: function () {
            return this.getValue(RefreshDefinition.actionProperty);
        },
        set: function (value) {
            this.setValue(RefreshDefinition.actionProperty, value);
            if (value) {
                value.setParent(this.parent);
            }
        },
        enumerable: false,
        configurable: true
    });
    RefreshDefinition.prototype.getSchemaKey = function () {
        return "RefreshDefinition";
    };
    //#region Schema
    RefreshDefinition.actionProperty = new RefreshActionProperty(serialization_1.Versions.v1_4, "action");
    RefreshDefinition.userIdsProperty = new serialization_1.StringArrayProperty(serialization_1.Versions.v1_4, "userIds");
    __decorate([
        (0, serialization_1.property)(RefreshDefinition.actionProperty)
    ], RefreshDefinition.prototype, "action", null);
    __decorate([
        (0, serialization_1.property)(RefreshDefinition.userIdsProperty)
    ], RefreshDefinition.prototype, "userIds", void 0);
    return RefreshDefinition;
}(serialization_1.SerializableObject));
exports.RefreshDefinition = RefreshDefinition;
var AuthCardButton = /** @class */ (function (_super) {
    __extends(AuthCardButton, _super);
    function AuthCardButton() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AuthCardButton.prototype.getSchemaKey = function () {
        return "AuthCardButton";
    };
    //#region Schema
    AuthCardButton.typeProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_4, "type");
    AuthCardButton.titleProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_4, "title");
    AuthCardButton.imageProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_4, "image");
    AuthCardButton.valueProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_4, "value");
    __decorate([
        (0, serialization_1.property)(AuthCardButton.typeProperty)
    ], AuthCardButton.prototype, "type", void 0);
    __decorate([
        (0, serialization_1.property)(AuthCardButton.titleProperty)
    ], AuthCardButton.prototype, "title", void 0);
    __decorate([
        (0, serialization_1.property)(AuthCardButton.imageProperty)
    ], AuthCardButton.prototype, "image", void 0);
    __decorate([
        (0, serialization_1.property)(AuthCardButton.valueProperty)
    ], AuthCardButton.prototype, "value", void 0);
    return AuthCardButton;
}(serialization_1.SerializableObject));
exports.AuthCardButton = AuthCardButton;
var TokenExchangeResource = /** @class */ (function (_super) {
    __extends(TokenExchangeResource, _super);
    function TokenExchangeResource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TokenExchangeResource.prototype.getSchemaKey = function () {
        return "TokenExchangeResource";
    };
    //#region Schema
    TokenExchangeResource.idProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_4, "id");
    TokenExchangeResource.uriProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_4, "uri");
    TokenExchangeResource.providerIdProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_4, "providerId");
    __decorate([
        (0, serialization_1.property)(TokenExchangeResource.idProperty)
    ], TokenExchangeResource.prototype, "id", void 0);
    __decorate([
        (0, serialization_1.property)(TokenExchangeResource.uriProperty)
    ], TokenExchangeResource.prototype, "uri", void 0);
    __decorate([
        (0, serialization_1.property)(TokenExchangeResource.providerIdProperty)
    ], TokenExchangeResource.prototype, "providerId", void 0);
    return TokenExchangeResource;
}(serialization_1.SerializableObject));
exports.TokenExchangeResource = TokenExchangeResource;
var Authentication = /** @class */ (function (_super) {
    __extends(Authentication, _super);
    function Authentication() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Authentication.prototype.getSchemaKey = function () {
        return "Authentication";
    };
    //#region Schema
    Authentication.textProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_4, "text");
    Authentication.connectionNameProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_4, "connectionName");
    Authentication.buttonsProperty = new serialization_1.SerializableObjectCollectionProperty(serialization_1.Versions.v1_4, "buttons", AuthCardButton);
    Authentication.tokenExchangeResourceProperty = new serialization_1.SerializableObjectProperty(serialization_1.Versions.v1_4, "tokenExchangeResource", TokenExchangeResource, true);
    __decorate([
        (0, serialization_1.property)(Authentication.textProperty)
    ], Authentication.prototype, "text", void 0);
    __decorate([
        (0, serialization_1.property)(Authentication.connectionNameProperty)
    ], Authentication.prototype, "connectionName", void 0);
    __decorate([
        (0, serialization_1.property)(Authentication.buttonsProperty)
    ], Authentication.prototype, "buttons", void 0);
    __decorate([
        (0, serialization_1.property)(Authentication.tokenExchangeResourceProperty)
    ], Authentication.prototype, "tokenExchangeResource", void 0);
    return Authentication;
}(serialization_1.SerializableObject));
exports.Authentication = Authentication;
// @dynamic
var AdaptiveCard = /** @class */ (function (_super) {
    __extends(AdaptiveCard, _super);
    function AdaptiveCard() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.designMode = false;
        return _this;
    }
    Object.defineProperty(AdaptiveCard.prototype, "refresh", {
        get: function () {
            return this.getValue(AdaptiveCard.refreshProperty);
        },
        set: function (value) {
            this.setValue(AdaptiveCard.refreshProperty, value);
            if (value) {
                value.parent = this;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AdaptiveCard, "processMarkdown", {
        get: function () {
            throw new Error(strings_1.Strings.errors.processMarkdownEventRemoved());
        },
        // eslint-disable-next-line @typescript-eslint/naming-convention
        set: function (_value) {
            throw new Error(strings_1.Strings.errors.processMarkdownEventRemoved());
        },
        enumerable: false,
        configurable: true
    });
    AdaptiveCard.applyMarkdown = function (text) {
        var result = {
            didProcess: false
        };
        if (AdaptiveCard.onProcessMarkdown) {
            AdaptiveCard.onProcessMarkdown(text, result);
        }
        else if (window.markdownit) {
            // Check for markdownit
            var markdownIt = window.markdownit;
            result.outputHtml = markdownIt().render(text);
            result.didProcess = true;
        }
        else if (!AdaptiveCard._haveWarnedAboutNoMarkdownProcessing) {
            // eslint-disable-next-line no-console
            console.warn(strings_1.Strings.errors.markdownProcessingNotEnabled);
            AdaptiveCard._haveWarnedAboutNoMarkdownProcessing = true;
        }
        return result;
    };
    AdaptiveCard.prototype.isVersionSupported = function () {
        if (this.bypassVersionCheck) {
            return true;
        }
        else {
            var unsupportedVersion = !this.version ||
                !this.version.isValid ||
                this.maxVersion.major < this.version.major ||
                (this.maxVersion.major === this.version.major &&
                    this.maxVersion.minor < this.version.minor);
            return !unsupportedVersion;
        }
    };
    AdaptiveCard.prototype.getDefaultSerializationContext = function () {
        return new SerializationContext(this.version);
    };
    AdaptiveCard.prototype.getItemsCollectionPropertyName = function () {
        return "body";
    };
    AdaptiveCard.prototype.canHostSingletons = function () {
        return true;
    };
    AdaptiveCard.prototype.internalParse = function (source, context) {
        this._fallbackCard = undefined;
        var fallbackElement = context.parseElement(undefined, source["fallback"], this.forbiddenChildElements(), !this.isDesignMode());
        if (fallbackElement) {
            this._fallbackCard = new AdaptiveCard();
            this._fallbackCard.addItem(fallbackElement);
        }
        _super.prototype.internalParse.call(this, source, context);
    };
    AdaptiveCard.prototype.internalToJSON = function (target, context) {
        this.setValue(AdaptiveCard.versionProperty, context.targetVersion);
        _super.prototype.internalToJSON.call(this, target, context);
    };
    AdaptiveCard.prototype.internalRender = function () {
        var renderedElement = _super.prototype.internalRender.call(this);
        if (shared_1.GlobalSettings.useAdvancedCardBottomTruncation && renderedElement) {
            // Unlike containers, the root card element should be allowed to
            // be shorter than its content (otherwise the overflow truncation
            // logic would never get triggered)
            renderedElement.style.removeProperty("minHeight");
        }
        return renderedElement;
    };
    AdaptiveCard.prototype.getHasBackground = function (ignoreBackgroundImages) {
        if (ignoreBackgroundImages === void 0) { ignoreBackgroundImages = false; }
        return true;
    };
    AdaptiveCard.prototype.getDefaultPadding = function () {
        return new shared_1.PaddingDefinition(Enums.Spacing.Padding, Enums.Spacing.Padding, Enums.Spacing.Padding, Enums.Spacing.Padding);
    };
    AdaptiveCard.prototype.shouldSerialize = function (_context) {
        return true;
    };
    Object.defineProperty(AdaptiveCard.prototype, "renderIfEmpty", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AdaptiveCard.prototype, "bypassVersionCheck", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AdaptiveCard.prototype, "allowCustomStyle", {
        get: function () {
            return this.hostConfig.adaptiveCard && this.hostConfig.adaptiveCard.allowCustomStyle;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AdaptiveCard.prototype, "hasBackground", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    AdaptiveCard.prototype.getJsonTypeName = function () {
        return "AdaptiveCard";
    };
    AdaptiveCard.prototype.internalValidateProperties = function (context) {
        _super.prototype.internalValidateProperties.call(this, context);
        if (this.getValue(CardElement.typeNameProperty) !== "AdaptiveCard") {
            context.addFailure(this, Enums.ValidationEvent.MissingCardType, strings_1.Strings.errors.invalidCardType());
        }
        if (!this.bypassVersionCheck && !this.version) {
            context.addFailure(this, Enums.ValidationEvent.PropertyCantBeNull, strings_1.Strings.errors.propertyMustBeSet("version"));
        }
        else if (!this.isVersionSupported()) {
            context.addFailure(this, Enums.ValidationEvent.UnsupportedCardVersion, strings_1.Strings.errors.unsupportedCardVersion(this.version.toString(), this.maxVersion.toString()));
        }
    };
    AdaptiveCard.prototype.render = function (target) {
        var renderedCard;
        if (this.shouldFallback() && this._fallbackCard) {
            this._fallbackCard.hostConfig = this.hostConfig;
            renderedCard = this._fallbackCard.render();
        }
        else {
            renderedCard = _super.prototype.render.call(this);
            if (renderedCard) {
                renderedCard.classList.add(this.hostConfig.makeCssClassName("ac-adaptiveCard"));
                // Having a tabIndex on the root container for a card can mess up accessibility in some scenarios.
                // However, we've shipped this behavior before, and so can't just turn it off in a point release. For
                // now, to unblock accessibility scenarios for our customers, we've got an option to turn it off. In a
                // future release, we should strongly consider flipping the default such that we *don't* emit a tabIndex
                // by default.
                if (shared_1.GlobalSettings.setTabIndexAtCardRoot) {
                    renderedCard.tabIndex = 0;
                }
                if (this.speak) {
                    renderedCard.setAttribute("aria-label", this.speak);
                }
            }
        }
        if (target) {
            Utils.appendChild(target, renderedCard);
            this.updateLayout();
        }
        return renderedCard;
    };
    AdaptiveCard.prototype.updateLayout = function (processChildren) {
        if (processChildren === void 0) { processChildren = true; }
        _super.prototype.updateLayout.call(this, processChildren);
        if (shared_1.GlobalSettings.useAdvancedCardBottomTruncation && this.isDisplayed()) {
            var padding = this.hostConfig.getEffectiveSpacing(Enums.Spacing.Default);
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
            this["handleOverflow"](this.renderedElement.offsetHeight - padding);
        }
    };
    AdaptiveCard.prototype.shouldFallback = function () {
        return _super.prototype.shouldFallback.call(this) || !this.isVersionSupported();
    };
    Object.defineProperty(AdaptiveCard.prototype, "hasVisibleSeparator", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    AdaptiveCard.schemaUrl = "http://adaptivecards.io/schemas/adaptive-card.json";
    //#region Schema
    // eslint-disable-next-line @typescript-eslint/naming-convention
    AdaptiveCard.$schemaProperty = new serialization_1.CustomProperty(serialization_1.Versions.v1_0, "$schema", function (sender, property, source, context) {
        return AdaptiveCard.schemaUrl;
    }, function (sender, prop, target, value, context) {
        context.serializeValue(target, prop.name, AdaptiveCard.schemaUrl);
    });
    AdaptiveCard.versionProperty = new serialization_1.CustomProperty(serialization_1.Versions.v1_0, "version", function (sender, prop, source, context) {
        var version = serialization_1.Version.parse(source[prop.name], context);
        if (version === undefined) {
            version = serialization_1.Versions.latest;
            context.logParseEvent(sender, Enums.ValidationEvent.InvalidPropertyValue, strings_1.Strings.errors.invalidCardVersion(version.toString()));
        }
        return version;
    }, function (sender, prop, target, value, context) {
        if (value !== undefined) {
            context.serializeValue(target, prop.name, value.toString());
        }
    }, serialization_1.Versions.v1_0);
    AdaptiveCard.fallbackTextProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "fallbackText");
    AdaptiveCard.speakProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "speak");
    AdaptiveCard.refreshProperty = new serialization_1.SerializableObjectProperty(serialization_1.Versions.v1_4, "refresh", RefreshDefinition, true);
    AdaptiveCard.authenticationProperty = new serialization_1.SerializableObjectProperty(serialization_1.Versions.v1_4, "authentication", Authentication, true);
    //#endregion
    AdaptiveCard._haveWarnedAboutNoMarkdownProcessing = false;
    __decorate([
        (0, serialization_1.property)(AdaptiveCard.versionProperty)
    ], AdaptiveCard.prototype, "version", void 0);
    __decorate([
        (0, serialization_1.property)(AdaptiveCard.fallbackTextProperty)
    ], AdaptiveCard.prototype, "fallbackText", void 0);
    __decorate([
        (0, serialization_1.property)(AdaptiveCard.speakProperty)
    ], AdaptiveCard.prototype, "speak", void 0);
    __decorate([
        (0, serialization_1.property)(AdaptiveCard.refreshProperty)
    ], AdaptiveCard.prototype, "refresh", null);
    __decorate([
        (0, serialization_1.property)(AdaptiveCard.authenticationProperty)
    ], AdaptiveCard.prototype, "authentication", void 0);
    return AdaptiveCard;
}(ContainerWithActions));
exports.AdaptiveCard = AdaptiveCard;
var InlineAdaptiveCard = /** @class */ (function (_super) {
    __extends(InlineAdaptiveCard, _super);
    function InlineAdaptiveCard() {
        //#region Schema
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.suppressStyle = false;
        return _this;
    }
    InlineAdaptiveCard.prototype.getSchemaKey = function () {
        return "InlineAdaptiveCard";
    };
    InlineAdaptiveCard.prototype.populateSchema = function (schema) {
        _super.prototype.populateSchema.call(this, schema);
        schema.remove(AdaptiveCard.$schemaProperty, AdaptiveCard.versionProperty);
    };
    //#endregion
    InlineAdaptiveCard.prototype.getDefaultPadding = function () {
        return new shared_1.PaddingDefinition(this.suppressStyle ? Enums.Spacing.None : Enums.Spacing.Padding, Enums.Spacing.Padding, this.suppressStyle ? Enums.Spacing.None : Enums.Spacing.Padding, Enums.Spacing.Padding);
    };
    Object.defineProperty(InlineAdaptiveCard.prototype, "bypassVersionCheck", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(InlineAdaptiveCard.prototype, "defaultStyle", {
        get: function () {
            if (this.suppressStyle) {
                return Enums.ContainerStyle.Default;
            }
            else {
                return this.hostConfig.actions.showCard.style
                    ? this.hostConfig.actions.showCard.style
                    : Enums.ContainerStyle.Emphasis;
            }
        },
        enumerable: false,
        configurable: true
    });
    InlineAdaptiveCard.prototype.render = function (target) {
        var renderedCard = _super.prototype.render.call(this, target);
        if (renderedCard) {
            renderedCard.setAttribute("aria-live", "polite");
            renderedCard.removeAttribute("tabindex");
        }
        return renderedCard;
    };
    return InlineAdaptiveCard;
}(AdaptiveCard));
var SerializationContext = /** @class */ (function (_super) {
    __extends(SerializationContext, _super);
    function SerializationContext() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._forbiddenTypes = new Set();
        return _this;
    }
    SerializationContext.prototype.internalParseCardObject = function (parent, source, forbiddenTypes, allowFallback, createInstanceCallback, logParseEvent, parsingSingletonObject) {
        var _this = this;
        if (parsingSingletonObject === void 0) { parsingSingletonObject = false; }
        var result = undefined;
        if (source && typeof source === "object") {
            var oldForbiddenTypes_1 = new Set();
            this._forbiddenTypes.forEach(function (type) {
                oldForbiddenTypes_1.add(type);
            });
            forbiddenTypes.forEach(function (type) {
                _this._forbiddenTypes.add(type);
            });
            var typeName = Utils.parseString(source["type"]);
            var ignoreForbiddenType = parsingSingletonObject && typeName === "Carousel";
            if (typeName && this._forbiddenTypes.has(typeName) && !ignoreForbiddenType) {
                logParseEvent(typeName, Enums.TypeErrorType.ForbiddenType);
            }
            else {
                var tryToFallback = false;
                result = createInstanceCallback(typeName);
                if (!result) {
                    tryToFallback = shared_1.GlobalSettings.enableFallback && allowFallback;
                    logParseEvent(typeName, Enums.TypeErrorType.UnknownType);
                }
                else {
                    result.setParent(parent);
                    result.parse(source, this);
                    tryToFallback =
                        shared_1.GlobalSettings.enableFallback && allowFallback && result.shouldFallback();
                }
                if (tryToFallback) {
                    var fallback = source["fallback"];
                    if (!fallback && parent) {
                        parent.setShouldFallback(true);
                    }
                    if (typeof fallback === "string" && fallback.toLowerCase() === "drop") {
                        result = undefined;
                    }
                    else if (typeof fallback === "object") {
                        result = this.internalParseCardObject(parent, fallback, forbiddenTypes, true, createInstanceCallback, logParseEvent);
                    }
                }
            }
            this._forbiddenTypes = oldForbiddenTypes_1;
        }
        return result;
    };
    SerializationContext.prototype.cardObjectParsed = function (o, source) {
        if (o instanceof Action && this.onParseAction) {
            this.onParseAction(o, source, this);
        }
        else if (o instanceof CardElement && this.onParseElement) {
            this.onParseElement(o, source, this);
        }
    };
    SerializationContext.prototype.shouldSerialize = function (o) {
        if (o instanceof Action) {
            return this.actionRegistry.findByName(o.getJsonTypeName()) !== undefined;
        }
        else if (o instanceof CardElement) {
            return this.elementRegistry.findByName(o.getJsonTypeName()) !== undefined;
        }
        else {
            return true;
        }
    };
    SerializationContext.prototype.parseCardObject = function (parent, source, forbiddenTypeNames, allowFallback, createInstanceCallback, logParseEvent, parsingSingletonObject) {
        if (parsingSingletonObject === void 0) { parsingSingletonObject = false; }
        var forbiddenTypes = new Set(forbiddenTypeNames);
        var result = this.internalParseCardObject(parent, source, forbiddenTypes, allowFallback, createInstanceCallback, logParseEvent, parsingSingletonObject);
        if (result !== undefined) {
            this.cardObjectParsed(result, source);
        }
        return result;
    };
    SerializationContext.prototype.parseElement = function (parent, source, forbiddenTypes, allowFallback, _parsingSingletonObject) {
        var _this = this;
        if (_parsingSingletonObject === void 0) { _parsingSingletonObject = false; }
        return this.parseCardObject(parent, source, forbiddenTypes, allowFallback, function (typeName) {
            return _this.elementRegistry.createInstance(typeName, _this.targetVersion);
        }, function (typeName, errorType) {
            if (errorType === Enums.TypeErrorType.UnknownType) {
                _this.logParseEvent(undefined, Enums.ValidationEvent.UnknownElementType, strings_1.Strings.errors.unknownElementType(typeName));
            }
            else {
                _this.logParseEvent(undefined, Enums.ValidationEvent.ElementTypeNotAllowed, strings_1.Strings.errors.elementTypeNotAllowed(typeName));
            }
        }, _parsingSingletonObject);
    };
    SerializationContext.prototype.parseAction = function (parent, source, forbiddenActionTypes, allowFallback) {
        var _this = this;
        return this.parseCardObject(parent, source, forbiddenActionTypes, allowFallback, function (typeName) {
            return _this.actionRegistry.createInstance(typeName, _this.targetVersion);
        }, function (typeName, errorType) {
            if (errorType === Enums.TypeErrorType.UnknownType) {
                _this.logParseEvent(undefined, Enums.ValidationEvent.UnknownActionType, strings_1.Strings.errors.unknownActionType(typeName));
            }
            else {
                _this.logParseEvent(undefined, Enums.ValidationEvent.ActionTypeNotAllowed, strings_1.Strings.errors.actionTypeNotAllowed(typeName));
            }
        });
    };
    Object.defineProperty(SerializationContext.prototype, "elementRegistry", {
        get: function () {
            var _a;
            return (_a = this._elementRegistry) !== null && _a !== void 0 ? _a : registry_1.GlobalRegistry.elements;
        },
        enumerable: false,
        configurable: true
    });
    // Not using a property setter here because the setter should accept "undefined"
    // whereas the getter should never return undefined.
    SerializationContext.prototype.setElementRegistry = function (value) {
        this._elementRegistry = value;
    };
    Object.defineProperty(SerializationContext.prototype, "actionRegistry", {
        get: function () {
            var _a;
            return (_a = this._actionRegistry) !== null && _a !== void 0 ? _a : registry_1.GlobalRegistry.actions;
        },
        enumerable: false,
        configurable: true
    });
    // Not using a property setter here because the setter should accept "undefined"
    // whereas the getter should never return undefined.
    SerializationContext.prototype.setActionRegistry = function (value) {
        this._actionRegistry = value;
    };
    return SerializationContext;
}(serialization_1.BaseSerializationContext));
exports.SerializationContext = SerializationContext;
registry_1.GlobalRegistry.defaultElements.register("Container", Container);
registry_1.GlobalRegistry.defaultElements.register("TextBlock", TextBlock);
registry_1.GlobalRegistry.defaultElements.register("RichTextBlock", RichTextBlock, serialization_1.Versions.v1_2);
registry_1.GlobalRegistry.defaultElements.register("TextRun", TextRun, serialization_1.Versions.v1_2);
registry_1.GlobalRegistry.defaultElements.register("Image", Image);
registry_1.GlobalRegistry.defaultElements.register("ImageSet", ImageSet);
registry_1.GlobalRegistry.defaultElements.register("Media", Media, serialization_1.Versions.v1_1);
registry_1.GlobalRegistry.defaultElements.register("FactSet", FactSet);
registry_1.GlobalRegistry.defaultElements.register("ColumnSet", ColumnSet);
registry_1.GlobalRegistry.defaultElements.register("ActionSet", ActionSet, serialization_1.Versions.v1_2);
registry_1.GlobalRegistry.defaultElements.register("Input.Text", TextInput);
registry_1.GlobalRegistry.defaultElements.register("Input.Date", DateInput);
registry_1.GlobalRegistry.defaultElements.register("Input.Time", TimeInput);
registry_1.GlobalRegistry.defaultElements.register("Input.Number", NumberInput);
registry_1.GlobalRegistry.defaultElements.register("Input.ChoiceSet", ChoiceSetInput);
registry_1.GlobalRegistry.defaultElements.register("Input.Toggle", ToggleInput);
registry_1.GlobalRegistry.defaultActions.register(OpenUrlAction.JsonTypeName, OpenUrlAction);
registry_1.GlobalRegistry.defaultActions.register(SubmitAction.JsonTypeName, SubmitAction);
registry_1.GlobalRegistry.defaultActions.register(ShowCardAction.JsonTypeName, ShowCardAction);
registry_1.GlobalRegistry.defaultActions.register(ToggleVisibilityAction.JsonTypeName, ToggleVisibilityAction, serialization_1.Versions.v1_2);
registry_1.GlobalRegistry.defaultActions.register(ExecuteAction.JsonTypeName, ExecuteAction, serialization_1.Versions.v1_4);
//# sourceMappingURL=card-elements.js.map

/***/ }),

/***/ "../adaptivecards/lib/card-object.js":
/*!*******************************************!*\
  !*** ../adaptivecards/lib/card-object.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CardObject = exports.ValidationResults = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var Enums = __webpack_require__(/*! ./enums */ "../adaptivecards/lib/enums.js");
var strings_1 = __webpack_require__(/*! ./strings */ "../adaptivecards/lib/strings.js");
var shared_1 = __webpack_require__(/*! ./shared */ "../adaptivecards/lib/shared.js");
var host_capabilities_1 = __webpack_require__(/*! ./host-capabilities */ "../adaptivecards/lib/host-capabilities.js");
var serialization_1 = __webpack_require__(/*! ./serialization */ "../adaptivecards/lib/serialization.js");
var ValidationResults = /** @class */ (function () {
    function ValidationResults() {
        this.allIds = {};
        this.validationEvents = [];
    }
    ValidationResults.prototype.addFailure = function (cardObject, event, message) {
        this.validationEvents.push({
            phase: Enums.ValidationPhase.Validation,
            source: cardObject,
            event: event,
            message: message
        });
    };
    return ValidationResults;
}());
exports.ValidationResults = ValidationResults;
var CardObject = /** @class */ (function (_super) {
    __extends(CardObject, _super);
    function CardObject() {
        //#region Schema
        var _this = _super !== null && _super.apply(this, arguments) || this;
        //#endregion
        _this._shouldFallback = false;
        return _this;
    }
    CardObject.prototype.getSchemaKey = function () {
        return this.getJsonTypeName();
    };
    Object.defineProperty(CardObject.prototype, "requires", {
        get: function () {
            return this.getValue(CardObject.requiresProperty);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Checks if this CardObject contains the given DOM Node.
     * @param node The DOM Node to look for.
     * @returns `true` if the DOM Node was found, `false` otherwise.
     */
    CardObject.prototype.contains = function (node) {
        if (this._renderedElement) {
            return this._renderedElement.contains(node);
        }
        return false;
    };
    CardObject.prototype.preProcessPropertyValue = function (prop, propertyValue) {
        var value = propertyValue === undefined ? this.getValue(prop) : propertyValue;
        if (shared_1.GlobalSettings.allowPreProcessingPropertyValues) {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            var currentObject = this;
            while (currentObject && !currentObject.onPreProcessPropertyValue) {
                currentObject = currentObject.parent;
            }
            if (currentObject && currentObject.onPreProcessPropertyValue) {
                return currentObject.onPreProcessPropertyValue(this, prop, value);
            }
        }
        return value;
    };
    CardObject.prototype.setParent = function (value) {
        this._parent = value;
    };
    CardObject.prototype.setShouldFallback = function (value) {
        this._shouldFallback = value;
    };
    CardObject.prototype.shouldFallback = function () {
        return this._shouldFallback || !this.requires.areAllMet(this.hostConfig.hostCapabilities);
    };
    CardObject.prototype.getRootObject = function () {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var currentObject = this;
        while (currentObject.parent) {
            currentObject = currentObject.parent;
        }
        return currentObject;
    };
    CardObject.prototype.internalValidateProperties = function (context) {
        if (this.id) {
            if (context.allIds.hasOwnProperty(this.id)) {
                if (context.allIds[this.id] === 1) {
                    context.addFailure(this, Enums.ValidationEvent.DuplicateId, strings_1.Strings.errors.duplicateId(this.id));
                }
                context.allIds[this.id] += 1;
            }
            else {
                context.allIds[this.id] = 1;
            }
        }
    };
    CardObject.prototype.validateProperties = function () {
        var result = new ValidationResults();
        this.internalValidateProperties(result);
        return result;
    };
    /**
     * Recursively searches this CardObject and any children to find the
     * innermost CardObject that owns the given DOM Node.
     *
     * @param node The DOM Node to look for.
     *
     * @returns The owner of the given DOM Node, or `undefined` if no owner was found.
     */
    CardObject.prototype.findDOMNodeOwner = function (node) {
        // default implementation for CardObjects with no associated children
        return this.contains(node) ? this : undefined;
    };
    CardObject.prototype.releaseDOMResources = function () {
        // Do nothing in base implementation
    };
    Object.defineProperty(CardObject.prototype, "parent", {
        get: function () {
            return this._parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CardObject.prototype, "renderedElement", {
        get: function () {
            return this._renderedElement;
        },
        enumerable: false,
        configurable: true
    });
    CardObject.typeNameProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "type", undefined, undefined, undefined, function (sender) {
        return sender.getJsonTypeName();
    });
    CardObject.idProperty = new serialization_1.StringProperty(serialization_1.Versions.v1_0, "id");
    CardObject.requiresProperty = new serialization_1.SerializableObjectProperty(serialization_1.Versions.v1_2, "requires", host_capabilities_1.HostCapabilities, false, new host_capabilities_1.HostCapabilities());
    __decorate([
        (0, serialization_1.property)(CardObject.idProperty)
    ], CardObject.prototype, "id", void 0);
    __decorate([
        (0, serialization_1.property)(CardObject.requiresProperty)
    ], CardObject.prototype, "requires", null);
    return CardObject;
}(serialization_1.SerializableObject));
exports.CardObject = CardObject;
//# sourceMappingURL=card-object.js.map

/***/ }),

/***/ "../adaptivecards/lib/channel-adapter.js":
/*!***********************************************!*\
  !*** ../adaptivecards/lib/channel-adapter.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelAdapter = void 0;
var ChannelAdapter = /** @class */ (function () {
    function ChannelAdapter() {
    }
    return ChannelAdapter;
}());
exports.ChannelAdapter = ChannelAdapter;
//# sourceMappingURL=channel-adapter.js.map

/***/ }),

/***/ "../adaptivecards/lib/controls/collection.js":
/*!***************************************************!*\
  !*** ../adaptivecards/lib/controls/collection.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Collection = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var Collection = /** @class */ (function () {
    function Collection() {
        this._items = [];
    }
    Collection.prototype.get = function (index) {
        return this._items[index];
    };
    Collection.prototype.add = function (item) {
        this._items.push(item);
        if (this.onItemAdded) {
            this.onItemAdded(item);
        }
    };
    Collection.prototype.remove = function (item) {
        var i = this._items.indexOf(item);
        if (i >= 0) {
            this._items = this._items.splice(i, 1);
            if (this.onItemRemoved) {
                this.onItemRemoved(item);
            }
        }
    };
    Collection.prototype.indexOf = function (item) {
        return this._items.indexOf(item);
    };
    Object.defineProperty(Collection.prototype, "length", {
        get: function () {
            return this._items.length;
        },
        enumerable: false,
        configurable: true
    });
    return Collection;
}());
exports.Collection = Collection;
//# sourceMappingURL=collection.js.map

/***/ }),

/***/ "../adaptivecards/lib/controls/constants.js":
/*!**************************************************!*\
  !*** ../adaptivecards/lib/controls/constants.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Constants = void 0;
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
var Constants = /** @class */ (function () {
    function Constants() {
    }
    Constants.keys = {
        tab: "Tab",
        enter: "Enter",
        escape: "Escape",
        space: " ",
        up: "ArrowUp",
        down: "ArrowDown",
        delete: "Delete"
    };
    return Constants;
}());
exports.Constants = Constants;
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "../adaptivecards/lib/controls/index.js":
/*!**********************************************!*\
  !*** ../adaptivecards/lib/controls/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (C) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__exportStar(__webpack_require__(/*! ./menu-item */ "../adaptivecards/lib/controls/menu-item.js"), exports);
__exportStar(__webpack_require__(/*! ./popup-menu */ "../adaptivecards/lib/controls/popup-menu.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../adaptivecards/lib/controls/menu-item.js":
/*!**************************************************!*\
  !*** ../adaptivecards/lib/controls/menu-item.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MenuItem = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var host_config_1 = __webpack_require__(/*! ../host-config */ "../adaptivecards/lib/host-config.js");
var constants_1 = __webpack_require__(/*! ./constants */ "../adaptivecards/lib/controls/constants.js");
var MenuItem = /** @class */ (function () {
    function MenuItem(key, value) {
        this._isEnabled = true;
        this.key = key;
        this._value = value;
    }
    MenuItem.prototype.click = function () {
        if (this.isEnabled && this.onClick) {
            this.onClick(this);
        }
    };
    MenuItem.prototype.updateCssClasses = function () {
        if (this._element) {
            var effectiveHostConfig = this._hostConfig ? this._hostConfig : host_config_1.defaultHostConfig;
            this._element.className = effectiveHostConfig.makeCssClassName("ac-ctrl");
            this._element.classList.add(effectiveHostConfig.makeCssClassName(this.isEnabled ? "ac-ctrl-dropdown-item" : "ac-ctrl-dropdown-item-disabled"));
            if (!this.isEnabled) {
                this._element.classList.add(effectiveHostConfig.makeCssClassName("ac-disabled"));
            }
        }
    };
    MenuItem.prototype.toString = function () {
        return this.value;
    };
    MenuItem.prototype.render = function (hostConfig) {
        var _this = this;
        this._hostConfig = hostConfig;
        if (!this._element) {
            this._element = document.createElement("span");
            this._element.innerText = this.value;
            this._element.setAttribute("role", "menuitem");
            if (!this.isEnabled) {
                this._element.setAttribute("aria-disabled", "true");
            }
            this._element.setAttribute("aria-current", "false");
            this._element.onmouseup = function (_e) {
                _this.click();
            };
            this._element.onkeydown = function (e) {
                if (e.key === constants_1.Constants.keys.enter) {
                    e.cancelBubble = true;
                    _this.click();
                }
            };
            this.updateCssClasses();
        }
        return this._element;
    };
    Object.defineProperty(MenuItem.prototype, "value", {
        get: function () {
            return this._value;
        },
        set: function (newValue) {
            this._value = newValue;
            if (this._element) {
                this._element.innerText = newValue;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MenuItem.prototype, "isEnabled", {
        get: function () {
            return this._isEnabled;
        },
        set: function (value) {
            if (this._isEnabled !== value) {
                this._isEnabled = value;
                this.updateCssClasses();
            }
        },
        enumerable: false,
        configurable: true
    });
    return MenuItem;
}());
exports.MenuItem = MenuItem;
//# sourceMappingURL=menu-item.js.map

/***/ }),

/***/ "../adaptivecards/lib/controls/popup-control.js":
/*!******************************************************!*\
  !*** ../adaptivecards/lib/controls/popup-control.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PopupControl = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var constants_1 = __webpack_require__(/*! ./constants */ "../adaptivecards/lib/controls/constants.js");
var Utils = __webpack_require__(/*! ../utils */ "../adaptivecards/lib/utils.js");
var host_config_1 = __webpack_require__(/*! ../host-config */ "../adaptivecards/lib/host-config.js");
var PopupControl = /** @class */ (function () {
    function PopupControl() {
        this._isOpen = false;
    }
    PopupControl.prototype.keyDown = function (e) {
        switch (e.key) {
            case constants_1.Constants.keys.escape:
                this.closePopup(true);
                break;
        }
    };
    PopupControl.prototype.render = function (_rootElementBounds) {
        var _this = this;
        var element = document.createElement("div");
        element.tabIndex = 0;
        element.className = this.hostConfig.makeCssClassName("ac-ctrl", "ac-ctrl-popup-container");
        element.setAttribute("role", "dialog");
        element.setAttribute("aria-modal", "true");
        element.onkeydown = function (e) {
            _this.keyDown(e);
            return !e.cancelBubble;
        };
        element.appendChild(this.renderContent());
        return element;
    };
    PopupControl.prototype.focus = function () {
        if (this._popupElement) {
            this._popupElement.firstElementChild.focus();
        }
    };
    PopupControl.prototype.popup = function (rootElement) {
        var _a, _b, _c, _d, _f;
        var _this = this;
        if (!this._isOpen) {
            this._overlayElement = document.createElement("div");
            this._overlayElement.className = this.hostConfig.makeCssClassName("ac-ctrl-overlay");
            this._overlayElement.tabIndex = 0;
            this._overlayElement.style.width = document.documentElement.scrollWidth + "px";
            this._overlayElement.style.height = document.documentElement.scrollHeight + "px";
            this._overlayElement.onfocus = function (_e) {
                _this.closePopup(true);
            };
            document.body.appendChild(this._overlayElement);
            var rootElementBounds = rootElement.getBoundingClientRect();
            this._popupElement = this.render(rootElementBounds);
            (_a = this._popupElement.classList).remove.apply(_a, this.hostConfig.makeCssClassNames("ac-ctrl-slide", "ac-ctrl-slideLeftToRight", "ac-ctrl-slideRightToLeft", "ac-ctrl-slideTopToBottom", "ac-ctrl-slideRightToLeft"));
            window.addEventListener("resize", function (_e) {
                _this.closePopup(true);
            });
            var rootElementLabel = rootElement.getAttribute("aria-label");
            if (rootElementLabel) {
                this._popupElement.setAttribute("aria-label", rootElementLabel);
            }
            this._overlayElement.appendChild(this._popupElement);
            var popupElementBounds = this._popupElement.getBoundingClientRect();
            var availableSpaceBelow = window.innerHeight - rootElementBounds.bottom;
            var availableSpaceAbove = rootElementBounds.top;
            var availableSpaceRight = window.innerWidth - rootElementBounds.right;
            var availableSpaceLeft = rootElementBounds.left;
            var left = rootElementBounds.left + Utils.getScrollX();
            var top_1;
            if (availableSpaceAbove < popupElementBounds.height &&
                availableSpaceBelow < popupElementBounds.height) {
                // Not enough space above or below root element
                var actualPopupHeight = Math.min(popupElementBounds.height, window.innerHeight);
                this._popupElement.style.maxHeight = actualPopupHeight + "px";
                if (actualPopupHeight < popupElementBounds.height) {
                    top_1 = Utils.getScrollY();
                }
                else {
                    top_1 =
                        Utils.getScrollY() +
                            rootElementBounds.top +
                            (rootElementBounds.height - actualPopupHeight) / 2;
                }
                if (availableSpaceLeft < popupElementBounds.width &&
                    availableSpaceRight < popupElementBounds.width) {
                    // Not enough space left or right of root element
                    var actualPopupWidth = Math.min(popupElementBounds.width, window.innerWidth);
                    this._popupElement.style.maxWidth = actualPopupWidth + "px";
                    if (actualPopupWidth < popupElementBounds.width) {
                        left = Utils.getScrollX();
                    }
                    else {
                        left =
                            Utils.getScrollX() +
                                rootElementBounds.left +
                                (rootElementBounds.width - actualPopupWidth) / 2;
                    }
                }
                else {
                    // Enough space on the left or right of the root element
                    if (availableSpaceRight >= popupElementBounds.width) {
                        left = Utils.getScrollX() + rootElementBounds.right;
                        (_b = this._popupElement.classList).add.apply(_b, this.hostConfig.makeCssClassNames("ac-ctrl-slide", "ac-ctrl-slideLeftToRight"));
                    }
                    else {
                        left =
                            Utils.getScrollX() + rootElementBounds.left - popupElementBounds.width;
                        (_c = this._popupElement.classList).add.apply(_c, this.hostConfig.makeCssClassNames("ac-ctrl-slide", "ac-ctrl-slideRightToLeft"));
                    }
                }
            }
            else {
                // Enough space above or below root element
                if (availableSpaceBelow >= popupElementBounds.height) {
                    top_1 = Utils.getScrollY() + rootElementBounds.bottom;
                    (_d = this._popupElement.classList).add.apply(_d, this.hostConfig.makeCssClassNames("ac-ctrl-slide", "ac-ctrl-slideTopToBottom"));
                }
                else {
                    top_1 = Utils.getScrollY() + rootElementBounds.top - popupElementBounds.height;
                    (_f = this._popupElement.classList).add.apply(_f, this.hostConfig.makeCssClassNames("ac-ctrl-slide", "ac-ctrl-slideBottomToTop"));
                }
                if (availableSpaceRight < popupElementBounds.width) {
                    left = Utils.getScrollX() + rootElementBounds.right - popupElementBounds.width;
                }
            }
            this._popupElement.style.left = left + "px";
            this._popupElement.style.top = top_1 + "px";
            this._popupElement.focus();
            this._isOpen = true;
        }
    };
    PopupControl.prototype.closePopup = function (wasCancelled) {
        if (this._isOpen) {
            document.body.removeChild(this._overlayElement);
            this._isOpen = false;
            if (this.onClose) {
                this.onClose(this, wasCancelled);
            }
        }
    };
    Object.defineProperty(PopupControl.prototype, "hostConfig", {
        get: function () {
            return this._hostConfig ? this._hostConfig : host_config_1.defaultHostConfig;
        },
        set: function (value) {
            this._hostConfig = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PopupControl.prototype, "isOpen", {
        get: function () {
            return this._isOpen;
        },
        enumerable: false,
        configurable: true
    });
    return PopupControl;
}());
exports.PopupControl = PopupControl;
//# sourceMappingURL=popup-control.js.map

/***/ }),

/***/ "../adaptivecards/lib/controls/popup-menu.js":
/*!***************************************************!*\
  !*** ../adaptivecards/lib/controls/popup-menu.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PopupMenu = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var constants_1 = __webpack_require__(/*! ./constants */ "../adaptivecards/lib/controls/constants.js");
var collection_1 = __webpack_require__(/*! ./collection */ "../adaptivecards/lib/controls/collection.js");
var popup_control_1 = __webpack_require__(/*! ./popup-control */ "../adaptivecards/lib/controls/popup-control.js");
var PopupMenu = /** @class */ (function (_super) {
    __extends(PopupMenu, _super);
    function PopupMenu() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._items = new collection_1.Collection();
        _this._renderedItems = [];
        _this._selectedIndex = -1;
        return _this;
    }
    PopupMenu.prototype.renderContent = function () {
        var element = document.createElement("div");
        element.className = this.hostConfig.makeCssClassName("ac-ctrl ac-popup");
        element.setAttribute("role", "listbox");
        for (var i = 0; i < this._items.length; i++) {
            var renderedItem = this._items.get(i).render(this.hostConfig);
            renderedItem.tabIndex = 0;
            element.appendChild(renderedItem);
            if (i === this.selectedIndex) {
                renderedItem.focus();
            }
            this._renderedItems.push(renderedItem);
        }
        return element;
    };
    PopupMenu.prototype.keyDown = function (e) {
        _super.prototype.keyDown.call(this, e);
        var selectedItemIndex = this._selectedIndex;
        switch (e.key) {
            case constants_1.Constants.keys.tab:
                this.closePopup(true);
                break;
            /*
            case Constants.keys.enter:
                if (this.selectedIndex >= 0) {
                    this.selectedIndex = this.selectedIndex;

                    this.close();
                }

                break;
            */
            case constants_1.Constants.keys.up:
                if (selectedItemIndex <= 0) {
                    selectedItemIndex = this._renderedItems.length - 1;
                }
                else {
                    selectedItemIndex--;
                    if (selectedItemIndex < 0) {
                        selectedItemIndex = this._renderedItems.length - 1;
                    }
                }
                this.selectedIndex = selectedItemIndex;
                e.cancelBubble = true;
                break;
            case constants_1.Constants.keys.down:
                if (selectedItemIndex < 0) {
                    selectedItemIndex = 0;
                }
                else {
                    selectedItemIndex++;
                    if (selectedItemIndex >= this._renderedItems.length) {
                        selectedItemIndex = 0;
                    }
                }
                this.selectedIndex = selectedItemIndex;
                e.cancelBubble = true;
                break;
        }
    };
    Object.defineProperty(PopupMenu.prototype, "items", {
        get: function () {
            return this._items;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PopupMenu.prototype, "selectedIndex", {
        get: function () {
            return this._selectedIndex;
        },
        set: function (index) {
            if (index >= 0 && index < this._renderedItems.length) {
                this._renderedItems[index].focus();
                this._selectedIndex = index;
            }
        },
        enumerable: false,
        configurable: true
    });
    return PopupMenu;
}(popup_control_1.PopupControl));
exports.PopupMenu = PopupMenu;
//# sourceMappingURL=popup-menu.js.map

/***/ }),

/***/ "../adaptivecards/lib/enums.js":
/*!*************************************!*\
  !*** ../adaptivecards/lib/enums.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogLevel = exports.RefreshMode = exports.TypeErrorType = exports.ContainerFitStatus = exports.ValidationEvent = exports.ValidationPhase = exports.InputTextStyle = exports.ActionIconPlacement = exports.FillMode = exports.Orientation = exports.ShowCardActionMode = exports.ImageStyle = exports.ActionAlignment = exports.VerticalAlignment = exports.HorizontalAlignment = exports.TextColor = exports.Spacing = exports.FontType = exports.TextWeight = exports.TextSize = exports.SizeUnit = exports.ImageSize = exports.Size = exports.ActionMode = exports.ActionStyle = exports.ContainerStyle = void 0;
/*
    This should really be a string enum, e.g.

        export enum ContainerStyle {
            Default = "default",
            Emphasis = "emphasis"
        }

    However, some hosts do not use a version of TypeScript
    recent enough to understand string enums. This is
    a compatible construct that does not require using
    a more recent version of TypeScript.

    Also note the "weird" way these readonly fields are declared is to work around
    a breaking change introduced in TS 3.1 wrt d.ts generation. DO NOT CHANGE
    and adopt this syntax for all other static readonly fields.
*/
/* eslint-disable @typescript-eslint/no-extraneous-class, @typescript-eslint/naming-convention */
var ContainerStyle = /** @class */ (function () {
    function ContainerStyle() {
    }
    ContainerStyle.Default = "default";
    ContainerStyle.Emphasis = "emphasis";
    ContainerStyle.Accent = "accent";
    ContainerStyle.Good = "good";
    ContainerStyle.Attention = "attention";
    ContainerStyle.Warning = "warning";
    return ContainerStyle;
}());
exports.ContainerStyle = ContainerStyle;
var ActionStyle = /** @class */ (function () {
    function ActionStyle() {
    }
    ActionStyle.Default = "default";
    ActionStyle.Positive = "positive";
    ActionStyle.Destructive = "destructive";
    return ActionStyle;
}());
exports.ActionStyle = ActionStyle;
var ActionMode = /** @class */ (function () {
    function ActionMode() {
    }
    ActionMode.Primary = "primary";
    ActionMode.Secondary = "secondary";
    return ActionMode;
}());
exports.ActionMode = ActionMode;
/* eslint-enable @typescript-eslint/no-extraneous-class, @typescript-eslint/naming-convention */
var Size;
(function (Size) {
    Size[Size["Auto"] = 0] = "Auto";
    Size[Size["Stretch"] = 1] = "Stretch";
    Size[Size["Small"] = 2] = "Small";
    Size[Size["Medium"] = 3] = "Medium";
    Size[Size["Large"] = 4] = "Large";
})(Size = exports.Size || (exports.Size = {}));
var ImageSize;
(function (ImageSize) {
    ImageSize[ImageSize["Small"] = 0] = "Small";
    ImageSize[ImageSize["Medium"] = 1] = "Medium";
    ImageSize[ImageSize["Large"] = 2] = "Large";
})(ImageSize = exports.ImageSize || (exports.ImageSize = {}));
var SizeUnit;
(function (SizeUnit) {
    SizeUnit[SizeUnit["Weight"] = 0] = "Weight";
    SizeUnit[SizeUnit["Pixel"] = 1] = "Pixel";
})(SizeUnit = exports.SizeUnit || (exports.SizeUnit = {}));
var TextSize;
(function (TextSize) {
    TextSize[TextSize["Small"] = 0] = "Small";
    TextSize[TextSize["Default"] = 1] = "Default";
    TextSize[TextSize["Medium"] = 2] = "Medium";
    TextSize[TextSize["Large"] = 3] = "Large";
    TextSize[TextSize["ExtraLarge"] = 4] = "ExtraLarge";
})(TextSize = exports.TextSize || (exports.TextSize = {}));
var TextWeight;
(function (TextWeight) {
    TextWeight[TextWeight["Lighter"] = 0] = "Lighter";
    TextWeight[TextWeight["Default"] = 1] = "Default";
    TextWeight[TextWeight["Bolder"] = 2] = "Bolder";
})(TextWeight = exports.TextWeight || (exports.TextWeight = {}));
var FontType;
(function (FontType) {
    FontType[FontType["Default"] = 0] = "Default";
    FontType[FontType["Monospace"] = 1] = "Monospace";
})(FontType = exports.FontType || (exports.FontType = {}));
var Spacing;
(function (Spacing) {
    Spacing[Spacing["None"] = 0] = "None";
    Spacing[Spacing["Small"] = 1] = "Small";
    Spacing[Spacing["Default"] = 2] = "Default";
    Spacing[Spacing["Medium"] = 3] = "Medium";
    Spacing[Spacing["Large"] = 4] = "Large";
    Spacing[Spacing["ExtraLarge"] = 5] = "ExtraLarge";
    Spacing[Spacing["Padding"] = 6] = "Padding";
})(Spacing = exports.Spacing || (exports.Spacing = {}));
var TextColor;
(function (TextColor) {
    TextColor[TextColor["Default"] = 0] = "Default";
    TextColor[TextColor["Dark"] = 1] = "Dark";
    TextColor[TextColor["Light"] = 2] = "Light";
    TextColor[TextColor["Accent"] = 3] = "Accent";
    TextColor[TextColor["Good"] = 4] = "Good";
    TextColor[TextColor["Warning"] = 5] = "Warning";
    TextColor[TextColor["Attention"] = 6] = "Attention";
})(TextColor = exports.TextColor || (exports.TextColor = {}));
var HorizontalAlignment;
(function (HorizontalAlignment) {
    HorizontalAlignment[HorizontalAlignment["Left"] = 0] = "Left";
    HorizontalAlignment[HorizontalAlignment["Center"] = 1] = "Center";
    HorizontalAlignment[HorizontalAlignment["Right"] = 2] = "Right";
})(HorizontalAlignment = exports.HorizontalAlignment || (exports.HorizontalAlignment = {}));
var VerticalAlignment;
(function (VerticalAlignment) {
    VerticalAlignment[VerticalAlignment["Top"] = 0] = "Top";
    VerticalAlignment[VerticalAlignment["Center"] = 1] = "Center";
    VerticalAlignment[VerticalAlignment["Bottom"] = 2] = "Bottom";
})(VerticalAlignment = exports.VerticalAlignment || (exports.VerticalAlignment = {}));
var ActionAlignment;
(function (ActionAlignment) {
    ActionAlignment[ActionAlignment["Left"] = 0] = "Left";
    ActionAlignment[ActionAlignment["Center"] = 1] = "Center";
    ActionAlignment[ActionAlignment["Right"] = 2] = "Right";
    ActionAlignment[ActionAlignment["Stretch"] = 3] = "Stretch";
})(ActionAlignment = exports.ActionAlignment || (exports.ActionAlignment = {}));
var ImageStyle;
(function (ImageStyle) {
    ImageStyle[ImageStyle["Default"] = 0] = "Default";
    ImageStyle[ImageStyle["Person"] = 1] = "Person";
})(ImageStyle = exports.ImageStyle || (exports.ImageStyle = {}));
var ShowCardActionMode;
(function (ShowCardActionMode) {
    ShowCardActionMode[ShowCardActionMode["Inline"] = 0] = "Inline";
    ShowCardActionMode[ShowCardActionMode["Popup"] = 1] = "Popup";
})(ShowCardActionMode = exports.ShowCardActionMode || (exports.ShowCardActionMode = {}));
var Orientation;
(function (Orientation) {
    Orientation[Orientation["Horizontal"] = 0] = "Horizontal";
    Orientation[Orientation["Vertical"] = 1] = "Vertical";
})(Orientation = exports.Orientation || (exports.Orientation = {}));
var FillMode;
(function (FillMode) {
    FillMode[FillMode["Cover"] = 0] = "Cover";
    FillMode[FillMode["RepeatHorizontally"] = 1] = "RepeatHorizontally";
    FillMode[FillMode["RepeatVertically"] = 2] = "RepeatVertically";
    FillMode[FillMode["Repeat"] = 3] = "Repeat";
})(FillMode = exports.FillMode || (exports.FillMode = {}));
var ActionIconPlacement;
(function (ActionIconPlacement) {
    ActionIconPlacement[ActionIconPlacement["LeftOfTitle"] = 0] = "LeftOfTitle";
    ActionIconPlacement[ActionIconPlacement["AboveTitle"] = 1] = "AboveTitle";
})(ActionIconPlacement = exports.ActionIconPlacement || (exports.ActionIconPlacement = {}));
var InputTextStyle;
(function (InputTextStyle) {
    InputTextStyle[InputTextStyle["Text"] = 0] = "Text";
    InputTextStyle[InputTextStyle["Tel"] = 1] = "Tel";
    InputTextStyle[InputTextStyle["Url"] = 2] = "Url";
    InputTextStyle[InputTextStyle["Email"] = 3] = "Email";
    InputTextStyle[InputTextStyle["Password"] = 4] = "Password";
})(InputTextStyle = exports.InputTextStyle || (exports.InputTextStyle = {}));
var ValidationPhase;
(function (ValidationPhase) {
    ValidationPhase[ValidationPhase["Parse"] = 0] = "Parse";
    ValidationPhase[ValidationPhase["ToJSON"] = 1] = "ToJSON";
    ValidationPhase[ValidationPhase["Validation"] = 2] = "Validation";
})(ValidationPhase = exports.ValidationPhase || (exports.ValidationPhase = {}));
var ValidationEvent;
(function (ValidationEvent) {
    ValidationEvent[ValidationEvent["Hint"] = 0] = "Hint";
    ValidationEvent[ValidationEvent["ActionTypeNotAllowed"] = 1] = "ActionTypeNotAllowed";
    ValidationEvent[ValidationEvent["CollectionCantBeEmpty"] = 2] = "CollectionCantBeEmpty";
    ValidationEvent[ValidationEvent["Deprecated"] = 3] = "Deprecated";
    ValidationEvent[ValidationEvent["ElementTypeNotAllowed"] = 4] = "ElementTypeNotAllowed";
    ValidationEvent[ValidationEvent["InteractivityNotAllowed"] = 5] = "InteractivityNotAllowed";
    ValidationEvent[ValidationEvent["InvalidPropertyValue"] = 6] = "InvalidPropertyValue";
    ValidationEvent[ValidationEvent["MissingCardType"] = 7] = "MissingCardType";
    ValidationEvent[ValidationEvent["PropertyCantBeNull"] = 8] = "PropertyCantBeNull";
    ValidationEvent[ValidationEvent["TooManyActions"] = 9] = "TooManyActions";
    ValidationEvent[ValidationEvent["UnknownActionType"] = 10] = "UnknownActionType";
    ValidationEvent[ValidationEvent["UnknownElementType"] = 11] = "UnknownElementType";
    ValidationEvent[ValidationEvent["UnsupportedCardVersion"] = 12] = "UnsupportedCardVersion";
    ValidationEvent[ValidationEvent["DuplicateId"] = 13] = "DuplicateId";
    ValidationEvent[ValidationEvent["UnsupportedProperty"] = 14] = "UnsupportedProperty";
    ValidationEvent[ValidationEvent["RequiredInputsShouldHaveLabel"] = 15] = "RequiredInputsShouldHaveLabel";
    ValidationEvent[ValidationEvent["RequiredInputsShouldHaveErrorMessage"] = 16] = "RequiredInputsShouldHaveErrorMessage";
    ValidationEvent[ValidationEvent["Other"] = 17] = "Other";
})(ValidationEvent = exports.ValidationEvent || (exports.ValidationEvent = {}));
var ContainerFitStatus;
(function (ContainerFitStatus) {
    ContainerFitStatus[ContainerFitStatus["FullyInContainer"] = 0] = "FullyInContainer";
    ContainerFitStatus[ContainerFitStatus["Overflowing"] = 1] = "Overflowing";
    ContainerFitStatus[ContainerFitStatus["FullyOutOfContainer"] = 2] = "FullyOutOfContainer";
})(ContainerFitStatus = exports.ContainerFitStatus || (exports.ContainerFitStatus = {}));
var TypeErrorType;
(function (TypeErrorType) {
    TypeErrorType[TypeErrorType["UnknownType"] = 0] = "UnknownType";
    TypeErrorType[TypeErrorType["ForbiddenType"] = 1] = "ForbiddenType";
})(TypeErrorType = exports.TypeErrorType || (exports.TypeErrorType = {}));
var RefreshMode;
(function (RefreshMode) {
    RefreshMode[RefreshMode["Disabled"] = 0] = "Disabled";
    RefreshMode[RefreshMode["Manual"] = 1] = "Manual";
    RefreshMode[RefreshMode["Automatic"] = 2] = "Automatic";
})(RefreshMode = exports.RefreshMode || (exports.RefreshMode = {}));
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Info"] = 0] = "Info";
    LogLevel[LogLevel["Warning"] = 1] = "Warning";
    LogLevel[LogLevel["Error"] = 2] = "Error";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
//# sourceMappingURL=enums.js.map

/***/ }),

/***/ "../adaptivecards/lib/host-capabilities.js":
/*!*************************************************!*\
  !*** ../adaptivecards/lib/host-capabilities.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HostCapabilities = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var serialization_1 = __webpack_require__(/*! ./serialization */ "../adaptivecards/lib/serialization.js");
var HostCapabilities = /** @class */ (function (_super) {
    __extends(HostCapabilities, _super);
    function HostCapabilities() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._capabilities = {};
        return _this;
    }
    HostCapabilities.prototype.getSchemaKey = function () {
        return "HostCapabilities";
    };
    HostCapabilities.prototype.internalParse = function (source, context) {
        _super.prototype.internalParse.call(this, source, context);
        if (source) {
            // eslint-disable-next-line guard-for-in
            for (var name_1 in source) {
                var jsonVersion = source[name_1];
                if (typeof jsonVersion === "string") {
                    if (jsonVersion === "*") {
                        this.addCapability(name_1, "*");
                    }
                    else {
                        var version = serialization_1.Version.parse(jsonVersion, context);
                        if (version === null || version === void 0 ? void 0 : version.isValid) {
                            this.addCapability(name_1, version);
                        }
                    }
                }
            }
        }
    };
    HostCapabilities.prototype.internalToJSON = function (target, context) {
        _super.prototype.internalToJSON.call(this, target, context);
        // eslint-disable-next-line guard-for-in
        for (var key in this._capabilities) {
            target[key] = this._capabilities[key];
        }
    };
    HostCapabilities.prototype.addCapability = function (name, version) {
        this._capabilities[name] = version;
    };
    HostCapabilities.prototype.removeCapability = function (name) {
        delete this._capabilities[name];
    };
    HostCapabilities.prototype.clear = function () {
        this._capabilities = {};
    };
    HostCapabilities.prototype.hasCapability = function (name, version) {
        if (this._capabilities.hasOwnProperty(name)) {
            if (version === "*" || this._capabilities[name] === "*") {
                return true;
            }
            return version.compareTo(this._capabilities[name]) <= 0;
        }
        return false;
    };
    HostCapabilities.prototype.areAllMet = function (hostCapabilities) {
        for (var capabilityName in this._capabilities) {
            if (!hostCapabilities.hasCapability(capabilityName, this._capabilities[capabilityName])) {
                return false;
            }
        }
        return true;
    };
    return HostCapabilities;
}(serialization_1.SerializableObject));
exports.HostCapabilities = HostCapabilities;
//# sourceMappingURL=host-capabilities.js.map

/***/ }),

/***/ "../adaptivecards/lib/host-config.js":
/*!*******************************************!*\
  !*** ../adaptivecards/lib/host-config.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultHostConfig = exports.HostConfig = exports.FontTypeSet = exports.FontTypeDefinition = exports.ContainerStyleSet = exports.ContainerStyleDefinition = exports.ColorSetDefinition = exports.ActionsConfig = exports.ShowCardActionConfig = exports.FactSetConfig = exports.FactTitleDefinition = exports.FactTextDefinition = exports.InputConfig = exports.InputLabelConfig = exports.RequiredInputLabelTextDefinition = exports.TextBlockConfig = exports.TextStyleSet = exports.TextStyleDefinition = exports.BaseTextDefinition = exports.TableConfig = exports.MediaConfig = exports.ImageSetConfig = exports.AdaptiveCardConfig = exports.TextColorDefinition = exports.ColorDefinition = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var Enums = __webpack_require__(/*! ./enums */ "../adaptivecards/lib/enums.js");
var Utils = __webpack_require__(/*! ./utils */ "../adaptivecards/lib/utils.js");
var Shared = __webpack_require__(/*! ./shared */ "../adaptivecards/lib/shared.js");
var host_capabilities_1 = __webpack_require__(/*! ./host-capabilities */ "../adaptivecards/lib/host-capabilities.js");
function parseHostConfigEnum(targetEnum, value, defaultValue) {
    if (typeof value === "string") {
        var parsedValue = Utils.parseEnum(targetEnum, value, defaultValue);
        return parsedValue !== undefined ? parsedValue : defaultValue;
    }
    else if (typeof value === "number") {
        return value;
    }
    else {
        return defaultValue;
    }
}
var ColorDefinition = /** @class */ (function () {
    function ColorDefinition(defaultColor, subtleColor) {
        this.default = "#000000";
        this.subtle = "#666666";
        if (defaultColor) {
            this.default = defaultColor;
        }
        if (subtleColor) {
            this.subtle = subtleColor;
        }
    }
    ColorDefinition.prototype.parse = function (obj) {
        if (obj) {
            this.default = obj["default"] || this.default;
            this.subtle = obj["subtle"] || this.subtle;
        }
    };
    return ColorDefinition;
}());
exports.ColorDefinition = ColorDefinition;
var TextColorDefinition = /** @class */ (function (_super) {
    __extends(TextColorDefinition, _super);
    function TextColorDefinition() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.highlightColors = new ColorDefinition("#22000000", "#11000000");
        return _this;
    }
    TextColorDefinition.prototype.parse = function (obj) {
        _super.prototype.parse.call(this, obj);
        if (obj) {
            this.highlightColors.parse(obj["highlightColors"]);
        }
    };
    return TextColorDefinition;
}(ColorDefinition));
exports.TextColorDefinition = TextColorDefinition;
var AdaptiveCardConfig = /** @class */ (function () {
    function AdaptiveCardConfig(obj) {
        this.allowCustomStyle = false;
        if (obj) {
            this.allowCustomStyle = obj["allowCustomStyle"] || this.allowCustomStyle;
        }
    }
    return AdaptiveCardConfig;
}());
exports.AdaptiveCardConfig = AdaptiveCardConfig;
var ImageSetConfig = /** @class */ (function () {
    function ImageSetConfig(obj) {
        this.imageSize = Enums.Size.Medium;
        this.maxImageHeight = 100;
        if (obj) {
            this.imageSize = obj["imageSize"] != null ? obj["imageSize"] : this.imageSize;
            this.maxImageHeight = Utils.parseNumber(obj["maxImageHeight"], 100);
        }
    }
    ImageSetConfig.prototype.toJSON = function () {
        return {
            imageSize: Enums.Size[this.imageSize],
            maxImageHeight: this.maxImageHeight
        };
    };
    return ImageSetConfig;
}());
exports.ImageSetConfig = ImageSetConfig;
var MediaConfig = /** @class */ (function () {
    function MediaConfig(obj) {
        this.allowInlinePlayback = true;
        if (obj) {
            this.defaultPoster = obj["defaultPoster"];
            this.allowInlinePlayback = obj["allowInlinePlayback"] || this.allowInlinePlayback;
        }
    }
    MediaConfig.prototype.toJSON = function () {
        return {
            defaultPoster: this.defaultPoster,
            allowInlinePlayback: this.allowInlinePlayback
        };
    };
    return MediaConfig;
}());
exports.MediaConfig = MediaConfig;
var TableConfig = /** @class */ (function () {
    function TableConfig(obj) {
        this.cellSpacing = 8;
        if (obj) {
            this.cellSpacing =
                obj.cellSpacing && typeof obj.cellSpacing === "number"
                    ? obj.cellSpacing
                    : this.cellSpacing;
        }
    }
    TableConfig.prototype.toJSON = function () {
        return {
            cellSpacing: this.cellSpacing
        };
    };
    return TableConfig;
}());
exports.TableConfig = TableConfig;
var BaseTextDefinition = /** @class */ (function () {
    function BaseTextDefinition(obj) {
        this.size = Enums.TextSize.Default;
        this.color = Enums.TextColor.Default;
        this.isSubtle = false;
        this.weight = Enums.TextWeight.Default;
        this.parse(obj);
    }
    BaseTextDefinition.prototype.parse = function (obj) {
        if (obj) {
            this.size = parseHostConfigEnum(Enums.TextSize, obj["size"], this.size);
            this.color = parseHostConfigEnum(Enums.TextColor, obj["color"], this.color);
            this.isSubtle =
                obj.isSubtle !== undefined && typeof obj.isSubtle === "boolean"
                    ? obj.isSubtle
                    : this.isSubtle;
            this.weight = parseHostConfigEnum(Enums.TextWeight, obj["weight"], this.getDefaultWeight());
        }
    };
    BaseTextDefinition.prototype.getDefaultWeight = function () {
        return Enums.TextWeight.Default;
    };
    BaseTextDefinition.prototype.toJSON = function () {
        return {
            size: Enums.TextSize[this.size],
            color: Enums.TextColor[this.color],
            isSubtle: this.isSubtle,
            weight: Enums.TextWeight[this.weight]
        };
    };
    return BaseTextDefinition;
}());
exports.BaseTextDefinition = BaseTextDefinition;
var TextStyleDefinition = /** @class */ (function (_super) {
    __extends(TextStyleDefinition, _super);
    function TextStyleDefinition() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.fontType = Enums.FontType.Default;
        return _this;
    }
    TextStyleDefinition.prototype.parse = function (obj) {
        _super.prototype.parse.call(this, obj);
        if (obj) {
            this.fontType = parseHostConfigEnum(Enums.FontType, obj.fontType, this.fontType);
        }
    };
    return TextStyleDefinition;
}(BaseTextDefinition));
exports.TextStyleDefinition = TextStyleDefinition;
var TextStyleSet = /** @class */ (function () {
    function TextStyleSet(obj) {
        this.default = new TextStyleDefinition();
        this.heading = new TextStyleDefinition({
            size: "Large",
            weight: "Bolder"
        });
        this.columnHeader = new TextStyleDefinition({
            weight: "Bolder"
        });
        if (obj) {
            this.heading.parse(obj.heading);
            this.columnHeader.parse(obj.columnHeader);
        }
    }
    TextStyleSet.prototype.getStyleByName = function (name) {
        switch (name.toLowerCase()) {
            case "heading":
                return this.heading;
            case "columnHeader":
                return this.columnHeader;
            default:
                return this.default;
        }
    };
    return TextStyleSet;
}());
exports.TextStyleSet = TextStyleSet;
var TextBlockConfig = /** @class */ (function () {
    function TextBlockConfig(obj) {
        if (obj) {
            this.headingLevel = Utils.parseNumber(obj.headingLevel);
        }
    }
    return TextBlockConfig;
}());
exports.TextBlockConfig = TextBlockConfig;
var RequiredInputLabelTextDefinition = /** @class */ (function (_super) {
    __extends(RequiredInputLabelTextDefinition, _super);
    function RequiredInputLabelTextDefinition() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.suffix = " *";
        _this.suffixColor = Enums.TextColor.Attention;
        return _this;
    }
    RequiredInputLabelTextDefinition.prototype.parse = function (obj) {
        _super.prototype.parse.call(this, obj);
        if (obj) {
            this.suffix = obj["suffix"] || this.suffix;
            this.suffixColor = parseHostConfigEnum(Enums.TextColor, obj["suffixColor"], this.suffixColor);
        }
    };
    RequiredInputLabelTextDefinition.prototype.toJSON = function () {
        var result = _super.prototype.toJSON.call(this);
        result["suffix"] = this.suffix;
        result["suffixColor"] = Enums.TextColor[this.suffixColor];
        return result;
    };
    return RequiredInputLabelTextDefinition;
}(BaseTextDefinition));
exports.RequiredInputLabelTextDefinition = RequiredInputLabelTextDefinition;
var InputLabelConfig = /** @class */ (function () {
    function InputLabelConfig(obj) {
        this.inputSpacing = Enums.Spacing.Small;
        this.requiredInputs = new RequiredInputLabelTextDefinition();
        this.optionalInputs = new BaseTextDefinition();
        if (obj) {
            this.inputSpacing = parseHostConfigEnum(Enums.Spacing, obj["inputSpacing"], this.inputSpacing);
            this.requiredInputs = new RequiredInputLabelTextDefinition(obj["requiredInputs"]);
            this.optionalInputs = new BaseTextDefinition(obj["optionalInputs"]);
        }
    }
    return InputLabelConfig;
}());
exports.InputLabelConfig = InputLabelConfig;
var InputConfig = /** @class */ (function () {
    function InputConfig(obj) {
        this.label = new InputLabelConfig();
        this.errorMessage = new BaseTextDefinition({
            color: Enums.TextColor.Attention
        });
        if (obj) {
            this.label = new InputLabelConfig(obj["label"]);
            this.errorMessage = new BaseTextDefinition(obj["errorMessage"]);
        }
    }
    return InputConfig;
}());
exports.InputConfig = InputConfig;
var FactTextDefinition = /** @class */ (function (_super) {
    __extends(FactTextDefinition, _super);
    function FactTextDefinition() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.wrap = true;
        return _this;
    }
    FactTextDefinition.prototype.parse = function (obj) {
        _super.prototype.parse.call(this, obj);
        if (obj) {
            this.wrap = obj["wrap"] != null ? obj["wrap"] : this.wrap;
        }
    };
    FactTextDefinition.prototype.toJSON = function () {
        var result = _super.prototype.toJSON.call(this);
        result["wrap"] = this.wrap;
        return result;
    };
    return FactTextDefinition;
}(BaseTextDefinition));
exports.FactTextDefinition = FactTextDefinition;
var FactTitleDefinition = /** @class */ (function (_super) {
    __extends(FactTitleDefinition, _super);
    function FactTitleDefinition(obj) {
        var _this = _super.call(this, obj) || this;
        _this.maxWidth = 150;
        _this.weight = Enums.TextWeight.Bolder;
        if (obj) {
            _this.maxWidth = obj["maxWidth"] != null ? obj["maxWidth"] : _this.maxWidth;
            _this.weight = parseHostConfigEnum(Enums.TextWeight, obj["weight"], Enums.TextWeight.Bolder);
        }
        return _this;
    }
    FactTitleDefinition.prototype.getDefaultWeight = function () {
        return Enums.TextWeight.Bolder;
    };
    return FactTitleDefinition;
}(FactTextDefinition));
exports.FactTitleDefinition = FactTitleDefinition;
var FactSetConfig = /** @class */ (function () {
    function FactSetConfig(obj) {
        this.title = new FactTitleDefinition();
        this.value = new FactTextDefinition();
        this.spacing = 10;
        if (obj) {
            this.title = new FactTitleDefinition(obj["title"]);
            this.value = new FactTextDefinition(obj["value"]);
            this.spacing =
                obj.spacing && obj.spacing != null ? obj.spacing && obj.spacing : this.spacing;
        }
    }
    return FactSetConfig;
}());
exports.FactSetConfig = FactSetConfig;
var ShowCardActionConfig = /** @class */ (function () {
    function ShowCardActionConfig(obj) {
        this.actionMode = Enums.ShowCardActionMode.Inline;
        this.inlineTopMargin = 16;
        this.style = Enums.ContainerStyle.Emphasis;
        if (obj) {
            this.actionMode = parseHostConfigEnum(Enums.ShowCardActionMode, obj["actionMode"], Enums.ShowCardActionMode.Inline);
            this.inlineTopMargin =
                obj["inlineTopMargin"] != null ? obj["inlineTopMargin"] : this.inlineTopMargin;
            this.style =
                obj["style"] && typeof obj["style"] === "string"
                    ? obj["style"]
                    : Enums.ContainerStyle.Emphasis;
        }
    }
    ShowCardActionConfig.prototype.toJSON = function () {
        return {
            actionMode: Enums.ShowCardActionMode[this.actionMode],
            inlineTopMargin: this.inlineTopMargin,
            style: this.style
        };
    };
    return ShowCardActionConfig;
}());
exports.ShowCardActionConfig = ShowCardActionConfig;
var ActionsConfig = /** @class */ (function () {
    function ActionsConfig(obj) {
        this.maxActions = 5;
        this.spacing = Enums.Spacing.Default;
        this.buttonSpacing = 20;
        this.showCard = new ShowCardActionConfig();
        this.preExpandSingleShowCardAction = false;
        this.actionsOrientation = Enums.Orientation.Horizontal;
        this.actionAlignment = Enums.ActionAlignment.Left;
        this.iconPlacement = Enums.ActionIconPlacement.LeftOfTitle;
        this.allowTitleToWrap = false;
        this.iconSize = 16;
        if (obj) {
            this.maxActions = obj["maxActions"] != null ? obj["maxActions"] : this.maxActions;
            this.spacing = parseHostConfigEnum(Enums.Spacing, obj.spacing && obj.spacing, Enums.Spacing.Default);
            this.buttonSpacing =
                obj["buttonSpacing"] != null ? obj["buttonSpacing"] : this.buttonSpacing;
            this.showCard = new ShowCardActionConfig(obj["showCard"]);
            this.preExpandSingleShowCardAction = Utils.parseBool(obj["preExpandSingleShowCardAction"], false);
            this.actionsOrientation = parseHostConfigEnum(Enums.Orientation, obj["actionsOrientation"], Enums.Orientation.Horizontal);
            this.actionAlignment = parseHostConfigEnum(Enums.ActionAlignment, obj["actionAlignment"], Enums.ActionAlignment.Left);
            this.iconPlacement = parseHostConfigEnum(Enums.ActionIconPlacement, obj["iconPlacement"], Enums.ActionIconPlacement.LeftOfTitle);
            this.allowTitleToWrap =
                obj["allowTitleToWrap"] != null ? obj["allowTitleToWrap"] : this.allowTitleToWrap;
            try {
                var sizeAndUnit = Shared.SizeAndUnit.parse(obj["iconSize"]);
                if (sizeAndUnit.unit === Enums.SizeUnit.Pixel) {
                    this.iconSize = sizeAndUnit.physicalSize;
                }
            }
            catch (e) {
                // Swallow this, keep default icon size
            }
        }
    }
    ActionsConfig.prototype.toJSON = function () {
        return {
            maxActions: this.maxActions,
            spacing: Enums.Spacing[this.spacing],
            buttonSpacing: this.buttonSpacing,
            showCard: this.showCard,
            preExpandSingleShowCardAction: this.preExpandSingleShowCardAction,
            actionsOrientation: Enums.Orientation[this.actionsOrientation],
            actionAlignment: Enums.ActionAlignment[this.actionAlignment]
        };
    };
    return ActionsConfig;
}());
exports.ActionsConfig = ActionsConfig;
var ColorSetDefinition = /** @class */ (function () {
    function ColorSetDefinition(obj) {
        this.default = new TextColorDefinition();
        this.dark = new TextColorDefinition();
        this.light = new TextColorDefinition();
        this.accent = new TextColorDefinition();
        this.good = new TextColorDefinition();
        this.warning = new TextColorDefinition();
        this.attention = new TextColorDefinition();
        this.parse(obj);
    }
    ColorSetDefinition.prototype.parseSingleColor = function (obj, propertyName) {
        if (obj) {
            this[propertyName].parse(obj[propertyName]);
        }
    };
    ColorSetDefinition.prototype.parse = function (obj) {
        if (obj) {
            this.parseSingleColor(obj, "default");
            this.parseSingleColor(obj, "dark");
            this.parseSingleColor(obj, "light");
            this.parseSingleColor(obj, "accent");
            this.parseSingleColor(obj, "good");
            this.parseSingleColor(obj, "warning");
            this.parseSingleColor(obj, "attention");
        }
    };
    return ColorSetDefinition;
}());
exports.ColorSetDefinition = ColorSetDefinition;
var ContainerStyleDefinition = /** @class */ (function () {
    function ContainerStyleDefinition(obj) {
        this.foregroundColors = new ColorSetDefinition({
            "default": { default: "#333333", subtle: "#EE333333" },
            "dark": { default: "#000000", subtle: "#66000000" },
            "light": { default: "#FFFFFF", subtle: "#33000000" },
            "accent": { default: "#2E89FC", subtle: "#882E89FC" },
            "good": { default: "#028A02", subtle: "#DD027502" },
            "warning": { default: "#E69500", subtle: "#DDE69500" },
            "attention": { default: "#CC3300", subtle: "#DDCC3300" }
        });
        this.parse(obj);
    }
    ContainerStyleDefinition.prototype.parse = function (obj) {
        if (obj) {
            this.backgroundColor = obj["backgroundColor"];
            this.foregroundColors.parse(obj["foregroundColors"]);
            this.highlightBackgroundColor = obj["highlightBackgroundColor"];
            this.highlightForegroundColor = obj["highlightForegroundColor"];
            this.borderColor = obj["borderColor"];
        }
    };
    Object.defineProperty(ContainerStyleDefinition.prototype, "isBuiltIn", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    return ContainerStyleDefinition;
}());
exports.ContainerStyleDefinition = ContainerStyleDefinition;
var BuiltInContainerStyleDefinition = /** @class */ (function (_super) {
    __extends(BuiltInContainerStyleDefinition, _super);
    function BuiltInContainerStyleDefinition() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BuiltInContainerStyleDefinition.prototype, "isBuiltIn", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    return BuiltInContainerStyleDefinition;
}(ContainerStyleDefinition));
var ContainerStyleSet = /** @class */ (function () {
    function ContainerStyleSet(obj) {
        this._allStyles = {};
        this._allStyles[Enums.ContainerStyle.Default] = new BuiltInContainerStyleDefinition();
        this._allStyles[Enums.ContainerStyle.Emphasis] = new BuiltInContainerStyleDefinition();
        this._allStyles[Enums.ContainerStyle.Accent] = new BuiltInContainerStyleDefinition();
        this._allStyles[Enums.ContainerStyle.Good] = new BuiltInContainerStyleDefinition();
        this._allStyles[Enums.ContainerStyle.Attention] = new BuiltInContainerStyleDefinition();
        this._allStyles[Enums.ContainerStyle.Warning] = new BuiltInContainerStyleDefinition();
        if (obj) {
            this._allStyles[Enums.ContainerStyle.Default].parse(obj[Enums.ContainerStyle.Default]);
            this._allStyles[Enums.ContainerStyle.Emphasis].parse(obj[Enums.ContainerStyle.Emphasis]);
            this._allStyles[Enums.ContainerStyle.Accent].parse(obj[Enums.ContainerStyle.Accent]);
            this._allStyles[Enums.ContainerStyle.Good].parse(obj[Enums.ContainerStyle.Good]);
            this._allStyles[Enums.ContainerStyle.Attention].parse(obj[Enums.ContainerStyle.Attention]);
            this._allStyles[Enums.ContainerStyle.Warning].parse(obj[Enums.ContainerStyle.Warning]);
            var customStyleArray = obj["customStyles"];
            if (customStyleArray && Array.isArray(customStyleArray)) {
                for (var _i = 0, customStyleArray_1 = customStyleArray; _i < customStyleArray_1.length; _i++) {
                    var customStyle = customStyleArray_1[_i];
                    if (customStyle) {
                        var styleName = customStyle["name"];
                        if (styleName && typeof styleName === "string") {
                            if (this._allStyles.hasOwnProperty(styleName)) {
                                this._allStyles[styleName].parse(customStyle["style"]);
                            }
                            else {
                                this._allStyles[styleName] = new ContainerStyleDefinition(customStyle["style"]);
                            }
                        }
                    }
                }
            }
        }
    }
    ContainerStyleSet.prototype.toJSON = function () {
        var _this = this;
        var customStyleArray = [];
        Object.keys(this._allStyles).forEach(function (key) {
            if (!_this._allStyles[key].isBuiltIn) {
                customStyleArray.push({
                    name: key,
                    style: _this._allStyles[key]
                });
            }
        });
        var result = {
            default: this.default,
            emphasis: this.emphasis
        };
        if (customStyleArray.length > 0) {
            result.customStyles = customStyleArray;
        }
        return result;
    };
    ContainerStyleSet.prototype.getStyleByName = function (name, defaultValue) {
        if (name && this._allStyles.hasOwnProperty(name)) {
            return this._allStyles[name];
        }
        else {
            return defaultValue ? defaultValue : this._allStyles[Enums.ContainerStyle.Default];
        }
    };
    Object.defineProperty(ContainerStyleSet.prototype, "default", {
        get: function () {
            return this._allStyles[Enums.ContainerStyle.Default];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ContainerStyleSet.prototype, "emphasis", {
        get: function () {
            return this._allStyles[Enums.ContainerStyle.Emphasis];
        },
        enumerable: false,
        configurable: true
    });
    return ContainerStyleSet;
}());
exports.ContainerStyleSet = ContainerStyleSet;
var FontTypeDefinition = /** @class */ (function () {
    function FontTypeDefinition(fontFamily) {
        this.fontFamily = "Segoe UI,Segoe,Segoe WP,Helvetica Neue,Helvetica,sans-serif";
        this.fontSizes = {
            small: 12,
            default: 14,
            medium: 17,
            large: 21,
            extraLarge: 26
        };
        this.fontWeights = {
            lighter: 200,
            default: 400,
            bolder: 600
        };
        if (fontFamily) {
            this.fontFamily = fontFamily;
        }
    }
    FontTypeDefinition.prototype.parse = function (obj) {
        this.fontFamily = obj["fontFamily"] || this.fontFamily;
        this.fontSizes = {
            small: (obj.fontSizes && obj.fontSizes["small"]) || this.fontSizes.small,
            default: (obj.fontSizes && obj.fontSizes["default"]) || this.fontSizes.default,
            medium: (obj.fontSizes && obj.fontSizes["medium"]) || this.fontSizes.medium,
            large: (obj.fontSizes && obj.fontSizes["large"]) || this.fontSizes.large,
            extraLarge: (obj.fontSizes && obj.fontSizes["extraLarge"]) || this.fontSizes.extraLarge
        };
        this.fontWeights = {
            lighter: (obj.fontWeights && obj.fontWeights["lighter"]) || this.fontWeights.lighter,
            default: (obj.fontWeights && obj.fontWeights["default"]) || this.fontWeights.default,
            bolder: (obj.fontWeights && obj.fontWeights["bolder"]) || this.fontWeights.bolder
        };
    };
    FontTypeDefinition.monospace = new FontTypeDefinition("'Courier New', Courier, monospace");
    return FontTypeDefinition;
}());
exports.FontTypeDefinition = FontTypeDefinition;
var FontTypeSet = /** @class */ (function () {
    function FontTypeSet(obj) {
        this.default = new FontTypeDefinition();
        this.monospace = new FontTypeDefinition("'Courier New', Courier, monospace");
        if (obj) {
            this.default.parse(obj["default"]);
            this.monospace.parse(obj["monospace"]);
        }
    }
    FontTypeSet.prototype.getStyleDefinition = function (style) {
        switch (style) {
            case Enums.FontType.Monospace:
                return this.monospace;
            case Enums.FontType.Default:
            default:
                return this.default;
        }
    };
    return FontTypeSet;
}());
exports.FontTypeSet = FontTypeSet;
var HostConfig = /** @class */ (function () {
    function HostConfig(obj) {
        this.hostCapabilities = new host_capabilities_1.HostCapabilities();
        this.choiceSetInputValueSeparator = ",";
        this.supportsInteractivity = true;
        this.spacing = {
            small: 3,
            default: 8,
            medium: 20,
            large: 30,
            extraLarge: 40,
            padding: 15
        };
        this.separator = {
            lineThickness: 1,
            lineColor: "#EEEEEE"
        };
        this.imageSizes = {
            small: 40,
            medium: 80,
            large: 160
        };
        this.containerStyles = new ContainerStyleSet();
        this.inputs = new InputConfig();
        this.actions = new ActionsConfig();
        this.adaptiveCard = new AdaptiveCardConfig();
        this.imageSet = new ImageSetConfig();
        this.media = new MediaConfig();
        this.factSet = new FactSetConfig();
        this.table = new TableConfig();
        this.textStyles = new TextStyleSet();
        this.textBlock = new TextBlockConfig();
        this.alwaysAllowBleed = false;
        if (obj) {
            if (typeof obj === "string" || obj instanceof String) {
                obj = JSON.parse(obj);
            }
            this.choiceSetInputValueSeparator =
                obj && typeof obj["choiceSetInputValueSeparator"] === "string"
                    ? obj["choiceSetInputValueSeparator"]
                    : this.choiceSetInputValueSeparator;
            this.supportsInteractivity =
                obj && typeof obj["supportsInteractivity"] === "boolean"
                    ? obj["supportsInteractivity"]
                    : this.supportsInteractivity;
            this._legacyFontType = new FontTypeDefinition();
            this._legacyFontType.parse(obj);
            if (obj.fontTypes) {
                this.fontTypes = new FontTypeSet(obj.fontTypes);
            }
            if (obj.lineHeights) {
                this.lineHeights = {
                    small: obj.lineHeights["small"],
                    default: obj.lineHeights["default"],
                    medium: obj.lineHeights["medium"],
                    large: obj.lineHeights["large"],
                    extraLarge: obj.lineHeights["extraLarge"]
                };
            }
            this.imageSizes = {
                small: (obj.imageSizes && obj.imageSizes["small"]) || this.imageSizes.small,
                medium: (obj.imageSizes && obj.imageSizes["medium"]) || this.imageSizes.medium,
                large: (obj.imageSizes && obj.imageSizes["large"]) || this.imageSizes.large
            };
            this.containerStyles = new ContainerStyleSet(obj["containerStyles"]);
            this.spacing = {
                small: (obj.spacing && obj.spacing["small"]) || this.spacing.small,
                default: (obj.spacing && obj.spacing["default"]) || this.spacing.default,
                medium: (obj.spacing && obj.spacing["medium"]) || this.spacing.medium,
                large: (obj.spacing && obj.spacing["large"]) || this.spacing.large,
                extraLarge: (obj.spacing && obj.spacing["extraLarge"]) || this.spacing.extraLarge,
                padding: (obj.spacing && obj.spacing["padding"]) || this.spacing.padding
            };
            this.separator = {
                lineThickness: (obj.separator && obj.separator["lineThickness"]) ||
                    this.separator.lineThickness,
                lineColor: (obj.separator && obj.separator["lineColor"]) || this.separator.lineColor
            };
            this.inputs = new InputConfig(obj.inputs || this.inputs);
            this.actions = new ActionsConfig(obj.actions || this.actions);
            this.adaptiveCard = new AdaptiveCardConfig(obj.adaptiveCard || this.adaptiveCard);
            this.imageSet = new ImageSetConfig(obj["imageSet"]);
            this.factSet = new FactSetConfig(obj["factSet"]);
            this.textStyles = new TextStyleSet(obj["textStyles"]);
            this.textBlock = new TextBlockConfig(obj["textBlock"]);
        }
    }
    HostConfig.prototype.getFontTypeDefinition = function (style) {
        if (this.fontTypes) {
            return this.fontTypes.getStyleDefinition(style);
        }
        else {
            return style === Enums.FontType.Monospace
                ? FontTypeDefinition.monospace
                : this._legacyFontType;
        }
    };
    HostConfig.prototype.getEffectiveSpacing = function (spacing) {
        switch (spacing) {
            case Enums.Spacing.Small:
                return this.spacing.small;
            case Enums.Spacing.Default:
                return this.spacing.default;
            case Enums.Spacing.Medium:
                return this.spacing.medium;
            case Enums.Spacing.Large:
                return this.spacing.large;
            case Enums.Spacing.ExtraLarge:
                return this.spacing.extraLarge;
            case Enums.Spacing.Padding:
                return this.spacing.padding;
            default:
                return 0;
        }
    };
    HostConfig.prototype.paddingDefinitionToSpacingDefinition = function (paddingDefinition) {
        return new Shared.SpacingDefinition(this.getEffectiveSpacing(paddingDefinition.top), this.getEffectiveSpacing(paddingDefinition.right), this.getEffectiveSpacing(paddingDefinition.bottom), this.getEffectiveSpacing(paddingDefinition.left));
    };
    HostConfig.prototype.makeCssClassNames = function () {
        var classNames = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            classNames[_i] = arguments[_i];
        }
        var result = [];
        for (var _a = 0, classNames_1 = classNames; _a < classNames_1.length; _a++) {
            var className = classNames_1[_a];
            result.push((this.cssClassNamePrefix ? this.cssClassNamePrefix + "-" : "") + className);
        }
        return result;
    };
    HostConfig.prototype.makeCssClassName = function () {
        var classNames = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            classNames[_i] = arguments[_i];
        }
        var result = this.makeCssClassNames.apply(this, classNames).join(" ");
        return result ? result : "";
    };
    Object.defineProperty(HostConfig.prototype, "fontFamily", {
        get: function () {
            return this._legacyFontType.fontFamily;
        },
        set: function (value) {
            this._legacyFontType.fontFamily = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HostConfig.prototype, "fontSizes", {
        get: function () {
            return this._legacyFontType.fontSizes;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HostConfig.prototype, "fontWeights", {
        get: function () {
            return this._legacyFontType.fontWeights;
        },
        enumerable: false,
        configurable: true
    });
    return HostConfig;
}());
exports.HostConfig = HostConfig;
// eslint-disable-next-line @typescript-eslint/naming-convention
exports.defaultHostConfig = new HostConfig({
    supportsInteractivity: true,
    spacing: {
        small: 10,
        default: 20,
        medium: 30,
        large: 40,
        extraLarge: 50,
        padding: 20
    },
    separator: {
        lineThickness: 1,
        lineColor: "#EEEEEE"
    },
    fontTypes: {
        default: {
            fontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
            fontSizes: {
                small: 12,
                default: 14,
                medium: 17,
                large: 21,
                extraLarge: 26
            },
            fontWeights: {
                lighter: 200,
                default: 400,
                bolder: 600
            }
        },
        monospace: {
            fontFamily: "'Courier New', Courier, monospace",
            fontSizes: {
                small: 12,
                default: 14,
                medium: 17,
                large: 21,
                extraLarge: 26
            },
            fontWeights: {
                lighter: 200,
                default: 400,
                bolder: 600
            }
        }
    },
    imageSizes: {
        small: 40,
        medium: 80,
        large: 160
    },
    containerStyles: {
        default: {
            backgroundColor: "#FFFFFF",
            foregroundColors: {
                default: {
                    default: "#333333",
                    subtle: "#EE333333"
                },
                dark: {
                    default: "#000000",
                    subtle: "#66000000"
                },
                light: {
                    default: "#FFFFFF",
                    subtle: "#33000000"
                },
                accent: {
                    default: "#2E89FC",
                    subtle: "#882E89FC"
                },
                attention: {
                    default: "#cc3300",
                    subtle: "#DDcc3300"
                },
                good: {
                    default: "#028A02",
                    subtle: "#DD027502"
                },
                warning: {
                    default: "#e69500",
                    subtle: "#DDe69500"
                }
            }
        },
        emphasis: {
            backgroundColor: "#08000000",
            foregroundColors: {
                default: {
                    default: "#333333",
                    subtle: "#EE333333"
                },
                dark: {
                    default: "#000000",
                    subtle: "#66000000"
                },
                light: {
                    default: "#FFFFFF",
                    subtle: "#33000000"
                },
                accent: {
                    default: "#2E89FC",
                    subtle: "#882E89FC"
                },
                attention: {
                    default: "#cc3300",
                    subtle: "#DDcc3300"
                },
                good: {
                    default: "#028A02",
                    subtle: "#DD027502"
                },
                warning: {
                    default: "#e69500",
                    subtle: "#DDe69500"
                }
            }
        },
        accent: {
            backgroundColor: "#C7DEF9",
            foregroundColors: {
                default: {
                    default: "#333333",
                    subtle: "#EE333333"
                },
                dark: {
                    default: "#000000",
                    subtle: "#66000000"
                },
                light: {
                    default: "#FFFFFF",
                    subtle: "#33000000"
                },
                accent: {
                    default: "#2E89FC",
                    subtle: "#882E89FC"
                },
                attention: {
                    default: "#cc3300",
                    subtle: "#DDcc3300"
                },
                good: {
                    default: "#028A02",
                    subtle: "#DD027502"
                },
                warning: {
                    default: "#e69500",
                    subtle: "#DDe69500"
                }
            }
        },
        good: {
            backgroundColor: "#CCFFCC",
            foregroundColors: {
                default: {
                    default: "#333333",
                    subtle: "#EE333333"
                },
                dark: {
                    default: "#000000",
                    subtle: "#66000000"
                },
                light: {
                    default: "#FFFFFF",
                    subtle: "#33000000"
                },
                accent: {
                    default: "#2E89FC",
                    subtle: "#882E89FC"
                },
                attention: {
                    default: "#cc3300",
                    subtle: "#DDcc3300"
                },
                good: {
                    default: "#028A02",
                    subtle: "#DD027502"
                },
                warning: {
                    default: "#e69500",
                    subtle: "#DDe69500"
                }
            }
        },
        attention: {
            backgroundColor: "#FFC5B2",
            foregroundColors: {
                default: {
                    default: "#333333",
                    subtle: "#EE333333"
                },
                dark: {
                    default: "#000000",
                    subtle: "#66000000"
                },
                light: {
                    default: "#FFFFFF",
                    subtle: "#33000000"
                },
                accent: {
                    default: "#2E89FC",
                    subtle: "#882E89FC"
                },
                attention: {
                    default: "#cc3300",
                    subtle: "#DDcc3300"
                },
                good: {
                    default: "#028A02",
                    subtle: "#DD027502"
                },
                warning: {
                    default: "#e69500",
                    subtle: "#DDe69500"
                }
            }
        },
        warning: {
            backgroundColor: "#FFE2B2",
            foregroundColors: {
                default: {
                    default: "#333333",
                    subtle: "#EE333333"
                },
                dark: {
                    default: "#000000",
                    subtle: "#66000000"
                },
                light: {
                    default: "#FFFFFF",
                    subtle: "#33000000"
                },
                accent: {
                    default: "#2E89FC",
                    subtle: "#882E89FC"
                },
                attention: {
                    default: "#cc3300",
                    subtle: "#DDcc3300"
                },
                good: {
                    default: "#028A02",
                    subtle: "#DD027502"
                },
                warning: {
                    default: "#e69500",
                    subtle: "#DDe69500"
                }
            }
        }
    },
    inputs: {
        label: {
            requiredInputs: {
                weight: Enums.TextWeight.Bolder,
                suffix: " *",
                suffixColor: Enums.TextColor.Attention
            },
            optionalInputs: {
                weight: Enums.TextWeight.Bolder
            }
        },
        errorMessage: {
            color: Enums.TextColor.Attention,
            weight: Enums.TextWeight.Bolder
        }
    },
    actions: {
        maxActions: 5,
        spacing: Enums.Spacing.Default,
        buttonSpacing: 10,
        showCard: {
            actionMode: Enums.ShowCardActionMode.Inline,
            inlineTopMargin: 16
        },
        actionsOrientation: Enums.Orientation.Horizontal,
        actionAlignment: Enums.ActionAlignment.Left
    },
    adaptiveCard: {
        allowCustomStyle: false
    },
    imageSet: {
        imageSize: Enums.Size.Medium,
        maxImageHeight: 100
    },
    factSet: {
        title: {
            color: Enums.TextColor.Default,
            size: Enums.TextSize.Default,
            isSubtle: false,
            weight: Enums.TextWeight.Bolder,
            wrap: true,
            maxWidth: 150
        },
        value: {
            color: Enums.TextColor.Default,
            size: Enums.TextSize.Default,
            isSubtle: false,
            weight: Enums.TextWeight.Default,
            wrap: true
        },
        spacing: 10
    }
});
//# sourceMappingURL=host-config.js.map

/***/ }),

/***/ "../adaptivecards/lib/registry.js":
/*!****************************************!*\
  !*** ../adaptivecards/lib/registry.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GlobalRegistry = exports.CardObjectRegistry = exports.ElementSingletonBehavior = void 0;
var serialization_1 = __webpack_require__(/*! ./serialization */ "../adaptivecards/lib/serialization.js");
/**
 * Describes whether a certain element can be parsed in a "singleton" context.
 * Specifically, is the element allowed to exist as an object in a context where the
 * parent expects an Array of elements (e.g. `AdaptiveCard.body`)
 *
 * @example - Singleton element in a container (note `items` contains an `object` rather than an `Array<object>`)
 * ```json
 * {
 *     "type": "Container",
 *     "items": {
 *         "type": "AllowedSingletonElement"
 *     }
 * }
 * ```
 */
var ElementSingletonBehavior;
(function (ElementSingletonBehavior) {
    /** Element only valid in a singleton context. */
    ElementSingletonBehavior[ElementSingletonBehavior["Only"] = 0] = "Only";
    /** Element is allowed in a singleton context, but not required to be a singleton. */
    ElementSingletonBehavior[ElementSingletonBehavior["Allowed"] = 1] = "Allowed";
    /** Element is not allowed to exist in a singleton context. */
    ElementSingletonBehavior[ElementSingletonBehavior["NotAllowed"] = 2] = "NotAllowed";
})(ElementSingletonBehavior = exports.ElementSingletonBehavior || (exports.ElementSingletonBehavior = {}));
var CardObjectRegistry = /** @class */ (function () {
    function CardObjectRegistry() {
        this._items = {};
    }
    CardObjectRegistry.prototype.findByName = function (typeName) {
        return this._items.hasOwnProperty(typeName) ? this._items[typeName] : undefined;
    };
    CardObjectRegistry.prototype.clear = function () {
        this._items = {};
    };
    CardObjectRegistry.prototype.copyTo = function (target) {
        var keys = Object.keys(this._items);
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            var typeRegistration = this._items[key];
            target.register(typeRegistration.typeName, typeRegistration.objectType, typeRegistration.schemaVersion, typeRegistration.singletonBehavior);
        }
    };
    CardObjectRegistry.prototype.register = function (typeName, objectType, schemaVersion, singletonBehavior) {
        if (schemaVersion === void 0) { schemaVersion = serialization_1.Versions.v1_0; }
        if (singletonBehavior === void 0) { singletonBehavior = ElementSingletonBehavior.NotAllowed; }
        var registrationInfo = this.findByName(typeName);
        if (registrationInfo !== undefined) {
            registrationInfo.objectType = objectType;
        }
        else {
            registrationInfo = {
                typeName: typeName,
                objectType: objectType,
                schemaVersion: schemaVersion,
                singletonBehavior: singletonBehavior
            };
        }
        this._items[typeName] = registrationInfo;
    };
    CardObjectRegistry.prototype.unregister = function (typeName) {
        delete this._items[typeName];
    };
    CardObjectRegistry.prototype.createInstance = function (typeName, targetVersion) {
        var registrationInfo = this.findByName(typeName);
        return registrationInfo && registrationInfo.schemaVersion.compareTo(targetVersion) <= 0
            ? new registrationInfo.objectType()
            : undefined;
    };
    CardObjectRegistry.prototype.getItemCount = function () {
        return Object.keys(this._items).length;
    };
    CardObjectRegistry.prototype.getItemAt = function (index) {
        var _this = this;
        return Object.keys(this._items).map(function (e) { return _this._items[e]; })[index];
    };
    return CardObjectRegistry;
}());
exports.CardObjectRegistry = CardObjectRegistry;
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
var GlobalRegistry = /** @class */ (function () {
    function GlobalRegistry() {
    }
    GlobalRegistry.populateWithDefaultElements = function (registry) {
        registry.clear();
        GlobalRegistry.defaultElements.copyTo(registry);
    };
    GlobalRegistry.populateWithDefaultActions = function (registry) {
        registry.clear();
        GlobalRegistry.defaultActions.copyTo(registry);
    };
    Object.defineProperty(GlobalRegistry, "elements", {
        get: function () {
            if (!GlobalRegistry._elements) {
                GlobalRegistry._elements = new CardObjectRegistry();
                GlobalRegistry.populateWithDefaultElements(GlobalRegistry._elements);
            }
            return GlobalRegistry._elements;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GlobalRegistry, "actions", {
        get: function () {
            if (!GlobalRegistry._actions) {
                GlobalRegistry._actions = new CardObjectRegistry();
                GlobalRegistry.populateWithDefaultActions(GlobalRegistry._actions);
            }
            return GlobalRegistry._actions;
        },
        enumerable: false,
        configurable: true
    });
    GlobalRegistry.reset = function () {
        GlobalRegistry._elements = undefined;
        GlobalRegistry._actions = undefined;
    };
    GlobalRegistry.defaultElements = new CardObjectRegistry();
    GlobalRegistry.defaultActions = new CardObjectRegistry();
    return GlobalRegistry;
}());
exports.GlobalRegistry = GlobalRegistry;
//# sourceMappingURL=registry.js.map

/***/ }),

/***/ "../adaptivecards/lib/serialization.js":
/*!*********************************************!*\
  !*** ../adaptivecards/lib/serialization.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SerializableObject = exports.property = exports.SerializableObjectSchema = exports.CustomProperty = exports.SerializableObjectCollectionProperty = exports.SerializableObjectProperty = exports.EnumProperty = exports.ValueSetProperty = exports.StringArrayProperty = exports.PixelSizeProperty = exports.NumProperty = exports.BoolProperty = exports.StringProperty = exports.PropertyDefinition = exports.BaseSerializationContext = exports.isVersionLessOrEqual = exports.Versions = exports.Version = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var shared_1 = __webpack_require__(/*! ./shared */ "../adaptivecards/lib/shared.js");
var Utils = __webpack_require__(/*! ./utils */ "../adaptivecards/lib/utils.js");
var Enums = __webpack_require__(/*! ./enums */ "../adaptivecards/lib/enums.js");
var strings_1 = __webpack_require__(/*! ./strings */ "../adaptivecards/lib/strings.js");
var Version = /** @class */ (function () {
    function Version(major, minor, label) {
        if (major === void 0) { major = 1; }
        if (minor === void 0) { minor = 1; }
        this._isValid = true;
        this._major = major;
        this._minor = minor;
        this._label = label;
    }
    Version.parse = function (versionString, context) {
        if (!versionString) {
            return undefined;
        }
        var result = new Version();
        result._versionString = versionString;
        var regEx = /(\d+).(\d+)/gi;
        var matches = regEx.exec(versionString);
        if (matches != null && matches.length === 3) {
            result._major = parseInt(matches[1]);
            result._minor = parseInt(matches[2]);
        }
        else {
            result._isValid = false;
        }
        if (!result._isValid) {
            context.logParseEvent(undefined, Enums.ValidationEvent.InvalidPropertyValue, strings_1.Strings.errors.invalidVersionString(result._versionString));
        }
        return result;
    };
    Version.prototype.toString = function () {
        return !this._isValid ? this._versionString : this._major + "." + this._minor;
    };
    Version.prototype.toJSON = function () {
        return this.toString();
    };
    Version.prototype.compareTo = function (otherVersion) {
        if (!this.isValid || !otherVersion.isValid) {
            throw new Error("Cannot compare invalid version.");
        }
        if (this.major > otherVersion.major) {
            return 1;
        }
        else if (this.major < otherVersion.major) {
            return -1;
        }
        else if (this.minor > otherVersion.minor) {
            return 1;
        }
        else if (this.minor < otherVersion.minor) {
            return -1;
        }
        return 0;
    };
    Object.defineProperty(Version.prototype, "label", {
        get: function () {
            return this._label ? this._label : this.toString();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Version.prototype, "major", {
        get: function () {
            return this._major;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Version.prototype, "minor", {
        get: function () {
            return this._minor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Version.prototype, "isValid", {
        get: function () {
            return this._isValid;
        },
        enumerable: false,
        configurable: true
    });
    return Version;
}());
exports.Version = Version;
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
var Versions = /** @class */ (function () {
    function Versions() {
    }
    /* eslint-enable @typescript-eslint/naming-convention */
    Versions.getAllDeclaredVersions = function () {
        var ctor = Versions;
        var properties = [];
        for (var propertyName in ctor) {
            if (propertyName.match(/^v[0-9_]*$/)) {
                // filter latest
                try {
                    var propertyValue = ctor[propertyName];
                    if (propertyValue instanceof Version) {
                        properties.push(propertyValue);
                    }
                }
                catch (_a) {
                    // If a property happens to have a getter function and
                    // it throws an exception, we need to catch it here
                }
            }
        }
        return properties.sort(function (v1, v2) { return v1.compareTo(v2); });
    };
    /* eslint-disable @typescript-eslint/naming-convention */
    Versions.v1_0 = new Version(1, 0);
    Versions.v1_1 = new Version(1, 1);
    Versions.v1_2 = new Version(1, 2);
    Versions.v1_3 = new Version(1, 3);
    Versions.v1_4 = new Version(1, 4);
    Versions.v1_5 = new Version(1, 5);
    // If preview tag is added/removed from any version,
    // don't forget to update .ac-schema-version-1-?::after too in adaptivecards-site\themes\adaptivecards\source\css\style.css
    Versions.v1_6 = new Version(1, 6, "1.6 Preview");
    Versions.latest = Versions.v1_5;
    return Versions;
}());
exports.Versions = Versions;
function isVersionLessOrEqual(version, targetVersion) {
    if (version instanceof Version) {
        if (targetVersion instanceof Version) {
            return targetVersion.compareTo(version) >= 0;
        }
        else {
            // Target version is *
            return true;
        }
    }
    else {
        // Version is *
        return true;
    }
}
exports.isVersionLessOrEqual = isVersionLessOrEqual;
var BaseSerializationContext = /** @class */ (function () {
    function BaseSerializationContext(targetVersion) {
        if (targetVersion === void 0) { targetVersion = Versions.latest; }
        this._validationEvents = [];
        this.targetVersion = targetVersion;
    }
    BaseSerializationContext.prototype.serializeValue = function (target, propertyName, propertyValue, defaultValue, forceDeleteIfNullOrDefault) {
        if (defaultValue === void 0) { defaultValue = undefined; }
        if (forceDeleteIfNullOrDefault === void 0) { forceDeleteIfNullOrDefault = false; }
        if (propertyValue === null ||
            propertyValue === undefined ||
            propertyValue === defaultValue) {
            if (!shared_1.GlobalSettings.enableFullJsonRoundTrip || forceDeleteIfNullOrDefault) {
                delete target[propertyName];
            }
        }
        else if (propertyValue === defaultValue) {
            delete target[propertyName];
        }
        else {
            target[propertyName] = propertyValue;
        }
    };
    BaseSerializationContext.prototype.serializeString = function (target, propertyName, propertyValue, defaultValue) {
        if (propertyValue === null ||
            propertyValue === undefined ||
            propertyValue === defaultValue) {
            if (!shared_1.GlobalSettings.enableFullJsonRoundTrip) {
                delete target[propertyName];
            }
        }
        else {
            target[propertyName] = propertyValue;
        }
    };
    BaseSerializationContext.prototype.serializeBool = function (target, propertyName, propertyValue, defaultValue) {
        if (propertyValue === null ||
            propertyValue === undefined ||
            propertyValue === defaultValue) {
            if (!shared_1.GlobalSettings.enableFullJsonRoundTrip) {
                delete target[propertyName];
            }
        }
        else {
            target[propertyName] = propertyValue;
        }
    };
    BaseSerializationContext.prototype.serializeNumber = function (target, propertyName, propertyValue, defaultValue) {
        if (propertyValue === null ||
            propertyValue === undefined ||
            propertyValue === defaultValue ||
            isNaN(propertyValue)) {
            if (!shared_1.GlobalSettings.enableFullJsonRoundTrip) {
                delete target[propertyName];
            }
        }
        else {
            target[propertyName] = propertyValue;
        }
    };
    BaseSerializationContext.prototype.serializeEnum = function (enumType, target, propertyName, propertyValue, defaultValue) {
        if (defaultValue === void 0) { defaultValue = undefined; }
        if (propertyValue === null ||
            propertyValue === undefined ||
            propertyValue === defaultValue) {
            if (!shared_1.GlobalSettings.enableFullJsonRoundTrip) {
                delete target[propertyName];
            }
        }
        else {
            target[propertyName] = enumType[propertyValue];
        }
    };
    BaseSerializationContext.prototype.serializeArray = function (target, propertyName, propertyValue) {
        var items = [];
        if (propertyValue) {
            for (var _i = 0, propertyValue_1 = propertyValue; _i < propertyValue_1.length; _i++) {
                var item = propertyValue_1[_i];
                var serializedItem = undefined;
                if (item instanceof SerializableObject) {
                    serializedItem = item.toJSON(this);
                }
                else if (item.toJSON) {
                    serializedItem = item.toJSON();
                }
                else {
                    serializedItem = item;
                }
                if (serializedItem !== undefined) {
                    items.push(serializedItem);
                }
            }
        }
        if (items.length === 0) {
            if (target.hasOwnProperty(propertyName) && Array.isArray(target[propertyName])) {
                delete target[propertyName];
            }
        }
        else {
            this.serializeValue(target, propertyName, items);
        }
    };
    BaseSerializationContext.prototype.clearEvents = function () {
        this._validationEvents = [];
    };
    BaseSerializationContext.prototype.logEvent = function (source, phase, event, message) {
        this._validationEvents.push({
            source: source,
            phase: phase,
            event: event,
            message: message
        });
    };
    BaseSerializationContext.prototype.logParseEvent = function (source, event, message) {
        this.logEvent(source, Enums.ValidationPhase.Parse, event, message);
    };
    BaseSerializationContext.prototype.getEventAt = function (index) {
        return this._validationEvents[index];
    };
    Object.defineProperty(BaseSerializationContext.prototype, "eventCount", {
        get: function () {
            return this._validationEvents.length;
        },
        enumerable: false,
        configurable: true
    });
    return BaseSerializationContext;
}());
exports.BaseSerializationContext = BaseSerializationContext;
var SimpleSerializationContext = /** @class */ (function (_super) {
    __extends(SimpleSerializationContext, _super);
    function SimpleSerializationContext() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SimpleSerializationContext;
}(BaseSerializationContext));
var PropertyDefinition = /** @class */ (function () {
    function PropertyDefinition(targetVersion, name, defaultValue, onGetInitialValue) {
        this.targetVersion = targetVersion;
        this.name = name;
        this.defaultValue = defaultValue;
        this.onGetInitialValue = onGetInitialValue;
        this.isSerializationEnabled = true;
        this.sequentialNumber = PropertyDefinition._sequentialNumber;
        PropertyDefinition._sequentialNumber++;
    }
    PropertyDefinition.prototype.getInternalName = function () {
        return this.name;
    };
    PropertyDefinition.prototype.parse = function (sender, source, context) {
        return source[this.name];
    };
    PropertyDefinition.prototype.toJSON = function (sender, target, value, context) {
        context.serializeValue(target, this.name, value, this.defaultValue);
    };
    PropertyDefinition._sequentialNumber = 0;
    return PropertyDefinition;
}());
exports.PropertyDefinition = PropertyDefinition;
var StringProperty = /** @class */ (function (_super) {
    __extends(StringProperty, _super);
    function StringProperty(targetVersion, name, treatEmptyAsUndefined, regEx, defaultValue, onGetInitialValue) {
        if (treatEmptyAsUndefined === void 0) { treatEmptyAsUndefined = true; }
        var _this = _super.call(this, targetVersion, name, defaultValue, onGetInitialValue) || this;
        _this.targetVersion = targetVersion;
        _this.name = name;
        _this.treatEmptyAsUndefined = treatEmptyAsUndefined;
        _this.regEx = regEx;
        _this.defaultValue = defaultValue;
        _this.onGetInitialValue = onGetInitialValue;
        return _this;
    }
    StringProperty.prototype.parse = function (sender, source, context) {
        var parsedValue = Utils.parseString(source[this.name], this.defaultValue);
        var isUndefined = parsedValue === undefined || (parsedValue === "" && this.treatEmptyAsUndefined);
        if (!isUndefined && this.regEx !== undefined) {
            var matches = this.regEx.exec(parsedValue);
            if (!matches) {
                context.logParseEvent(sender, Enums.ValidationEvent.InvalidPropertyValue, strings_1.Strings.errors.invalidPropertyValue(parsedValue, this.name));
                return undefined;
            }
        }
        return parsedValue;
    };
    StringProperty.prototype.toJSON = function (sender, target, value, context) {
        context.serializeString(target, this.name, value === "" && this.treatEmptyAsUndefined ? undefined : value, this.defaultValue);
    };
    return StringProperty;
}(PropertyDefinition));
exports.StringProperty = StringProperty;
var BoolProperty = /** @class */ (function (_super) {
    __extends(BoolProperty, _super);
    function BoolProperty(targetVersion, name, defaultValue, onGetInitialValue) {
        var _this = _super.call(this, targetVersion, name, defaultValue, onGetInitialValue) || this;
        _this.targetVersion = targetVersion;
        _this.name = name;
        _this.defaultValue = defaultValue;
        _this.onGetInitialValue = onGetInitialValue;
        return _this;
    }
    BoolProperty.prototype.parse = function (sender, source, context) {
        return Utils.parseBool(source[this.name], this.defaultValue);
    };
    BoolProperty.prototype.toJSON = function (sender, target, value, context) {
        context.serializeBool(target, this.name, value, this.defaultValue);
    };
    return BoolProperty;
}(PropertyDefinition));
exports.BoolProperty = BoolProperty;
var NumProperty = /** @class */ (function (_super) {
    __extends(NumProperty, _super);
    function NumProperty(targetVersion, name, defaultValue, onGetInitialValue) {
        var _this = _super.call(this, targetVersion, name, defaultValue, onGetInitialValue) || this;
        _this.targetVersion = targetVersion;
        _this.name = name;
        _this.defaultValue = defaultValue;
        _this.onGetInitialValue = onGetInitialValue;
        return _this;
    }
    NumProperty.prototype.parse = function (sender, source, context) {
        return Utils.parseNumber(source[this.name], this.defaultValue);
    };
    NumProperty.prototype.toJSON = function (sender, target, value, context) {
        context.serializeNumber(target, this.name, value, this.defaultValue);
    };
    return NumProperty;
}(PropertyDefinition));
exports.NumProperty = NumProperty;
var PixelSizeProperty = /** @class */ (function (_super) {
    __extends(PixelSizeProperty, _super);
    function PixelSizeProperty() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PixelSizeProperty.prototype.parse = function (sender, source, context) {
        var result = undefined;
        var value = source[this.name];
        if (typeof value === "string") {
            var isValid = false;
            try {
                var size = shared_1.SizeAndUnit.parse(value, true);
                if (size.unit === Enums.SizeUnit.Pixel) {
                    result = size.physicalSize;
                    isValid = true;
                }
            }
            catch (_a) {
                // Do nothing. A parse error is emitted below
            }
            if (!isValid) {
                context.logParseEvent(sender, Enums.ValidationEvent.InvalidPropertyValue, strings_1.Strings.errors.invalidPropertyValue(source[this.name], "minHeight"));
            }
        }
        return result;
    };
    PixelSizeProperty.prototype.toJSON = function (sender, target, value, context) {
        context.serializeValue(target, this.name, typeof value === "number" && !isNaN(value) ? value + "px" : undefined);
    };
    return PixelSizeProperty;
}(PropertyDefinition));
exports.PixelSizeProperty = PixelSizeProperty;
var StringArrayProperty = /** @class */ (function (_super) {
    __extends(StringArrayProperty, _super);
    function StringArrayProperty(targetVersion, name, defaultValue, onGetInitialValue) {
        var _this = _super.call(this, targetVersion, name, defaultValue, onGetInitialValue) || this;
        _this.targetVersion = targetVersion;
        _this.name = name;
        _this.defaultValue = defaultValue;
        _this.onGetInitialValue = onGetInitialValue;
        return _this;
    }
    StringArrayProperty.prototype.parse = function (sender, source, context) {
        var sourceValue = source[this.name];
        if (sourceValue === undefined || !Array.isArray(sourceValue)) {
            return this.defaultValue;
        }
        var result = [];
        for (var _i = 0, sourceValue_1 = sourceValue; _i < sourceValue_1.length; _i++) {
            var value = sourceValue_1[_i];
            if (typeof value === "string") {
                result.push(value);
            }
            else {
                context.logParseEvent(sender, Enums.ValidationEvent.InvalidPropertyValue, "Invalid array value \"".concat(JSON.stringify(value), "\" of type \"").concat(typeof value, "\" ignored for \"").concat(this.name, "\"."));
            }
        }
        return result;
    };
    StringArrayProperty.prototype.toJSON = function (sender, target, value, context) {
        context.serializeArray(target, this.name, value);
    };
    return StringArrayProperty;
}(PropertyDefinition));
exports.StringArrayProperty = StringArrayProperty;
var ValueSetProperty = /** @class */ (function (_super) {
    __extends(ValueSetProperty, _super);
    function ValueSetProperty(targetVersion, name, values, defaultValue, onGetInitialValue) {
        var _this = _super.call(this, targetVersion, name, defaultValue, onGetInitialValue) || this;
        _this.targetVersion = targetVersion;
        _this.name = name;
        _this.values = values;
        _this.defaultValue = defaultValue;
        _this.onGetInitialValue = onGetInitialValue;
        return _this;
    }
    ValueSetProperty.prototype.isValidValue = function (value, context) {
        for (var _i = 0, _a = this.values; _i < _a.length; _i++) {
            var versionedValue = _a[_i];
            if (value.toLowerCase() === versionedValue.value.toLowerCase()) {
                var targetVersion = versionedValue.targetVersion
                    ? versionedValue.targetVersion
                    : this.targetVersion;
                return targetVersion.compareTo(context.targetVersion) <= 0;
            }
        }
        return false;
    };
    ValueSetProperty.prototype.parse = function (sender, source, context) {
        var sourceValue = source[this.name];
        if (sourceValue === undefined) {
            return this.defaultValue;
        }
        if (typeof sourceValue === "string") {
            for (var _i = 0, _a = this.values; _i < _a.length; _i++) {
                var versionedValue = _a[_i];
                if (sourceValue.toLowerCase() === versionedValue.value.toLowerCase()) {
                    var targetVersion = versionedValue.targetVersion
                        ? versionedValue.targetVersion
                        : this.targetVersion;
                    if (targetVersion.compareTo(context.targetVersion) <= 0) {
                        return versionedValue.value;
                    }
                    else {
                        context.logParseEvent(sender, Enums.ValidationEvent.InvalidPropertyValue, strings_1.Strings.errors.propertyValueNotSupported(sourceValue, this.name, targetVersion.toString(), context.targetVersion.toString()));
                        return this.defaultValue;
                    }
                }
            }
        }
        context.logParseEvent(sender, Enums.ValidationEvent.InvalidPropertyValue, strings_1.Strings.errors.invalidPropertyValue(sourceValue, this.name));
        return this.defaultValue;
    };
    ValueSetProperty.prototype.toJSON = function (sender, target, value, context) {
        var invalidValue = false;
        if (value !== undefined) {
            invalidValue = true;
            for (var _i = 0, _a = this.values; _i < _a.length; _i++) {
                var versionedValue = _a[_i];
                if (versionedValue.value === value) {
                    var targetVersion = versionedValue.targetVersion
                        ? versionedValue.targetVersion
                        : this.targetVersion;
                    if (targetVersion.compareTo(context.targetVersion) <= 0) {
                        invalidValue = false;
                        break;
                    }
                    else {
                        context.logEvent(sender, Enums.ValidationPhase.ToJSON, Enums.ValidationEvent.InvalidPropertyValue, strings_1.Strings.errors.propertyValueNotSupported(value, this.name, targetVersion.toString(), context.targetVersion.toString()));
                    }
                }
            }
        }
        if (!invalidValue) {
            context.serializeValue(target, this.name, value, this.defaultValue, true);
        }
    };
    return ValueSetProperty;
}(PropertyDefinition));
exports.ValueSetProperty = ValueSetProperty;
var EnumProperty = /** @class */ (function (_super) {
    __extends(EnumProperty, _super);
    function EnumProperty(targetVersion, name, enumType, defaultValue, values, onGetInitialValue) {
        var _this = _super.call(this, targetVersion, name, defaultValue, onGetInitialValue) || this;
        _this.targetVersion = targetVersion;
        _this.name = name;
        _this.enumType = enumType;
        _this.defaultValue = defaultValue;
        _this.onGetInitialValue = onGetInitialValue;
        _this._values = [];
        if (!values) {
            // eslint-disable-next-line guard-for-in
            for (var key in enumType) {
                var keyAsNumber = parseInt(key, 10);
                if (keyAsNumber >= 0) {
                    _this._values.push({ value: keyAsNumber });
                }
            }
        }
        else {
            _this._values = values;
        }
        return _this;
    }
    EnumProperty.prototype.parse = function (sender, source, context) {
        var sourceValue = source[this.name];
        if (typeof sourceValue !== "string") {
            return this.defaultValue;
        }
        var enumValue = Utils.getEnumValueByName(this.enumType, sourceValue);
        if (enumValue !== undefined) {
            for (var _i = 0, _a = this.values; _i < _a.length; _i++) {
                var versionedValue = _a[_i];
                if (versionedValue.value === enumValue) {
                    var targetVersion = versionedValue.targetVersion
                        ? versionedValue.targetVersion
                        : this.targetVersion;
                    if (targetVersion.compareTo(context.targetVersion) <= 0) {
                        return enumValue;
                    }
                    else {
                        context.logParseEvent(sender, Enums.ValidationEvent.InvalidPropertyValue, strings_1.Strings.errors.propertyValueNotSupported(sourceValue, this.name, targetVersion.toString(), context.targetVersion.toString()));
                        return this.defaultValue;
                    }
                }
            }
        }
        context.logParseEvent(sender, Enums.ValidationEvent.InvalidPropertyValue, strings_1.Strings.errors.invalidPropertyValue(sourceValue, this.name));
        return this.defaultValue;
    };
    EnumProperty.prototype.toJSON = function (sender, target, value, context) {
        var invalidValue = false;
        if (value !== undefined) {
            invalidValue = true;
            for (var _i = 0, _a = this.values; _i < _a.length; _i++) {
                var versionedValue = _a[_i];
                if (versionedValue.value === value) {
                    var targetVersion = versionedValue.targetVersion
                        ? versionedValue.targetVersion
                        : this.targetVersion;
                    if (targetVersion.compareTo(context.targetVersion) <= 0) {
                        invalidValue = false;
                        break;
                    }
                    else {
                        context.logEvent(sender, Enums.ValidationPhase.ToJSON, Enums.ValidationEvent.InvalidPropertyValue, strings_1.Strings.errors.invalidPropertyValue(value, this.name));
                    }
                }
            }
        }
        if (!invalidValue) {
            context.serializeEnum(this.enumType, target, this.name, value, this.defaultValue);
        }
    };
    Object.defineProperty(EnumProperty.prototype, "values", {
        get: function () {
            return this._values;
        },
        enumerable: false,
        configurable: true
    });
    return EnumProperty;
}(PropertyDefinition));
exports.EnumProperty = EnumProperty;
var SerializableObjectProperty = /** @class */ (function (_super) {
    __extends(SerializableObjectProperty, _super);
    function SerializableObjectProperty(targetVersion, name, objectType, nullable, defaultValue) {
        if (nullable === void 0) { nullable = false; }
        var _this = _super.call(this, targetVersion, name, defaultValue, function (sender) {
            return _this.nullable ? undefined : new _this.objectType();
        }) || this;
        _this.targetVersion = targetVersion;
        _this.name = name;
        _this.objectType = objectType;
        _this.nullable = nullable;
        return _this;
    }
    SerializableObjectProperty.prototype.parse = function (sender, source, context) {
        var sourceValue = source[this.name];
        if (sourceValue === undefined) {
            return this.onGetInitialValue ? this.onGetInitialValue(sender) : this.defaultValue;
        }
        var result = new this.objectType();
        result.parse(sourceValue, context);
        return result;
    };
    SerializableObjectProperty.prototype.toJSON = function (sender, target, value, context) {
        var serializedValue = undefined;
        if (value !== undefined && !value.hasAllDefaultValues()) {
            serializedValue = value.toJSON(context);
        }
        if (typeof serializedValue === "object" && Object.keys(serializedValue).length === 0) {
            serializedValue = undefined;
        }
        context.serializeValue(target, this.name, serializedValue, this.defaultValue, true);
    };
    return SerializableObjectProperty;
}(PropertyDefinition));
exports.SerializableObjectProperty = SerializableObjectProperty;
var SerializableObjectCollectionProperty = /** @class */ (function (_super) {
    __extends(SerializableObjectCollectionProperty, _super);
    function SerializableObjectCollectionProperty(targetVersion, name, objectType, onItemAdded) {
        var _this = _super.call(this, targetVersion, name, undefined, function (sender) {
            return [];
        }) || this;
        _this.targetVersion = targetVersion;
        _this.name = name;
        _this.objectType = objectType;
        _this.onItemAdded = onItemAdded;
        return _this;
    }
    SerializableObjectCollectionProperty.prototype.parse = function (sender, source, context) {
        var result = [];
        var sourceCollection = source[this.name];
        if (Array.isArray(sourceCollection)) {
            for (var _i = 0, sourceCollection_1 = sourceCollection; _i < sourceCollection_1.length; _i++) {
                var sourceItem = sourceCollection_1[_i];
                var item = new this.objectType();
                item.parse(sourceItem, context);
                result.push(item);
                if (this.onItemAdded) {
                    this.onItemAdded(sender, item);
                }
            }
        }
        return result.length > 0
            ? result
            : this.onGetInitialValue
                ? this.onGetInitialValue(sender)
                : undefined;
    };
    SerializableObjectCollectionProperty.prototype.toJSON = function (sender, target, value, context) {
        context.serializeArray(target, this.name, value);
    };
    return SerializableObjectCollectionProperty;
}(PropertyDefinition));
exports.SerializableObjectCollectionProperty = SerializableObjectCollectionProperty;
var CustomProperty = /** @class */ (function (_super) {
    __extends(CustomProperty, _super);
    function CustomProperty(targetVersion, name, onParse, onToJSON, defaultValue, onGetInitialValue) {
        var _this = _super.call(this, targetVersion, name, defaultValue, onGetInitialValue) || this;
        _this.targetVersion = targetVersion;
        _this.name = name;
        _this.onParse = onParse;
        _this.onToJSON = onToJSON;
        _this.defaultValue = defaultValue;
        _this.onGetInitialValue = onGetInitialValue;
        if (!_this.onParse) {
            throw new Error("CustomPropertyDefinition instances must have an onParse handler.");
        }
        if (!_this.onToJSON) {
            throw new Error("CustomPropertyDefinition instances must have an onToJSON handler.");
        }
        return _this;
    }
    CustomProperty.prototype.parse = function (sender, source, context) {
        return this.onParse(sender, this, source, context);
    };
    CustomProperty.prototype.toJSON = function (sender, target, value, context) {
        this.onToJSON(sender, this, target, value, context);
    };
    return CustomProperty;
}(PropertyDefinition));
exports.CustomProperty = CustomProperty;
var SerializableObjectSchema = /** @class */ (function () {
    function SerializableObjectSchema() {
        this._properties = [];
    }
    SerializableObjectSchema.prototype.indexOf = function (prop) {
        for (var i = 0; i < this._properties.length; i++) {
            if (this._properties[i] === prop) {
                return i;
            }
        }
        return -1;
    };
    SerializableObjectSchema.prototype.add = function () {
        var properties = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            properties[_i] = arguments[_i];
        }
        for (var _a = 0, properties_1 = properties; _a < properties_1.length; _a++) {
            var prop = properties_1[_a];
            if (this.indexOf(prop) === -1) {
                this._properties.push(prop);
            }
        }
    };
    SerializableObjectSchema.prototype.remove = function () {
        var properties = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            properties[_i] = arguments[_i];
        }
        for (var _a = 0, properties_2 = properties; _a < properties_2.length; _a++) {
            var prop = properties_2[_a];
            while (true) {
                var index = this.indexOf(prop);
                if (index >= 0) {
                    this._properties.splice(index, 1);
                }
                else {
                    break;
                }
            }
        }
    };
    SerializableObjectSchema.prototype.getItemAt = function (index) {
        return this._properties[index];
    };
    SerializableObjectSchema.prototype.getCount = function () {
        return this._properties.length;
    };
    return SerializableObjectSchema;
}());
exports.SerializableObjectSchema = SerializableObjectSchema;
// This is a decorator function, used to map SerializableObject descendant class members to
// schema properties
function property(prop) {
    return function (target, propertyKey) {
        var descriptor = Object.getOwnPropertyDescriptor(target, propertyKey) || {};
        if (!descriptor.get && !descriptor.set) {
            descriptor.get = function () {
                return this.getValue(prop);
            };
            descriptor.set = function (value) {
                this.setValue(prop, value);
            };
            Object.defineProperty(target, propertyKey, descriptor);
        }
    };
}
exports.property = property;
var SerializableObject = /** @class */ (function () {
    function SerializableObject() {
        this._propertyBag = {};
        this._rawProperties = {};
        this.maxVersion = SerializableObject.defaultMaxVersion;
        var s = this.getSchema();
        for (var i = 0; i < s.getCount(); i++) {
            var prop = s.getItemAt(i);
            if (prop.onGetInitialValue) {
                this.setValue(prop, prop.onGetInitialValue(this));
            }
        }
    }
    SerializableObject.prototype.getDefaultSerializationContext = function () {
        return new SimpleSerializationContext();
    };
    SerializableObject.prototype.populateSchema = function (schema) {
        var ctor = this.constructor;
        var properties = [];
        // eslint-disable-next-line guard-for-in
        for (var propertyName in ctor) {
            try {
                var propertyValue = ctor[propertyName];
                if (propertyValue instanceof PropertyDefinition) {
                    properties.push(propertyValue);
                }
            }
            catch (_a) {
                // If a property happens to have a getter function and
                // it throws an exception, we need to catch it here
            }
        }
        if (properties.length > 0) {
            var sortedProperties = properties.sort(function (p1, p2) {
                if (p1.sequentialNumber > p2.sequentialNumber) {
                    return 1;
                }
                else if (p1.sequentialNumber < p2.sequentialNumber) {
                    return -1;
                }
                return 0;
            });
            schema.add.apply(schema, sortedProperties);
        }
        if (SerializableObject.onRegisterCustomProperties) {
            SerializableObject.onRegisterCustomProperties(this, schema);
        }
    };
    SerializableObject.prototype.getValue = function (prop) {
        return this._propertyBag.hasOwnProperty(prop.getInternalName())
            ? this._propertyBag[prop.getInternalName()]
            : prop.defaultValue;
    };
    SerializableObject.prototype.setValue = function (prop, value) {
        if (value === undefined || value === null) {
            delete this._propertyBag[prop.getInternalName()];
        }
        else {
            this._propertyBag[prop.getInternalName()] = value;
        }
    };
    SerializableObject.prototype.internalParse = function (source, context) {
        this._propertyBag = {};
        this._rawProperties = shared_1.GlobalSettings.enableFullJsonRoundTrip ? (source ? source : {}) : {};
        if (source) {
            var s = this.getSchema();
            for (var i = 0; i < s.getCount(); i++) {
                var prop = s.getItemAt(i);
                if (prop.isSerializationEnabled) {
                    var propertyValue = prop.onGetInitialValue
                        ? prop.onGetInitialValue(this)
                        : undefined;
                    if (source.hasOwnProperty(prop.name)) {
                        if (prop.targetVersion.compareTo(context.targetVersion) <= 0) {
                            propertyValue = prop.parse(this, source, context);
                        }
                        else {
                            context.logParseEvent(this, Enums.ValidationEvent.UnsupportedProperty, strings_1.Strings.errors.propertyNotSupported(prop.name, prop.targetVersion.toString(), context.targetVersion.toString()));
                        }
                    }
                    this.setValue(prop, propertyValue);
                }
            }
        }
        else {
            this.resetDefaultValues();
        }
    };
    SerializableObject.prototype.internalToJSON = function (target, context) {
        var s = this.getSchema();
        var serializedProperties = [];
        for (var i = 0; i < s.getCount(); i++) {
            var prop = s.getItemAt(i);
            // Avoid serializing the same property multiple times. This is necessary
            // because some property definitions map to the same underlying schema
            // property
            if (prop.isSerializationEnabled &&
                prop.targetVersion.compareTo(context.targetVersion) <= 0 &&
                serializedProperties.indexOf(prop.name) === -1) {
                prop.toJSON(this, target, this.getValue(prop), context);
                serializedProperties.push(prop.name);
            }
        }
    };
    SerializableObject.prototype.shouldSerialize = function (_context) {
        return true;
    };
    SerializableObject.prototype.parse = function (source, context) {
        this.internalParse(source, context ? context : new SimpleSerializationContext());
    };
    SerializableObject.prototype.toJSON = function (context) {
        var effectiveContext;
        if (context && context instanceof BaseSerializationContext) {
            effectiveContext = context;
        }
        else {
            effectiveContext = this.getDefaultSerializationContext();
            effectiveContext.toJSONOriginalParam = context;
        }
        if (this.shouldSerialize(effectiveContext)) {
            var result = void 0;
            if (shared_1.GlobalSettings.enableFullJsonRoundTrip &&
                this._rawProperties &&
                typeof this._rawProperties === "object") {
                result = this._rawProperties;
            }
            else {
                result = {};
            }
            this.internalToJSON(result, effectiveContext);
            return result;
        }
        else {
            return undefined;
        }
    };
    SerializableObject.prototype.hasDefaultValue = function (prop) {
        return this.getValue(prop) === prop.defaultValue;
    };
    SerializableObject.prototype.hasAllDefaultValues = function () {
        var s = this.getSchema();
        for (var i = 0; i < s.getCount(); i++) {
            var prop = s.getItemAt(i);
            if (!this.hasDefaultValue(prop)) {
                return false;
            }
        }
        return true;
    };
    SerializableObject.prototype.resetDefaultValues = function () {
        var s = this.getSchema();
        for (var i = 0; i < s.getCount(); i++) {
            var prop = s.getItemAt(i);
            this.setValue(prop, prop.defaultValue);
        }
    };
    SerializableObject.prototype.setCustomProperty = function (name, value) {
        var shouldDeleteProperty = (typeof value === "string" && !value) || value === undefined || value === null;
        if (shouldDeleteProperty) {
            delete this._rawProperties[name];
        }
        else {
            this._rawProperties[name] = value;
        }
    };
    SerializableObject.prototype.getCustomProperty = function (name) {
        return this._rawProperties[name];
    };
    SerializableObject.prototype.getSchema = function () {
        var schema = SerializableObject._schemaCache[this.getSchemaKey()];
        if (!schema) {
            schema = new SerializableObjectSchema();
            this.populateSchema(schema);
            SerializableObject._schemaCache[this.getSchemaKey()] = schema;
        }
        return schema;
    };
    SerializableObject.defaultMaxVersion = Versions.latest;
    SerializableObject._schemaCache = {};
    return SerializableObject;
}());
exports.SerializableObject = SerializableObject;
//# sourceMappingURL=serialization.js.map

/***/ }),

/***/ "../adaptivecards/lib/shared.js":
/*!**************************************!*\
  !*** ../adaptivecards/lib/shared.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UUID = exports.SizeAndUnit = exports.PaddingDefinition = exports.SpacingDefinition = exports.StringWithSubstitutions = exports.ContentTypes = exports.GlobalSettings = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var Enums = __webpack_require__(/*! ./enums */ "../adaptivecards/lib/enums.js");
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
var GlobalSettings = /** @class */ (function () {
    function GlobalSettings() {
    }
    GlobalSettings.useAdvancedTextBlockTruncation = true;
    GlobalSettings.useAdvancedCardBottomTruncation = false;
    GlobalSettings.useMarkdownInRadioButtonAndCheckbox = true;
    GlobalSettings.allowMarkForTextHighlighting = false;
    GlobalSettings.alwaysBleedSeparators = false;
    GlobalSettings.enableFullJsonRoundTrip = false;
    GlobalSettings.displayInputValidationErrors = true;
    GlobalSettings.allowPreProcessingPropertyValues = false;
    GlobalSettings.setTabIndexAtCardRoot = true;
    GlobalSettings.enableFallback = true;
    GlobalSettings.useWebkitLineClamp = true;
    GlobalSettings.allowMoreThanMaxActionsInOverflowMenu = false;
    GlobalSettings.removePaddingFromContainersWithBackgroundImage = false;
    GlobalSettings.resetInputsDirtyStateAfterActionExecution = true;
    GlobalSettings.applets = {
        logEnabled: true,
        logLevel: Enums.LogLevel.Error,
        maximumRetryAttempts: 3,
        defaultTimeBetweenRetryAttempts: 3000,
        authPromptWidth: 400,
        authPromptHeight: 600,
        refresh: {
            mode: Enums.RefreshMode.Manual,
            timeBetweenAutomaticRefreshes: 3000,
            maximumConsecutiveAutomaticRefreshes: 3,
            allowManualRefreshesAfterAutomaticRefreshes: true
        }
    };
    return GlobalSettings;
}());
exports.GlobalSettings = GlobalSettings;
exports.ContentTypes = {
    applicationJson: "application/json",
    applicationXWwwFormUrlencoded: "application/x-www-form-urlencoded"
};
var StringWithSubstitutions = /** @class */ (function () {
    function StringWithSubstitutions() {
        this._isProcessed = false;
    }
    StringWithSubstitutions.prototype.getReferencedInputs = function (inputs, referencedInputs) {
        if (!referencedInputs) {
            throw new Error("The referencedInputs parameter cannot be null.");
        }
        if (this._original) {
            for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
                var input = inputs_1[_i];
                var matches = new RegExp("\\{{2}(" + input.id + ").value\\}{2}", "gi").exec(this._original);
                if (matches != null && input.id) {
                    referencedInputs[input.id] = input;
                }
            }
        }
    };
    StringWithSubstitutions.prototype.substituteInputValues = function (inputs, contentType) {
        this._processed = this._original;
        if (this._original) {
            var regEx = /\{{2}([a-z0-9_$@]+).value\}{2}/gi;
            var matches = void 0;
            while ((matches = regEx.exec(this._original)) !== null && this._processed) {
                for (var _i = 0, _a = Object.keys(inputs); _i < _a.length; _i++) {
                    var key = _a[_i];
                    if (key.toLowerCase() === matches[1].toLowerCase()) {
                        var matchedInput = inputs[key];
                        var valueForReplace = "";
                        if (matchedInput.value) {
                            valueForReplace = matchedInput.value;
                        }
                        if (contentType === exports.ContentTypes.applicationJson) {
                            valueForReplace = JSON.stringify(valueForReplace);
                            valueForReplace = valueForReplace.slice(1, -1);
                        }
                        else if (contentType === exports.ContentTypes.applicationXWwwFormUrlencoded) {
                            valueForReplace = encodeURIComponent(valueForReplace);
                        }
                        this._processed = this._processed.replace(matches[0], valueForReplace);
                        break;
                    }
                }
            }
        }
        this._isProcessed = true;
    };
    StringWithSubstitutions.prototype.getOriginal = function () {
        return this._original;
    };
    StringWithSubstitutions.prototype.get = function () {
        if (!this._isProcessed) {
            return this._original;
        }
        else {
            return this._processed;
        }
    };
    StringWithSubstitutions.prototype.set = function (value) {
        this._original = value;
        this._isProcessed = false;
    };
    return StringWithSubstitutions;
}());
exports.StringWithSubstitutions = StringWithSubstitutions;
var SpacingDefinition = /** @class */ (function () {
    function SpacingDefinition(top, right, bottom, left) {
        if (top === void 0) { top = 0; }
        if (right === void 0) { right = 0; }
        if (bottom === void 0) { bottom = 0; }
        if (left === void 0) { left = 0; }
        this.left = 0;
        this.top = 0;
        this.right = 0;
        this.bottom = 0;
        this.top = top;
        this.right = right;
        this.bottom = bottom;
        this.left = left;
    }
    return SpacingDefinition;
}());
exports.SpacingDefinition = SpacingDefinition;
var PaddingDefinition = /** @class */ (function () {
    function PaddingDefinition(top, right, bottom, left) {
        if (top === void 0) { top = Enums.Spacing.None; }
        if (right === void 0) { right = Enums.Spacing.None; }
        if (bottom === void 0) { bottom = Enums.Spacing.None; }
        if (left === void 0) { left = Enums.Spacing.None; }
        this.top = Enums.Spacing.None;
        this.right = Enums.Spacing.None;
        this.bottom = Enums.Spacing.None;
        this.left = Enums.Spacing.None;
        this.top = top;
        this.right = right;
        this.bottom = bottom;
        this.left = left;
    }
    return PaddingDefinition;
}());
exports.PaddingDefinition = PaddingDefinition;
var SizeAndUnit = /** @class */ (function () {
    function SizeAndUnit(physicalSize, unit) {
        this.physicalSize = physicalSize;
        this.unit = unit;
    }
    SizeAndUnit.parse = function (input, requireUnitSpecifier) {
        if (requireUnitSpecifier === void 0) { requireUnitSpecifier = false; }
        var result = new SizeAndUnit(0, Enums.SizeUnit.Weight);
        if (typeof input === "number") {
            result.physicalSize = input;
            return result;
        }
        else if (typeof input === "string") {
            var regExp = /^([0-9]+)(px|\*)?$/g;
            var matches = regExp.exec(input);
            var expectedMatchCount = requireUnitSpecifier ? 3 : 2;
            if (matches && matches.length >= expectedMatchCount) {
                result.physicalSize = parseInt(matches[1]);
                if (matches.length === 3) {
                    if (matches[2] === "px") {
                        result.unit = Enums.SizeUnit.Pixel;
                    }
                }
                return result;
            }
        }
        throw new Error("Invalid size: " + input);
    };
    return SizeAndUnit;
}());
exports.SizeAndUnit = SizeAndUnit;
/**
 * Fast UUID generator, RFC4122 version 4 compliant.
 * @author Jeff Ward (jcward.com).
 * @license MIT license
 * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
 **/
/* eslint-disable @typescript-eslint/no-extraneous-class, @typescript-eslint/naming-convention, no-bitwise */
var UUID = /** @class */ (function () {
    function UUID() {
    }
    UUID.generate = function () {
        var d0 = (Math.random() * 0xffffffff) | 0;
        var d1 = (Math.random() * 0xffffffff) | 0;
        var d2 = (Math.random() * 0xffffffff) | 0;
        var d3 = (Math.random() * 0xffffffff) | 0;
        return (UUID.lut[d0 & 0xff] +
            UUID.lut[(d0 >> 8) & 0xff] +
            UUID.lut[(d0 >> 16) & 0xff] +
            UUID.lut[(d0 >> 24) & 0xff] +
            "-" +
            UUID.lut[d1 & 0xff] +
            UUID.lut[(d1 >> 8) & 0xff] +
            "-" +
            UUID.lut[((d1 >> 16) & 0x0f) | 0x40] +
            UUID.lut[(d1 >> 24) & 0xff] +
            "-" +
            UUID.lut[(d2 & 0x3f) | 0x80] +
            UUID.lut[(d2 >> 8) & 0xff] +
            "-" +
            UUID.lut[(d2 >> 16) & 0xff] +
            UUID.lut[(d2 >> 24) & 0xff] +
            UUID.lut[d3 & 0xff] +
            UUID.lut[(d3 >> 8) & 0xff] +
            UUID.lut[(d3 >> 16) & 0xff] +
            UUID.lut[(d3 >> 24) & 0xff]);
    };
    UUID.initialize = function () {
        for (var i = 0; i < 256; i++) {
            UUID.lut[i] = (i < 16 ? "0" : "") + i.toString(16);
        }
    };
    UUID.lut = [];
    return UUID;
}());
exports.UUID = UUID;
UUID.initialize();
/* eslint-enable @typescript-eslint/no-extraneous-class, @typescript-eslint/naming-convention, no-bitwise */
//# sourceMappingURL=shared.js.map

/***/ }),

/***/ "../adaptivecards/lib/strings.js":
/*!***************************************!*\
  !*** ../adaptivecards/lib/strings.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Strings = void 0;
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
var Strings = /** @class */ (function () {
    function Strings() {
    }
    Strings.errors = {
        unknownElementType: function (typeName) {
            return "Unknown element type \"".concat(typeName, "\". Fallback will be used if present.");
        },
        unknownActionType: function (typeName) {
            return "Unknown action type \"".concat(typeName, "\". Fallback will be used if present.");
        },
        elementTypeNotAllowed: function (typeName) {
            return "Element type \"".concat(typeName, "\" is not allowed in this context.");
        },
        actionTypeNotAllowed: function (typeName) {
            return "Action type \"".concat(typeName, "\" is not allowed in this context.");
        },
        invalidPropertyValue: function (value, propertyName) {
            return "Invalid value \"".concat(value, "\" for property \"").concat(propertyName, "\".");
        },
        showCardMustHaveCard: function () {
            return "\"An Action.ShowCard must have its \"card\" property set to a valid AdaptiveCard object.";
        },
        invalidColumnWidth: function (invalidWidth) {
            return "Invalid column width \"".concat(invalidWidth, "\" - defaulting to \"auto\".");
        },
        invalidCardVersion: function (defaultingToVersion) {
            return "Invalid card version. Defaulting to \"".concat(defaultingToVersion, "\".");
        },
        invalidVersionString: function (versionString) {
            return "Invalid version string \"".concat(versionString, "\".");
        },
        propertyValueNotSupported: function (value, propertyName, supportedInVersion, versionUsed) {
            return "Value \"".concat(value, "\" for property \"").concat(propertyName, "\" is supported in version ").concat(supportedInVersion, ", but you are using version ").concat(versionUsed, ".");
        },
        propertyNotSupported: function (propertyName, supportedInVersion, versionUsed) {
            return "Property \"".concat(propertyName, "\" is supported in version ").concat(supportedInVersion, ", but you are using version ").concat(versionUsed, ".");
        },
        indexOutOfRange: function (index) { return "Index out of range (".concat(index, ")."); },
        elementCannotBeUsedAsInline: function () {
            return "RichTextBlock.addInline: the specified card element cannot be used as a RichTextBlock inline.";
        },
        inlineAlreadyParented: function () {
            return "RichTextBlock.addInline: the specified inline already belongs to another RichTextBlock.";
        },
        interactivityNotAllowed: function () { return "Interactivity is not allowed."; },
        inputsMustHaveUniqueId: function () { return "All inputs must have a unique Id."; },
        choiceSetMustHaveAtLeastOneChoice: function () {
            return "An Input.ChoiceSet must have at least one choice defined.";
        },
        choiceSetChoicesMustHaveTitleAndValue: function () {
            return "All choices in an Input.ChoiceSet must have their title and value properties set.";
        },
        propertyMustBeSet: function (propertyName) { return "Property \"".concat(propertyName, "\" must be set."); },
        actionHttpHeadersMustHaveNameAndValue: function () {
            return "All headers of an Action.Http must have their name and value properties set.";
        },
        tooManyActions: function (maximumActions) {
            return "Maximum number of actions exceeded (".concat(maximumActions, ").");
        },
        tooLittleTimeDelay: function (minAutoplayDelay) {
            return "Autoplay Delay is too short (".concat(minAutoplayDelay, ").");
        },
        columnAlreadyBelongsToAnotherSet: function () { return "This column already belongs to another ColumnSet."; },
        invalidCardType: function () {
            return "Invalid or missing card type. Make sure the card's type property is set to \"AdaptiveCard\".";
        },
        unsupportedCardVersion: function (version, maxSupportedVersion) {
            return "The specified card version (".concat(version, ") is not supported or still in preview. The latest released card version is ").concat(maxSupportedVersion, ".");
        },
        duplicateId: function (id) { return "Duplicate Id \"".concat(id, "\"."); },
        markdownProcessingNotEnabled: function () {
            return "Markdown processing isn't enabled. Please see https://www.npmjs.com/package/adaptivecards#supporting-markdown";
        },
        processMarkdownEventRemoved: function () {
            return "The processMarkdown event has been removed. Please update your code and set onProcessMarkdown instead.";
        },
        elementAlreadyParented: function () { return "The element already belongs to another container."; },
        actionAlreadyParented: function () { return "The action already belongs to another element."; },
        elementTypeNotStandalone: function (typeName) {
            return "Elements of type ".concat(typeName, " cannot be used as standalone elements.");
        }
    };
    Strings.magicCodeInputCard = {
        tryAgain: function () { return "That didn't work... let's try again."; },
        pleaseLogin: function () {
            return 'Please login in the popup. You will obtain a magic code. Paste that code below and select "Submit"';
        },
        enterMagicCode: function () { return "Enter magic code"; },
        pleaseEnterMagicCodeYouReceived: function () { return "Please enter the magic code you received."; },
        submit: function () { return "Submit"; },
        cancel: function () { return "Cancel"; },
        somethingWentWrong: function () { return "Something went wrong. This action can't be handled."; },
        authenticationFailed: function () { return "Authentication failed."; }
    };
    Strings.runtime = {
        automaticRefreshPaused: function () { return "Automatic refresh paused."; },
        clckToRestartAutomaticRefresh: function () { return "Click to restart."; },
        refreshThisCard: function () { return "Refresh this card"; }
    };
    Strings.hints = {
        dontUseWeightedAndStrecthedColumnsInSameSet: function () {
            return "It is not recommended to use weighted and stretched columns in the same ColumnSet, because in such a situation stretched columns will always get the minimum amount of space.";
        }
    };
    Strings.defaults = {
        inlineActionTitle: function () { return "Inline Action"; },
        overflowButtonText: function () { return "..."; },
        mediaPlayerAriaLabel: function () { return "Media content"; },
        mediaPlayerPlayMedia: function () { return "Play media"; },
        youTubeVideoPlayer: function () { return "YouTube video player"; },
        vimeoVideoPlayer: function () { return "Vimeo video player"; },
        dailymotionVideoPlayer: function () { return "Dailymotion video player"; }
    };
    return Strings;
}());
exports.Strings = Strings;
//# sourceMappingURL=strings.js.map

/***/ }),

/***/ "../adaptivecards/lib/table.js":
/*!*************************************!*\
  !*** ../adaptivecards/lib/table.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Table = exports.TableRow = exports.TableCell = exports.StylableContainer = exports.TableColumnDefinition = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var card_elements_1 = __webpack_require__(/*! ./card-elements */ "../adaptivecards/lib/card-elements.js");
var enums_1 = __webpack_require__(/*! ./enums */ "../adaptivecards/lib/enums.js");
var registry_1 = __webpack_require__(/*! ./registry */ "../adaptivecards/lib/registry.js");
var serialization_1 = __webpack_require__(/*! ./serialization */ "../adaptivecards/lib/serialization.js");
var shared_1 = __webpack_require__(/*! ./shared */ "../adaptivecards/lib/shared.js");
var strings_1 = __webpack_require__(/*! ./strings */ "../adaptivecards/lib/strings.js");
var utils_1 = __webpack_require__(/*! ./utils */ "../adaptivecards/lib/utils.js");
var TableColumnDefinition = /** @class */ (function (_super) {
    __extends(TableColumnDefinition, _super);
    function TableColumnDefinition() {
        //#region Schema
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.width = new shared_1.SizeAndUnit(1, enums_1.SizeUnit.Weight);
        return _this;
    }
    TableColumnDefinition.prototype.getSchemaKey = function () {
        return "ColumnDefinition";
    };
    TableColumnDefinition.horizontalCellContentAlignmentProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_5, "horizontalCellContentAlignment", enums_1.HorizontalAlignment);
    TableColumnDefinition.verticalCellContentAlignmentProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_5, "verticalCellContentAlignment", enums_1.VerticalAlignment);
    TableColumnDefinition.widthProperty = new serialization_1.CustomProperty(serialization_1.Versions.v1_5, "width", function (sender, prop, source, context) {
        var result = prop.defaultValue;
        var value = source[prop.name];
        var invalidWidth = false;
        if (typeof value === "number" && !isNaN(value)) {
            result = new shared_1.SizeAndUnit(value, enums_1.SizeUnit.Weight);
        }
        else if (typeof value === "string") {
            try {
                result = shared_1.SizeAndUnit.parse(value);
            }
            catch (e) {
                invalidWidth = true;
            }
        }
        else {
            invalidWidth = true;
        }
        if (invalidWidth) {
            context.logParseEvent(sender, enums_1.ValidationEvent.InvalidPropertyValue, strings_1.Strings.errors.invalidColumnWidth(value));
        }
        return result;
    }, function (sender, property, target, value, context) {
        if (value.unit === enums_1.SizeUnit.Pixel) {
            context.serializeValue(target, "width", value.physicalSize + "px");
        }
        else {
            context.serializeNumber(target, "width", value.physicalSize);
        }
    }, new shared_1.SizeAndUnit(1, enums_1.SizeUnit.Weight));
    __decorate([
        (0, serialization_1.property)(TableColumnDefinition.horizontalCellContentAlignmentProperty)
    ], TableColumnDefinition.prototype, "horizontalCellContentAlignment", void 0);
    __decorate([
        (0, serialization_1.property)(TableColumnDefinition.verticalCellContentAlignmentProperty)
    ], TableColumnDefinition.prototype, "verticalCellContentAlignment", void 0);
    __decorate([
        (0, serialization_1.property)(TableColumnDefinition.widthProperty)
    ], TableColumnDefinition.prototype, "width", void 0);
    return TableColumnDefinition;
}(serialization_1.SerializableObject));
exports.TableColumnDefinition = TableColumnDefinition;
var StylableContainer = /** @class */ (function (_super) {
    __extends(StylableContainer, _super);
    function StylableContainer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._items = [];
        return _this;
    }
    StylableContainer.prototype.parseItem = function (source, context) {
        var _this = this;
        return context.parseCardObject(this, source, [], // Forbidden types not supported for elements for now
        !this.isDesignMode(), function (typeName) {
            return _this.createItemInstance(typeName);
        }, function (typeName, _errorType) {
            context.logParseEvent(undefined, enums_1.ValidationEvent.ElementTypeNotAllowed, strings_1.Strings.errors.elementTypeNotAllowed(typeName));
        });
    };
    StylableContainer.prototype.internalAddItem = function (item) {
        if (!item.parent) {
            this._items.push(item);
            item.setParent(this);
        }
        else {
            throw new Error(strings_1.Strings.errors.elementAlreadyParented());
        }
    };
    StylableContainer.prototype.internalRemoveItem = function (item) {
        var itemIndex = this._items.indexOf(item);
        if (itemIndex >= 0) {
            this._items.splice(itemIndex, 1);
            item.setParent(undefined);
            this.updateLayout();
            return true;
        }
        return false;
    };
    StylableContainer.prototype.internalIndexOf = function (item) {
        return this._items.indexOf(item);
    };
    StylableContainer.prototype.internalParse = function (source, context) {
        _super.prototype.internalParse.call(this, source, context);
        this._items = [];
        var items = source[this.getCollectionPropertyName()];
        if (Array.isArray(items)) {
            for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
                var item = items_1[_i];
                var instance = this.parseItem(item, context);
                if (instance) {
                    this._items.push(instance);
                }
            }
        }
    };
    StylableContainer.prototype.internalToJSON = function (target, context) {
        _super.prototype.internalToJSON.call(this, target, context);
        context.serializeArray(target, this.getCollectionPropertyName(), this._items);
    };
    StylableContainer.prototype.removeItem = function (item) {
        return this.internalRemoveItem(item);
    };
    StylableContainer.prototype.getItemCount = function () {
        return this._items.length;
    };
    StylableContainer.prototype.getItemAt = function (index) {
        return this._items[index];
    };
    StylableContainer.prototype.getFirstVisibleRenderedItem = function () {
        return this.getItemCount() > 0 ? this.getItemAt(0) : undefined;
    };
    StylableContainer.prototype.getLastVisibleRenderedItem = function () {
        return this.getItemCount() > 0 ? this.getItemAt(this.getItemCount() - 1) : undefined;
    };
    return StylableContainer;
}(card_elements_1.StylableCardElementContainer));
exports.StylableContainer = StylableContainer;
var TableCell = /** @class */ (function (_super) {
    __extends(TableCell, _super);
    function TableCell() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._columnIndex = -1;
        _this._cellType = "data";
        return _this;
    }
    TableCell.prototype.getHasBorder = function () {
        return this.parentRow.parentTable.showGridLines;
    };
    TableCell.prototype.applyBorder = function () {
        if (this.renderedElement && this.getHasBorder()) {
            var styleDefinition = this.hostConfig.containerStyles.getStyleByName(this.parentRow.parentTable.gridStyle);
            if (styleDefinition.borderColor) {
                var borderColor = (0, utils_1.stringToCssColor)(styleDefinition.borderColor);
                if (borderColor) {
                    this.renderedElement.style.borderRight = "1px solid " + borderColor;
                    this.renderedElement.style.borderBottom = "1px solid " + borderColor;
                }
            }
        }
    };
    TableCell.prototype.getDefaultPadding = function () {
        return this.getHasBackground() || this.getHasBorder()
            ? new shared_1.PaddingDefinition(enums_1.Spacing.Small, enums_1.Spacing.Small, enums_1.Spacing.Small, enums_1.Spacing.Small)
            : _super.prototype.getDefaultPadding.call(this);
    };
    TableCell.prototype.internalRender = function () {
        var cellElement = _super.prototype.internalRender.call(this);
        if (cellElement) {
            cellElement.setAttribute("role", this.cellType === "data" ? "cell" : "columnheader");
            cellElement.style.minWidth = "0";
            if (this.cellType === "header") {
                cellElement.setAttribute("scope", "col");
            }
        }
        return cellElement;
    };
    TableCell.prototype.shouldSerialize = function (_context) {
        return true;
    };
    TableCell.prototype.getJsonTypeName = function () {
        return "TableCell";
    };
    TableCell.prototype.getEffectiveTextStyleDefinition = function () {
        if (this.cellType === "header") {
            return this.hostConfig.textStyles.columnHeader;
        }
        return _super.prototype.getEffectiveTextStyleDefinition.call(this);
    };
    TableCell.prototype.getEffectiveHorizontalAlignment = function () {
        if (this.horizontalAlignment !== undefined) {
            return this.horizontalAlignment;
        }
        if (this.parentRow.horizontalCellContentAlignment !== undefined) {
            return this.parentRow.horizontalCellContentAlignment;
        }
        if (this.columnIndex >= 0) {
            var horizontalAlignment = this.parentRow.parentTable.getColumnAt(this.columnIndex).horizontalCellContentAlignment;
            if (horizontalAlignment !== undefined) {
                return horizontalAlignment;
            }
        }
        if (this.parentRow.parentTable.horizontalCellContentAlignment !== undefined) {
            return this.parentRow.parentTable.horizontalCellContentAlignment;
        }
        return _super.prototype.getEffectiveHorizontalAlignment.call(this);
    };
    TableCell.prototype.getEffectiveVerticalContentAlignment = function () {
        if (this.verticalContentAlignment !== undefined) {
            return this.verticalContentAlignment;
        }
        if (this.parentRow.verticalCellContentAlignment !== undefined) {
            return this.parentRow.verticalCellContentAlignment;
        }
        if (this.columnIndex >= 0) {
            var verticalAlignment = this.parentRow.parentTable.getColumnAt(this.columnIndex).verticalCellContentAlignment;
            if (verticalAlignment !== undefined) {
                return verticalAlignment;
            }
        }
        if (this.parentRow.parentTable.verticalCellContentAlignment !== undefined) {
            return this.parentRow.parentTable.verticalCellContentAlignment;
        }
        return _super.prototype.getEffectiveVerticalContentAlignment.call(this);
    };
    Object.defineProperty(TableCell.prototype, "columnIndex", {
        get: function () {
            return this._columnIndex;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TableCell.prototype, "cellType", {
        get: function () {
            return this._cellType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TableCell.prototype, "parentRow", {
        get: function () {
            return this.parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TableCell.prototype, "isStandalone", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    return TableCell;
}(card_elements_1.Container));
exports.TableCell = TableCell;
var TableRow = /** @class */ (function (_super) {
    __extends(TableRow, _super);
    function TableRow() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    //#endregion
    TableRow.prototype.getDefaultPadding = function () {
        return new shared_1.PaddingDefinition(enums_1.Spacing.None, enums_1.Spacing.None, enums_1.Spacing.None, enums_1.Spacing.None);
    };
    TableRow.prototype.applyBackground = function () {
        if (this.renderedElement) {
            var styleDefinition = this.hostConfig.containerStyles.getStyleByName(this.style, this.hostConfig.containerStyles.getStyleByName(this.defaultStyle));
            if (styleDefinition.backgroundColor) {
                var bgColor = (0, utils_1.stringToCssColor)(styleDefinition.backgroundColor);
                if (bgColor) {
                    this.renderedElement.style.backgroundColor = bgColor;
                }
            }
        }
    };
    TableRow.prototype.getCollectionPropertyName = function () {
        return "cells";
    };
    TableRow.prototype.createItemInstance = function (typeName) {
        return !typeName || typeName === "TableCell" ? new TableCell() : undefined;
    };
    TableRow.prototype.internalRender = function () {
        var isFirstRow = this.getIsFirstRow();
        var cellSpacing = this.hostConfig.table.cellSpacing;
        var rowElement = document.createElement("div");
        rowElement.setAttribute("role", "row");
        rowElement.style.display = "flex";
        rowElement.style.flexDirection = "row";
        for (var i = 0; i < Math.min(this.getItemCount(), this.parentTable.getColumnCount()); i++) {
            var cell = this.getItemAt(i);
            // Cheating a bit in order to keep cellType read-only
            cell["_columnIndex"] = i;
            cell["_cellType"] =
                this.parentTable.firstRowAsHeaders && isFirstRow ? "header" : "data";
            var renderedCell = cell.render();
            if (renderedCell) {
                var column = this.parentTable.getColumnAt(i);
                if (column.computedWidth.unit === enums_1.SizeUnit.Pixel) {
                    renderedCell.style.flex = "0 0 " + column.computedWidth.physicalSize + "px";
                }
                else {
                    renderedCell.style.flex = "1 1 " + column.computedWidth.physicalSize + "%";
                }
                if (i > 0 && !this.parentTable.showGridLines && cellSpacing > 0) {
                    renderedCell.style.marginLeft = cellSpacing + "px";
                }
                rowElement.appendChild(renderedCell);
            }
        }
        return rowElement.children.length > 0 ? rowElement : undefined;
    };
    TableRow.prototype.shouldSerialize = function (_context) {
        return true;
    };
    TableRow.prototype.addCell = function (cell) {
        this.internalAddItem(cell);
    };
    TableRow.prototype.removeCellAt = function (columnIndex) {
        if (columnIndex >= 0 && columnIndex < this.getItemCount()) {
            return this.removeItem(this.getItemAt(columnIndex));
        }
        return false;
    };
    TableRow.prototype.indexOf = function (cardElement) {
        return cardElement instanceof TableCell ? this.internalIndexOf(cardElement) : -1;
    };
    TableRow.prototype.ensureHasEnoughCells = function (cellCount) {
        while (this.getItemCount() < cellCount) {
            this.addCell(new TableCell());
        }
    };
    TableRow.prototype.getJsonTypeName = function () {
        return "TableRow";
    };
    TableRow.prototype.getIsFirstRow = function () {
        return this.parentTable.getItemAt(0) === this;
    };
    Object.defineProperty(TableRow.prototype, "parentTable", {
        get: function () {
            return this.parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TableRow.prototype, "isStandalone", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    //#region Schema
    TableRow.styleProperty = new card_elements_1.ContainerStyleProperty(serialization_1.Versions.v1_5, "style");
    TableRow.horizontalCellContentAlignmentProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_5, "horizontalCellContentAlignment", enums_1.HorizontalAlignment);
    TableRow.verticalCellContentAlignmentProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_5, "verticalCellContentAlignment", enums_1.VerticalAlignment);
    __decorate([
        (0, serialization_1.property)(TableRow.horizontalCellContentAlignmentProperty)
    ], TableRow.prototype, "horizontalCellContentAlignment", void 0);
    __decorate([
        (0, serialization_1.property)(TableRow.verticalCellContentAlignmentProperty)
    ], TableRow.prototype, "verticalCellContentAlignment", void 0);
    return TableRow;
}(StylableContainer));
exports.TableRow = TableRow;
var Table = /** @class */ (function (_super) {
    __extends(Table, _super);
    function Table() {
        //#region Schema
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._columns = [];
        _this.firstRowAsHeaders = true;
        _this.showGridLines = true;
        return _this;
    }
    Object.defineProperty(Table.prototype, "gridStyle", {
        get: function () {
            var style = this.getValue(Table.gridStyleProperty);
            if (style && this.hostConfig.containerStyles.getStyleByName(style)) {
                return style;
            }
            return undefined;
        },
        set: function (value) {
            this.setValue(Table.gridStyleProperty, value);
        },
        enumerable: false,
        configurable: true
    });
    //#endregion
    Table.prototype.ensureRowsHaveEnoughCells = function () {
        for (var i = 0; i < this.getItemCount(); i++) {
            this.getItemAt(i).ensureHasEnoughCells(this.getColumnCount());
        }
    };
    Table.prototype.removeCellsFromColumn = function (columnIndex) {
        for (var i = 0; i < this.getItemCount(); i++) {
            this.getItemAt(i).removeCellAt(columnIndex);
        }
    };
    Table.prototype.getCollectionPropertyName = function () {
        return "rows";
    };
    Table.prototype.createItemInstance = function (typeName) {
        return !typeName || typeName === "TableRow" ? new TableRow() : undefined;
    };
    Table.prototype.internalParse = function (source, context) {
        _super.prototype.internalParse.call(this, source, context);
        this.ensureRowsHaveEnoughCells();
    };
    Table.prototype.internalRender = function () {
        if (this.getItemCount() > 0) {
            var totalWeights = 0;
            for (var _i = 0, _a = this._columns; _i < _a.length; _i++) {
                var column = _a[_i];
                if (column.width.unit === enums_1.SizeUnit.Weight) {
                    totalWeights += column.width.physicalSize;
                }
            }
            for (var _b = 0, _c = this._columns; _b < _c.length; _b++) {
                var column = _c[_b];
                if (column.width.unit === enums_1.SizeUnit.Pixel) {
                    column.computedWidth = new shared_1.SizeAndUnit(column.width.physicalSize, enums_1.SizeUnit.Pixel);
                }
                else {
                    column.computedWidth = new shared_1.SizeAndUnit((100 / totalWeights) * column.width.physicalSize, enums_1.SizeUnit.Weight);
                }
            }
            var tableElement = document.createElement("div");
            tableElement.setAttribute("role", "table");
            tableElement.style.display = "flex";
            tableElement.style.flexDirection = "column";
            if (this.showGridLines) {
                var styleDefinition = this.hostConfig.containerStyles.getStyleByName(this.gridStyle);
                if (styleDefinition.borderColor) {
                    var borderColor = (0, utils_1.stringToCssColor)(styleDefinition.borderColor);
                    if (borderColor) {
                        tableElement.style.borderTop = "1px solid " + borderColor;
                        tableElement.style.borderLeft = "1px solid " + borderColor;
                    }
                }
            }
            var cellSpacing = this.hostConfig.table.cellSpacing;
            for (var i = 0; i < this.getItemCount(); i++) {
                var renderedRow = this.getItemAt(i).render();
                if (renderedRow) {
                    if (i > 0 && !this.showGridLines && cellSpacing > 0) {
                        var separatorRow = document.createElement("div");
                        separatorRow.setAttribute("aria-hidden", "true");
                        separatorRow.style.height = cellSpacing + "px";
                        tableElement.appendChild(separatorRow);
                    }
                    tableElement.appendChild(renderedRow);
                }
            }
            return tableElement;
        }
        return undefined;
    };
    Table.prototype.addColumn = function (column) {
        this._columns.push(column);
        this.ensureRowsHaveEnoughCells();
    };
    Table.prototype.removeColumn = function (column) {
        var index = this._columns.indexOf(column);
        if (index >= 0) {
            this.removeCellsFromColumn(index);
            this._columns.splice(index, 1);
        }
    };
    Table.prototype.getColumnCount = function () {
        return this._columns.length;
    };
    Table.prototype.getColumnAt = function (index) {
        return this._columns[index];
    };
    Table.prototype.addRow = function (row) {
        this.internalAddItem(row);
        row.ensureHasEnoughCells(this.getColumnCount());
    };
    Table.prototype.indexOf = function (cardElement) {
        return cardElement instanceof TableRow ? this.internalIndexOf(cardElement) : -1;
    };
    Table.prototype.getJsonTypeName = function () {
        return "Table";
    };
    Table._columnsProperty = new serialization_1.SerializableObjectCollectionProperty(serialization_1.Versions.v1_5, "columns", TableColumnDefinition);
    Table.firstRowAsHeadersProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_5, "firstRowAsHeaders", true);
    Table.showGridLinesProperty = new serialization_1.BoolProperty(serialization_1.Versions.v1_5, "showGridLines", true);
    Table.gridStyleProperty = new card_elements_1.ContainerStyleProperty(serialization_1.Versions.v1_5, "gridStyle");
    Table.horizontalCellContentAlignmentProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_5, "horizontalCellContentAlignment", enums_1.HorizontalAlignment);
    Table.verticalCellContentAlignmentProperty = new serialization_1.EnumProperty(serialization_1.Versions.v1_5, "verticalCellContentAlignment", enums_1.VerticalAlignment);
    __decorate([
        (0, serialization_1.property)(Table._columnsProperty)
    ], Table.prototype, "_columns", void 0);
    __decorate([
        (0, serialization_1.property)(Table.firstRowAsHeadersProperty)
    ], Table.prototype, "firstRowAsHeaders", void 0);
    __decorate([
        (0, serialization_1.property)(Table.showGridLinesProperty)
    ], Table.prototype, "showGridLines", void 0);
    __decorate([
        (0, serialization_1.property)(Table.gridStyleProperty)
    ], Table.prototype, "gridStyle", null);
    __decorate([
        (0, serialization_1.property)(Table.horizontalCellContentAlignmentProperty)
    ], Table.prototype, "horizontalCellContentAlignment", void 0);
    __decorate([
        (0, serialization_1.property)(Table.verticalCellContentAlignmentProperty)
    ], Table.prototype, "verticalCellContentAlignment", void 0);
    return Table;
}(StylableContainer));
exports.Table = Table;
registry_1.GlobalRegistry.defaultElements.register("Table", Table, serialization_1.Versions.v1_5);
//# sourceMappingURL=table.js.map

/***/ }),

/***/ "../adaptivecards/lib/text-formatters.js":
/*!***********************************************!*\
  !*** ../adaptivecards/lib/text-formatters.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatText = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var AbstractTextFormatter = /** @class */ (function () {
    function AbstractTextFormatter(regularExpression) {
        this._regularExpression = regularExpression;
    }
    AbstractTextFormatter.prototype.format = function (lang, input) {
        var matches;
        if (input) {
            var result = input;
            while ((matches = this._regularExpression.exec(input)) != null) {
                result = result.replace(matches[0], this.internalFormat(lang, matches));
            }
            return result;
        }
        else {
            return input;
        }
    };
    return AbstractTextFormatter;
}());
var DateFormatter = /** @class */ (function (_super) {
    __extends(DateFormatter, _super);
    function DateFormatter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DateFormatter.prototype.internalFormat = function (lang, matches) {
        var date = new Date(Date.parse(matches[1]));
        var format = matches[2] !== undefined ? matches[2].toLowerCase() : "compact";
        if (format !== "compact") {
            return date.toLocaleDateString(lang, {
                day: "numeric",
                weekday: format,
                month: format,
                year: "numeric"
            });
        }
        else {
            return date.toLocaleDateString();
        }
    };
    return DateFormatter;
}(AbstractTextFormatter));
var TimeFormatter = /** @class */ (function (_super) {
    __extends(TimeFormatter, _super);
    function TimeFormatter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeFormatter.prototype.internalFormat = function (lang, matches) {
        var date = new Date(Date.parse(matches[1]));
        return date.toLocaleTimeString(lang, { hour: "numeric", minute: "2-digit" });
    };
    return TimeFormatter;
}(AbstractTextFormatter));
function formatText(lang, text) {
    var formatters = [
        new DateFormatter(/\{{2}DATE\((\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|(?:(?:-|\+)\d{2}:\d{2})))(?:, ?(COMPACT|LONG|SHORT))?\)\}{2}/g),
        new TimeFormatter(/\{{2}TIME\((\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|(?:(?:-|\+)\d{2}:\d{2})))\)\}{2}/g)
    ];
    var result = text;
    for (var _i = 0, formatters_1 = formatters; _i < formatters_1.length; _i++) {
        var formatter = formatters_1[_i];
        result = formatter.format(lang, result);
    }
    return result;
}
exports.formatText = formatText;
//# sourceMappingURL=text-formatters.js.map

/***/ }),

/***/ "../adaptivecards/lib/utils.js":
/*!*************************************!*\
  !*** ../adaptivecards/lib/utils.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clearElementChildren = exports.getScrollY = exports.getScrollX = exports.getFitStatus = exports.truncate = exports.truncateText = exports.stringToCssColor = exports.parseEnum = exports.getEnumValueByName = exports.parseBool = exports.parseNumber = exports.parseString = exports.appendChild = exports.generateUniqueId = exports.isMobileOS = exports.isInternetExplorer = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var Enums = __webpack_require__(/*! ./enums */ "../adaptivecards/lib/enums.js");
var Shared = __webpack_require__(/*! ./shared */ "../adaptivecards/lib/shared.js");
function isInternetExplorer() {
    // The documentMode property only exists in IE
    return window.document.documentMode !== undefined;
}
exports.isInternetExplorer = isInternetExplorer;
function isMobileOS() {
    var userAgent = window.navigator.userAgent;
    return (!!userAgent.match(/Android/i) || !!userAgent.match(/iPad/i) || !!userAgent.match(/iPhone/i));
}
exports.isMobileOS = isMobileOS;
/**
 * Generate a UUID prepended with "__ac-"
 */
function generateUniqueId() {
    return "__ac-" + Shared.UUID.generate();
}
exports.generateUniqueId = generateUniqueId;
function appendChild(node, child) {
    if (child) {
        node.appendChild(child);
    }
}
exports.appendChild = appendChild;
function parseString(obj, defaultValue) {
    return typeof obj === "string" ? obj : defaultValue;
}
exports.parseString = parseString;
function parseNumber(obj, defaultValue) {
    return typeof obj === "number" ? obj : defaultValue;
}
exports.parseNumber = parseNumber;
function parseBool(value, defaultValue) {
    if (typeof value === "boolean") {
        return value;
    }
    else if (typeof value === "string") {
        switch (value.toLowerCase()) {
            case "true":
                return true;
            case "false":
                return false;
            default:
                return defaultValue;
        }
    }
    return defaultValue;
}
exports.parseBool = parseBool;
function getEnumValueByName(enumType, name) {
    // eslint-disable-next-line guard-for-in
    for (var key in enumType) {
        var keyAsNumber = parseInt(key, 10);
        if (keyAsNumber >= 0) {
            var value = enumType[key];
            if (value && typeof value === "string" && value.toLowerCase() === name.toLowerCase()) {
                return keyAsNumber;
            }
        }
    }
    return undefined;
}
exports.getEnumValueByName = getEnumValueByName;
function parseEnum(enumType, name, defaultValue) {
    if (!name) {
        return defaultValue;
    }
    var enumValue = getEnumValueByName(enumType, name);
    return enumValue !== undefined ? enumValue : defaultValue;
}
exports.parseEnum = parseEnum;
function stringToCssColor(color) {
    if (color) {
        var regEx = /#([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})?/gi;
        var matches = regEx.exec(color);
        if (matches && matches[4]) {
            var a = parseInt(matches[1], 16) / 255;
            var r = parseInt(matches[2], 16);
            var g = parseInt(matches[3], 16);
            var b = parseInt(matches[4], 16);
            return "rgba(" + r + "," + g + "," + b + "," + a + ")";
        }
    }
    return color;
}
exports.stringToCssColor = stringToCssColor;
function truncateWorker(element, maxHeight, fullText, truncateAt, lineHeight) {
    var fits = function () {
        // Allow a one pixel overflow to account for rounding differences
        // between browsers
        return maxHeight - element.scrollHeight >= -1.0;
    };
    if (fits()) {
        return;
    }
    var breakableIndices = findBreakableIndices(fullText);
    var lo = 0;
    var hi = breakableIndices.length;
    var bestBreakIdx = 0;
    // Do a binary search for the longest string that fits
    while (lo < hi) {
        var mid = Math.floor((lo + hi) / 2);
        truncateAt(fullText, breakableIndices[mid]);
        if (fits()) {
            bestBreakIdx = breakableIndices[mid];
            lo = mid + 1;
        }
        else {
            hi = mid;
        }
    }
    truncateAt(fullText, bestBreakIdx);
    // If we have extra room, try to expand the string letter by letter
    // (covers the case where we have to break in the middle of a long word)
    if (lineHeight && maxHeight - element.scrollHeight >= lineHeight - 1.0) {
        var idx = findNextCharacter(fullText, bestBreakIdx);
        while (idx < fullText.length) {
            truncateAt(fullText, idx);
            if (fits()) {
                bestBreakIdx = idx;
                idx = findNextCharacter(fullText, idx);
            }
            else {
                break;
            }
        }
        truncateAt(fullText, bestBreakIdx);
    }
}
function truncateText(element, maxHeight, lineHeight) {
    truncateWorker(element, maxHeight, element.innerText, function (text, idx) {
        element.innerText = text.substring(0, idx) + "...";
    }, lineHeight);
}
exports.truncateText = truncateText;
/**
 * {@link truncate} has been deprecated and is no longer in use internally. This policy passes
 * content through as it always has, which is _supposed_ to be dealing with text only (see {@link
 * TextBlock.truncateIfSupported}), but had a bug where it might actually pass through an element
 * for which innerHTML yielded actual HTML (since fixed).
 */
var ttDeprecatedPolicy = (typeof window === 'undefined') ? undefined : (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy("adaptivecards#deprecatedExportedFunctionPolicy", {
    createHTML: function (value) { return value; }
});
/** @deprecated Use {@link truncateText} instead. */
function truncate(element, maxHeight, lineHeight) {
    truncateWorker(element, maxHeight, element.innerHTML, function (text, idx) {
        var _a;
        var truncatedString = text.substring(0, idx) + "...";
        var truncatedHTML = (_a = ttDeprecatedPolicy === null || ttDeprecatedPolicy === void 0 ? void 0 : ttDeprecatedPolicy.createHTML(truncatedString)) !== null && _a !== void 0 ? _a : truncatedString;
        element.innerHTML = truncatedHTML;
    }, lineHeight);
}
exports.truncate = truncate;
function findBreakableIndices(html) {
    var results = [];
    var idx = findNextCharacter(html, -1);
    while (idx < html.length) {
        if (html[idx] === " ") {
            results.push(idx);
        }
        idx = findNextCharacter(html, idx);
    }
    return results;
}
function findNextCharacter(html, currIdx) {
    currIdx += 1;
    // If we found the start of an HTML tag, keep advancing until we get
    // past it, so we don't end up truncating in the middle of the tag
    while (currIdx < html.length && html[currIdx] === "<") {
        while (currIdx < html.length && html[currIdx++] !== ">") {
            continue;
        }
    }
    return currIdx;
}
function getFitStatus(element, containerEnd) {
    var start = element.offsetTop;
    var end = start + element.clientHeight;
    if (end <= containerEnd) {
        return Enums.ContainerFitStatus.FullyInContainer;
    }
    else if (start < containerEnd) {
        return Enums.ContainerFitStatus.Overflowing;
    }
    else {
        return Enums.ContainerFitStatus.FullyOutOfContainer;
    }
}
exports.getFitStatus = getFitStatus;
function getScrollX() {
    return window.pageXOffset;
}
exports.getScrollX = getScrollX;
function getScrollY() {
    return window.pageYOffset;
}
exports.getScrollY = getScrollY;
function clearElementChildren(element) {
    while (element.firstChild) {
        element.removeChild(element.firstChild);
    }
}
exports.clearElementChildren = clearElementChildren;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "../node_modules/object-assign/index.js":
/*!**********************************************!*\
  !*** ../node_modules/object-assign/index.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "../node_modules/prop-types/checkPropTypes.js":
/*!****************************************************!*\
  !*** ../node_modules/prop-types/checkPropTypes.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "../node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "../node_modules/prop-types/factoryWithTypeCheckers.js":
/*!*************************************************************!*\
  !*** ../node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "../node_modules/prop-types/node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "../node_modules/object-assign/index.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "../node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "../node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "../node_modules/prop-types/index.js":
/*!*******************************************!*\
  !*** ../node_modules/prop-types/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "../node_modules/prop-types/node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "../node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "../node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!**************************************************************!*\
  !*** ../node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "../node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js":
/*!************************************************************************************!*\
  !*** ../node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "../node_modules/prop-types/node_modules/react-is/index.js":
/*!*****************************************************************!*\
  !*** ../node_modules/prop-types/node_modules/react-is/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "../node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "../node_modules/punycode/punycode.es6.js":
/*!************************************************!*\
  !*** ../node_modules/punycode/punycode.es6.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ucs2decode": () => (/* binding */ ucs2decode),
/* harmony export */   "ucs2encode": () => (/* binding */ ucs2encode),
/* harmony export */   "decode": () => (/* binding */ decode),
/* harmony export */   "encode": () => (/* binding */ encode),
/* harmony export */   "toASCII": () => (/* binding */ toASCII),
/* harmony export */   "toUnicode": () => (/* binding */ toUnicode),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


/** Highest positive signed 32-bit float value */
const maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128; // 0x80
const delimiter = '-'; // '\x2D'

/** Regular expressions */
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
const errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	const result = [];
	let length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	const parts = string.split('@');
	let result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\x2E');
	const labels = string.split('.');
	const encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	const output = [];
	let counter = 0;
	const length = string.length;
	while (counter < length) {
		const value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			const extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
const ucs2encode = array => String.fromCodePoint(...array);

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
const basicToDigit = function(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
const digitToBasic = function(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
const adapt = function(delta, numPoints, firstTime) {
	let k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
const decode = function(input) {
	// Don't use UCS-2.
	const output = [];
	const inputLength = input.length;
	let i = 0;
	let n = initialN;
	let bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	let basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (let j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		let oldi = i;
		for (let w = 1, k = base; /* no condition */; k += base) {

			if (index >= inputLength) {
				error('invalid-input');
			}

			const digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error('overflow');
			}

			i += digit * w;
			const t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

			if (digit < t) {
				break;
			}

			const baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error('overflow');
			}

			w *= baseMinusT;

		}

		const out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);

	}

	return String.fromCodePoint(...output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
const encode = function(input) {
	const output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	let inputLength = input.length;

	// Initialize the state.
	let n = initialN;
	let delta = 0;
	let bias = initialBias;

	// Handle the basic code points.
	for (const currentValue of input) {
		if (currentValue < 0x80) {
			output.push(stringFromCharCode(currentValue));
		}
	}

	let basicLength = output.length;
	let handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		let m = maxInt;
		for (const currentValue of input) {
			if (currentValue >= n && currentValue < m) {
				m = currentValue;
			}
		}

		// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
		// but guard against overflow.
		const handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		for (const currentValue of input) {
			if (currentValue < n && ++delta > maxInt) {
				error('overflow');
			}
			if (currentValue == n) {
				// Represent delta as a generalized variable-length integer.
				let q = delta;
				for (let k = base; /* no condition */; k += base) {
					const t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
					if (q < t) {
						break;
					}
					const qMinusT = q - t;
					const baseMinusT = base - t;
					output.push(
						stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
					);
					q = floor(qMinusT / baseMinusT);
				}

				output.push(stringFromCharCode(digitToBasic(q, 0)));
				bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
				delta = 0;
				++handledCPCount;
			}
		}

		++delta;
		++n;

	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
const toUnicode = function(input) {
	return mapDomain(input, function(string) {
		return regexPunycode.test(string)
			? decode(string.slice(4).toLowerCase())
			: string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
const toASCII = function(input) {
	return mapDomain(input, function(string) {
		return regexNonASCII.test(string)
			? 'xn--' + encode(string)
			: string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
const punycode = {
	/**
	 * A string representing the current Punycode.js version number.
	 * @memberOf punycode
	 * @type String
	 */
	'version': '2.1.0',
	/**
	 * An object of methods to convert from JavaScript's internal character
	 * representation (UCS-2) to Unicode code points, and back.
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode
	 * @type Object
	 */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (punycode);


/***/ }),

/***/ "./src/adaptive-card.tsx":
/*!*******************************!*\
  !*** ./src/adaptive-card.tsx ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdaptiveCard = void 0;
var AdaptiveCards = __importStar(__webpack_require__(/*! adaptivecards */ "../adaptivecards/lib/adaptivecards.js"));
var react_1 = __importStar(__webpack_require__(/*! react */ "react"));
var PropTypes = __importStar(__webpack_require__(/*! prop-types */ "../node_modules/prop-types/index.js"));
var markdown = __importStar(__webpack_require__(/*! markdown-it */ "./node_modules/markdown-it/index.js"));
var propTypes = {
    /** The card schema.  It must comply with the card schema. [More Info](https://docs.microsoft.com/en-us/adaptive-cards/create/cardschema) */
    payload: PropTypes.object.isRequired,
    /** Method that will be invoked anytime a card action is executed. [More Info](https://docs.microsoft.com/en-us/adaptive-cards/display/implementingrenderer#actions) */
    onExecuteAction: PropTypes.func,
    /** Method that will be invoked when a Submit action is executed. [More Info](https://docs.microsoft.com/en-us/adaptive-cards/display/implementingrenderer#actionsubmit) */
    onActionSubmit: PropTypes.func,
    /** Method that will be invoked when an Open Url action is executed. [More Info](https://docs.microsoft.com/en-us/adaptive-cards/display/implementingrenderer#actionopenurl) */
    onActionOpenUrl: PropTypes.func,
    /** Method that will be invoked when a Show Card action is executed. [More Info](https://docs.microsoft.com/en-us/adaptive-cards/display/implementingrenderer#actionshowcard) */
    onActionShowCard: PropTypes.func,
    /** Method that will be invoked if an error is thrown while trying to render a card. */
    onError: PropTypes.func,
    /** JSX styles that will be applied to the card conatiner */
    style: PropTypes.object,
    /** HostConfig. [More Info](https://docs.microsoft.com/en-us/adaptive-cards/rendering-cards/host-config) */
    hostConfig: PropTypes.object,
};
var defaultOpenUrlHandler = function (action) {
    window.open(action.url, '_blank');
};
var setUpMarkdownIt = function () {
    if (!AdaptiveCards.AdaptiveCard.onProcessMarkdown) {
        AdaptiveCards.AdaptiveCard.onProcessMarkdown = function (text, result) {
            result.outputHtml = new markdown.default().render(text);
            result.didProcess = true;
        };
    }
};
setUpMarkdownIt();
var AdaptiveCard = function (_a) {
    var payload = _a.payload, onExecuteAction = _a.onExecuteAction, onActionSubmit = _a.onActionSubmit, onActionOpenUrl = _a.onActionOpenUrl, onActionShowCard = _a.onActionShowCard, onError = _a.onError, style = _a.style, hostConfig = _a.hostConfig;
    var _b = (0, react_1.useState)(), error = _b[0], setError = _b[1];
    var targetRef = (0, react_1.useRef)(null);
    var cardRef = (0, react_1.useRef)(new AdaptiveCards.AdaptiveCard());
    var executeAction = (0, react_1.useCallback)(function (a) {
        var type = a.getJsonTypeName();
        switch (type) {
            case AdaptiveCards.OpenUrlAction.JsonTypeName: {
                if (onActionOpenUrl) {
                    onActionOpenUrl(a);
                }
                else {
                    defaultOpenUrlHandler(a);
                }
                break;
            }
            case AdaptiveCards.ShowCardAction.JsonTypeName: {
                if (onActionShowCard) {
                    onActionShowCard(a);
                }
                break;
            }
            case AdaptiveCards.SubmitAction.JsonTypeName: {
                if (onActionSubmit) {
                    onActionSubmit(a);
                }
                break;
            }
        }
        // TODO: Why is there a global action handler when we have specific
        // handlers for the above cases? Can we simplify to one approach?
        if (onExecuteAction) {
            onExecuteAction(a);
        }
    }, [onActionOpenUrl, onActionShowCard, onActionSubmit, onExecuteAction]);
    (0, react_1.useEffect)(function () {
        cardRef.current.onExecuteAction = executeAction;
    }, [executeAction]);
    (0, react_1.useEffect)(function () {
        cardRef.current.hostConfig = new AdaptiveCards.HostConfig(hostConfig);
    }, [hostConfig]);
    (0, react_1.useEffect)(function () {
        var _a, _b;
        if (!targetRef.current) {
            return;
        }
        var card = cardRef.current;
        try {
            card.parse(payload);
            var result = card.render();
            var trustedHtml = (typeof window === 'undefined') ? "" : ((_b = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.emptyHTML) !== null && _b !== void 0 ? _b : "");
            targetRef.current.innerHTML = trustedHtml;
            targetRef.current.appendChild(result);
        }
        catch (cardRenderError) {
            if (onError) {
                onError(cardRenderError);
                setError(cardRenderError);
            }
        }
    }, [hostConfig, payload, onError]);
    if (error) {
        return react_1.default.createElement("div", { style: { color: 'red' } }, error.message);
    }
    return react_1.default.createElement("div", { style: style, ref: targetRef });
};
exports.AdaptiveCard = AdaptiveCard;
exports.AdaptiveCard.propTypes = propTypes;


/***/ }),

/***/ "./src/adaptivecards-react.ts":
/*!************************************!*\
  !*** ./src/adaptivecards-react.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__exportStar(__webpack_require__(/*! ./adaptive-card */ "./src/adaptive-card.tsx"), exports);
__exportStar(__webpack_require__(/*! ./host-config-context */ "./src/host-config-context.tsx"), exports);


/***/ }),

/***/ "./src/host-config-context.tsx":
/*!*************************************!*\
  !*** ./src/host-config-context.tsx ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProvidesHostConfigContext = exports.AdaptiveCardUsingHostConfigContext = exports.HostConfigContext = void 0;
var react_1 = __importStar(__webpack_require__(/*! react */ "react"));
var adaptive_card_1 = __webpack_require__(/*! ./adaptive-card */ "./src/adaptive-card.tsx");
exports.HostConfigContext = (0, react_1.createContext)({ hostConfig: null });
var AdaptiveCardUsingHostConfigContext = function (props) {
    var context = (0, react_1.useContext)(exports.HostConfigContext);
    return react_1.default.createElement(adaptive_card_1.AdaptiveCard, __assign({}, props, { hostConfig: context.hostConfig }));
};
exports.AdaptiveCardUsingHostConfigContext = AdaptiveCardUsingHostConfigContext;
var ProvidesHostConfigContext = function (_a) {
    var hostConfig = _a.hostConfig, children = _a.children;
    return react_1.default.createElement(exports.HostConfigContext.Provider, { value: { hostConfig: hostConfig } }, children);
};
exports.ProvidesHostConfigContext = ProvidesHostConfigContext;


/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "React" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_react__;

/***/ }),

/***/ "./node_modules/entities/lib/maps/entities.json":
/*!******************************************************!*\
  !*** ./node_modules/entities/lib/maps/entities.json ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"\'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\\"","QUOT":"\\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/adaptivecards-react.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRhcHRpdmVjYXJkcy1yZWFjdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTzs7Ozs7Ozs7OztBQ1ZhOzs7QUFHYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsMkJBQTJCOzs7QUFHM0IseUJBQXlCLG9DQUFvQzs7QUFFN0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLHFEQUFVOztBQUV2QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7O0FBRXhCLHFCQUFxQjs7QUFFckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7O0FBRXRCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxhQUFhO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxhQUFhO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNDQUFzQztBQUM5RSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLFNBQVM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDcFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7O0FBR2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0Isa0RBQWtEOztBQUVsRDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyx1Q0FBdUM7QUFDdkMsd0NBQXdDO0FBQ3hDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDBCQUEwQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SCxJQUFJO0FBQzNIO0FBQ0E7QUFDQSxrSEFBa0gsZUFBZSxJQUFJLGtCQUFrQjtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUIsVUFBVSx1QkFBdUI7QUFDakMsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLDZNQUE2TSwrQkFBK0IsaUJBQWlCO0FBQzdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsME1BQTBNLCtCQUErQixpQkFBaUI7QUFDMVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0JBQWdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQ0FBa0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdCQUFnQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxnQkFBZ0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUsaUJBQWlCLGlCQUFpQixXQUFXO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0QsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGdCQUFnQjtBQUN4RTtBQUNBLGdEQUFnRCxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBLGdFQUFnRSxnQkFBZ0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsK0JBQStCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0NBQWtDO0FBQzVDLFVBQVUsaUNBQWlDO0FBQzNDLFVBQVUsaUNBQWlDO0FBQzNDLFVBQVUsbUNBQW1DO0FBQzdDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdCQUFnQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZ0JBQWdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0JBQWdCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGdCQUFnQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCLFVBQVUsbUJBQW1CO0FBQzdCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELEVBQUUsT0FBTyxFQUFFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGdCQUFnQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0NBQXNDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQ0FBa0M7QUFDNUMsVUFBVSxtQ0FBbUM7QUFDN0MsVUFBVTtBQUNWO0FBQ0EseUdBQXlHLGlDQUFpQyxJQUFJLG1DQUFtQztBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsc0JBQXNCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxnQkFBZ0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0JBQWdCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsZ0JBQWdCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0JBQWdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0RBQWtELGdCQUFnQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsOEJBQThCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLHFDQUFxQztBQUNyQztBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0JBQWdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxnQkFBZ0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxnQkFBZ0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0JBQWdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxzQkFBc0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0JBQWdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUNBQXFDO0FBQ25ELGNBQWMsc0NBQXNDO0FBQ3BELGNBQWMsa0ZBQWtGO0FBQ2hHLGNBQWMsZ0ZBQWdGO0FBQzlGLGNBQWMscUZBQXFGO0FBQ25HLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlCQUF5QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDJCQUEyQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0QsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw0QkFBNEI7QUFDNUI7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlDQUF5QztBQUNsRSxzQkFBc0IseUNBQXlDO0FBQy9ELHVCQUF1Qix5Q0FBeUM7QUFDaEUsd0JBQXdCLHlDQUF5QztBQUNqRSxzQkFBc0IseUNBQXlDO0FBQy9ELHlCQUF5Qix5Q0FBeUM7QUFDbEUsMkJBQTJCO0FBQzNCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsZ0NBQWdDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDBCQUEwQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Qsa0JBQWtCO0FBQ2xCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCwwQkFBMEI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELDZCQUE2QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNELGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLEtBQXFDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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RUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztVRU5BO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uL25vZGVfbW9kdWxlcy9saW5raWZ5LWl0L2luZGV4LmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbGlua2lmeS1pdC9saWIvcmUuanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9jb21tb24vZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfYmxvY2tzLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX3JlLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi91dGlscy5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL2luZGV4LmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19kZXN0aW5hdGlvbi5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfbGFiZWwuanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX3RpdGxlLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2luZGV4LmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3BhcnNlcl9ibG9jay5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wYXJzZXJfY29yZS5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wYXJzZXJfaW5saW5lLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3ByZXNldHMvY29tbW9ubWFyay5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2RlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy96ZXJvLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3JlbmRlcmVyLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVyLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGUuanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svY29kZS5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9mZW5jZS5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oZWFkaW5nLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hyLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2h0bWxfYmxvY2suanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGhlYWRpbmcuanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGlzdC5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9wYXJhZ3JhcGguanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcmVmZXJlbmNlLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3RhYmxlLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvYmxvY2suanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9saW5raWZ5LmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbm9ybWFsaXplLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMuanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zdGF0ZV9jb3JlLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9hdXRvbGluay5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFja3RpY2tzLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9iYWxhbmNlX3BhaXJzLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbXBoYXNpcy5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW50aXR5LmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2h0bWxfaW5saW5lLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9pbWFnZS5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbGluay5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbmV3bGluZS5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RhdGVfaW5saW5lLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdHJpa2V0aHJvdWdoLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0LmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0X2NvbGxhcHNlLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3Rva2VuLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWR1cmwvZGVjb2RlLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWR1cmwvZW5jb2RlLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWR1cmwvZm9ybWF0LmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvbWR1cmwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uL25vZGVfbW9kdWxlcy9tZHVybC9wYXJzZS5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4vbm9kZV9tb2R1bGVzL3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2MvcmVnZXguanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uL25vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL0NmL3JlZ2V4LmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4LmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9aL3JlZ2V4LmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi9ub2RlX21vZHVsZXMvdWMubWljcm8vaW5kZXguanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uL25vZGVfbW9kdWxlcy91Yy5taWNyby9wcm9wZXJ0aWVzL0FueS9yZWdleC5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4uL2FkYXB0aXZlY2FyZHMvbGliL2FjdGl2aXR5LXJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uLi9hZGFwdGl2ZWNhcmRzL2xpYi9hZGFwdGl2ZS1hcHBsZXQuanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uLi9hZGFwdGl2ZWNhcmRzL2xpYi9hZGFwdGl2ZWNhcmRzLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi4vYWRhcHRpdmVjYXJkcy9saWIvY2FyZC1lbGVtZW50cy5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4uL2FkYXB0aXZlY2FyZHMvbGliL2NhcmQtb2JqZWN0LmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi4vYWRhcHRpdmVjYXJkcy9saWIvY2hhbm5lbC1hZGFwdGVyLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi4vYWRhcHRpdmVjYXJkcy9saWIvY29udHJvbHMvY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4uL2FkYXB0aXZlY2FyZHMvbGliL2NvbnRyb2xzL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4uL2FkYXB0aXZlY2FyZHMvbGliL2NvbnRyb2xzL2luZGV4LmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi4vYWRhcHRpdmVjYXJkcy9saWIvY29udHJvbHMvbWVudS1pdGVtLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi4vYWRhcHRpdmVjYXJkcy9saWIvY29udHJvbHMvcG9wdXAtY29udHJvbC5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4uL2FkYXB0aXZlY2FyZHMvbGliL2NvbnRyb2xzL3BvcHVwLW1lbnUuanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uLi9hZGFwdGl2ZWNhcmRzL2xpYi9lbnVtcy5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4uL2FkYXB0aXZlY2FyZHMvbGliL2hvc3QtY2FwYWJpbGl0aWVzLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi4vYWRhcHRpdmVjYXJkcy9saWIvaG9zdC1jb25maWcuanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uLi9hZGFwdGl2ZWNhcmRzL2xpYi9yZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4uL2FkYXB0aXZlY2FyZHMvbGliL3NlcmlhbGl6YXRpb24uanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uLi9hZGFwdGl2ZWNhcmRzL2xpYi9zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uLi9hZGFwdGl2ZWNhcmRzL2xpYi9zdHJpbmdzLmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi4vYWRhcHRpdmVjYXJkcy9saWIvdGFibGUuanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uLi9hZGFwdGl2ZWNhcmRzL2xpYi90ZXh0LWZvcm1hdHRlcnMuanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uLi9hZGFwdGl2ZWNhcmRzL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvLi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4uL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5lczYuanMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uL3NyYy9hZGFwdGl2ZS1jYXJkLnRzeCIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzLy4vc3JjL2FkYXB0aXZlY2FyZHMtcmVhY3QudHMiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy8uL3NyYy9ob3N0LWNvbmZpZy1jb250ZXh0LnRzeCIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzL2V4dGVybmFsIHVtZCBcIlJlYWN0XCIiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vQWRhcHRpdmVDYXJkcy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL0FkYXB0aXZlQ2FyZHMvd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzL3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9BZGFwdGl2ZUNhcmRzL3dlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJSZWFjdFwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJSZWFjdFwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJBZGFwdGl2ZUNhcmRzXCJdID0gZmFjdG9yeShyZXF1aXJlKFwiUmVhY3RcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkFkYXB0aXZlQ2FyZHNcIl0gPSBmYWN0b3J5KHJvb3RbXCJSZWFjdFwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX3JlYWN0X18pIHtcbnJldHVybiAiLCIndXNlIHN0cmljdCc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhlbHBlcnNcblxuLy8gTWVyZ2Ugb2JqZWN0c1xuLy9cbmZ1bmN0aW9uIGFzc2lnbihvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkgeyByZXR1cm47IH1cblxuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfY2xhc3Mob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTsgfVxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7IH1cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nOyB9XG5mdW5jdGlvbiBpc1JlZ0V4cChvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBSZWdFeHBdJzsgfVxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nOyB9XG5cblxuZnVuY3Rpb24gZXNjYXBlUkUoc3RyKSB7IHJldHVybiBzdHIucmVwbGFjZSgvWy4/KiteJFtcXF1cXFxcKCl7fXwtXS9nLCAnXFxcXCQmJyk7IH1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGZ1enp5TGluazogdHJ1ZSxcbiAgZnV6enlFbWFpbDogdHJ1ZSxcbiAgZnV6enlJUDogZmFsc2Vcbn07XG5cblxuZnVuY3Rpb24gaXNPcHRpb25zT2JqKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqIHx8IHt9KS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgaykge1xuICAgIHJldHVybiBhY2MgfHwgZGVmYXVsdE9wdGlvbnMuaGFzT3duUHJvcGVydHkoayk7XG4gIH0sIGZhbHNlKTtcbn1cblxuXG52YXIgZGVmYXVsdFNjaGVtYXMgPSB7XG4gICdodHRwOic6IHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHRleHQsIHBvcywgc2VsZikge1xuICAgICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICAgIGlmICghc2VsZi5yZS5odHRwKSB7XG4gICAgICAgIC8vIGNvbXBpbGUgbGF6aWx5LCBiZWNhdXNlIFwiaG9zdFwiLWNvbnRhaW5pbmcgdmFyaWFibGVzIGNhbiBjaGFuZ2Ugb24gdGxkcyB1cGRhdGUuXG4gICAgICAgIHNlbGYucmUuaHR0cCA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeXFxcXC9cXFxcLycgKyBzZWxmLnJlLnNyY19hdXRoICsgc2VsZi5yZS5zcmNfaG9zdF9wb3J0X3N0cmljdCArIHNlbGYucmUuc3JjX3BhdGgsICdpJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYucmUuaHR0cC50ZXN0KHRhaWwpKSB7XG4gICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUuaHR0cClbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LFxuICAnaHR0cHM6JzogICdodHRwOicsXG4gICdmdHA6JzogICAgJ2h0dHA6JyxcbiAgJy8vJzogICAgICB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcbiAgICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgICBpZiAoIXNlbGYucmUubm9faHR0cCkge1xuICAgICAgLy8gY29tcGlsZSBsYXppbHksIGJlY2F1c2UgXCJob3N0XCItY29udGFpbmluZyB2YXJpYWJsZXMgY2FuIGNoYW5nZSBvbiB0bGRzIHVwZGF0ZS5cbiAgICAgICAgc2VsZi5yZS5ub19odHRwID0gIG5ldyBSZWdFeHAoXG4gICAgICAgICAgJ14nICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19hdXRoICtcbiAgICAgICAgICAvLyBEb24ndCBhbGxvdyBzaW5nbGUtbGV2ZWwgZG9tYWlucywgYmVjYXVzZSBvZiBmYWxzZSBwb3NpdGl2ZXMgbGlrZSAnLy90ZXN0J1xuICAgICAgICAgIC8vIHdpdGggY29kZSBjb21tZW50c1xuICAgICAgICAgICcoPzpsb2NhbGhvc3R8KD86KD86JyArIHNlbGYucmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKycgKyBzZWxmLnJlLnNyY19kb21haW5fcm9vdCArICcpJyArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfcG9ydCArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfaG9zdF90ZXJtaW5hdG9yICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19wYXRoLFxuXG4gICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnJlLm5vX2h0dHAudGVzdCh0YWlsKSkge1xuICAgICAgICAvLyBzaG91bGQgbm90IGJlIGA6Ly9gICYgYC8vL2AsIHRoYXQgcHJvdGVjdHMgZnJvbSBlcnJvcnMgaW4gcHJvdG9jb2wgbmFtZVxuICAgICAgICBpZiAocG9zID49IDMgJiYgdGV4dFtwb3MgLSAzXSA9PT0gJzonKSB7IHJldHVybiAwOyB9XG4gICAgICAgIGlmIChwb3MgPj0gMyAmJiB0ZXh0W3BvcyAtIDNdID09PSAnLycpIHsgcmV0dXJuIDA7IH1cbiAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5ub19odHRwKVswXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sXG4gICdtYWlsdG86Jzoge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgICAgaWYgKCFzZWxmLnJlLm1haWx0bykge1xuICAgICAgICBzZWxmLnJlLm1haWx0byA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeJyArIHNlbGYucmUuc3JjX2VtYWlsX25hbWUgKyAnQCcgKyBzZWxmLnJlLnNyY19ob3N0X3N0cmljdCwgJ2knXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5yZS5tYWlsdG8udGVzdCh0YWlsKSkge1xuICAgICAgICByZXR1cm4gdGFpbC5tYXRjaChzZWxmLnJlLm1haWx0bylbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG59O1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG4vLyBSRSBwYXR0ZXJuIGZvciAyLWNoYXJhY3RlciB0bGRzIChhdXRvZ2VuZXJhdGVkIGJ5IC4vc3VwcG9ydC90bGRzXzJjaGFyX2dlbi5qcylcbnZhciB0bGRzXzJjaF9zcmNfcmUgPSAnYVtjZGVmZ2lsbW5vcXJzdHV3eHpdfGJbYWJkZWZnaGlqbW5vcnN0dnd5el18Y1thY2RmZ2hpa2xtbm9ydXZ3eHl6XXxkW2Vqa21vel18ZVtjZWdyc3R1XXxmW2lqa21vcl18Z1thYmRlZmdoaWxtbnBxcnN0dXd5XXxoW2ttbnJ0dV18aVtkZWxtbm9xcnN0XXxqW2Vtb3BdfGtbZWdoaW1ucHJ3eXpdfGxbYWJjaWtyc3R1dnldfG1bYWNkZWdoa2xtbm9wcXJzdHV2d3h5el18blthY2VmZ2lsb3BydXpdfG9tfHBbYWVmZ2hrbG1ucnN0d3ldfHFhfHJbZW9zdXddfHNbYWJjZGVnaGlqa2xtbm9ydHV2eHl6XXx0W2NkZmdoamtsbW5vcnR2d3pdfHVbYWdrc3l6XXx2W2FjZWdpbnVdfHdbZnNdfHlbZXRdfHpbYW13XSc7XG5cbi8vIERPTidUIHRyeSB0byBtYWtlIFBScyB3aXRoIGNoYW5nZXMuIEV4dGVuZCBUTERzIHdpdGggTGlua2lmeUl0LnRsZHMoKSBpbnN0ZWFkXG52YXIgdGxkc19kZWZhdWx0ID0gJ2Jpenxjb218ZWR1fGdvdnxuZXR8b3JnfHByb3x3ZWJ8eHh4fGFlcm98YXNpYXxjb29wfGluZm98bXVzZXVtfG5hbWV8c2hvcHzRgNGEJy5zcGxpdCgnfCcpO1xuXG4vKmVzbGludC1lbmFibGUgbWF4LWxlbiovXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIHJlc2V0U2NhbkNhY2hlKHNlbGYpIHtcbiAgc2VsZi5fX2luZGV4X18gPSAtMTtcbiAgc2VsZi5fX3RleHRfY2FjaGVfXyAgID0gJyc7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRvcihyZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRleHQsIHBvcykge1xuICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgaWYgKHJlLnRlc3QodGFpbCkpIHtcbiAgICAgIHJldHVybiB0YWlsLm1hdGNoKHJlKVswXS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb3JtYWxpemVyKCkge1xuICByZXR1cm4gZnVuY3Rpb24gKG1hdGNoLCBzZWxmKSB7XG4gICAgc2VsZi5ub3JtYWxpemUobWF0Y2gpO1xuICB9O1xufVxuXG4vLyBTY2hlbWFzIGNvbXBpbGVyLiBCdWlsZCByZWdleHBzLlxuLy9cbmZ1bmN0aW9uIGNvbXBpbGUoc2VsZikge1xuXG4gIC8vIExvYWQgJiBjbG9uZSBSRSBwYXR0ZXJucy5cbiAgdmFyIHJlID0gc2VsZi5yZSA9IHJlcXVpcmUoJy4vbGliL3JlJykoc2VsZi5fX29wdHNfXyk7XG5cbiAgLy8gRGVmaW5lIGR5bmFtaWMgcGF0dGVybnNcbiAgdmFyIHRsZHMgPSBzZWxmLl9fdGxkc19fLnNsaWNlKCk7XG5cbiAgc2VsZi5vbkNvbXBpbGUoKTtcblxuICBpZiAoIXNlbGYuX190bGRzX3JlcGxhY2VkX18pIHtcbiAgICB0bGRzLnB1c2godGxkc18yY2hfc3JjX3JlKTtcbiAgfVxuICB0bGRzLnB1c2gocmUuc3JjX3huKTtcblxuICByZS5zcmNfdGxkcyA9IHRsZHMuam9pbignfCcpO1xuXG4gIGZ1bmN0aW9uIHVudHBsKHRwbCkgeyByZXR1cm4gdHBsLnJlcGxhY2UoJyVUTERTJScsIHJlLnNyY190bGRzKTsgfVxuXG4gIHJlLmVtYWlsX2Z1enp5ICAgICAgPSBSZWdFeHAodW50cGwocmUudHBsX2VtYWlsX2Z1enp5KSwgJ2knKTtcbiAgcmUubGlua19mdXp6eSAgICAgICA9IFJlZ0V4cCh1bnRwbChyZS50cGxfbGlua19mdXp6eSksICdpJyk7XG4gIHJlLmxpbmtfbm9faXBfZnV6enkgPSBSZWdFeHAodW50cGwocmUudHBsX2xpbmtfbm9faXBfZnV6enkpLCAnaScpO1xuICByZS5ob3N0X2Z1enp5X3Rlc3QgID0gUmVnRXhwKHVudHBsKHJlLnRwbF9ob3N0X2Z1enp5X3Rlc3QpLCAnaScpO1xuXG4gIC8vXG4gIC8vIENvbXBpbGUgZWFjaCBzY2hlbWFcbiAgLy9cblxuICB2YXIgYWxpYXNlcyA9IFtdO1xuXG4gIHNlbGYuX19jb21waWxlZF9fID0ge307IC8vIFJlc2V0IGNvbXBpbGVkIGRhdGFcblxuICBmdW5jdGlvbiBzY2hlbWFFcnJvcihuYW1lLCB2YWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyhMaW5raWZ5SXQpIEludmFsaWQgc2NoZW1hIFwiJyArIG5hbWUgKyAnXCI6ICcgKyB2YWwpO1xuICB9XG5cbiAgT2JqZWN0LmtleXMoc2VsZi5fX3NjaGVtYXNfXykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciB2YWwgPSBzZWxmLl9fc2NoZW1hc19fW25hbWVdO1xuXG4gICAgLy8gc2tpcCBkaXNhYmxlZCBtZXRob2RzXG4gICAgaWYgKHZhbCA9PT0gbnVsbCkgeyByZXR1cm47IH1cblxuICAgIHZhciBjb21waWxlZCA9IHsgdmFsaWRhdGU6IG51bGwsIGxpbms6IG51bGwgfTtcblxuICAgIHNlbGYuX19jb21waWxlZF9fW25hbWVdID0gY29tcGlsZWQ7XG5cbiAgICBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgaWYgKGlzUmVnRXhwKHZhbC52YWxpZGF0ZSkpIHtcbiAgICAgICAgY29tcGlsZWQudmFsaWRhdGUgPSBjcmVhdGVWYWxpZGF0b3IodmFsLnZhbGlkYXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWwudmFsaWRhdGUpKSB7XG4gICAgICAgIGNvbXBpbGVkLnZhbGlkYXRlID0gdmFsLnZhbGlkYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRnVuY3Rpb24odmFsLm5vcm1hbGl6ZSkpIHtcbiAgICAgICAgY29tcGlsZWQubm9ybWFsaXplID0gdmFsLm5vcm1hbGl6ZTtcbiAgICAgIH0gZWxzZSBpZiAoIXZhbC5ub3JtYWxpemUpIHtcbiAgICAgICAgY29tcGlsZWQubm9ybWFsaXplID0gY3JlYXRlTm9ybWFsaXplcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyh2YWwpKSB7XG4gICAgICBhbGlhc2VzLnB1c2gobmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgfSk7XG5cbiAgLy9cbiAgLy8gQ29tcGlsZSBwb3N0cG9uZWQgYWxpYXNlc1xuICAvL1xuXG4gIGFsaWFzZXMuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICBpZiAoIXNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXSkge1xuICAgICAgLy8gU2lsZW50bHkgZmFpbCBvbiBtaXNzZWQgc2NoZW1hcyB0byBhdm9pZCBlcnJvbnMgb24gZGlzYWJsZS5cbiAgICAgIC8vIHNjaGVtYUVycm9yKGFsaWFzLCBzZWxmLl9fc2NoZW1hc19fW2FsaWFzXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi5fX2NvbXBpbGVkX19bYWxpYXNdLnZhbGlkYXRlID1cbiAgICAgIHNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXS52YWxpZGF0ZTtcbiAgICBzZWxmLl9fY29tcGlsZWRfX1thbGlhc10ubm9ybWFsaXplID1cbiAgICAgIHNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXS5ub3JtYWxpemU7XG4gIH0pO1xuXG4gIC8vXG4gIC8vIEZha2UgcmVjb3JkIGZvciBndWVzc2VkIGxpbmtzXG4gIC8vXG4gIHNlbGYuX19jb21waWxlZF9fWycnXSA9IHsgdmFsaWRhdGU6IG51bGwsIG5vcm1hbGl6ZTogY3JlYXRlTm9ybWFsaXplcigpIH07XG5cbiAgLy9cbiAgLy8gQnVpbGQgc2NoZW1hIGNvbmRpdGlvblxuICAvL1xuICB2YXIgc2xpc3QgPSBPYmplY3Qua2V5cyhzZWxmLl9fY29tcGlsZWRfXylcbiAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgZGlzYWJsZWQgJiBmYWtlIHNjaGVtYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lLmxlbmd0aCA+IDAgJiYgc2VsZi5fX2NvbXBpbGVkX19bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAubWFwKGVzY2FwZVJFKVxuICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCd8Jyk7XG4gIC8vICg/IV8pIGNhdXNlIDEuNXggc2xvd2Rvd25cbiAgc2VsZi5yZS5zY2hlbWFfdGVzdCAgID0gUmVnRXhwKCcoXnwoPyFfKSg/Ols+PFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKSgnICsgc2xpc3QgKyAnKScsICdpJyk7XG4gIHNlbGYucmUuc2NoZW1hX3NlYXJjaCA9IFJlZ0V4cCgnKF58KD8hXykoPzpbPjxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSkoJyArIHNsaXN0ICsgJyknLCAnaWcnKTtcblxuICBzZWxmLnJlLnByZXRlc3QgPSBSZWdFeHAoXG4gICAgJygnICsgc2VsZi5yZS5zY2hlbWFfdGVzdC5zb3VyY2UgKyAnKXwoJyArIHNlbGYucmUuaG9zdF9mdXp6eV90ZXN0LnNvdXJjZSArICcpfEAnLFxuICAgICdpJ1xuICApO1xuXG4gIC8vXG4gIC8vIENsZWFudXBcbiAgLy9cblxuICByZXNldFNjYW5DYWNoZShzZWxmKTtcbn1cblxuLyoqXG4gKiBjbGFzcyBNYXRjaFxuICpcbiAqIE1hdGNoIHJlc3VsdC4gU2luZ2xlIGVsZW1lbnQgb2YgYXJyYXksIHJldHVybmVkIGJ5IFtbTGlua2lmeUl0I21hdGNoXV1cbiAqKi9cbmZ1bmN0aW9uIE1hdGNoKHNlbGYsIHNoaWZ0KSB7XG4gIHZhciBzdGFydCA9IHNlbGYuX19pbmRleF9fLFxuICAgICAgZW5kICAgPSBzZWxmLl9fbGFzdF9pbmRleF9fLFxuICAgICAgdGV4dCAgPSBzZWxmLl9fdGV4dF9jYWNoZV9fLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gIC8qKlxuICAgKiBNYXRjaCNzY2hlbWEgLT4gU3RyaW5nXG4gICAqXG4gICAqIFByZWZpeCAocHJvdG9jb2wpIGZvciBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnNjaGVtYSAgICA9IHNlbGYuX19zY2hlbWFfXy50b0xvd2VyQ2FzZSgpO1xuICAvKipcbiAgICogTWF0Y2gjaW5kZXggLT4gTnVtYmVyXG4gICAqXG4gICAqIEZpcnN0IHBvc2l0aW9uIG9mIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMuaW5kZXggICAgID0gc3RhcnQgKyBzaGlmdDtcbiAgLyoqXG4gICAqIE1hdGNoI2xhc3RJbmRleCAtPiBOdW1iZXJcbiAgICpcbiAgICogTmV4dCBwb3NpdGlvbiBhZnRlciBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLmxhc3RJbmRleCA9IGVuZCArIHNoaWZ0O1xuICAvKipcbiAgICogTWF0Y2gjcmF3IC0+IFN0cmluZ1xuICAgKlxuICAgKiBNYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnJhdyAgICAgICA9IHRleHQ7XG4gIC8qKlxuICAgKiBNYXRjaCN0ZXh0IC0+IFN0cmluZ1xuICAgKlxuICAgKiBOb3RtYWxpemVkIHRleHQgb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy50ZXh0ICAgICAgPSB0ZXh0O1xuICAvKipcbiAgICogTWF0Y2gjdXJsIC0+IFN0cmluZ1xuICAgKlxuICAgKiBOb3JtYWxpemVkIHVybCBvZiBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnVybCAgICAgICA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoKHNlbGYsIHNoaWZ0KSB7XG4gIHZhciBtYXRjaCA9IG5ldyBNYXRjaChzZWxmLCBzaGlmdCk7XG5cbiAgc2VsZi5fX2NvbXBpbGVkX19bbWF0Y2guc2NoZW1hXS5ub3JtYWxpemUobWF0Y2gsIHNlbGYpO1xuXG4gIHJldHVybiBtYXRjaDtcbn1cblxuXG4vKipcbiAqIGNsYXNzIExpbmtpZnlJdFxuICoqL1xuXG4vKipcbiAqIG5ldyBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucylcbiAqIC0gc2NoZW1hcyAoT2JqZWN0KTogT3B0aW9uYWwuIEFkZGl0aW9uYWwgc2NoZW1hcyB0byB2YWxpZGF0ZSAocHJlZml4L3ZhbGlkYXRvcilcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogeyBmdXp6eUxpbmt8ZnV6enlFbWFpbHxmdXp6eUlQOiB0cnVlfGZhbHNlIH1cbiAqXG4gKiBDcmVhdGVzIG5ldyBsaW5raWZpZXIgaW5zdGFuY2Ugd2l0aCBvcHRpb25hbCBhZGRpdGlvbmFsIHNjaGVtYXMuXG4gKiBDYW4gYmUgY2FsbGVkIHdpdGhvdXQgYG5ld2Aga2V5d29yZCBmb3IgY29udmVuaWVuY2UuXG4gKlxuICogQnkgZGVmYXVsdCB1bmRlcnN0YW5kczpcbiAqXG4gKiAtIGBodHRwKHMpOi8vLi4uYCAsIGBmdHA6Ly8uLi5gLCBgbWFpbHRvOi4uLmAgJiBgLy8uLi5gIGxpbmtzXG4gKiAtIFwiZnV6enlcIiBsaW5rcyBhbmQgZW1haWxzIChleGFtcGxlLmNvbSwgZm9vQGJhci5jb20pLlxuICpcbiAqIGBzY2hlbWFzYCBpcyBhbiBvYmplY3QsIHdoZXJlIGVhY2gga2V5L3ZhbHVlIGRlc2NyaWJlcyBwcm90b2NvbC9ydWxlOlxuICpcbiAqIC0gX19rZXlfXyAtIGxpbmsgcHJlZml4ICh1c3VhbGx5LCBwcm90b2NvbCBuYW1lIHdpdGggYDpgIGF0IHRoZSBlbmQsIGBza3lwZTpgXG4gKiAgIGZvciBleGFtcGxlKS4gYGxpbmtpZnktaXRgIG1ha2VzIHNodXJlIHRoYXQgcHJlZml4IGlzIG5vdCBwcmVjZWVkZWQgd2l0aFxuICogICBhbHBoYW51bWVyaWMgY2hhciBhbmQgc3ltYm9scy4gT25seSB3aGl0ZXNwYWNlcyBhbmQgcHVuY3R1YXRpb24gYWxsb3dlZC5cbiAqIC0gX192YWx1ZV9fIC0gcnVsZSB0byBjaGVjayB0YWlsIGFmdGVyIGxpbmsgcHJlZml4XG4gKiAgIC0gX1N0cmluZ18gLSBqdXN0IGFsaWFzIHRvIGV4aXN0aW5nIHJ1bGVcbiAqICAgLSBfT2JqZWN0X1xuICogICAgIC0gX3ZhbGlkYXRlXyAtIHZhbGlkYXRvciBmdW5jdGlvbiAoc2hvdWxkIHJldHVybiBtYXRjaGVkIGxlbmd0aCBvbiBzdWNjZXNzKSxcbiAqICAgICAgIG9yIGBSZWdFeHBgLlxuICogICAgIC0gX25vcm1hbGl6ZV8gLSBvcHRpb25hbCBmdW5jdGlvbiB0byBub3JtYWxpemUgdGV4dCAmIHVybCBvZiBtYXRjaGVkIHJlc3VsdFxuICogICAgICAgKGZvciBleGFtcGxlLCBmb3IgQHR3aXR0ZXIgbWVudGlvbnMpLlxuICpcbiAqIGBvcHRpb25zYDpcbiAqXG4gKiAtIF9fZnV6enlMaW5rX18gLSByZWNvZ25pZ2UgVVJMLXMgd2l0aG91dCBgaHR0cChzKTpgIHByZWZpeC4gRGVmYXVsdCBgdHJ1ZWAuXG4gKiAtIF9fZnV6enlJUF9fIC0gYWxsb3cgSVBzIGluIGZ1enp5IGxpbmtzIGFib3ZlLiBDYW4gY29uZmxpY3Qgd2l0aCBzb21lIHRleHRzXG4gKiAgIGxpa2UgdmVyc2lvbiBudW1iZXJzLiBEZWZhdWx0IGBmYWxzZWAuXG4gKiAtIF9fZnV6enlFbWFpbF9fIC0gcmVjb2duaXplIGVtYWlscyB3aXRob3V0IGBtYWlsdG86YCBwcmVmaXguXG4gKlxuICoqL1xuZnVuY3Rpb24gTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExpbmtpZnlJdCkpIHtcbiAgICByZXR1cm4gbmV3IExpbmtpZnlJdChzY2hlbWFzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIGlmIChpc09wdGlvbnNPYmooc2NoZW1hcykpIHtcbiAgICAgIG9wdGlvbnMgPSBzY2hlbWFzO1xuICAgICAgc2NoZW1hcyA9IHt9O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX19vcHRzX18gICAgICAgICAgID0gYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgLy8gQ2FjaGUgbGFzdCB0ZXN0ZWQgcmVzdWx0LiBVc2VkIHRvIHNraXAgcmVwZWF0aW5nIHN0ZXBzIG9uIG5leHQgYG1hdGNoYCBjYWxsLlxuICB0aGlzLl9faW5kZXhfXyAgICAgICAgICA9IC0xO1xuICB0aGlzLl9fbGFzdF9pbmRleF9fICAgICA9IC0xOyAvLyBOZXh0IHNjYW4gcG9zaXRpb25cbiAgdGhpcy5fX3NjaGVtYV9fICAgICAgICAgPSAnJztcbiAgdGhpcy5fX3RleHRfY2FjaGVfXyAgICAgPSAnJztcblxuICB0aGlzLl9fc2NoZW1hc19fICAgICAgICA9IGFzc2lnbih7fSwgZGVmYXVsdFNjaGVtYXMsIHNjaGVtYXMpO1xuICB0aGlzLl9fY29tcGlsZWRfXyAgICAgICA9IHt9O1xuXG4gIHRoaXMuX190bGRzX18gICAgICAgICAgID0gdGxkc19kZWZhdWx0O1xuICB0aGlzLl9fdGxkc19yZXBsYWNlZF9fICA9IGZhbHNlO1xuXG4gIHRoaXMucmUgPSB7fTtcblxuICBjb21waWxlKHRoaXMpO1xufVxuXG5cbi8qKiBjaGFpbmFibGVcbiAqIExpbmtpZnlJdCNhZGQoc2NoZW1hLCBkZWZpbml0aW9uKVxuICogLSBzY2hlbWEgKFN0cmluZyk6IHJ1bGUgbmFtZSAoZml4ZWQgcGF0dGVybiBwcmVmaXgpXG4gKiAtIGRlZmluaXRpb24gKFN0cmluZ3xSZWdFeHB8T2JqZWN0KTogc2NoZW1hIGRlZmluaXRpb25cbiAqXG4gKiBBZGQgbmV3IHJ1bGUgZGVmaW5pdGlvbi4gU2VlIGNvbnN0cnVjdG9yIGRlc2NyaXB0aW9uIGZvciBkZXRhaWxzLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoc2NoZW1hLCBkZWZpbml0aW9uKSB7XG4gIHRoaXMuX19zY2hlbWFzX19bc2NoZW1hXSA9IGRlZmluaXRpb247XG4gIGNvbXBpbGUodGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlXG4gKiBMaW5raWZ5SXQjc2V0KG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHsgZnV6enlMaW5rfGZ1enp5RW1haWx8ZnV6enlJUDogdHJ1ZXxmYWxzZSB9XG4gKlxuICogU2V0IHJlY29nbml0aW9uIG9wdGlvbnMgZm9yIGxpbmtzIHdpdGhvdXQgc2NoZW1hLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQob3B0aW9ucykge1xuICB0aGlzLl9fb3B0c19fID0gYXNzaWduKHRoaXMuX19vcHRzX18sIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjdGVzdCh0ZXh0KSAtPiBCb29sZWFuXG4gKlxuICogU2VhcmNoZXMgbGlua2lmaWFibGUgcGF0dGVybiBhbmQgcmV0dXJucyBgdHJ1ZWAgb24gc3VjY2VzcyBvciBgZmFsc2VgIG9uIGZhaWwuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiB0ZXN0KHRleHQpIHtcbiAgLy8gUmVzZXQgc2NhbiBjYWNoZVxuICB0aGlzLl9fdGV4dF9jYWNoZV9fID0gdGV4dDtcbiAgdGhpcy5fX2luZGV4X18gICAgICA9IC0xO1xuXG4gIGlmICghdGV4dC5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgdmFyIG0sIG1sLCBtZSwgbGVuLCBzaGlmdCwgbmV4dCwgcmUsIHRsZF9wb3MsIGF0X3BvcztcblxuICAvLyB0cnkgdG8gc2NhbiBmb3IgbGluayB3aXRoIHNjaGVtYSAtIHRoYXQncyB0aGUgbW9zdCBzaW1wbGUgcnVsZVxuICBpZiAodGhpcy5yZS5zY2hlbWFfdGVzdC50ZXN0KHRleHQpKSB7XG4gICAgcmUgPSB0aGlzLnJlLnNjaGVtYV9zZWFyY2g7XG4gICAgcmUubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoKG0gPSByZS5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgbGVuID0gdGhpcy50ZXN0U2NoZW1hQXQodGV4dCwgbVsyXSwgcmUubGFzdEluZGV4KTtcbiAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgdGhpcy5fX3NjaGVtYV9fICAgICA9IG1bMl07XG4gICAgICAgIHRoaXMuX19pbmRleF9fICAgICAgPSBtLmluZGV4ICsgbVsxXS5sZW5ndGg7XG4gICAgICAgIHRoaXMuX19sYXN0X2luZGV4X18gPSBtLmluZGV4ICsgbVswXS5sZW5ndGggKyBsZW47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9fb3B0c19fLmZ1enp5TGluayAmJiB0aGlzLl9fY29tcGlsZWRfX1snaHR0cDonXSkge1xuICAgIC8vIGd1ZXNzIHNjaGVtYWxlc3MgbGlua3NcbiAgICB0bGRfcG9zID0gdGV4dC5zZWFyY2godGhpcy5yZS5ob3N0X2Z1enp5X3Rlc3QpO1xuICAgIGlmICh0bGRfcG9zID49IDApIHtcbiAgICAgIC8vIGlmIHRsZCBpcyBsb2NhdGVkIGFmdGVyIGZvdW5kIGxpbmsgLSBubyBuZWVkIHRvIGNoZWNrIGZ1enp5IHBhdHRlcm5cbiAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgdGxkX3BvcyA8IHRoaXMuX19pbmRleF9fKSB7XG4gICAgICAgIGlmICgobWwgPSB0ZXh0Lm1hdGNoKHRoaXMuX19vcHRzX18uZnV6enlJUCA/IHRoaXMucmUubGlua19mdXp6eSA6IHRoaXMucmUubGlua19ub19pcF9mdXp6eSkpICE9PSBudWxsKSB7XG5cbiAgICAgICAgICBzaGlmdCA9IG1sLmluZGV4ICsgbWxbMV0ubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCBzaGlmdCA8IHRoaXMuX19pbmRleF9fKSB7XG4gICAgICAgICAgICB0aGlzLl9fc2NoZW1hX18gICAgID0gJyc7XG4gICAgICAgICAgICB0aGlzLl9faW5kZXhfXyAgICAgID0gc2hpZnQ7XG4gICAgICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbWwuaW5kZXggKyBtbFswXS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX19vcHRzX18uZnV6enlFbWFpbCAmJiB0aGlzLl9fY29tcGlsZWRfX1snbWFpbHRvOiddKSB7XG4gICAgLy8gZ3Vlc3Mgc2NoZW1hbGVzcyBlbWFpbHNcbiAgICBhdF9wb3MgPSB0ZXh0LmluZGV4T2YoJ0AnKTtcbiAgICBpZiAoYXRfcG9zID49IDApIHtcbiAgICAgIC8vIFdlIGNhbid0IHNraXAgdGhpcyBjaGVjaywgYmVjYXVzZSB0aGlzIGNhc2VzIGFyZSBwb3NzaWJsZTpcbiAgICAgIC8vIDE5Mi4xNjguMS4xQGdtYWlsLmNvbSwgbXkuaW5AZXhhbXBsZS5jb21cbiAgICAgIGlmICgobWUgPSB0ZXh0Lm1hdGNoKHRoaXMucmUuZW1haWxfZnV6enkpKSAhPT0gbnVsbCkge1xuXG4gICAgICAgIHNoaWZ0ID0gbWUuaW5kZXggKyBtZVsxXS5sZW5ndGg7XG4gICAgICAgIG5leHQgID0gbWUuaW5kZXggKyBtZVswXS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCBzaGlmdCA8IHRoaXMuX19pbmRleF9fIHx8XG4gICAgICAgICAgICAoc2hpZnQgPT09IHRoaXMuX19pbmRleF9fICYmIG5leHQgPiB0aGlzLl9fbGFzdF9pbmRleF9fKSkge1xuICAgICAgICAgIHRoaXMuX19zY2hlbWFfXyAgICAgPSAnbWFpbHRvOic7XG4gICAgICAgICAgdGhpcy5fX2luZGV4X18gICAgICA9IHNoaWZ0O1xuICAgICAgICAgIHRoaXMuX19sYXN0X2luZGV4X18gPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuX19pbmRleF9fID49IDA7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I3ByZXRlc3QodGV4dCkgLT4gQm9vbGVhblxuICpcbiAqIFZlcnkgcXVpY2sgY2hlY2ssIHRoYXQgY2FuIGdpdmUgZmFsc2UgcG9zaXRpdmVzLiBSZXR1cm5zIHRydWUgaWYgbGluayBNQVkgQkVcbiAqIGNhbiBleGlzdHMuIENhbiBiZSB1c2VkIGZvciBzcGVlZCBvcHRpbWl6YXRpb24sIHdoZW4geW91IG5lZWQgdG8gY2hlY2sgdGhhdFxuICogbGluayBOT1QgZXhpc3RzLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5wcmV0ZXN0ID0gZnVuY3Rpb24gcHJldGVzdCh0ZXh0KSB7XG4gIHJldHVybiB0aGlzLnJlLnByZXRlc3QudGVzdCh0ZXh0KTtcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjdGVzdFNjaGVtYUF0KHRleHQsIG5hbWUsIHBvc2l0aW9uKSAtPiBOdW1iZXJcbiAqIC0gdGV4dCAoU3RyaW5nKTogdGV4dCB0byBzY2FuXG4gKiAtIG5hbWUgKFN0cmluZyk6IHJ1bGUgKHNjaGVtYSkgbmFtZVxuICogLSBwb3NpdGlvbiAoTnVtYmVyKTogdGV4dCBvZmZzZXQgdG8gY2hlY2sgZnJvbVxuICpcbiAqIFNpbWlsYXIgdG8gW1tMaW5raWZ5SXQjdGVzdF1dIGJ1dCBjaGVja3Mgb25seSBzcGVjaWZpYyBwcm90b2NvbCB0YWlsIGV4YWN0bHlcbiAqIGF0IGdpdmVuIHBvc2l0aW9uLiBSZXR1cm5zIGxlbmd0aCBvZiBmb3VuZCBwYXR0ZXJuICgwIG9uIGZhaWwpLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS50ZXN0U2NoZW1hQXQgPSBmdW5jdGlvbiB0ZXN0U2NoZW1hQXQodGV4dCwgc2NoZW1hLCBwb3MpIHtcbiAgLy8gSWYgbm90IHN1cHBvcnRlZCBzY2hlbWEgY2hlY2sgcmVxdWVzdGVkIC0gdGVybWluYXRlXG4gIGlmICghdGhpcy5fX2NvbXBpbGVkX19bc2NoZW1hLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX19jb21waWxlZF9fW3NjaGVtYS50b0xvd2VyQ2FzZSgpXS52YWxpZGF0ZSh0ZXh0LCBwb3MsIHRoaXMpO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCNtYXRjaCh0ZXh0KSAtPiBBcnJheXxudWxsXG4gKlxuICogUmV0dXJucyBhcnJheSBvZiBmb3VuZCBsaW5rIGRlc2NyaXB0aW9ucyBvciBgbnVsbGAgb24gZmFpbC4gV2Ugc3Ryb25nbHlcbiAqIHJlY29tbWVuZCB0byB1c2UgW1tMaW5raWZ5SXQjdGVzdF1dIGZpcnN0LCBmb3IgYmVzdCBzcGVlZC5cbiAqXG4gKiAjIyMjIyBSZXN1bHQgbWF0Y2ggZGVzY3JpcHRpb25cbiAqXG4gKiAtIF9fc2NoZW1hX18gLSBsaW5rIHNjaGVtYSwgY2FuIGJlIGVtcHR5IGZvciBmdXp6eSBsaW5rcywgb3IgYC8vYCBmb3JcbiAqICAgcHJvdG9jb2wtbmV1dHJhbCAgbGlua3MuXG4gKiAtIF9faW5kZXhfXyAtIG9mZnNldCBvZiBtYXRjaGVkIHRleHRcbiAqIC0gX19sYXN0SW5kZXhfXyAtIGluZGV4IG9mIG5leHQgY2hhciBhZnRlciBtYXRoY2ggZW5kXG4gKiAtIF9fcmF3X18gLSBtYXRjaGVkIHRleHRcbiAqIC0gX190ZXh0X18gLSBub3JtYWxpemVkIHRleHRcbiAqIC0gX191cmxfXyAtIGxpbmssIGdlbmVyYXRlZCBmcm9tIG1hdGNoZWQgdGV4dFxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKHRleHQpIHtcbiAgdmFyIHNoaWZ0ID0gMCwgcmVzdWx0ID0gW107XG5cbiAgLy8gVHJ5IHRvIHRha2UgcHJldmlvdXMgZWxlbWVudCBmcm9tIGNhY2hlLCBpZiAudGVzdCgpIGNhbGxlZCBiZWZvcmVcbiAgaWYgKHRoaXMuX19pbmRleF9fID49IDAgJiYgdGhpcy5fX3RleHRfY2FjaGVfXyA9PT0gdGV4dCkge1xuICAgIHJlc3VsdC5wdXNoKGNyZWF0ZU1hdGNoKHRoaXMsIHNoaWZ0KSk7XG4gICAgc2hpZnQgPSB0aGlzLl9fbGFzdF9pbmRleF9fO1xuICB9XG5cbiAgLy8gQ3V0IGhlYWQgaWYgY2FjaGUgd2FzIHVzZWRcbiAgdmFyIHRhaWwgPSBzaGlmdCA/IHRleHQuc2xpY2Uoc2hpZnQpIDogdGV4dDtcblxuICAvLyBTY2FuIHN0cmluZyB1bnRpbCBlbmQgcmVhY2hlZFxuICB3aGlsZSAodGhpcy50ZXN0KHRhaWwpKSB7XG4gICAgcmVzdWx0LnB1c2goY3JlYXRlTWF0Y2godGhpcywgc2hpZnQpKTtcblxuICAgIHRhaWwgPSB0YWlsLnNsaWNlKHRoaXMuX19sYXN0X2luZGV4X18pO1xuICAgIHNoaWZ0ICs9IHRoaXMuX19sYXN0X2luZGV4X187XG4gIH1cblxuICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTGlua2lmeUl0I3RsZHMobGlzdCBbLCBrZWVwT2xkXSkgLT4gdGhpc1xuICogLSBsaXN0IChBcnJheSk6IGxpc3Qgb2YgdGxkc1xuICogLSBrZWVwT2xkIChCb29sZWFuKTogbWVyZ2Ugd2l0aCBjdXJyZW50IGxpc3QgaWYgYHRydWVgIChgZmFsc2VgIGJ5IGRlZmF1bHQpXG4gKlxuICogTG9hZCAob3IgbWVyZ2UpIG5ldyB0bGRzIGxpc3QuIFRob3NlIGFyZSB1c2VyIGZvciBmdXp6eSBsaW5rcyAod2l0aG91dCBwcmVmaXgpXG4gKiB0byBhdm9pZCBmYWxzZSBwb3NpdGl2ZXMuIEJ5IGRlZmF1bHQgdGhpcyBhbGdvcnl0aG0gdXNlZDpcbiAqXG4gKiAtIGhvc3RuYW1lIHdpdGggYW55IDItbGV0dGVyIHJvb3Qgem9uZXMgYXJlIG9rLlxuICogLSBiaXp8Y29tfGVkdXxnb3Z8bmV0fG9yZ3xwcm98d2VifHh4eHxhZXJvfGFzaWF8Y29vcHxpbmZvfG11c2V1bXxuYW1lfHNob3B80YDRhFxuICogICBhcmUgb2suXG4gKiAtIGVuY29kZWQgKGB4bi0tLi4uYCkgcm9vdCB6b25lcyBhcmUgb2suXG4gKlxuICogSWYgbGlzdCBpcyByZXBsYWNlZCwgdGhlbiBleGFjdCBtYXRjaCBmb3IgMi1jaGFycyByb290IHpvbmVzIHdpbGwgYmUgY2hlY2tlZC5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGxkcyA9IGZ1bmN0aW9uIHRsZHMobGlzdCwga2VlcE9sZCkge1xuICBsaXN0ID0gQXJyYXkuaXNBcnJheShsaXN0KSA/IGxpc3QgOiBbIGxpc3QgXTtcblxuICBpZiAoIWtlZXBPbGQpIHtcbiAgICB0aGlzLl9fdGxkc19fID0gbGlzdC5zbGljZSgpO1xuICAgIHRoaXMuX190bGRzX3JlcGxhY2VkX18gPSB0cnVlO1xuICAgIGNvbXBpbGUodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLl9fdGxkc19fID0gdGhpcy5fX3RsZHNfXy5jb25jYXQobGlzdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZWwsIGlkeCwgYXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwgIT09IGFycltpZHggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXZlcnNlKCk7XG5cbiAgY29tcGlsZSh0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIExpbmtpZnlJdCNub3JtYWxpemUobWF0Y2gpXG4gKlxuICogRGVmYXVsdCBub3JtYWxpemVyIChpZiBzY2hlbWEgZG9lcyBub3QgZGVmaW5lIGl0J3Mgb3duKS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKG1hdGNoKSB7XG5cbiAgLy8gRG8gbWluaW1hbCBwb3NzaWJsZSBjaGFuZ2VzIGJ5IGRlZmF1bHQuIE5lZWQgdG8gY29sbGVjdCBmZWVkYmFjayBwcmlvclxuICAvLyB0byBtb3ZlIGZvcndhcmQgaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L2xpbmtpZnktaXQvaXNzdWVzLzFcblxuICBpZiAoIW1hdGNoLnNjaGVtYSkgeyBtYXRjaC51cmwgPSAnaHR0cDovLycgKyBtYXRjaC51cmw7IH1cblxuICBpZiAobWF0Y2guc2NoZW1hID09PSAnbWFpbHRvOicgJiYgIS9ebWFpbHRvOi9pLnRlc3QobWF0Y2gudXJsKSkge1xuICAgIG1hdGNoLnVybCA9ICdtYWlsdG86JyArIG1hdGNoLnVybDtcbiAgfVxufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCNvbkNvbXBpbGUoKVxuICpcbiAqIE92ZXJyaWRlIHRvIG1vZGlmeSBiYXNpYyBSZWdFeHAtcy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUub25Db21waWxlID0gZnVuY3Rpb24gb25Db21waWxlKCkge1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtpZnlJdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciByZSA9IHt9O1xuXG4gIC8vIFVzZSBkaXJlY3QgZXh0cmFjdCBpbnN0ZWFkIG9mIGByZWdlbmVyYXRlYCB0byByZWR1c2UgYnJvd3NlcmlmaWVkIHNpemVcbiAgcmUuc3JjX0FueSA9IHJlcXVpcmUoJ3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4Jykuc291cmNlO1xuICByZS5zcmNfQ2MgID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX1ogICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX1AgICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleCcpLnNvdXJjZTtcblxuICAvLyBcXHB7XFxaXFxQXFxDY1xcQ0Z9ICh3aGl0ZSBzcGFjZXMgKyBjb250cm9sICsgZm9ybWF0ICsgcHVuY3R1YXRpb24pXG4gIHJlLnNyY19aUENjID0gWyByZS5zcmNfWiwgcmUuc3JjX1AsIHJlLnNyY19DYyBdLmpvaW4oJ3wnKTtcblxuICAvLyBcXHB7XFxaXFxDY30gKHdoaXRlIHNwYWNlcyArIGNvbnRyb2wpXG4gIHJlLnNyY19aQ2MgPSBbIHJlLnNyY19aLCByZS5zcmNfQ2MgXS5qb2luKCd8Jyk7XG5cbiAgLy8gRXhwZXJpbWVudGFsLiBMaXN0IG9mIGNoYXJzLCBjb21wbGV0ZWx5IHByb2hpYml0ZWQgaW4gbGlua3NcbiAgLy8gYmVjYXVzZSBjYW4gc2VwYXJhdGUgaXQgZnJvbSBvdGhlciBwYXJ0IG9mIHRleHRcbiAgdmFyIHRleHRfc2VwYXJhdG9ycyA9ICdbPjxcXHVmZjVjXSc7XG5cbiAgLy8gQWxsIHBvc3NpYmxlIHdvcmQgY2hhcmFjdGVycyAoZXZlcnl0aGluZyB3aXRob3V0IHB1bmN0dWF0aW9uLCBzcGFjZXMgJiBjb250cm9scylcbiAgLy8gRGVmaW5lZCB2aWEgcHVuY3R1YXRpb24gJiBzcGFjZXMgdG8gc2F2ZSBzcGFjZVxuICAvLyBTaG91bGQgYmUgc29tZXRoaW5nIGxpa2UgXFxwe1xcTFxcTlxcU1xcTX0gKFxcdyBidXQgd2l0aG91dCBgX2ApXG4gIHJlLnNyY19wc2V1ZG9fbGV0dGVyICAgICAgID0gJyg/Oig/IScgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfCcgKyByZS5zcmNfWlBDYyArICcpJyArIHJlLnNyY19BbnkgKyAnKSc7XG4gIC8vIFRoZSBzYW1lIGFzIGFib3RoZSBidXQgd2l0aG91dCBbMC05XVxuICAvLyB2YXIgc3JjX3BzZXVkb19sZXR0ZXJfbm9uX2QgPSAnKD86KD8hWzAtOV18JyArIHNyY19aUENjICsgJyknICsgc3JjX0FueSArICcpJztcblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIHJlLnNyY19pcDQgPVxuXG4gICAgJyg/OigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFxcXC4pezN9KDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPyknO1xuXG4gIC8vIFByb2hpYml0IGFueSBvZiBcIkAvW10oKVwiIGluIHVzZXIvcGFzcyB0byBhdm9pZCB3cm9uZyBkb21haW4gZmV0Y2guXG4gIHJlLnNyY19hdXRoICAgID0gJyg/Oig/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbQC9cXFxcW1xcXFxdKCldKS4pK0ApPyc7XG5cbiAgcmUuc3JjX3BvcnQgPVxuXG4gICAgJyg/OjooPzo2KD86WzAtNF1cXFxcZHszfXw1KD86WzAtNF1cXFxcZHsyfXw1KD86WzAtMl1cXFxcZHwzWzAtNV0pKSl8WzEtNV0/XFxcXGR7MSw0fSkpPyc7XG5cbiAgcmUuc3JjX2hvc3RfdGVybWluYXRvciA9XG5cbiAgICAnKD89JHwnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3wnICsgcmUuc3JjX1pQQ2MgKyAnKSg/IS18X3w6XFxcXGR8XFxcXC4tfFxcXFwuKD8hJHwnICsgcmUuc3JjX1pQQ2MgKyAnKSknO1xuXG4gIHJlLnNyY19wYXRoID1cblxuICAgICcoPzonICtcbiAgICAgICdbLz8jXScgK1xuICAgICAgICAnKD86JyArXG4gICAgICAgICAgJyg/IScgKyByZS5zcmNfWkNjICsgJ3wnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3xbKClbXFxcXF17fS4sXCJcXCc/IVxcXFwtXSkufCcgK1xuICAgICAgICAgICdcXFxcWyg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xcXFxcXSkuKSpcXFxcXXwnICtcbiAgICAgICAgICAnXFxcXCgoPzooPyEnICsgcmUuc3JjX1pDYyArICd8WyldKS4pKlxcXFwpfCcgK1xuICAgICAgICAgICdcXFxceyg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbfV0pLikqXFxcXH18JyArXG4gICAgICAgICAgJ1xcXFxcIig/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbXCJdKS4pK1xcXFxcInwnICtcbiAgICAgICAgICBcIlxcXFwnKD86KD8hXCIgKyByZS5zcmNfWkNjICsgXCJ8WyddKS4pK1xcXFwnfFwiICtcbiAgICAgICAgICBcIlxcXFwnKD89XCIgKyByZS5zcmNfcHNldWRvX2xldHRlciArICd8Wy1dKS58JyArICAvLyBhbGxvdyBgSSdtX2tpbmdgIGlmIG5vIHBhaXIgZm91bmRcbiAgICAgICAgICAnXFxcXC57Mix9W2EtekEtWjAtOSUvJl18JyArIC8vIGdvb2dsZSBoYXMgbWFueSBkb3RzIGluIFwiZ29vZ2xlIHNlYXJjaFwiIGxpbmtzICgjNjYsICM4MSkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2l0aHViIGhhcyAuLi4gaW4gY29tbWl0IHJhbmdlIGxpbmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RyaWN0IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBlbmdsaXNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBwZXJjZW50LWVuY29kZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIHBhcnRzIG9mIGZpbGUgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gcGFyYW1zIHNlcGFyYXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVudGlsIG1vcmUgZXhhbXBsZXMgZm91bmQuXG4gICAgICAgICAgJ1xcXFwuKD8hJyArIHJlLnNyY19aQ2MgKyAnfFsuXSkufCcgK1xuICAgICAgICAgIChvcHRzICYmIG9wdHNbJy0tLSddID9cbiAgICAgICAgICAgICdcXFxcLSg/IS0tKD86W14tXXwkKSkoPzotKil8JyAvLyBgLS0tYCA9PiBsb25nIGRhc2gsIHRlcm1pbmF0ZVxuICAgICAgICAgICAgOlxuICAgICAgICAgICAgJ1xcXFwtK3wnXG4gICAgICAgICAgKSArXG4gICAgICAgICAgJ1xcXFwsKD8hJyArIHJlLnNyY19aQ2MgKyAnKS58JyArICAgICAgIC8vIGFsbG93IGAsLCxgIGluIHBhdGhzXG4gICAgICAgICAgJ1xcXFwhKyg/IScgKyByZS5zcmNfWkNjICsgJ3xbIV0pLnwnICsgIC8vIGFsbG93IGAhISFgIGluIHBhdGhzLCBidXQgbm90IGF0IHRoZSBlbmRcbiAgICAgICAgICAnXFxcXD8oPyEnICsgcmUuc3JjX1pDYyArICd8Wz9dKS4nICtcbiAgICAgICAgJykrJyArXG4gICAgICAnfFxcXFwvJyArXG4gICAgJyk/JztcblxuICAvLyBBbGxvdyBhbnl0aGluZyBpbiBtYXJrZG93biBzcGVjLCBmb3JiaWQgcXVvdGUgKFwiKSBhdCB0aGUgZmlyc3QgcG9zaXRpb25cbiAgLy8gYmVjYXVzZSBlbWFpbHMgZW5jbG9zZWQgaW4gcXVvdGVzIGFyZSBmYXIgbW9yZSBjb21tb25cbiAgcmUuc3JjX2VtYWlsX25hbWUgPVxuXG4gICAgJ1tcXFxcLTs6Jj1cXFxcK1xcXFwkLFxcXFwuYS16QS1aMC05X11bXFxcXC07OiY9XFxcXCtcXFxcJCxcXFxcXCJcXFxcLmEtekEtWjAtOV9dKic7XG5cbiAgcmUuc3JjX3huID1cblxuICAgICd4bi0tW2EtejAtOVxcXFwtXXsxLDU5fSc7XG5cbiAgLy8gTW9yZSB0byByZWFkIGFib3V0IGRvbWFpbiBuYW1lc1xuICAvLyBodHRwOi8vc2VydmVyZmF1bHQuY29tL3F1ZXN0aW9ucy82MzgyNjAvXG5cbiAgcmUuc3JjX2RvbWFpbl9yb290ID1cblxuICAgIC8vIEFsbG93IGxldHRlcnMgJiBkaWdpdHMgKGh0dHA6Ly90ZXN0MSlcbiAgICAnKD86JyArXG4gICAgICByZS5zcmNfeG4gK1xuICAgICAgJ3wnICtcbiAgICAgIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJ3sxLDYzfScgK1xuICAgICcpJztcblxuICByZS5zcmNfZG9tYWluID1cblxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY194biArXG4gICAgICAnfCcgK1xuICAgICAgJyg/OicgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcpJyArXG4gICAgICAnfCcgK1xuICAgICAgJyg/OicgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcoPzotfCcgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcpezAsNjF9JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyknICtcbiAgICAnKSc7XG5cbiAgcmUuc3JjX2hvc3QgPVxuXG4gICAgJyg/OicgK1xuICAgIC8vIERvbid0IG5lZWQgSVAgY2hlY2ssIGJlY2F1c2UgZGlnaXRzIGFyZSBhbHJlYWR5IGFsbG93ZWQgaW4gbm9ybWFsIGRvbWFpbiBuYW1lc1xuICAgIC8vICAgc3JjX2lwNCArXG4gICAgLy8gJ3wnICtcbiAgICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKicgKyByZS5zcmNfZG9tYWluLypfcm9vdCovICsgJyknICtcbiAgICAnKSc7XG5cbiAgcmUudHBsX2hvc3RfZnV6enkgPVxuXG4gICAgJyg/OicgK1xuICAgICAgcmUuc3JjX2lwNCArXG4gICAgJ3wnICtcbiAgICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKyg/OiVUTERTJSkpJyArXG4gICAgJyknO1xuXG4gIHJlLnRwbF9ob3N0X25vX2lwX2Z1enp5ID1cblxuICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKyg/OiVUTERTJSkpJztcblxuICByZS5zcmNfaG9zdF9zdHJpY3QgPVxuXG4gICAgcmUuc3JjX2hvc3QgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnRwbF9ob3N0X2Z1enp5X3N0cmljdCA9XG5cbiAgICByZS50cGxfaG9zdF9mdXp6eSArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUuc3JjX2hvc3RfcG9ydF9zdHJpY3QgPVxuXG4gICAgcmUuc3JjX2hvc3QgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUudHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QgPVxuXG4gICAgcmUudHBsX2hvc3RfZnV6enkgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUudHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QgPVxuXG4gICAgcmUudHBsX2hvc3Rfbm9faXBfZnV6enkgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBNYWluIHJ1bGVzXG5cbiAgLy8gUnVkZSB0ZXN0IGZ1enp5IGxpbmtzIGJ5IGhvc3QsIGZvciBxdWljayBkZW55XG4gIHJlLnRwbF9ob3N0X2Z1enp5X3Rlc3QgPVxuXG4gICAgJ2xvY2FsaG9zdHx3d3dcXFxcLnxcXFxcLlxcXFxkezEsM31cXFxcLnwoPzpcXFxcLig/OiVUTERTJSkoPzonICsgcmUuc3JjX1pQQ2MgKyAnfD58JCkpJztcblxuICByZS50cGxfZW1haWxfZnV6enkgPVxuXG4gICAgICAnKF58JyArIHRleHRfc2VwYXJhdG9ycyArICd8XCJ8XFxcXCh8JyArIHJlLnNyY19aQ2MgKyAnKScgK1xuICAgICAgJygnICsgcmUuc3JjX2VtYWlsX25hbWUgKyAnQCcgKyByZS50cGxfaG9zdF9mdXp6eV9zdHJpY3QgKyAnKSc7XG5cbiAgcmUudHBsX2xpbmtfZnV6enkgPVxuICAgICAgLy8gRnV6enkgbGluayBjYW4ndCBiZSBwcmVwZW5kZWQgd2l0aCAuOi9cXC0gYW5kIG5vbiBwdW5jdHVhdGlvbi5cbiAgICAgIC8vIGJ1dCBjYW4gc3RhcnQgd2l0aCA+IChtYXJrZG93biBibG9ja3F1b3RlKVxuICAgICAgJyhefCg/IVsuOi9cXFxcLV9AXSkoPzpbJCs8PT5eYHxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSknICtcbiAgICAgICcoKD8hWyQrPD0+XmB8XFx1ZmY1Y10pJyArIHJlLnRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0ICsgcmUuc3JjX3BhdGggKyAnKSc7XG5cbiAgcmUudHBsX2xpbmtfbm9faXBfZnV6enkgPVxuICAgICAgLy8gRnV6enkgbGluayBjYW4ndCBiZSBwcmVwZW5kZWQgd2l0aCAuOi9cXC0gYW5kIG5vbiBwdW5jdHVhdGlvbi5cbiAgICAgIC8vIGJ1dCBjYW4gc3RhcnQgd2l0aCA+IChtYXJrZG93biBibG9ja3F1b3RlKVxuICAgICAgJyhefCg/IVsuOi9cXFxcLV9AXSkoPzpbJCs8PT5eYHxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSknICtcbiAgICAgICcoKD8hWyQrPD0+XmB8XFx1ZmY1Y10pJyArIHJlLnRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0ICsgcmUuc3JjX3BhdGggKyAnKSc7XG5cbiAgcmV0dXJuIHJlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliLycpO1xuIiwiLy8gSFRNTDUgZW50aXRpZXMgbWFwOiB7IG5hbWUgLT4gdXRmMTZzdHJpbmcgfVxuLy9cbid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQgcXVvdGVzOjAqL1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdlbnRpdGllcy9saWIvbWFwcy9lbnRpdGllcy5qc29uJyk7XG4iLCIvLyBMaXN0IG9mIHZhbGlkIGh0bWwgYmxvY2tzIG5hbWVzLCBhY2NvcnRpbmcgdG8gY29tbW9ubWFyayBzcGVjXG4vLyBodHRwOi8vamdtLmdpdGh1Yi5pby9Db21tb25NYXJrL3NwZWMuaHRtbCNodG1sLWJsb2Nrc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdhZGRyZXNzJyxcbiAgJ2FydGljbGUnLFxuICAnYXNpZGUnLFxuICAnYmFzZScsXG4gICdiYXNlZm9udCcsXG4gICdibG9ja3F1b3RlJyxcbiAgJ2JvZHknLFxuICAnY2FwdGlvbicsXG4gICdjZW50ZXInLFxuICAnY29sJyxcbiAgJ2NvbGdyb3VwJyxcbiAgJ2RkJyxcbiAgJ2RldGFpbHMnLFxuICAnZGlhbG9nJyxcbiAgJ2RpcicsXG4gICdkaXYnLFxuICAnZGwnLFxuICAnZHQnLFxuICAnZmllbGRzZXQnLFxuICAnZmlnY2FwdGlvbicsXG4gICdmaWd1cmUnLFxuICAnZm9vdGVyJyxcbiAgJ2Zvcm0nLFxuICAnZnJhbWUnLFxuICAnZnJhbWVzZXQnLFxuICAnaDEnLFxuICAnaDInLFxuICAnaDMnLFxuICAnaDQnLFxuICAnaDUnLFxuICAnaDYnLFxuICAnaGVhZCcsXG4gICdoZWFkZXInLFxuICAnaHInLFxuICAnaHRtbCcsXG4gICdpZnJhbWUnLFxuICAnbGVnZW5kJyxcbiAgJ2xpJyxcbiAgJ2xpbmsnLFxuICAnbWFpbicsXG4gICdtZW51JyxcbiAgJ21lbnVpdGVtJyxcbiAgJ25hdicsXG4gICdub2ZyYW1lcycsXG4gICdvbCcsXG4gICdvcHRncm91cCcsXG4gICdvcHRpb24nLFxuICAncCcsXG4gICdwYXJhbScsXG4gICdzZWN0aW9uJyxcbiAgJ3NvdXJjZScsXG4gICdzdW1tYXJ5JyxcbiAgJ3RhYmxlJyxcbiAgJ3Rib2R5JyxcbiAgJ3RkJyxcbiAgJ3Rmb290JyxcbiAgJ3RoJyxcbiAgJ3RoZWFkJyxcbiAgJ3RpdGxlJyxcbiAgJ3RyJyxcbiAgJ3RyYWNrJyxcbiAgJ3VsJ1xuXTtcbiIsIi8vIFJlZ2V4cHMgdG8gbWF0Y2ggaHRtbCBlbGVtZW50c1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhdHRyX25hbWUgICAgID0gJ1thLXpBLVpfOl1bYS16QS1aMC05Oi5fLV0qJztcblxudmFyIHVucXVvdGVkICAgICAgPSAnW15cIlxcJz08PmBcXFxceDAwLVxcXFx4MjBdKyc7XG52YXIgc2luZ2xlX3F1b3RlZCA9IFwiJ1teJ10qJ1wiO1xudmFyIGRvdWJsZV9xdW90ZWQgPSAnXCJbXlwiXSpcIic7XG5cbnZhciBhdHRyX3ZhbHVlICA9ICcoPzonICsgdW5xdW90ZWQgKyAnfCcgKyBzaW5nbGVfcXVvdGVkICsgJ3wnICsgZG91YmxlX3F1b3RlZCArICcpJztcblxudmFyIGF0dHJpYnV0ZSAgID0gJyg/OlxcXFxzKycgKyBhdHRyX25hbWUgKyAnKD86XFxcXHMqPVxcXFxzKicgKyBhdHRyX3ZhbHVlICsgJyk/KSc7XG5cbnZhciBvcGVuX3RhZyAgICA9ICc8W0EtWmEtel1bQS1aYS16MC05XFxcXC1dKicgKyBhdHRyaWJ1dGUgKyAnKlxcXFxzKlxcXFwvPz4nO1xuXG52YXIgY2xvc2VfdGFnICAgPSAnPFxcXFwvW0EtWmEtel1bQS1aYS16MC05XFxcXC1dKlxcXFxzKj4nO1xudmFyIGNvbW1lbnQgICAgID0gJzwhLS0tLT58PCEtLSg/Oi0/W14+LV0pKD86LT9bXi1dKSotLT4nO1xudmFyIHByb2Nlc3NpbmcgID0gJzxbP11bXFxcXHNcXFxcU10qP1s/XT4nO1xudmFyIGRlY2xhcmF0aW9uID0gJzwhW0EtWl0rXFxcXHMrW14+XSo+JztcbnZhciBjZGF0YSAgICAgICA9ICc8IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/XFxcXF1cXFxcXT4nO1xuXG52YXIgSFRNTF9UQUdfUkUgPSBuZXcgUmVnRXhwKCdeKD86JyArIG9wZW5fdGFnICsgJ3wnICsgY2xvc2VfdGFnICsgJ3wnICsgY29tbWVudCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBwcm9jZXNzaW5nICsgJ3wnICsgZGVjbGFyYXRpb24gKyAnfCcgKyBjZGF0YSArICcpJyk7XG52YXIgSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IG5ldyBSZWdFeHAoJ14oPzonICsgb3Blbl90YWcgKyAnfCcgKyBjbG9zZV90YWcgKyAnKScpO1xuXG5tb2R1bGUuZXhwb3J0cy5IVE1MX1RBR19SRSA9IEhUTUxfVEFHX1JFO1xubW9kdWxlLmV4cG9ydHMuSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IEhUTUxfT1BFTl9DTE9TRV9UQUdfUkU7XG4iLCIvLyBVdGlsaXRpZXNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gX2NsYXNzKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7IH1cblxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7IH1cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGhhcyhvYmplY3QsIGtleSkge1xuICByZXR1cm4gX2hhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xufVxuXG4vLyBNZXJnZSBvYmplY3RzXG4vL1xuZnVuY3Rpb24gYXNzaWduKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICdtdXN0IGJlIG9iamVjdCcpO1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gb2JqO1xufVxuXG4vLyBSZW1vdmUgZWxlbWVudCBmcm9tIGFycmF5IGFuZCBwdXQgYW5vdGhlciBhcnJheSBhdCB0aG9zZSBwb3NpdGlvbi5cbi8vIFVzZWZ1bCBmb3Igc29tZSBvcGVyYXRpb25zIHdpdGggdG9rZW5zXG5mdW5jdGlvbiBhcnJheVJlcGxhY2VBdChzcmMsIHBvcywgbmV3RWxlbWVudHMpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdChzcmMuc2xpY2UoMCwgcG9zKSwgbmV3RWxlbWVudHMsIHNyYy5zbGljZShwb3MgKyAxKSk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbnRpdHlDb2RlKGMpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgLy8gYnJva2VuIHNlcXVlbmNlXG4gIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REZGRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gbmV2ZXIgdXNlZFxuICBpZiAoYyA+PSAweEZERDAgJiYgYyA8PSAweEZERUYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmICgoYyAmIDB4RkZGRikgPT09IDB4RkZGRiB8fCAoYyAmIDB4RkZGRikgPT09IDB4RkZGRSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gY29udHJvbCBjb2Rlc1xuICBpZiAoYyA+PSAweDAwICYmIGMgPD0gMHgwOCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGMgPT09IDB4MEIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChjID49IDB4MEUgJiYgYyA8PSAweDFGKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYyA+PSAweDdGICYmIGMgPD0gMHg5RikgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gb3V0IG9mIHJhbmdlXG4gIGlmIChjID4gMHgxMEZGRkYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmcm9tQ29kZVBvaW50KGMpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgaWYgKGMgPiAweGZmZmYpIHtcbiAgICBjIC09IDB4MTAwMDA7XG4gICAgdmFyIHN1cnJvZ2F0ZTEgPSAweGQ4MDAgKyAoYyA+PiAxMCksXG4gICAgICAgIHN1cnJvZ2F0ZTIgPSAweGRjMDAgKyAoYyAmIDB4M2ZmKTtcblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHN1cnJvZ2F0ZTEsIHN1cnJvZ2F0ZTIpO1xuICB9XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xufVxuXG5cbnZhciBVTkVTQ0FQRV9NRF9SRSAgPSAvXFxcXChbIVwiIyQlJicoKSorLFxcLS5cXC86Ozw9Pj9AW1xcXFxcXF1eX2B7fH1+XSkvZztcbnZhciBFTlRJVFlfUkUgICAgICAgPSAvJihbYS16I11bYS16MC05XXsxLDMxfSk7L2dpO1xudmFyIFVORVNDQVBFX0FMTF9SRSA9IG5ldyBSZWdFeHAoVU5FU0NBUEVfTURfUkUuc291cmNlICsgJ3wnICsgRU5USVRZX1JFLnNvdXJjZSwgJ2dpJyk7XG5cbnZhciBESUdJVEFMX0VOVElUWV9URVNUX1JFID0gL14jKCg/OnhbYS1mMC05XXsxLDh9fFswLTldezEsOH0pKS9pO1xuXG52YXIgZW50aXRpZXMgPSByZXF1aXJlKCcuL2VudGl0aWVzJyk7XG5cbmZ1bmN0aW9uIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKG1hdGNoLCBuYW1lKSB7XG4gIHZhciBjb2RlID0gMDtcblxuICBpZiAoaGFzKGVudGl0aWVzLCBuYW1lKSkge1xuICAgIHJldHVybiBlbnRpdGllc1tuYW1lXTtcbiAgfVxuXG4gIGlmIChuYW1lLmNoYXJDb2RlQXQoMCkgPT09IDB4MjMvKiAjICovICYmIERJR0lUQUxfRU5USVRZX1RFU1RfUkUudGVzdChuYW1lKSkge1xuICAgIGNvZGUgPSBuYW1lWzFdLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICBwYXJzZUludChuYW1lLnNsaWNlKDIpLCAxNikgOiBwYXJzZUludChuYW1lLnNsaWNlKDEpLCAxMCk7XG5cbiAgICBpZiAoaXNWYWxpZEVudGl0eUNvZGUoY29kZSkpIHtcbiAgICAgIHJldHVybiBmcm9tQ29kZVBvaW50KGNvZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaDtcbn1cblxuLypmdW5jdGlvbiByZXBsYWNlRW50aXRpZXMoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignJicpIDwgMCkgeyByZXR1cm4gc3RyOyB9XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKEVOVElUWV9SRSwgcmVwbGFjZUVudGl0eVBhdHRlcm4pO1xufSovXG5cbmZ1bmN0aW9uIHVuZXNjYXBlTWQoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignXFxcXCcpIDwgMCkgeyByZXR1cm4gc3RyOyB9XG4gIHJldHVybiBzdHIucmVwbGFjZShVTkVTQ0FQRV9NRF9SRSwgJyQxJyk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlQWxsKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJ1xcXFwnKSA8IDAgJiYgc3RyLmluZGV4T2YoJyYnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuXG4gIHJldHVybiBzdHIucmVwbGFjZShVTkVTQ0FQRV9BTExfUkUsIGZ1bmN0aW9uIChtYXRjaCwgZXNjYXBlZCwgZW50aXR5KSB7XG4gICAgaWYgKGVzY2FwZWQpIHsgcmV0dXJuIGVzY2FwZWQ7IH1cbiAgICByZXR1cm4gcmVwbGFjZUVudGl0eVBhdHRlcm4obWF0Y2gsIGVudGl0eSk7XG4gIH0pO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgSFRNTF9FU0NBUEVfVEVTVF9SRSA9IC9bJjw+XCJdLztcbnZhciBIVE1MX0VTQ0FQRV9SRVBMQUNFX1JFID0gL1smPD5cIl0vZztcbnZhciBIVE1MX1JFUExBQ0VNRU5UUyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnXG59O1xuXG5mdW5jdGlvbiByZXBsYWNlVW5zYWZlQ2hhcihjaCkge1xuICByZXR1cm4gSFRNTF9SRVBMQUNFTUVOVFNbY2hdO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cikge1xuICBpZiAoSFRNTF9FU0NBUEVfVEVTVF9SRS50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSwgcmVwbGFjZVVuc2FmZUNoYXIpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbnZhciBSRUdFWFBfRVNDQVBFX1JFID0gL1suPyorXiRbXFxdXFxcXCgpe318LV0vZztcblxuZnVuY3Rpb24gZXNjYXBlUkUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShSRUdFWFBfRVNDQVBFX1JFLCAnXFxcXCQmJyk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzU3BhY2UoY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4MDk6XG4gICAgY2FzZSAweDIwOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBacyAodW5pY29kZSBjbGFzcykgfHwgW1xcdFxcZlxcdlxcclxcbl1cbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjb2RlKSB7XG4gIGlmIChjb2RlID49IDB4MjAwMCAmJiBjb2RlIDw9IDB4MjAwQSkgeyByZXR1cm4gdHJ1ZTsgfVxuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4MDk6IC8vIFxcdFxuICAgIGNhc2UgMHgwQTogLy8gXFxuXG4gICAgY2FzZSAweDBCOiAvLyBcXHZcbiAgICBjYXNlIDB4MEM6IC8vIFxcZlxuICAgIGNhc2UgMHgwRDogLy8gXFxyXG4gICAgY2FzZSAweDIwOlxuICAgIGNhc2UgMHhBMDpcbiAgICBjYXNlIDB4MTY4MDpcbiAgICBjYXNlIDB4MjAyRjpcbiAgICBjYXNlIDB4MjA1RjpcbiAgICBjYXNlIDB4MzAwMDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuKi9cbnZhciBVTklDT0RFX1BVTkNUX1JFID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4Jyk7XG5cbi8vIEN1cnJlbnRseSB3aXRob3V0IGFzdHJhbCBjaGFyYWN0ZXJzIHN1cHBvcnQuXG5mdW5jdGlvbiBpc1B1bmN0Q2hhcihjaCkge1xuICByZXR1cm4gVU5JQ09ERV9QVU5DVF9SRS50ZXN0KGNoKTtcbn1cblxuXG4vLyBNYXJrZG93biBBU0NJSSBwdW5jdHVhdGlvbiBjaGFyYWN0ZXJzLlxuLy9cbi8vICEsIFwiLCAjLCAkLCAlLCAmLCAnLCAoLCApLCAqLCArLCAsLCAtLCAuLCAvLCA6LCA7LCA8LCA9LCA+LCA/LCBALCBbLCBcXCwgXSwgXiwgXywgYCwgeywgfCwgfSwgb3IgflxuLy8gaHR0cDovL3NwZWMuY29tbW9ubWFyay5vcmcvMC4xNS8jYXNjaWktcHVuY3R1YXRpb24tY2hhcmFjdGVyXG4vL1xuLy8gRG9uJ3QgY29uZnVzZSB3aXRoIHVuaWNvZGUgcHVuY3R1YXRpb24gISEhIEl0IGxhY2tzIHNvbWUgY2hhcnMgaW4gYXNjaWkgcmFuZ2UuXG4vL1xuZnVuY3Rpb24gaXNNZEFzY2lpUHVuY3QoY2gpIHtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMHgyMS8qICEgKi86XG4gICAgY2FzZSAweDIyLyogXCIgKi86XG4gICAgY2FzZSAweDIzLyogIyAqLzpcbiAgICBjYXNlIDB4MjQvKiAkICovOlxuICAgIGNhc2UgMHgyNS8qICUgKi86XG4gICAgY2FzZSAweDI2LyogJiAqLzpcbiAgICBjYXNlIDB4MjcvKiAnICovOlxuICAgIGNhc2UgMHgyOC8qICggKi86XG4gICAgY2FzZSAweDI5LyogKSAqLzpcbiAgICBjYXNlIDB4MkEvKiAqICovOlxuICAgIGNhc2UgMHgyQi8qICsgKi86XG4gICAgY2FzZSAweDJDLyogLCAqLzpcbiAgICBjYXNlIDB4MkQvKiAtICovOlxuICAgIGNhc2UgMHgyRS8qIC4gKi86XG4gICAgY2FzZSAweDJGLyogLyAqLzpcbiAgICBjYXNlIDB4M0EvKiA6ICovOlxuICAgIGNhc2UgMHgzQi8qIDsgKi86XG4gICAgY2FzZSAweDNDLyogPCAqLzpcbiAgICBjYXNlIDB4M0QvKiA9ICovOlxuICAgIGNhc2UgMHgzRS8qID4gKi86XG4gICAgY2FzZSAweDNGLyogPyAqLzpcbiAgICBjYXNlIDB4NDAvKiBAICovOlxuICAgIGNhc2UgMHg1Qi8qIFsgKi86XG4gICAgY2FzZSAweDVDLyogXFwgKi86XG4gICAgY2FzZSAweDVELyogXSAqLzpcbiAgICBjYXNlIDB4NUUvKiBeICovOlxuICAgIGNhc2UgMHg1Ri8qIF8gKi86XG4gICAgY2FzZSAweDYwLyogYCAqLzpcbiAgICBjYXNlIDB4N0IvKiB7ICovOlxuICAgIGNhc2UgMHg3Qy8qIHwgKi86XG4gICAgY2FzZSAweDdELyogfSAqLzpcbiAgICBjYXNlIDB4N0UvKiB+ICovOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBIZXBsZXIgdG8gdW5pZnkgW3JlZmVyZW5jZSBsYWJlbHNdLlxuLy9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlZmVyZW5jZShzdHIpIHtcbiAgLy8gVHJpbSBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuICAvL1xuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcblxuICAvLyBJbiBub2RlIHYxMCAn4bqeJy50b0xvd2VyQ2FzZSgpID09PSAn4bm+Jywgd2hpY2ggaXMgcHJlc3VtZWQgdG8gYmUgYSBidWdcbiAgLy8gZml4ZWQgaW4gdjEyIChjb3VsZG4ndCBmaW5kIGFueSBkZXRhaWxzKS5cbiAgLy9cbiAgLy8gU28gdHJlYXQgdGhpcyBvbmUgYXMgYSBzcGVjaWFsIGNhc2VcbiAgLy8gKHJlbW92ZSB0aGlzIHdoZW4gbm9kZSB2MTAgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCkuXG4gIC8vXG4gIGlmICgn4bqeJy50b0xvd2VyQ2FzZSgpID09PSAn4bm+Jykge1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC/hup4vZywgJ8OfJyk7XG4gIH1cblxuICAvLyAudG9Mb3dlckNhc2UoKS50b1VwcGVyQ2FzZSgpIHNob3VsZCBnZXQgcmlkIG9mIGFsbCBkaWZmZXJlbmNlc1xuICAvLyBiZXR3ZWVuIGxldHRlciB2YXJpYW50cy5cbiAgLy9cbiAgLy8gU2ltcGxlIC50b0xvd2VyQ2FzZSgpIGRvZXNuJ3Qgbm9ybWFsaXplIDEyNSBjb2RlIHBvaW50cyBjb3JyZWN0bHksXG4gIC8vIGFuZCAudG9VcHBlckNhc2UgZG9lc24ndCBub3JtYWxpemUgNiBvZiB0aGVtIChsaXN0IG9mIGV4Y2VwdGlvbnM6XG4gIC8vIMSwLCDPtCwg4bqeLCDihKYsIOKEqiwg4oSrIC0gdGhvc2UgYXJlIGFscmVhZHkgdXBwZXJjYXNlZCwgYnV0IGhhdmUgZGlmZmVyZW50bHlcbiAgLy8gdXBwZXJjYXNlZCB2ZXJzaW9ucykuXG4gIC8vXG4gIC8vIEhlcmUncyBhbiBleGFtcGxlIHNob3dpbmcgaG93IGl0IGhhcHBlbnMuIExldHMgdGFrZSBncmVlayBsZXR0ZXIgb21lZ2E6XG4gIC8vIHVwcGVyY2FzZSBVKzAzOTggKM6YKSwgVSswM2Y0ICjPtCkgYW5kIGxvd2VyY2FzZSBVKzAzYjggKM64KSwgVSswM2QxICjPkSlcbiAgLy9cbiAgLy8gVW5pY29kZSBlbnRyaWVzOlxuICAvLyAwMzk4O0dSRUVLIENBUElUQUwgTEVUVEVSIFRIRVRBO0x1OzA7TDs7Ozs7Tjs7OzswM0I4O1xuICAvLyAwM0I4O0dSRUVLIFNNQUxMIExFVFRFUiBUSEVUQTtMbDswO0w7Ozs7O047OzswMzk4OzswMzk4XG4gIC8vIDAzRDE7R1JFRUsgVEhFVEEgU1lNQk9MO0xsOzA7TDs8Y29tcGF0PiAwM0I4Ozs7O047R1JFRUsgU01BTEwgTEVUVEVSIFNDUklQVCBUSEVUQTs7MDM5ODs7MDM5OFxuICAvLyAwM0Y0O0dSRUVLIENBUElUQUwgVEhFVEEgU1lNQk9MO0x1OzA7TDs8Y29tcGF0PiAwMzk4Ozs7O047Ozs7MDNCODtcbiAgLy9cbiAgLy8gQ2FzZS1pbnNlbnNpdGl2ZSBjb21wYXJpc29uIHNob3VsZCB0cmVhdCBhbGwgb2YgdGhlbSBhcyBlcXVpdmFsZW50LlxuICAvL1xuICAvLyBCdXQgLnRvTG93ZXJDYXNlKCkgZG9lc24ndCBjaGFuZ2Ugz5EgKGl0J3MgYWxyZWFkeSBsb3dlcmNhc2UpLFxuICAvLyBhbmQgLnRvVXBwZXJDYXNlKCkgZG9lc24ndCBjaGFuZ2Ugz7QgKGFscmVhZHkgdXBwZXJjYXNlKS5cbiAgLy9cbiAgLy8gQXBwbHlpbmcgZmlyc3QgbG93ZXIgdGhlbiB1cHBlciBjYXNlIG5vcm1hbGl6ZXMgYW55IGNoYXJhY3RlcjpcbiAgLy8gJ1xcdTAzOThcXHUwM2Y0XFx1MDNiOFxcdTAzZDEnLnRvTG93ZXJDYXNlKCkudG9VcHBlckNhc2UoKSA9PT0gJ1xcdTAzOThcXHUwMzk4XFx1MDM5OFxcdTAzOTgnXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgaXMgZXF1aXZhbGVudCB0byB1bmljb2RlIGNhc2UgZm9sZGluZzsgdW5pY29kZSBub3JtYWxpemF0aW9uXG4gIC8vIGlzIGEgZGlmZmVyZW50IHN0ZXAgdGhhdCBpcyBub3QgcmVxdWlyZWQgaGVyZS5cbiAgLy9cbiAgLy8gRmluYWwgcmVzdWx0IHNob3VsZCBiZSB1cHBlcmNhc2VkLCBiZWNhdXNlIGl0J3MgbGF0ZXIgc3RvcmVkIGluIGFuIG9iamVjdFxuICAvLyAodGhpcyBhdm9pZCBhIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBtZW1iZXJzLFxuICAvLyBtb3N0IG5vdGFibHksIGBfX3Byb3RvX19gKVxuICAvL1xuICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCkudG9VcHBlckNhc2UoKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gUmUtZXhwb3J0IGxpYnJhcmllcyBjb21tb25seSB1c2VkIGluIGJvdGggbWFya2Rvd24taXQgYW5kIGl0cyBwbHVnaW5zLFxuLy8gc28gcGx1Z2lucyB3b24ndCBoYXZlIHRvIGRlcGVuZCBvbiB0aGVtIGV4cGxpY2l0bHksIHdoaWNoIHJlZHVjZXMgdGhlaXJcbi8vIGJ1bmRsZWQgc2l6ZSAoZS5nLiBhIGJyb3dzZXIgYnVpbGQpLlxuLy9cbmV4cG9ydHMubGliICAgICAgICAgICAgICAgICA9IHt9O1xuZXhwb3J0cy5saWIubWR1cmwgICAgICAgICAgID0gcmVxdWlyZSgnbWR1cmwnKTtcbmV4cG9ydHMubGliLnVjbWljcm8gICAgICAgICA9IHJlcXVpcmUoJ3VjLm1pY3JvJyk7XG5cbmV4cG9ydHMuYXNzaWduICAgICAgICAgICAgICA9IGFzc2lnbjtcbmV4cG9ydHMuaXNTdHJpbmcgICAgICAgICAgICA9IGlzU3RyaW5nO1xuZXhwb3J0cy5oYXMgICAgICAgICAgICAgICAgID0gaGFzO1xuZXhwb3J0cy51bmVzY2FwZU1kICAgICAgICAgID0gdW5lc2NhcGVNZDtcbmV4cG9ydHMudW5lc2NhcGVBbGwgICAgICAgICA9IHVuZXNjYXBlQWxsO1xuZXhwb3J0cy5pc1ZhbGlkRW50aXR5Q29kZSAgID0gaXNWYWxpZEVudGl0eUNvZGU7XG5leHBvcnRzLmZyb21Db2RlUG9pbnQgICAgICAgPSBmcm9tQ29kZVBvaW50O1xuLy8gZXhwb3J0cy5yZXBsYWNlRW50aXRpZXMgICAgID0gcmVwbGFjZUVudGl0aWVzO1xuZXhwb3J0cy5lc2NhcGVIdG1sICAgICAgICAgID0gZXNjYXBlSHRtbDtcbmV4cG9ydHMuYXJyYXlSZXBsYWNlQXQgICAgICA9IGFycmF5UmVwbGFjZUF0O1xuZXhwb3J0cy5pc1NwYWNlICAgICAgICAgICAgID0gaXNTcGFjZTtcbmV4cG9ydHMuaXNXaGl0ZVNwYWNlICAgICAgICA9IGlzV2hpdGVTcGFjZTtcbmV4cG9ydHMuaXNNZEFzY2lpUHVuY3QgICAgICA9IGlzTWRBc2NpaVB1bmN0O1xuZXhwb3J0cy5pc1B1bmN0Q2hhciAgICAgICAgID0gaXNQdW5jdENoYXI7XG5leHBvcnRzLmVzY2FwZVJFICAgICAgICAgICAgPSBlc2NhcGVSRTtcbmV4cG9ydHMubm9ybWFsaXplUmVmZXJlbmNlICA9IG5vcm1hbGl6ZVJlZmVyZW5jZTtcbiIsIi8vIEp1c3QgYSBzaG9ydGN1dCBmb3IgYnVsayBleHBvcnRcbid1c2Ugc3RyaWN0JztcblxuXG5leHBvcnRzLnBhcnNlTGlua0xhYmVsICAgICAgID0gcmVxdWlyZSgnLi9wYXJzZV9saW5rX2xhYmVsJyk7XG5leHBvcnRzLnBhcnNlTGlua0Rlc3RpbmF0aW9uID0gcmVxdWlyZSgnLi9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uJyk7XG5leHBvcnRzLnBhcnNlTGlua1RpdGxlICAgICAgID0gcmVxdWlyZSgnLi9wYXJzZV9saW5rX3RpdGxlJyk7XG4iLCIvLyBQYXJzZSBsaW5rIGRlc3RpbmF0aW9uXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1bmVzY2FwZUFsbCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLnVuZXNjYXBlQWxsO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VMaW5rRGVzdGluYXRpb24oc3RyLCBwb3MsIG1heCkge1xuICB2YXIgY29kZSwgbGV2ZWwsXG4gICAgICBsaW5lcyA9IDAsXG4gICAgICBzdGFydCA9IHBvcyxcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBwb3M6IDAsXG4gICAgICAgIGxpbmVzOiAwLFxuICAgICAgICBzdHI6ICcnXG4gICAgICB9O1xuXG4gIGlmIChzdHIuY2hhckNvZGVBdChwb3MpID09PSAweDNDIC8qIDwgKi8pIHtcbiAgICBwb3MrKztcbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmIChjb2RlID09PSAweDBBIC8qIFxcbiAqLykgeyByZXR1cm4gcmVzdWx0OyB9XG4gICAgICBpZiAoY29kZSA9PT0gMHgzQyAvKiA8ICovKSB7IHJldHVybiByZXN1bHQ7IH1cbiAgICAgIGlmIChjb2RlID09PSAweDNFIC8qID4gKi8pIHtcbiAgICAgICAgcmVzdWx0LnBvcyA9IHBvcyArIDE7XG4gICAgICAgIHJlc3VsdC5zdHIgPSB1bmVzY2FwZUFsbChzdHIuc2xpY2Uoc3RhcnQgKyAxLCBwb3MpKTtcbiAgICAgICAgcmVzdWx0Lm9rID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSAweDVDIC8qIFxcICovICYmIHBvcyArIDEgPCBtYXgpIHtcbiAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICB9XG5cbiAgICAvLyBubyBjbG9zaW5nICc+J1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyB0aGlzIHNob3VsZCBiZSAuLi4gfSBlbHNlIHsgLi4uIGJyYW5jaFxuXG4gIGxldmVsID0gMDtcbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGNvZGUgPT09IDB4MjApIHsgYnJlYWs7IH1cblxuICAgIC8vIGFzY2lpIGNvbnRyb2wgY2hhcmFjdGVyc1xuICAgIGlmIChjb2RlIDwgMHgyMCB8fCBjb2RlID09PSAweDdGKSB7IGJyZWFrOyB9XG5cbiAgICBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XG4gICAgICBpZiAoc3RyLmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDB4MjApIHsgYnJlYWs7IH1cbiAgICAgIHBvcyArPSAyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDB4MjggLyogKCAqLykge1xuICAgICAgbGV2ZWwrKztcbiAgICAgIGlmIChsZXZlbCA+IDMyKSB7IHJldHVybiByZXN1bHQ7IH1cbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gMHgyOSAvKiApICovKSB7XG4gICAgICBpZiAobGV2ZWwgPT09IDApIHsgYnJlYWs7IH1cbiAgICAgIGxldmVsLS07XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHBvcykgeyByZXR1cm4gcmVzdWx0OyB9XG4gIGlmIChsZXZlbCAhPT0gMCkgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCwgcG9zKSk7XG4gIHJlc3VsdC5saW5lcyA9IGxpbmVzO1xuICByZXN1bHQucG9zID0gcG9zO1xuICByZXN1bHQub2sgPSB0cnVlO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIFBhcnNlIGxpbmsgbGFiZWxcbi8vXG4vLyB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBmaXJzdCBjaGFyYWN0ZXIgKFwiW1wiKSBhbHJlYWR5IG1hdGNoZXM7XG4vLyByZXR1cm5zIHRoZSBlbmQgb2YgdGhlIGxhYmVsXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGFydCwgZGlzYWJsZU5lc3RlZCkge1xuICB2YXIgbGV2ZWwsIGZvdW5kLCBtYXJrZXIsIHByZXZQb3MsXG4gICAgICBsYWJlbEVuZCA9IC0xLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zO1xuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0ICsgMTtcbiAgbGV2ZWwgPSAxO1xuXG4gIHdoaWxlIChzdGF0ZS5wb3MgPCBtYXgpIHtcbiAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpO1xuICAgIGlmIChtYXJrZXIgPT09IDB4NUQgLyogXSAqLykge1xuICAgICAgbGV2ZWwtLTtcbiAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByZXZQb3MgPSBzdGF0ZS5wb3M7XG4gICAgc3RhdGUubWQuaW5saW5lLnNraXBUb2tlbihzdGF0ZSk7XG4gICAgaWYgKG1hcmtlciA9PT0gMHg1QiAvKiBbICovKSB7XG4gICAgICBpZiAocHJldlBvcyA9PT0gc3RhdGUucG9zIC0gMSkge1xuICAgICAgICAvLyBpbmNyZWFzZSBsZXZlbCBpZiB3ZSBmaW5kIHRleHQgYFtgLCB3aGljaCBpcyBub3QgYSBwYXJ0IG9mIGFueSB0b2tlblxuICAgICAgICBsZXZlbCsrO1xuICAgICAgfSBlbHNlIGlmIChkaXNhYmxlTmVzdGVkKSB7XG4gICAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChmb3VuZCkge1xuICAgIGxhYmVsRW5kID0gc3RhdGUucG9zO1xuICB9XG5cbiAgLy8gcmVzdG9yZSBvbGQgc3RhdGVcbiAgc3RhdGUucG9zID0gb2xkUG9zO1xuXG4gIHJldHVybiBsYWJlbEVuZDtcbn07XG4iLCIvLyBQYXJzZSBsaW5rIHRpdGxlXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1bmVzY2FwZUFsbCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLnVuZXNjYXBlQWxsO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VMaW5rVGl0bGUoc3RyLCBwb3MsIG1heCkge1xuICB2YXIgY29kZSxcbiAgICAgIG1hcmtlcixcbiAgICAgIGxpbmVzID0gMCxcbiAgICAgIHN0YXJ0ID0gcG9zLFxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIHBvczogMCxcbiAgICAgICAgbGluZXM6IDAsXG4gICAgICAgIHN0cjogJydcbiAgICAgIH07XG5cbiAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIHJlc3VsdDsgfVxuXG4gIG1hcmtlciA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKG1hcmtlciAhPT0gMHgyMiAvKiBcIiAqLyAmJiBtYXJrZXIgIT09IDB4MjcgLyogJyAqLyAmJiBtYXJrZXIgIT09IDB4MjggLyogKCAqLykgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgcG9zKys7XG5cbiAgLy8gaWYgb3BlbmluZyBtYXJrZXIgaXMgXCIoXCIsIHN3aXRjaCBpdCB0byBjbG9zaW5nIG1hcmtlciBcIilcIlxuICBpZiAobWFya2VyID09PSAweDI4KSB7IG1hcmtlciA9IDB4Mjk7IH1cblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNvZGUgPT09IG1hcmtlcikge1xuICAgICAgcmVzdWx0LnBvcyA9IHBvcyArIDE7XG4gICAgICByZXN1bHQubGluZXMgPSBsaW5lcztcbiAgICAgIHJlc3VsdC5zdHIgPSB1bmVzY2FwZUFsbChzdHIuc2xpY2Uoc3RhcnQgKyAxLCBwb3MpKTtcbiAgICAgIHJlc3VsdC5vayA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyOCAvKiAoICovICYmIG1hcmtlciA9PT0gMHgyOSAvKiApICovKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwQSkge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgcG9zKys7XG4gICAgICBpZiAoc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwQSkge1xuICAgICAgICBsaW5lcysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBNYWluIHBhcnNlciBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJyk7XG52YXIgaGVscGVycyAgICAgID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG52YXIgUmVuZGVyZXIgICAgID0gcmVxdWlyZSgnLi9yZW5kZXJlcicpO1xudmFyIFBhcnNlckNvcmUgICA9IHJlcXVpcmUoJy4vcGFyc2VyX2NvcmUnKTtcbnZhciBQYXJzZXJCbG9jayAgPSByZXF1aXJlKCcuL3BhcnNlcl9ibG9jaycpO1xudmFyIFBhcnNlcklubGluZSA9IHJlcXVpcmUoJy4vcGFyc2VyX2lubGluZScpO1xudmFyIExpbmtpZnlJdCAgICA9IHJlcXVpcmUoJ2xpbmtpZnktaXQnKTtcbnZhciBtZHVybCAgICAgICAgPSByZXF1aXJlKCdtZHVybCcpO1xudmFyIHB1bnljb2RlICAgICA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cblxudmFyIGNvbmZpZyA9IHtcbiAgZGVmYXVsdDogcmVxdWlyZSgnLi9wcmVzZXRzL2RlZmF1bHQnKSxcbiAgemVybzogcmVxdWlyZSgnLi9wcmVzZXRzL3plcm8nKSxcbiAgY29tbW9ubWFyazogcmVxdWlyZSgnLi9wcmVzZXRzL2NvbW1vbm1hcmsnKVxufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vXG4vLyBUaGlzIHZhbGlkYXRvciBjYW4gcHJvaGliaXQgbW9yZSB0aGFuIHJlYWxseSBuZWVkZWQgdG8gcHJldmVudCBYU1MuIEl0J3MgYVxuLy8gdHJhZGVvZmYgdG8ga2VlcCBjb2RlIHNpbXBsZSBhbmQgdG8gYmUgc2VjdXJlIGJ5IGRlZmF1bHQuXG4vL1xuLy8gSWYgeW91IG5lZWQgZGlmZmVyZW50IHNldHVwIC0gb3ZlcnJpZGUgdmFsaWRhdG9yIG1ldGhvZCBhcyB5b3Ugd2lzaC4gT3Jcbi8vIHJlcGxhY2UgaXQgd2l0aCBkdW1teSBmdW5jdGlvbiBhbmQgdXNlIGV4dGVybmFsIHNhbml0aXplci5cbi8vXG5cbnZhciBCQURfUFJPVE9fUkUgPSAvXih2YnNjcmlwdHxqYXZhc2NyaXB0fGZpbGV8ZGF0YSk6LztcbnZhciBHT09EX0RBVEFfUkUgPSAvXmRhdGE6aW1hZ2VcXC8oZ2lmfHBuZ3xqcGVnfHdlYnApOy87XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTGluayh1cmwpIHtcbiAgLy8gdXJsIHNob3VsZCBiZSBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnQsIGFuZCBleGlzdGluZyBlbnRpdGllcyBhcmUgZGVjb2RlZFxuICB2YXIgc3RyID0gdXJsLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBCQURfUFJPVE9fUkUudGVzdChzdHIpID8gKEdPT0RfREFUQV9SRS50ZXN0KHN0cikgPyB0cnVlIDogZmFsc2UpIDogdHJ1ZTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG52YXIgUkVDT0RFX0hPU1ROQU1FX0ZPUiA9IFsgJ2h0dHA6JywgJ2h0dHBzOicsICdtYWlsdG86JyBdO1xuXG5mdW5jdGlvbiBub3JtYWxpemVMaW5rKHVybCkge1xuICB2YXIgcGFyc2VkID0gbWR1cmwucGFyc2UodXJsLCB0cnVlKTtcblxuICBpZiAocGFyc2VkLmhvc3RuYW1lKSB7XG4gICAgLy8gRW5jb2RlIGhvc3RuYW1lcyBpbiB1cmxzIGxpa2U6XG4gICAgLy8gYGh0dHA6Ly9ob3N0L2AsIGBodHRwczovL2hvc3QvYCwgYG1haWx0bzp1c2VyQGhvc3RgLCBgLy9ob3N0L2BcbiAgICAvL1xuICAgIC8vIFdlIGRvbid0IGVuY29kZSB1bmtub3duIHNjaGVtYXMsIGJlY2F1c2UgaXQncyBsaWtlbHkgdGhhdCB3ZSBlbmNvZGVcbiAgICAvLyBzb21ldGhpbmcgd2Ugc2hvdWxkbid0IChlLmcuIGBza3lwZTpuYW1lYCB0cmVhdGVkIGFzIGBza3lwZTpob3N0YClcbiAgICAvL1xuICAgIGlmICghcGFyc2VkLnByb3RvY29sIHx8IFJFQ09ERV9IT1NUTkFNRV9GT1IuaW5kZXhPZihwYXJzZWQucHJvdG9jb2wpID49IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZC5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkocGFyc2VkLmhvc3RuYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVyKSB7IC8qKi8gfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZHVybC5lbmNvZGUobWR1cmwuZm9ybWF0KHBhcnNlZCkpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVMaW5rVGV4dCh1cmwpIHtcbiAgdmFyIHBhcnNlZCA9IG1kdXJsLnBhcnNlKHVybCwgdHJ1ZSk7XG5cbiAgaWYgKHBhcnNlZC5ob3N0bmFtZSkge1xuICAgIC8vIEVuY29kZSBob3N0bmFtZXMgaW4gdXJscyBsaWtlOlxuICAgIC8vIGBodHRwOi8vaG9zdC9gLCBgaHR0cHM6Ly9ob3N0L2AsIGBtYWlsdG86dXNlckBob3N0YCwgYC8vaG9zdC9gXG4gICAgLy9cbiAgICAvLyBXZSBkb24ndCBlbmNvZGUgdW5rbm93biBzY2hlbWFzLCBiZWNhdXNlIGl0J3MgbGlrZWx5IHRoYXQgd2UgZW5jb2RlXG4gICAgLy8gc29tZXRoaW5nIHdlIHNob3VsZG4ndCAoZS5nLiBgc2t5cGU6bmFtZWAgdHJlYXRlZCBhcyBgc2t5cGU6aG9zdGApXG4gICAgLy9cbiAgICBpZiAoIXBhcnNlZC5wcm90b2NvbCB8fCBSRUNPREVfSE9TVE5BTUVfRk9SLmluZGV4T2YocGFyc2VkLnByb3RvY29sKSA+PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWQuaG9zdG5hbWUgPSBwdW55Y29kZS50b1VuaWNvZGUocGFyc2VkLmhvc3RuYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVyKSB7IC8qKi8gfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCAnJScgdG8gZXhjbHVkZSBsaXN0IGJlY2F1c2Ugb2YgaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2lzc3Vlcy83MjBcbiAgcmV0dXJuIG1kdXJsLmRlY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSwgbWR1cmwuZGVjb2RlLmRlZmF1bHRDaGFycyArICclJyk7XG59XG5cblxuLyoqXG4gKiBjbGFzcyBNYXJrZG93bkl0XG4gKlxuICogTWFpbiBwYXJzZXIvcmVuZGVyZXIgY2xhc3MuXG4gKlxuICogIyMjIyMgVXNhZ2VcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBub2RlLmpzLCBcImNsYXNzaWNcIiB3YXk6XG4gKiB2YXIgTWFya2Rvd25JdCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JyksXG4gKiAgICAgbWQgPSBuZXcgTWFya2Rvd25JdCgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKlxuICogLy8gbm9kZS5qcywgdGhlIHNhbWUsIGJ1dCB3aXRoIHN1Z2FyOlxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKlxuICogLy8gYnJvd3NlciB3aXRob3V0IEFNRCwgYWRkZWQgdG8gXCJ3aW5kb3dcIiBvbiBzY3JpcHQgbG9hZFxuICogLy8gTm90ZSwgdGhlcmUgYXJlIG5vIGRhc2guXG4gKiB2YXIgbWQgPSB3aW5kb3cubWFya2Rvd25pdCgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKiBgYGBcbiAqXG4gKiBTaW5nbGUgbGluZSByZW5kZXJpbmcsIHdpdGhvdXQgcGFyYWdyYXBoIHdyYXA6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcklubGluZSgnX19tYXJrZG93bi1pdF9fIHJ1bGV6eiEnKTtcbiAqIGBgYFxuICoqL1xuXG4vKipcbiAqIG5ldyBNYXJrZG93bkl0KFtwcmVzZXROYW1lLCBvcHRpb25zXSlcbiAqIC0gcHJlc2V0TmFtZSAoU3RyaW5nKTogb3B0aW9uYWwsIGBjb21tb25tYXJrYCAvIGB6ZXJvYFxuICogLSBvcHRpb25zIChPYmplY3QpXG4gKlxuICogQ3JlYXRlcyBwYXJzZXIgaW5zdGFuc2Ugd2l0aCBnaXZlbiBjb25maWcuIENhbiBiZSBjYWxsZWQgd2l0aG91dCBgbmV3YC5cbiAqXG4gKiAjIyMjIyBwcmVzZXROYW1lXG4gKlxuICogTWFya2Rvd25JdCBwcm92aWRlcyBuYW1lZCBwcmVzZXRzIGFzIGEgY29udmVuaWVuY2UgdG8gcXVpY2tseVxuICogZW5hYmxlL2Rpc2FibGUgYWN0aXZlIHN5bnRheCBydWxlcyBhbmQgb3B0aW9ucyBmb3IgY29tbW9uIHVzZSBjYXNlcy5cbiAqXG4gKiAtIFtcImNvbW1vbm1hcmtcIl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanMpIC1cbiAqICAgY29uZmlndXJlcyBwYXJzZXIgdG8gc3RyaWN0IFtDb21tb25NYXJrXShodHRwOi8vY29tbW9ubWFyay5vcmcvKSBtb2RlLlxuICogLSBbZGVmYXVsdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL2RlZmF1bHQuanMpIC1cbiAqICAgc2ltaWxhciB0byBHRk0sIHVzZWQgd2hlbiBubyBwcmVzZXQgbmFtZSBnaXZlbi4gRW5hYmxlcyBhbGwgYXZhaWxhYmxlIHJ1bGVzLFxuICogICBidXQgc3RpbGwgd2l0aG91dCBodG1sLCB0eXBvZ3JhcGhlciAmIGF1dG9saW5rZXIuXG4gKiAtIFtcInplcm9cIl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL3plcm8uanMpIC1cbiAqICAgYWxsIHJ1bGVzIGRpc2FibGVkLiBVc2VmdWwgdG8gcXVpY2tseSBzZXR1cCB5b3VyIGNvbmZpZyB2aWEgYC5lbmFibGUoKWAuXG4gKiAgIEZvciBleGFtcGxlLCB3aGVuIHlvdSBuZWVkIG9ubHkgYGJvbGRgIGFuZCBgaXRhbGljYCBtYXJrdXAgYW5kIG5vdGhpbmcgZWxzZS5cbiAqXG4gKiAjIyMjIyBvcHRpb25zOlxuICpcbiAqIC0gX19odG1sX18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlLiBCZSBjYXJlZnVsIVxuICogICBUaGF0J3Mgbm90IHNhZmUhIFlvdSBtYXkgbmVlZCBleHRlcm5hbCBzYW5pdGl6ZXIgdG8gcHJvdGVjdCBvdXRwdXQgZnJvbSBYU1MuXG4gKiAgIEl0J3MgYmV0dGVyIHRvIGV4dGVuZCBmZWF0dXJlcyB2aWEgcGx1Z2lucywgaW5zdGVhZCBvZiBlbmFibGluZyBIVE1MLlxuICogLSBfX3hodG1sT3V0X18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGFkZCAnLycgd2hlbiBjbG9zaW5nIHNpbmdsZSB0YWdzXG4gKiAgIChgPGJyIC8+YCkuIFRoaXMgaXMgbmVlZGVkIG9ubHkgZm9yIGZ1bGwgQ29tbW9uTWFyayBjb21wYXRpYmlsaXR5LiBJbiByZWFsXG4gKiAgIHdvcmxkIHlvdSB3aWxsIG5lZWQgSFRNTCBvdXRwdXQuXG4gKiAtIF9fYnJlYWtzX18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGNvbnZlcnQgYFxcbmAgaW4gcGFyYWdyYXBocyBpbnRvIGA8YnI+YC5cbiAqIC0gX19sYW5nUHJlZml4X18gLSBgbGFuZ3VhZ2UtYC4gQ1NTIGxhbmd1YWdlIGNsYXNzIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrcy5cbiAqICAgQ2FuIGJlIHVzZWZ1bCBmb3IgZXh0ZXJuYWwgaGlnaGxpZ2h0ZXJzLlxuICogLSBfX2xpbmtpZnlfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dCB0byBsaW5rcy5cbiAqIC0gX190eXBvZ3JhcGhlcl9fICAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gZW5hYmxlIFtzb21lIGxhbmd1YWdlLW5ldXRyYWxcbiAqICAgcmVwbGFjZW1lbnRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanMpICtcbiAqICAgcXVvdGVzIGJlYXV0aWZpY2F0aW9uIChzbWFydHF1b3RlcykuXG4gKiAtIF9fcXVvdGVzX18gLSBg4oCc4oCd4oCY4oCZYCwgU3RyaW5nIG9yIEFycmF5LiBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50XG4gKiAgIHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQgYW5kIHNtYXJ0cXVvdGVzIG9uLiBGb3IgZXhhbXBsZSwgeW91IGNhblxuICogICB1c2UgYCfCq8K74oCe4oCcJ2AgZm9yIFJ1c3NpYW4sIGAn4oCe4oCc4oCa4oCYJ2AgZm9yIEdlcm1hbiwgYW5kXG4gKiAgIGBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddYCBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gKiAtIF9faGlnaGxpZ2h0X18gLSBgbnVsbGAuIEhpZ2hsaWdodGVyIGZ1bmN0aW9uIGZvciBmZW5jZWQgY29kZSBibG9ja3MuXG4gKiAgIEhpZ2hsaWdodGVyIGBmdW5jdGlvbiAoc3RyLCBsYW5nKWAgc2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwuIEl0IGNhbiBhbHNvXG4gKiAgIHJldHVybiBlbXB0eSBzdHJpbmcgaWYgdGhlIHNvdXJjZSB3YXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkXG4gKiAgIGV4dGVybmFseS4gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBjb21tb25tYXJrIG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoJ2NvbW1vbm1hcmsnKTtcbiAqXG4gKiAvLyBkZWZhdWx0IG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiAvLyBlbmFibGUgZXZlcnl0aGluZ1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSh7XG4gKiAgIGh0bWw6IHRydWUsXG4gKiAgIGxpbmtpZnk6IHRydWUsXG4gKiAgIHR5cG9ncmFwaGVyOiB0cnVlXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqICMjIyMjIFN5bnRheCBoaWdobGlnaHRpbmdcbiAqXG4gKiBgYGBqc1xuICogdmFyIGhsanMgPSByZXF1aXJlKCdoaWdobGlnaHQuanMnKSAvLyBodHRwczovL2hpZ2hsaWdodGpzLm9yZy9cbiAqXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuIGhsanMuaGlnaGxpZ2h0KHN0ciwgeyBsYW5ndWFnZTogbGFuZywgaWdub3JlSWxsZWdhbHM6IHRydWUgfSkudmFsdWU7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnJzsgLy8gdXNlIGV4dGVybmFsIGRlZmF1bHQgZXNjYXBpbmdcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBPciB3aXRoIGZ1bGwgd3JhcHBlciBvdmVycmlkZSAoaWYgeW91IG5lZWQgYXNzaWduIGNsYXNzIHRvIGA8cHJlPmApOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBobGpzID0gcmVxdWlyZSgnaGlnaGxpZ2h0LmpzJykgLy8gaHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvXG4gKlxuICogLy8gQWN0dWFsIGRlZmF1bHQgdmFsdWVzXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuICc8cHJlIGNsYXNzPVwiaGxqc1wiPjxjb2RlPicgK1xuICogICAgICAgICAgICAgICAgaGxqcy5oaWdobGlnaHQoc3RyLCB7IGxhbmd1YWdlOiBsYW5nLCBpZ25vcmVJbGxlZ2FsczogdHJ1ZSB9KS52YWx1ZSArXG4gKiAgICAgICAgICAgICAgICAnPC9jb2RlPjwvcHJlPic7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnPHByZSBjbGFzcz1cImhsanNcIj48Y29kZT4nICsgbWQudXRpbHMuZXNjYXBlSHRtbChzdHIpICsgJzwvY29kZT48L3ByZT4nO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqKi9cbmZ1bmN0aW9uIE1hcmtkb3duSXQocHJlc2V0TmFtZSwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFya2Rvd25JdCkpIHtcbiAgICByZXR1cm4gbmV3IE1hcmtkb3duSXQocHJlc2V0TmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKHByZXNldE5hbWUpKSB7XG4gICAgICBvcHRpb25zID0gcHJlc2V0TmFtZSB8fCB7fTtcbiAgICAgIHByZXNldE5hbWUgPSAnZGVmYXVsdCc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjaW5saW5lIC0+IFBhcnNlcklubGluZVxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW1BhcnNlcklubGluZV1dLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5pbmxpbmUgPSBuZXcgUGFyc2VySW5saW5lKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjYmxvY2sgLT4gUGFyc2VyQmxvY2tcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tQYXJzZXJCbG9ja11dLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5ibG9jayA9IG5ldyBQYXJzZXJCbG9jaygpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2NvcmUgLT4gQ29yZVxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW0NvcmVdXSBjaGFpbiBleGVjdXRvci4gWW91IG1heSBuZWVkIGl0IHRvIGFkZCBuZXcgcnVsZXMgd2hlblxuICAgKiB3cml0aW5nIHBsdWdpbnMuIEZvciBzaW1wbGUgcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSBhbmRcbiAgICogW1tNYXJrZG93bkl0LmVuYWJsZV1dLlxuICAgKiovXG4gIHRoaXMuY29yZSA9IG5ldyBQYXJzZXJDb3JlKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjcmVuZGVyZXIgLT4gUmVuZGVyZXJcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tSZW5kZXJlcl1dLiBVc2UgaXQgdG8gbW9kaWZ5IG91dHB1dCBsb29rLiBPciB0byBhZGQgcmVuZGVyaW5nXG4gICAqIHJ1bGVzIGZvciBuZXcgdG9rZW4gdHlwZXMsIGdlbmVyYXRlZCBieSBwbHVnaW5zLlxuICAgKlxuICAgKiAjIyMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICAgKlxuICAgKiBmdW5jdGlvbiBteVRva2VuKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNlbGYpIHtcbiAgICogICAvLy4uLlxuICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAqIH07XG4gICAqXG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzWydteV90b2tlbiddID0gbXlUb2tlblxuICAgKiBgYGBcbiAgICpcbiAgICogU2VlIFtbUmVuZGVyZXJdXSBkb2NzIGFuZCBbc291cmNlIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcmVuZGVyZXIuanMpLlxuICAgKiovXG4gIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNsaW5raWZ5IC0+IExpbmtpZnlJdFxuICAgKlxuICAgKiBbbGlua2lmeS1pdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L2xpbmtpZnktaXQpIGluc3RhbmNlLlxuICAgKiBVc2VkIGJ5IFtsaW5raWZ5XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qcylcbiAgICogcnVsZS5cbiAgICoqL1xuICB0aGlzLmxpbmtpZnkgPSBuZXcgTGlua2lmeUl0KCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjdmFsaWRhdGVMaW5rKHVybCkgLT4gQm9vbGVhblxuICAgKlxuICAgKiBMaW5rIHZhbGlkYXRpb24gZnVuY3Rpb24uIENvbW1vbk1hcmsgYWxsb3dzIHRvbyBtdWNoIGluIGxpbmtzLiBCeSBkZWZhdWx0XG4gICAqIHdlIGRpc2FibGUgYGphdmFzY3JpcHQ6YCwgYHZic2NyaXB0OmAsIGBmaWxlOmAgc2NoZW1hcywgYW5kIGFsbW9zdCBhbGwgYGRhdGE6Li4uYCBzY2hlbWFzXG4gICAqIGV4Y2VwdCBzb21lIGVtYmVkZGVkIGltYWdlIHR5cGVzLlxuICAgKlxuICAgKiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJlaGF2aW91cjpcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gICAqIC8vIGVuYWJsZSBldmVyeXRoaW5nXG4gICAqIG1kLnZhbGlkYXRlTGluayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICogYGBgXG4gICAqKi9cbiAgdGhpcy52YWxpZGF0ZUxpbmsgPSB2YWxpZGF0ZUxpbms7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjbm9ybWFsaXplTGluayh1cmwpIC0+IFN0cmluZ1xuICAgKlxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGVuY29kZSBsaW5rIHVybCB0byBhIG1hY2hpbmUtcmVhZGFibGUgZm9ybWF0LFxuICAgKiB3aGljaCBpbmNsdWRlcyB1cmwtZW5jb2RpbmcsIHB1bnljb2RlLCBldGMuXG4gICAqKi9cbiAgdGhpcy5ub3JtYWxpemVMaW5rID0gbm9ybWFsaXplTGluaztcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNub3JtYWxpemVMaW5rVGV4dCh1cmwpIC0+IFN0cmluZ1xuICAgKlxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGRlY29kZSBsaW5rIHVybCB0byBhIGh1bWFuLXJlYWRhYmxlIGZvcm1hdGBcbiAgICoqL1xuICB0aGlzLm5vcm1hbGl6ZUxpbmtUZXh0ID0gbm9ybWFsaXplTGlua1RleHQ7XG5cblxuICAvLyBFeHBvc2UgdXRpbHMgJiBoZWxwZXJzIGZvciBlYXN5IGFjY2VzIGZyb20gcGx1Z2luc1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I3V0aWxzIC0+IHV0aWxzXG4gICAqXG4gICAqIEFzc29ydGVkIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VmdWwgdG8gd3JpdGUgcGx1Z2lucy4gU2VlIGRldGFpbHNcbiAgICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvY29tbW9uL3V0aWxzLmpzKS5cbiAgICoqL1xuICB0aGlzLnV0aWxzID0gdXRpbHM7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjaGVscGVycyAtPiBoZWxwZXJzXG4gICAqXG4gICAqIExpbmsgY29tcG9uZW50cyBwYXJzZXIgZnVuY3Rpb25zLCB1c2VmdWwgdG8gd3JpdGUgcGx1Z2lucy4gU2VlIGRldGFpbHNcbiAgICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvaGVscGVycykuXG4gICAqKi9cbiAgdGhpcy5oZWxwZXJzID0gdXRpbHMuYXNzaWduKHt9LCBoZWxwZXJzKTtcblxuXG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuICB0aGlzLmNvbmZpZ3VyZShwcmVzZXROYW1lKTtcblxuICBpZiAob3B0aW9ucykgeyB0aGlzLnNldChvcHRpb25zKTsgfVxufVxuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuc2V0KG9wdGlvbnMpXG4gKlxuICogU2V0IHBhcnNlciBvcHRpb25zIChpbiB0aGUgc2FtZSBmb3JtYXQgYXMgaW4gY29uc3RydWN0b3IpLiBQcm9iYWJseSwgeW91XG4gKiB3aWxsIG5ldmVyIG5lZWQgaXQsIGJ1dCB5b3UgY2FuIGNoYW5nZSBvcHRpb25zIGFmdGVyIGNvbnN0cnVjdG9yIGNhbGwuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLnNldCh7IGh0bWw6IHRydWUsIGJyZWFrczogdHJ1ZSB9KVxuICogICAgICAgICAgICAgLnNldCh7IHR5cG9ncmFwaGVyLCB0cnVlIH0pO1xuICogYGBgXG4gKlxuICogX19Ob3RlOl9fIFRvIGFjaGlldmUgdGhlIGJlc3QgcG9zc2libGUgcGVyZm9ybWFuY2UsIGRvbid0IG1vZGlmeSBhXG4gKiBgbWFya2Rvd24taXRgIGluc3RhbmNlIG9wdGlvbnMgb24gdGhlIGZseS4gSWYgeW91IG5lZWQgbXVsdGlwbGUgY29uZmlndXJhdGlvbnNcbiAqIGl0J3MgYmVzdCB0byBjcmVhdGUgbXVsdGlwbGUgaW5zdGFuY2VzIGFuZCBpbml0aWFsaXplIGVhY2ggd2l0aCBzZXBhcmF0ZVxuICogY29uZmlnLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdXRpbHMuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlLCBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5jb25maWd1cmUocHJlc2V0cylcbiAqXG4gKiBCYXRjaCBsb2FkIG9mIGFsbCBvcHRpb25zIGFuZCBjb21wZW5lbnQgc2V0dGluZ3MuIFRoaXMgaXMgaW50ZXJuYWwgbWV0aG9kLFxuICogYW5kIHlvdSBwcm9iYWJseSB3aWxsIG5vdCBuZWVkIGl0LiBCdXQgaWYgeW91IHdpbGwgLSBzZWUgYXZhaWxhYmxlIHByZXNldHNcbiAqIGFuZCBkYXRhIHN0cnVjdHVyZSBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L3RyZWUvbWFzdGVyL2xpYi9wcmVzZXRzKVxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgcHJlc2V0cyBpbnN0ZWFkIG9mIGRpcmVjdCBjb25maWcgbG9hZHMuIFRoYXRcbiAqIHdpbGwgZ2l2ZSBiZXR0ZXIgY29tcGF0aWJpbGl0eSB3aXRoIG5leHQgdmVyc2lvbnMuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAocHJlc2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXMsIHByZXNldE5hbWU7XG5cbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHByZXNldHMpKSB7XG4gICAgcHJlc2V0TmFtZSA9IHByZXNldHM7XG4gICAgcHJlc2V0cyA9IGNvbmZpZ1twcmVzZXROYW1lXTtcbiAgICBpZiAoIXByZXNldHMpIHsgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBgbWFya2Rvd24taXRgIHByZXNldCBcIicgKyBwcmVzZXROYW1lICsgJ1wiLCBjaGVjayBuYW1lJyk7IH1cbiAgfVxuXG4gIGlmICghcHJlc2V0cykgeyB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIGBtYXJrZG93bi1pdGAgcHJlc2V0LCBjYW5cXCd0IGJlIGVtcHR5Jyk7IH1cblxuICBpZiAocHJlc2V0cy5vcHRpb25zKSB7IHNlbGYuc2V0KHByZXNldHMub3B0aW9ucyk7IH1cblxuICBpZiAocHJlc2V0cy5jb21wb25lbnRzKSB7XG4gICAgT2JqZWN0LmtleXMocHJlc2V0cy5jb21wb25lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzKSB7XG4gICAgICAgIHNlbGZbbmFtZV0ucnVsZXIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMpO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlczIpIHtcbiAgICAgICAgc2VsZltuYW1lXS5ydWxlcjIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC5lbmFibGUobGlzdCwgaWdub3JlSW52YWxpZClcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogcnVsZSBuYW1lIG9yIGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGVcbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIEVuYWJsZSBsaXN0IG9yIHJ1bGVzLiBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgZmluZCBhcHByb3ByaWF0ZSBjb21wb25lbnRzLFxuICogY29udGFpbmluZyBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBydWxlIG5vdCBmb3VuZCwgYW5kIGBpZ25vcmVJbnZhbGlkYFxuICogbm90IHNldCAtIHRocm93cyBleGNlcHRpb24uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLmVuYWJsZShbJ3N1YicsICdzdXAnXSlcbiAqICAgICAgICAgICAgIC5kaXNhYmxlKCdzbWFydHF1b3RlcycpO1xuICogYGBgXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIFsgJ2NvcmUnLCAnYmxvY2snLCAnaW5saW5lJyBdLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzW2NoYWluXS5ydWxlci5lbmFibGUobGlzdCwgdHJ1ZSkpO1xuICB9LCB0aGlzKTtcblxuICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuaW5saW5lLnJ1bGVyMi5lbmFibGUobGlzdCwgdHJ1ZSkpO1xuXG4gIHZhciBtaXNzZWQgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcmVzdWx0LmluZGV4T2YobmFtZSkgPCAwOyB9KTtcblxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGVuYWJsZSB1bmtub3duIHJ1bGUocyk6ICcgKyBtaXNzZWQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuZGlzYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBydWxlIG5hbWUgb3IgbGlzdCBvZiBydWxlIG5hbWVzIHRvIGRpc2FibGUuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW01hcmtkb3duSXQuZW5hYmxlXV0sIGJ1dCB0dXJuIHNwZWNpZmllZCBydWxlcyBvZmYuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICBbICdjb3JlJywgJ2Jsb2NrJywgJ2lubGluZScgXS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpc1tjaGFpbl0ucnVsZXIuZGlzYWJsZShsaXN0LCB0cnVlKSk7XG4gIH0sIHRoaXMpO1xuXG4gIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5pbmxpbmUucnVsZXIyLmRpc2FibGUobGlzdCwgdHJ1ZSkpO1xuXG4gIHZhciBtaXNzZWQgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcmVzdWx0LmluZGV4T2YobmFtZSkgPCAwOyB9KTtcblxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGRpc2FibGUgdW5rbm93biBydWxlKHMpOiAnICsgbWlzc2VkKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC51c2UocGx1Z2luLCBwYXJhbXMpXG4gKlxuICogTG9hZCBzcGVjaWZpZWQgcGx1Z2luIHdpdGggZ2l2ZW4gcGFyYW1zIGludG8gY3VycmVudCBwYXJzZXIgaW5zdGFuY2UuXG4gKiBJdCdzIGp1c3QgYSBzdWdhciB0byBjYWxsIGBwbHVnaW4obWQsIHBhcmFtcylgIHdpdGggY3VycmluZy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGl0ZXJhdG9yID0gcmVxdWlyZSgnbWFya2Rvd24taXQtZm9yLWlubGluZScpO1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpXG4gKiAgICAgICAgICAgICAudXNlKGl0ZXJhdG9yLCAnZm9vX3JlcGxhY2UnLCAndGV4dCcsIGZ1bmN0aW9uICh0b2tlbnMsIGlkeCkge1xuICogICAgICAgICAgICAgICB0b2tlbnNbaWR4XS5jb250ZW50ID0gdG9rZW5zW2lkeF0uY29udGVudC5yZXBsYWNlKC9mb28vZywgJ2JhcicpO1xuICogICAgICAgICAgICAgfSk7XG4gKiBgYGBcbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4gLyosIHBhcmFtcywgLi4uICovKSB7XG4gIHZhciBhcmdzID0gWyB0aGlzIF0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICBwbHVnaW4uYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5wYXJzZShzcmMsIGVudikgLT4gQXJyYXlcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFBhcnNlIGlucHV0IHN0cmluZyBhbmQgcmV0dXJuIGxpc3Qgb2YgYmxvY2sgdG9rZW5zIChzcGVjaWFsIHRva2VuIHR5cGVcbiAqIFwiaW5saW5lXCIgd2lsbCBjb250YWluIGxpc3Qgb2YgaW5saW5lIHRva2VucykuIFlvdSBzaG91bGQgbm90IGNhbGwgdGhpc1xuICogbWV0aG9kIGRpcmVjdGx5LCB1bnRpbCB5b3Ugd3JpdGUgY3VzdG9tIHJlbmRlcmVyIChmb3IgZXhhbXBsZSwgdG8gcHJvZHVjZVxuICogQVNUKS5cbiAqXG4gKiBgZW52YCBpcyB1c2VkIHRvIHBhc3MgZGF0YSBiZXR3ZWVuIFwiZGlzdHJpYnV0ZWRcIiBydWxlcyBhbmQgcmV0dXJuIGFkZGl0aW9uYWxcbiAqIG1ldGFkYXRhIGxpa2UgcmVmZXJlbmNlIGluZm8sIG5lZWRlZCBmb3IgdGhlIHJlbmRlcmVyLiBJdCBhbHNvIGNhbiBiZSB1c2VkIHRvXG4gKiBpbmplY3QgZGF0YSBpbiBzcGVjaWZpYyBjYXNlcy4gVXN1YWxseSwgeW91IHdpbGwgYmUgb2sgdG8gcGFzcyBge31gLFxuICogYW5kIHRoZW4gcGFzcyB1cGRhdGVkIG9iamVjdCB0byByZW5kZXJlci5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBzaG91bGQgYmUgYSBTdHJpbmcnKTtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IG5ldyB0aGlzLmNvcmUuU3RhdGUoc3JjLCB0aGlzLCBlbnYpO1xuXG4gIHRoaXMuY29yZS5wcm9jZXNzKHN0YXRlKTtcblxuICByZXR1cm4gc3RhdGUudG9rZW5zO1xufTtcblxuXG4vKipcbiAqIE1hcmtkb3duSXQucmVuZGVyKHNyYyBbLCBlbnZdKSAtPiBTdHJpbmdcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFJlbmRlciBtYXJrZG93biBzdHJpbmcgaW50byBodG1sLiBJdCBkb2VzIGFsbCBtYWdpYyBmb3IgeW91IDopLlxuICpcbiAqIGBlbnZgIGNhbiBiZSB1c2VkIHRvIGluamVjdCBhZGRpdGlvbmFsIG1ldGFkYXRhIChge31gIGJ5IGRlZmF1bHQpLlxuICogQnV0IHlvdSB3aWxsIG5vdCBuZWVkIGl0IHdpdGggaGlnaCBwcm9iYWJpbGl0eS4gU2VlIGFsc28gY29tbWVudFxuICogaW4gW1tNYXJrZG93bkl0LnBhcnNlXV0uXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcbiAgZW52ID0gZW52IHx8IHt9O1xuXG4gIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnBhcnNlKHNyYywgZW52KSwgdGhpcy5vcHRpb25zLCBlbnYpO1xufTtcblxuXG4vKiogaW50ZXJuYWxcbiAqIE1hcmtkb3duSXQucGFyc2VJbmxpbmUoc3JjLCBlbnYpIC0+IEFycmF5XG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBUaGUgc2FtZSBhcyBbW01hcmtkb3duSXQucGFyc2VdXSBidXQgc2tpcCBhbGwgYmxvY2sgcnVsZXMuIEl0IHJldHVybnMgdGhlXG4gKiBibG9jayB0b2tlbnMgbGlzdCB3aXRoIHRoZSBzaW5nbGUgYGlubGluZWAgZWxlbWVudCwgY29udGFpbmluZyBwYXJzZWQgaW5saW5lXG4gKiB0b2tlbnMgaW4gYGNoaWxkcmVuYCBwcm9wZXJ0eS4gQWxzbyB1cGRhdGVzIGBlbnZgIG9iamVjdC5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnBhcnNlSW5saW5lID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIHZhciBzdGF0ZSA9IG5ldyB0aGlzLmNvcmUuU3RhdGUoc3JjLCB0aGlzLCBlbnYpO1xuXG4gIHN0YXRlLmlubGluZU1vZGUgPSB0cnVlO1xuICB0aGlzLmNvcmUucHJvY2VzcyhzdGF0ZSk7XG5cbiAgcmV0dXJuIHN0YXRlLnRva2Vucztcbn07XG5cblxuLyoqXG4gKiBNYXJrZG93bkl0LnJlbmRlcklubGluZShzcmMgWywgZW52XSkgLT4gU3RyaW5nXG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBTaW1pbGFyIHRvIFtbTWFya2Rvd25JdC5yZW5kZXJdXSBidXQgZm9yIHNpbmdsZSBwYXJhZ3JhcGggY29udGVudC4gUmVzdWx0XG4gKiB3aWxsIE5PVCBiZSB3cmFwcGVkIGludG8gYDxwPmAgdGFncy5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnJlbmRlcklubGluZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICBlbnYgPSBlbnYgfHwge307XG5cbiAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMucGFyc2VJbmxpbmUoc3JjLCBlbnYpLCB0aGlzLm9wdGlvbnMsIGVudik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTWFya2Rvd25JdDtcbiIsIi8qKiBpbnRlcm5hbFxuICogY2xhc3MgUGFyc2VyQmxvY2tcbiAqXG4gKiBCbG9jay1sZXZlbCB0b2tlbml6ZXIuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFJ1bGVyICAgICAgICAgICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuXG52YXIgX3J1bGVzID0gW1xuICAvLyBGaXJzdCAyIHBhcmFtcyAtIHJ1bGUgbmFtZSAmIHNvdXJjZS4gU2Vjb25kYXJ5IGFycmF5IC0gbGlzdCBvZiBydWxlcyxcbiAgLy8gd2hpY2ggY2FuIGJlIHRlcm1pbmF0ZWQgYnkgdGhpcyBvbmUuXG4gIFsgJ3RhYmxlJywgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3RhYmxlJyksICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScgXSBdLFxuICBbICdjb2RlJywgICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9jb2RlJykgXSxcbiAgWyAnZmVuY2UnLCAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svZmVuY2UnKSwgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcgXSBdLFxuICBbICdibG9ja3F1b3RlJywgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9ibG9ja3F1b3RlJyksIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScsICdsaXN0JyBdIF0sXG4gIFsgJ2hyJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2hyJyksICAgICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJywgJ2xpc3QnIF0gXSxcbiAgWyAnbGlzdCcsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svbGlzdCcpLCAgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAncmVmZXJlbmNlJywgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svcmVmZXJlbmNlJykgXSxcbiAgWyAnaHRtbF9ibG9jaycsIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaHRtbF9ibG9jaycpLCBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAnaGVhZGluZycsICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaGVhZGluZycpLCAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAnbGhlYWRpbmcnLCAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svbGhlYWRpbmcnKSBdLFxuICBbICdwYXJhZ3JhcGgnLCAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9wYXJhZ3JhcGgnKSBdXG5dO1xuXG5cbi8qKlxuICogbmV3IFBhcnNlckJsb2NrKClcbiAqKi9cbmZ1bmN0aW9uIFBhcnNlckJsb2NrKCkge1xuICAvKipcbiAgICogUGFyc2VyQmxvY2sjcnVsZXIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBLZWVwIGNvbmZpZ3VyYXRpb24gb2YgYmxvY2sgcnVsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdLCB7IGFsdDogKF9ydWxlc1tpXVsyXSB8fCBbXSkuc2xpY2UoKSB9KTtcbiAgfVxufVxuXG5cbi8vIEdlbmVyYXRlIHRva2VucyBmb3IgaW5wdXQgcmFuZ2Vcbi8vXG5QYXJzZXJCbG9jay5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSkge1xuICB2YXIgb2ssIGksXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpLFxuICAgICAgbGVuID0gcnVsZXMubGVuZ3RoLFxuICAgICAgbGluZSA9IHN0YXJ0TGluZSxcbiAgICAgIGhhc0VtcHR5TGluZXMgPSBmYWxzZSxcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3Rpbmc7XG5cbiAgd2hpbGUgKGxpbmUgPCBlbmRMaW5lKSB7XG4gICAgc3RhdGUubGluZSA9IGxpbmUgPSBzdGF0ZS5za2lwRW1wdHlMaW5lcyhsaW5lKTtcbiAgICBpZiAobGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBUZXJtaW5hdGlvbiBjb25kaXRpb24gZm9yIG5lc3RlZCBjYWxscy5cbiAgICAvLyBOZXN0ZWQgY2FsbHMgY3VycmVudGx5IHVzZWQgZm9yIGJsb2NrcXVvdGVzICYgbGlzdHNcbiAgICBpZiAoc3RhdGUuc0NvdW50W2xpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBJZiBuZXN0aW5nIGxldmVsIGV4Y2VlZGVkIC0gc2tpcCB0YWlsIHRvIHRoZSBlbmQuIFRoYXQncyBub3Qgb3JkaW5hcnlcbiAgICAvLyBzaXR1YXRpb24gYW5kIHdlIHNob3VsZCBub3QgY2FyZSBhYm91dCBjb250ZW50LlxuICAgIGlmIChzdGF0ZS5sZXZlbCA+PSBtYXhOZXN0aW5nKSB7XG4gICAgICBzdGF0ZS5saW5lID0gZW5kTGluZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFRyeSBhbGwgcG9zc2libGUgcnVsZXMuXG4gICAgLy8gT24gc3VjY2VzcywgcnVsZSBzaG91bGQ6XG4gICAgLy9cbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUubGluZWBcbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUudG9rZW5zYFxuICAgIC8vIC0gcmV0dXJuIHRydWVcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgbGluZSwgZW5kTGluZSwgZmFsc2UpO1xuICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgLy8gc2V0IHN0YXRlLnRpZ2h0IGlmIHdlIGhhZCBhbiBlbXB0eSBsaW5lIGJlZm9yZSBjdXJyZW50IHRhZ1xuICAgIC8vIGkuZS4gbGF0ZXN0IGVtcHR5IGxpbmUgc2hvdWxkIG5vdCBjb3VudFxuICAgIHN0YXRlLnRpZ2h0ID0gIWhhc0VtcHR5TGluZXM7XG5cbiAgICAvLyBwYXJhZ3JhcGggbWlnaHQgXCJlYXRcIiBvbmUgbmV3bGluZSBhZnRlciBpdCBpbiBuZXN0ZWQgbGlzdHNcbiAgICBpZiAoc3RhdGUuaXNFbXB0eShzdGF0ZS5saW5lIC0gMSkpIHtcbiAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIGxpbmUgPSBzdGF0ZS5saW5lO1xuXG4gICAgaWYgKGxpbmUgPCBlbmRMaW5lICYmIHN0YXRlLmlzRW1wdHkobGluZSkpIHtcbiAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xuICAgICAgbGluZSsrO1xuICAgICAgc3RhdGUubGluZSA9IGxpbmU7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogUGFyc2VyQmxvY2sucGFyc2Uoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpXG4gKlxuICogUHJvY2VzcyBpbnB1dCBzdHJpbmcgYW5kIHB1c2ggYmxvY2sgdG9rZW5zIGludG8gYG91dFRva2Vuc2BcbiAqKi9cblBhcnNlckJsb2NrLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzcmMsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzcmMpIHsgcmV0dXJuOyB9XG5cbiAgc3RhdGUgPSBuZXcgdGhpcy5TdGF0ZShzcmMsIG1kLCBlbnYsIG91dFRva2Vucyk7XG5cbiAgdGhpcy50b2tlbml6ZShzdGF0ZSwgc3RhdGUubGluZSwgc3RhdGUubGluZU1heCk7XG59O1xuXG5cblBhcnNlckJsb2NrLnByb3RvdHlwZS5TdGF0ZSA9IHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svc3RhdGVfYmxvY2snKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlckJsb2NrO1xuIiwiLyoqIGludGVybmFsXG4gKiBjbGFzcyBDb3JlXG4gKlxuICogVG9wLWxldmVsIHJ1bGVzIGV4ZWN1dG9yLiBHbHVlcyBibG9jay9pbmxpbmUgcGFyc2VycyBhbmQgZG9lcyBpbnRlcm1lZGlhdGVcbiAqIHRyYW5zZm9ybWF0aW9ucy5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgUnVsZXIgID0gcmVxdWlyZSgnLi9ydWxlcicpO1xuXG5cbnZhciBfcnVsZXMgPSBbXG4gIFsgJ25vcm1hbGl6ZScsICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL25vcm1hbGl6ZScpICAgICAgXSxcbiAgWyAnYmxvY2snLCAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvYmxvY2snKSAgICAgICAgICBdLFxuICBbICdpbmxpbmUnLCAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9pbmxpbmUnKSAgICAgICAgIF0sXG4gIFsgJ2xpbmtpZnknLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2xpbmtpZnknKSAgICAgICAgXSxcbiAgWyAncmVwbGFjZW1lbnRzJywgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzJykgICBdLFxuICBbICdzbWFydHF1b3RlcycsICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9zbWFydHF1b3RlcycpICAgIF1cbl07XG5cblxuLyoqXG4gKiBuZXcgQ29yZSgpXG4gKiovXG5mdW5jdGlvbiBDb3JlKCkge1xuICAvKipcbiAgICogQ29yZSNydWxlciAtPiBSdWxlclxuICAgKlxuICAgKiBbW1J1bGVyXV0gaW5zdGFuY2UuIEtlZXAgY29uZmlndXJhdGlvbiBvZiBjb3JlIHJ1bGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIENvcmUucHJvY2VzcyhzdGF0ZSlcbiAqXG4gKiBFeGVjdXRlcyBjb3JlIGNoYWluIHJ1bGVzLlxuICoqL1xuQ29yZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICB2YXIgaSwgbCwgcnVsZXM7XG5cbiAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKTtcblxuICBmb3IgKGkgPSAwLCBsID0gcnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcnVsZXNbaV0oc3RhdGUpO1xuICB9XG59O1xuXG5Db3JlLnByb3RvdHlwZS5TdGF0ZSA9IHJlcXVpcmUoJy4vcnVsZXNfY29yZS9zdGF0ZV9jb3JlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDb3JlO1xuIiwiLyoqIGludGVybmFsXG4gKiBjbGFzcyBQYXJzZXJJbmxpbmVcbiAqXG4gKiBUb2tlbml6ZXMgcGFyYWdyYXBoIGNvbnRlbnQuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFJ1bGVyICAgICAgICAgICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUGFyc2VyIHJ1bGVzXG5cbnZhciBfcnVsZXMgPSBbXG4gIFsgJ3RleHQnLCAgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3RleHQnKSBdLFxuICBbICduZXdsaW5lJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9uZXdsaW5lJykgXSxcbiAgWyAnZXNjYXBlJywgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZXNjYXBlJykgXSxcbiAgWyAnYmFja3RpY2tzJywgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvYmFja3RpY2tzJykgXSxcbiAgWyAnc3RyaWtldGhyb3VnaCcsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaCcpLnRva2VuaXplIF0sXG4gIFsgJ2VtcGhhc2lzJywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VtcGhhc2lzJykudG9rZW5pemUgXSxcbiAgWyAnbGluaycsICAgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvbGluaycpIF0sXG4gIFsgJ2ltYWdlJywgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2ltYWdlJykgXSxcbiAgWyAnYXV0b2xpbmsnLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvYXV0b2xpbmsnKSBdLFxuICBbICdodG1sX2lubGluZScsICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9odG1sX2lubGluZScpIF0sXG4gIFsgJ2VudGl0eScsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VudGl0eScpIF1cbl07XG5cbnZhciBfcnVsZXMyID0gW1xuICBbICdiYWxhbmNlX3BhaXJzJywgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9iYWxhbmNlX3BhaXJzJykgXSxcbiAgWyAnc3RyaWtldGhyb3VnaCcsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaCcpLnBvc3RQcm9jZXNzIF0sXG4gIFsgJ2VtcGhhc2lzJywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VtcGhhc2lzJykucG9zdFByb2Nlc3MgXSxcbiAgWyAndGV4dF9jb2xsYXBzZScsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvdGV4dF9jb2xsYXBzZScpIF1cbl07XG5cblxuLyoqXG4gKiBuZXcgUGFyc2VySW5saW5lKClcbiAqKi9cbmZ1bmN0aW9uIFBhcnNlcklubGluZSgpIHtcbiAgdmFyIGk7XG5cbiAgLyoqXG4gICAqIFBhcnNlcklubGluZSNydWxlciAtPiBSdWxlclxuICAgKlxuICAgKiBbW1J1bGVyXV0gaW5zdGFuY2UuIEtlZXAgY29uZmlndXJhdGlvbiBvZiBpbmxpbmUgcnVsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBfcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyLnB1c2goX3J1bGVzW2ldWzBdLCBfcnVsZXNbaV1bMV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcklubGluZSNydWxlcjIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBTZWNvbmQgcnVsZXIgdXNlZCBmb3IgcG9zdC1wcm9jZXNzaW5nXG4gICAqIChlLmcuIGluIGVtcGhhc2lzLWxpa2UgcnVsZXMpLlxuICAgKiovXG4gIHRoaXMucnVsZXIyID0gbmV3IFJ1bGVyKCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IF9ydWxlczIubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyMi5wdXNoKF9ydWxlczJbaV1bMF0sIF9ydWxlczJbaV1bMV0pO1xuICB9XG59XG5cblxuLy8gU2tpcCBzaW5nbGUgdG9rZW4gYnkgcnVubmluZyBhbGwgcnVsZXMgaW4gdmFsaWRhdGlvbiBtb2RlO1xuLy8gcmV0dXJucyBgdHJ1ZWAgaWYgYW55IHJ1bGUgcmVwb3J0ZWQgc3VjY2Vzc1xuLy9cblBhcnNlcklubGluZS5wcm90b3R5cGUuc2tpcFRva2VuID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHZhciBvaywgaSwgcG9zID0gc3RhdGUucG9zLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKSxcbiAgICAgIGxlbiA9IHJ1bGVzLmxlbmd0aCxcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3RpbmcsXG4gICAgICBjYWNoZSA9IHN0YXRlLmNhY2hlO1xuXG5cbiAgaWYgKHR5cGVvZiBjYWNoZVtwb3NdICE9PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXRlLnBvcyA9IGNhY2hlW3Bvc107XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxldmVsIDwgbWF4TmVzdGluZykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgLy8gSW5jcmVtZW50IHN0YXRlLmxldmVsIGFuZCBkZWNyZW1lbnQgaXQgbGF0ZXIgdG8gbGltaXQgcmVjdXJzaW9uLlxuICAgICAgLy8gSXQncyBoYXJtbGVzcyB0byBkbyBoZXJlLCBiZWNhdXNlIG5vIHRva2VucyBhcmUgY3JlYXRlZC4gQnV0IGlkZWFsbHksXG4gICAgICAvLyB3ZSdkIG5lZWQgYSBzZXBhcmF0ZSBwcml2YXRlIHN0YXRlIHZhcmlhYmxlIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAvL1xuICAgICAgc3RhdGUubGV2ZWwrKztcbiAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIHRydWUpO1xuICAgICAgc3RhdGUubGV2ZWwtLTtcblxuICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRvbyBtdWNoIG5lc3RpbmcsIGp1c3Qgc2tpcCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBwYXJhZ3JhcGguXG4gICAgLy9cbiAgICAvLyBOT1RFOiB0aGlzIHdpbGwgY2F1c2UgbGlua3MgdG8gYmVoYXZlIGluY29ycmVjdGx5IGluIHRoZSBmb2xsb3dpbmcgY2FzZSxcbiAgICAvLyAgICAgICB3aGVuIGFuIGFtb3VudCBvZiBgW2AgaXMgZXhhY3RseSBlcXVhbCB0byBgbWF4TmVzdGluZyArIDFgOlxuICAgIC8vXG4gICAgLy8gICAgICAgW1tbW1tbW1tbW1tbW1tbW1tbW1tbZm9vXSgpXG4gICAgLy9cbiAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyB3b3JrYXJvdW5kIHdoZW4gQ00gc3RhbmRhcmQgd2lsbCBhbGxvdyBuZXN0ZWQgbGlua3NcbiAgICAvLyAgICAgICAod2UgY2FuIHJlcGxhY2UgaXQgYnkgcHJldmVudGluZyBsaW5rcyBmcm9tIGJlaW5nIHBhcnNlZCBpblxuICAgIC8vICAgICAgIHZhbGlkYXRpb24gbW9kZSlcbiAgICAvL1xuICAgIHN0YXRlLnBvcyA9IHN0YXRlLnBvc01heDtcbiAgfVxuXG4gIGlmICghb2spIHsgc3RhdGUucG9zKys7IH1cbiAgY2FjaGVbcG9zXSA9IHN0YXRlLnBvcztcbn07XG5cblxuLy8gR2VuZXJhdGUgdG9rZW5zIGZvciBpbnB1dCByYW5nZVxuLy9cblBhcnNlcklubGluZS5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdmFyIG9rLCBpLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKSxcbiAgICAgIGxlbiA9IHJ1bGVzLmxlbmd0aCxcbiAgICAgIGVuZCA9IHN0YXRlLnBvc01heCxcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3Rpbmc7XG5cbiAgd2hpbGUgKHN0YXRlLnBvcyA8IGVuZCkge1xuICAgIC8vIFRyeSBhbGwgcG9zc2libGUgcnVsZXMuXG4gICAgLy8gT24gc3VjY2VzcywgcnVsZSBzaG91bGQ6XG4gICAgLy9cbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUucG9zYFxuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS50b2tlbnNgXG4gICAgLy8gLSByZXR1cm4gdHJ1ZVxuXG4gICAgaWYgKHN0YXRlLmxldmVsIDwgbWF4TmVzdGluZykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9rKSB7XG4gICAgICBpZiAoc3RhdGUucG9zID49IGVuZCkgeyBicmVhazsgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmNbc3RhdGUucG9zKytdO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBlbmRpbmcpIHtcbiAgICBzdGF0ZS5wdXNoUGVuZGluZygpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUGFyc2VySW5saW5lLnBhcnNlKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKVxuICpcbiAqIFByb2Nlc3MgaW5wdXQgc3RyaW5nIGFuZCBwdXNoIGlubGluZSB0b2tlbnMgaW50byBgb3V0VG9rZW5zYFxuICoqL1xuUGFyc2VySW5saW5lLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzdHIsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB2YXIgaSwgcnVsZXMsIGxlbjtcbiAgdmFyIHN0YXRlID0gbmV3IHRoaXMuU3RhdGUoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpO1xuXG4gIHRoaXMudG9rZW5pemUoc3RhdGUpO1xuXG4gIHJ1bGVzID0gdGhpcy5ydWxlcjIuZ2V0UnVsZXMoJycpO1xuICBsZW4gPSBydWxlcy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcnVsZXNbaV0oc3RhdGUpO1xuICB9XG59O1xuXG5cblBhcnNlcklubGluZS5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlcklubGluZTtcbiIsIi8vIENvbW1vbm1hcmsgZGVmYXVsdCBvcHRpb25zXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3B0aW9uczoge1xuICAgIGh0bWw6ICAgICAgICAgdHJ1ZSwgICAgICAgICAvLyBFbmFibGUgSFRNTCB0YWdzIGluIHNvdXJjZVxuICAgIHhodG1sT3V0OiAgICAgdHJ1ZSwgICAgICAgICAvLyBVc2UgJy8nIHRvIGNsb3NlIHNpbmdsZSB0YWdzICg8YnIgLz4pXG4gICAgYnJlYWtzOiAgICAgICBmYWxzZSwgICAgICAgIC8vIENvbnZlcnQgJ1xcbicgaW4gcGFyYWdyYXBocyBpbnRvIDxicj5cbiAgICBsYW5nUHJlZml4OiAgICdsYW5ndWFnZS0nLCAgLy8gQ1NTIGxhbmd1YWdlIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrc1xuICAgIGxpbmtpZnk6ICAgICAgZmFsc2UsICAgICAgICAvLyBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0cyB0byBsaW5rc1xuXG4gICAgLy8gRW5hYmxlIHNvbWUgbGFuZ3VhZ2UtbmV1dHJhbCByZXBsYWNlbWVudHMgKyBxdW90ZXMgYmVhdXRpZmljYXRpb25cbiAgICB0eXBvZ3JhcGhlcjogIGZhbHNlLFxuXG4gICAgLy8gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudCBwYWlycywgd2hlbiB0eXBvZ3JhcGhlciBlbmFibGVkLFxuICAgIC8vIGFuZCBzbWFydHF1b3RlcyBvbi4gQ291bGQgYmUgZWl0aGVyIGEgU3RyaW5nIG9yIGFuIEFycmF5LlxuICAgIC8vXG4gICAgLy8gRm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlICfCq8K74oCe4oCcJyBmb3IgUnVzc2lhbiwgJ+KAnuKAnOKAmuKAmCcgZm9yIEdlcm1hbixcbiAgICAvLyBhbmQgWyfCq1xceEEwJywgJ1xceEEwwrsnLCAn4oC5XFx4QTAnLCAnXFx4QTDigLonXSBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gICAgcXVvdGVzOiAnXFx1MjAxY1xcdTIwMWRcXHUyMDE4XFx1MjAxOScsIC8qIOKAnOKAneKAmOKAmSAqL1xuXG4gICAgLy8gSGlnaGxpZ2h0ZXIgZnVuY3Rpb24uIFNob3VsZCByZXR1cm4gZXNjYXBlZCBIVE1MLFxuICAgIC8vIG9yICcnIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGlzIG5vdCBjaGFuZ2VkIGFuZCBzaG91bGQgYmUgZXNjYXBlZCBleHRlcm5hbHkuXG4gICAgLy8gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gKC8qc3RyLCBsYW5nKi8pIHsgcmV0dXJuICcnOyB9XG4gICAgLy9cbiAgICBoaWdobGlnaHQ6IG51bGwsXG5cbiAgICBtYXhOZXN0aW5nOiAgIDIwICAgICAgICAgICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuXG4gICAgY29yZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ25vcm1hbGl6ZScsXG4gICAgICAgICdibG9jaycsXG4gICAgICAgICdpbmxpbmUnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGJsb2NrOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnYmxvY2txdW90ZScsXG4gICAgICAgICdjb2RlJyxcbiAgICAgICAgJ2ZlbmNlJyxcbiAgICAgICAgJ2hlYWRpbmcnLFxuICAgICAgICAnaHInLFxuICAgICAgICAnaHRtbF9ibG9jaycsXG4gICAgICAgICdsaGVhZGluZycsXG4gICAgICAgICdsaXN0JyxcbiAgICAgICAgJ3JlZmVyZW5jZScsXG4gICAgICAgICdwYXJhZ3JhcGgnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGlubGluZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ2F1dG9saW5rJyxcbiAgICAgICAgJ2JhY2t0aWNrcycsXG4gICAgICAgICdlbXBoYXNpcycsXG4gICAgICAgICdlbnRpdHknLFxuICAgICAgICAnZXNjYXBlJyxcbiAgICAgICAgJ2h0bWxfaW5saW5lJyxcbiAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgJ2xpbmsnLFxuICAgICAgICAnbmV3bGluZScsXG4gICAgICAgICd0ZXh0J1xuICAgICAgXSxcbiAgICAgIHJ1bGVzMjogW1xuICAgICAgICAnYmFsYW5jZV9wYWlycycsXG4gICAgICAgICdlbXBoYXNpcycsXG4gICAgICAgICd0ZXh0X2NvbGxhcHNlJ1xuICAgICAgXVxuICAgIH1cbiAgfVxufTtcbiIsIi8vIG1hcmtkb3duLWl0IGRlZmF1bHQgb3B0aW9uc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICBodG1sOiAgICAgICAgIGZhbHNlLCAgICAgICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICB4aHRtbE91dDogICAgIGZhbHNlLCAgICAgICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxuICAgIGJyZWFrczogICAgICAgZmFsc2UsICAgICAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XG4gICAgbGFuZ1ByZWZpeDogICAnbGFuZ3VhZ2UtJywgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcbiAgICBsaW5raWZ5OiAgICAgIGZhbHNlLCAgICAgICAgLy8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dHMgdG8gbGlua3NcblxuICAgIC8vIEVuYWJsZSBzb21lIGxhbmd1YWdlLW5ldXRyYWwgcmVwbGFjZW1lbnRzICsgcXVvdGVzIGJlYXV0aWZpY2F0aW9uXG4gICAgdHlwb2dyYXBoZXI6ICBmYWxzZSxcblxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIENvdWxkIGJlIGVpdGhlciBhIFN0cmluZyBvciBhbiBBcnJheS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSAnwqvCu+KAnuKAnCcgZm9yIFJ1c3NpYW4sICfigJ7igJzigJrigJgnIGZvciBHZXJtYW4sXG4gICAgLy8gYW5kIFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J10gZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICAgIHF1b3RlczogJ1xcdTIwMWNcXHUyMDFkXFx1MjAxOFxcdTIwMTknLCAvKiDigJzigJ3igJjigJkgKi9cblxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcbiAgICAvLyBvciAnJyBpZiB0aGUgc291cmNlIHN0cmluZyBpcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWQgZXh0ZXJuYWx5LlxuICAgIC8vIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxuICAgIC8vXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxuXG4gICAgbWF4TmVzdGluZzogICAxMDAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG5cbiAgICBjb3JlOiB7fSxcbiAgICBibG9jazoge30sXG4gICAgaW5saW5lOiB7fVxuICB9XG59O1xuIiwiLy8gXCJaZXJvXCIgcHJlc2V0LCB3aXRoIG5vdGhpbmcgZW5hYmxlZC4gVXNlZnVsIGZvciBtYW51YWwgY29uZmlndXJpbmcgb2Ygc2ltcGxlXG4vLyBtb2Rlcy4gRm9yIGV4YW1wbGUsIHRvIHBhcnNlIGJvbGQvaXRhbGljIG9ubHkuXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3B0aW9uczoge1xuICAgIGh0bWw6ICAgICAgICAgZmFsc2UsICAgICAgICAvLyBFbmFibGUgSFRNTCB0YWdzIGluIHNvdXJjZVxuICAgIHhodG1sT3V0OiAgICAgZmFsc2UsICAgICAgICAvLyBVc2UgJy8nIHRvIGNsb3NlIHNpbmdsZSB0YWdzICg8YnIgLz4pXG4gICAgYnJlYWtzOiAgICAgICBmYWxzZSwgICAgICAgIC8vIENvbnZlcnQgJ1xcbicgaW4gcGFyYWdyYXBocyBpbnRvIDxicj5cbiAgICBsYW5nUHJlZml4OiAgICdsYW5ndWFnZS0nLCAgLy8gQ1NTIGxhbmd1YWdlIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrc1xuICAgIGxpbmtpZnk6ICAgICAgZmFsc2UsICAgICAgICAvLyBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0cyB0byBsaW5rc1xuXG4gICAgLy8gRW5hYmxlIHNvbWUgbGFuZ3VhZ2UtbmV1dHJhbCByZXBsYWNlbWVudHMgKyBxdW90ZXMgYmVhdXRpZmljYXRpb25cbiAgICB0eXBvZ3JhcGhlcjogIGZhbHNlLFxuXG4gICAgLy8gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudCBwYWlycywgd2hlbiB0eXBvZ3JhcGhlciBlbmFibGVkLFxuICAgIC8vIGFuZCBzbWFydHF1b3RlcyBvbi4gQ291bGQgYmUgZWl0aGVyIGEgU3RyaW5nIG9yIGFuIEFycmF5LlxuICAgIC8vXG4gICAgLy8gRm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlICfCq8K74oCe4oCcJyBmb3IgUnVzc2lhbiwgJ+KAnuKAnOKAmuKAmCcgZm9yIEdlcm1hbixcbiAgICAvLyBhbmQgWyfCq1xceEEwJywgJ1xceEEwwrsnLCAn4oC5XFx4QTAnLCAnXFx4QTDigLonXSBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gICAgcXVvdGVzOiAnXFx1MjAxY1xcdTIwMWRcXHUyMDE4XFx1MjAxOScsIC8qIOKAnOKAneKAmOKAmSAqL1xuXG4gICAgLy8gSGlnaGxpZ2h0ZXIgZnVuY3Rpb24uIFNob3VsZCByZXR1cm4gZXNjYXBlZCBIVE1MLFxuICAgIC8vIG9yICcnIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGlzIG5vdCBjaGFuZ2VkIGFuZCBzaG91bGQgYmUgZXNjYXBlZCBleHRlcm5hbHkuXG4gICAgLy8gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gKC8qc3RyLCBsYW5nKi8pIHsgcmV0dXJuICcnOyB9XG4gICAgLy9cbiAgICBoaWdobGlnaHQ6IG51bGwsXG5cbiAgICBtYXhOZXN0aW5nOiAgIDIwICAgICAgICAgICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuXG4gICAgY29yZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ25vcm1hbGl6ZScsXG4gICAgICAgICdibG9jaycsXG4gICAgICAgICdpbmxpbmUnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGJsb2NrOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAncGFyYWdyYXBoJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBpbmxpbmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICd0ZXh0J1xuICAgICAgXSxcbiAgICAgIHJ1bGVzMjogW1xuICAgICAgICAnYmFsYW5jZV9wYWlycycsXG4gICAgICAgICd0ZXh0X2NvbGxhcHNlJ1xuICAgICAgXVxuICAgIH1cbiAgfVxufTtcbiIsIi8qKlxuICogY2xhc3MgUmVuZGVyZXJcbiAqXG4gKiBHZW5lcmF0ZXMgSFRNTCBmcm9tIHBhcnNlZCB0b2tlbiBzdHJlYW0uIEVhY2ggaW5zdGFuY2UgaGFzIGluZGVwZW5kZW50XG4gKiBjb3B5IG9mIHJ1bGVzLiBUaG9zZSBjYW4gYmUgcmV3cml0dGVuIHdpdGggZWFzZS4gQWxzbywgeW91IGNhbiBhZGQgbmV3XG4gKiBydWxlcyBpZiB5b3UgY3JlYXRlIHBsdWdpbiBhbmQgYWRkcyBuZXcgdG9rZW4gdHlwZXMuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGFzc2lnbiAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJykuYXNzaWduO1xudmFyIHVuZXNjYXBlQWxsICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJykudW5lc2NhcGVBbGw7XG52YXIgZXNjYXBlSHRtbCAgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKS5lc2NhcGVIdG1sO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbnZhciBkZWZhdWx0X3J1bGVzID0ge307XG5cblxuZGVmYXVsdF9ydWxlcy5jb2RlX2lubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgcmV0dXJuICAnPGNvZGUnICsgc2xmLnJlbmRlckF0dHJzKHRva2VuKSArICc+JyArXG4gICAgICAgICAgZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KSArXG4gICAgICAgICAgJzwvY29kZT4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmNvZGVfYmxvY2sgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuXG4gIHJldHVybiAgJzxwcmUnICsgc2xmLnJlbmRlckF0dHJzKHRva2VuKSArICc+PGNvZGU+JyArXG4gICAgICAgICAgZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KSArXG4gICAgICAgICAgJzwvY29kZT48L3ByZT5cXG4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmZlbmNlID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XSxcbiAgICAgIGluZm8gPSB0b2tlbi5pbmZvID8gdW5lc2NhcGVBbGwodG9rZW4uaW5mbykudHJpbSgpIDogJycsXG4gICAgICBsYW5nTmFtZSA9ICcnLFxuICAgICAgbGFuZ0F0dHJzID0gJycsXG4gICAgICBoaWdobGlnaHRlZCwgaSwgYXJyLCB0bXBBdHRycywgdG1wVG9rZW47XG5cbiAgaWYgKGluZm8pIHtcbiAgICBhcnIgPSBpbmZvLnNwbGl0KC8oXFxzKykvZyk7XG4gICAgbGFuZ05hbWUgPSBhcnJbMF07XG4gICAgbGFuZ0F0dHJzID0gYXJyLnNsaWNlKDIpLmpvaW4oJycpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgaGlnaGxpZ2h0ZWQgPSBvcHRpb25zLmhpZ2hsaWdodCh0b2tlbi5jb250ZW50LCBsYW5nTmFtZSwgbGFuZ0F0dHJzKSB8fCBlc2NhcGVIdG1sKHRva2VuLmNvbnRlbnQpO1xuICB9IGVsc2Uge1xuICAgIGhpZ2hsaWdodGVkID0gZXNjYXBlSHRtbCh0b2tlbi5jb250ZW50KTtcbiAgfVxuXG4gIGlmIChoaWdobGlnaHRlZC5pbmRleE9mKCc8cHJlJykgPT09IDApIHtcbiAgICByZXR1cm4gaGlnaGxpZ2h0ZWQgKyAnXFxuJztcbiAgfVxuXG4gIC8vIElmIGxhbmd1YWdlIGV4aXN0cywgaW5qZWN0IGNsYXNzIGdlbnRseSwgd2l0aG91dCBtb2RpZnlpbmcgb3JpZ2luYWwgdG9rZW4uXG4gIC8vIE1heSBiZSwgb25lIGRheSB3ZSB3aWxsIGFkZCAuZGVlcENsb25lKCkgZm9yIHRva2VuIGFuZCBzaW1wbGlmeSB0aGlzIHBhcnQsIGJ1dFxuICAvLyBub3cgd2UgcHJlZmVyIHRvIGtlZXAgdGhpbmdzIGxvY2FsLlxuICBpZiAoaW5mbykge1xuICAgIGkgICAgICAgID0gdG9rZW4uYXR0ckluZGV4KCdjbGFzcycpO1xuICAgIHRtcEF0dHJzID0gdG9rZW4uYXR0cnMgPyB0b2tlbi5hdHRycy5zbGljZSgpIDogW107XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRtcEF0dHJzLnB1c2goWyAnY2xhc3MnLCBvcHRpb25zLmxhbmdQcmVmaXggKyBsYW5nTmFtZSBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wQXR0cnNbaV0gPSB0bXBBdHRyc1tpXS5zbGljZSgpO1xuICAgICAgdG1wQXR0cnNbaV1bMV0gKz0gJyAnICsgb3B0aW9ucy5sYW5nUHJlZml4ICsgbGFuZ05hbWU7XG4gICAgfVxuXG4gICAgLy8gRmFrZSB0b2tlbiBqdXN0IHRvIHJlbmRlciBhdHRyaWJ1dGVzXG4gICAgdG1wVG9rZW4gPSB7XG4gICAgICBhdHRyczogdG1wQXR0cnNcbiAgICB9O1xuXG4gICAgcmV0dXJuICAnPHByZT48Y29kZScgKyBzbGYucmVuZGVyQXR0cnModG1wVG9rZW4pICsgJz4nXG4gICAgICAgICAgKyBoaWdobGlnaHRlZFxuICAgICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICB9XG5cblxuICByZXR1cm4gICc8cHJlPjxjb2RlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPidcbiAgICAgICAgKyBoaWdobGlnaHRlZFxuICAgICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5pbWFnZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgLy8gXCJhbHRcIiBhdHRyIE1VU1QgYmUgc2V0LCBldmVuIGlmIGVtcHR5LiBCZWNhdXNlIGl0J3MgbWFuZGF0b3J5IGFuZFxuICAvLyBzaG91bGQgYmUgcGxhY2VkIG9uIHByb3BlciBwb3NpdGlvbiBmb3IgdGVzdHMuXG4gIC8vXG4gIC8vIFJlcGxhY2UgY29udGVudCB3aXRoIGFjdHVhbCB2YWx1ZVxuXG4gIHRva2VuLmF0dHJzW3Rva2VuLmF0dHJJbmRleCgnYWx0JyldWzFdID1cbiAgICBzbGYucmVuZGVySW5saW5lQXNUZXh0KHRva2VuLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xuXG4gIHJldHVybiBzbGYucmVuZGVyVG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMpO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmhhcmRicmVhayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucyAvKiwgZW52ICovKSB7XG4gIHJldHVybiBvcHRpb25zLnhodG1sT3V0ID8gJzxiciAvPlxcbicgOiAnPGJyPlxcbic7XG59O1xuZGVmYXVsdF9ydWxlcy5zb2Z0YnJlYWsgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMgLyosIGVudiAqLykge1xuICByZXR1cm4gb3B0aW9ucy5icmVha3MgPyAob3B0aW9ucy54aHRtbE91dCA/ICc8YnIgLz5cXG4nIDogJzxicj5cXG4nKSA6ICdcXG4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLnRleHQgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KTtcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5odG1sX2Jsb2NrID0gZnVuY3Rpb24gKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuIHRva2Vuc1tpZHhdLmNvbnRlbnQ7XG59O1xuZGVmYXVsdF9ydWxlcy5odG1sX2lubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiB0b2tlbnNbaWR4XS5jb250ZW50O1xufTtcblxuXG4vKipcbiAqIG5ldyBSZW5kZXJlcigpXG4gKlxuICogQ3JlYXRlcyBuZXcgW1tSZW5kZXJlcl1dIGluc3RhbmNlIGFuZCBmaWxsIFtbUmVuZGVyZXIjcnVsZXNdXSB3aXRoIGRlZmF1bHRzLlxuICoqL1xuZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG5cbiAgLyoqXG4gICAqIFJlbmRlcmVyI3J1bGVzIC0+IE9iamVjdFxuICAgKlxuICAgKiBDb250YWlucyByZW5kZXIgcnVsZXMgZm9yIHRva2Vucy4gQ2FuIGJlIHVwZGF0ZWQgYW5kIGV4dGVuZGVkLlxuICAgKlxuICAgKiAjIyMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICAgKlxuICAgKiBtZC5yZW5kZXJlci5ydWxlcy5zdHJvbmdfb3BlbiAgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnPGI+JzsgfTtcbiAgICogbWQucmVuZGVyZXIucnVsZXMuc3Ryb25nX2Nsb3NlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJzwvYj4nOyB9O1xuICAgKlxuICAgKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVySW5saW5lKC4uLik7XG4gICAqIGBgYFxuICAgKlxuICAgKiBFYWNoIHJ1bGUgaXMgY2FsbGVkIGFzIGluZGVwZW5kZW50IHN0YXRpYyBmdW5jdGlvbiB3aXRoIGZpeGVkIHNpZ25hdHVyZTpcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBmdW5jdGlvbiBteV90b2tlbl9yZW5kZXIodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgcmVuZGVyZXIpIHtcbiAgICogICAvLyAuLi5cbiAgICogICByZXR1cm4gcmVuZGVyZWRIVE1MO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBTZWUgW3NvdXJjZSBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3JlbmRlcmVyLmpzKVxuICAgKiBmb3IgbW9yZSBkZXRhaWxzIGFuZCBleGFtcGxlcy5cbiAgICoqL1xuICB0aGlzLnJ1bGVzID0gYXNzaWduKHt9LCBkZWZhdWx0X3J1bGVzKTtcbn1cblxuXG4vKipcbiAqIFJlbmRlcmVyLnJlbmRlckF0dHJzKHRva2VuKSAtPiBTdHJpbmdcbiAqXG4gKiBSZW5kZXIgdG9rZW4gYXR0cmlidXRlcyB0byBzdHJpbmcuXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQXR0cnMgPSBmdW5jdGlvbiByZW5kZXJBdHRycyh0b2tlbikge1xuICB2YXIgaSwgbCwgcmVzdWx0O1xuXG4gIGlmICghdG9rZW4uYXR0cnMpIHsgcmV0dXJuICcnOyB9XG5cbiAgcmVzdWx0ID0gJyc7XG5cbiAgZm9yIChpID0gMCwgbCA9IHRva2VuLmF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHJlc3VsdCArPSAnICcgKyBlc2NhcGVIdG1sKHRva2VuLmF0dHJzW2ldWzBdKSArICc9XCInICsgZXNjYXBlSHRtbCh0b2tlbi5hdHRyc1tpXVsxXSkgKyAnXCInO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucykgLT4gU3RyaW5nXG4gKiAtIHRva2VucyAoQXJyYXkpOiBsaXN0IG9mIHRva2Vuc1xuICogLSBpZHggKE51bWJlZCk6IHRva2VuIGluZGV4IHRvIHJlbmRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKlxuICogRGVmYXVsdCB0b2tlbiByZW5kZXJlci4gQ2FuIGJlIG92ZXJyaWRlbiBieSBjdXN0b20gZnVuY3Rpb25cbiAqIGluIFtbUmVuZGVyZXIjcnVsZXNdXS5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJUb2tlbiA9IGZ1bmN0aW9uIHJlbmRlclRva2VuKHRva2VucywgaWR4LCBvcHRpb25zKSB7XG4gIHZhciBuZXh0VG9rZW4sXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIG5lZWRMZiA9IGZhbHNlLFxuICAgICAgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICAvLyBUaWdodCBsaXN0IHBhcmFncmFwaHNcbiAgaWYgKHRva2VuLmhpZGRlbikge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIEluc2VydCBhIG5ld2xpbmUgYmV0d2VlbiBoaWRkZW4gcGFyYWdyYXBoIGFuZCBzdWJzZXF1ZW50IG9wZW5pbmdcbiAgLy8gYmxvY2stbGV2ZWwgdGFnLlxuICAvL1xuICAvLyBGb3IgZXhhbXBsZSwgaGVyZSB3ZSBzaG91bGQgaW5zZXJ0IGEgbmV3bGluZSBiZWZvcmUgYmxvY2txdW90ZTpcbiAgLy8gIC0gYVxuICAvLyAgICA+XG4gIC8vXG4gIGlmICh0b2tlbi5ibG9jayAmJiB0b2tlbi5uZXN0aW5nICE9PSAtMSAmJiBpZHggJiYgdG9rZW5zW2lkeCAtIDFdLmhpZGRlbikge1xuICAgIHJlc3VsdCArPSAnXFxuJztcbiAgfVxuXG4gIC8vIEFkZCB0b2tlbiBuYW1lLCBlLmcuIGA8aW1nYFxuICByZXN1bHQgKz0gKHRva2VuLm5lc3RpbmcgPT09IC0xID8gJzwvJyA6ICc8JykgKyB0b2tlbi50YWc7XG5cbiAgLy8gRW5jb2RlIGF0dHJpYnV0ZXMsIGUuZy4gYDxpbWcgc3JjPVwiZm9vXCJgXG4gIHJlc3VsdCArPSB0aGlzLnJlbmRlckF0dHJzKHRva2VuKTtcblxuICAvLyBBZGQgYSBzbGFzaCBmb3Igc2VsZi1jbG9zaW5nIHRhZ3MsIGUuZy4gYDxpbWcgc3JjPVwiZm9vXCIgL2BcbiAgaWYgKHRva2VuLm5lc3RpbmcgPT09IDAgJiYgb3B0aW9ucy54aHRtbE91dCkge1xuICAgIHJlc3VsdCArPSAnIC8nO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBhZGQgYSBuZXdsaW5lIGFmdGVyIHRoaXMgdGFnXG4gIGlmICh0b2tlbi5ibG9jaykge1xuICAgIG5lZWRMZiA9IHRydWU7XG5cbiAgICBpZiAodG9rZW4ubmVzdGluZyA9PT0gMSkge1xuICAgICAgaWYgKGlkeCArIDEgPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIG5leHRUb2tlbiA9IHRva2Vuc1tpZHggKyAxXTtcblxuICAgICAgICBpZiAobmV4dFRva2VuLnR5cGUgPT09ICdpbmxpbmUnIHx8IG5leHRUb2tlbi5oaWRkZW4pIHtcbiAgICAgICAgICAvLyBCbG9jay1sZXZlbCB0YWcgY29udGFpbmluZyBhbiBpbmxpbmUgdGFnLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgbmVlZExmID0gZmFsc2U7XG5cbiAgICAgICAgfSBlbHNlIGlmIChuZXh0VG9rZW4ubmVzdGluZyA9PT0gLTEgJiYgbmV4dFRva2VuLnRhZyA9PT0gdG9rZW4udGFnKSB7XG4gICAgICAgICAgLy8gT3BlbmluZyB0YWcgKyBjbG9zaW5nIHRhZyBvZiB0aGUgc2FtZSB0eXBlLiBFLmcuIGA8bGk+PC9saT5gLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgbmVlZExmID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXN1bHQgKz0gbmVlZExmID8gJz5cXG4nIDogJz4nO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVySW5saW5lKHRva2Vucywgb3B0aW9ucywgZW52KSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb24gYmxvY2sgdG9rZW5zIHRvIHJlbmRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKiAtIGVudiAoT2JqZWN0KTogYWRkaXRpb25hbCBkYXRhIGZyb20gcGFyc2VkIGlucHV0IChyZWZlcmVuY2VzLCBmb3IgZXhhbXBsZSlcbiAqXG4gKiBUaGUgc2FtZSBhcyBbW1JlbmRlcmVyLnJlbmRlcl1dLCBidXQgZm9yIHNpbmdsZSB0b2tlbiBvZiBgaW5saW5lYCB0eXBlLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlcklubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMsIGVudikge1xuICB2YXIgdHlwZSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB0eXBlID0gdG9rZW5zW2ldLnR5cGU7XG5cbiAgICBpZiAodHlwZW9mIHJ1bGVzW3R5cGVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVzdWx0ICs9IHJ1bGVzW3R5cGVdKHRva2VucywgaSwgb3B0aW9ucywgZW52LCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVyVG9rZW4odG9rZW5zLCBpLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKiogaW50ZXJuYWxcbiAqIFJlbmRlcmVyLnJlbmRlcklubGluZUFzVGV4dCh0b2tlbnMsIG9wdGlvbnMsIGVudikgLT4gU3RyaW5nXG4gKiAtIHRva2VucyAoQXJyYXkpOiBsaXN0IG9uIGJsb2NrIHRva2VucyB0byByZW5kZXJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxuICogLSBlbnYgKE9iamVjdCk6IGFkZGl0aW9uYWwgZGF0YSBmcm9tIHBhcnNlZCBpbnB1dCAocmVmZXJlbmNlcywgZm9yIGV4YW1wbGUpXG4gKlxuICogU3BlY2lhbCBrbHVkZ2UgZm9yIGltYWdlIGBhbHRgIGF0dHJpYnV0ZXMgdG8gY29uZm9ybSBDb21tb25NYXJrIHNwZWMuXG4gKiBEb24ndCB0cnkgdG8gdXNlIGl0ISBTcGVjIHJlcXVpcmVzIHRvIHNob3cgYGFsdGAgY29udGVudCB3aXRoIHN0cmlwcGVkIG1hcmt1cCxcbiAqIGluc3RlYWQgb2Ygc2ltcGxlIGVzY2FwaW5nLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlcklubGluZUFzVGV4dCA9IGZ1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMsIGVudikge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICh0b2tlbnNbaV0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICByZXN1bHQgKz0gdG9rZW5zW2ldLmNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICh0b2tlbnNbaV0udHlwZSA9PT0gJ2ltYWdlJykge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVySW5saW5lQXNUZXh0KHRva2Vuc1tpXS5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcbiAgICB9IGVsc2UgaWYgKHRva2Vuc1tpXS50eXBlID09PSAnc29mdGJyZWFrJykge1xuICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVyKHRva2Vucywgb3B0aW9ucywgZW52KSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb24gYmxvY2sgdG9rZW5zIHRvIHJlbmRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKiAtIGVudiAoT2JqZWN0KTogYWRkaXRpb25hbCBkYXRhIGZyb20gcGFyc2VkIGlucHV0IChyZWZlcmVuY2VzLCBmb3IgZXhhbXBsZSlcbiAqXG4gKiBUYWtlcyB0b2tlbiBzdHJlYW0gYW5kIGdlbmVyYXRlcyBIVE1MLiBQcm9iYWJseSwgeW91IHdpbGwgbmV2ZXIgbmVlZCB0byBjYWxsXG4gKiB0aGlzIG1ldGhvZCBkaXJlY3RseS5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIGksIGxlbiwgdHlwZSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHR5cGUgPSB0b2tlbnNbaV0udHlwZTtcblxuICAgIGlmICh0eXBlID09PSAnaW5saW5lJykge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVySW5saW5lKHRva2Vuc1tpXS5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBydWxlc1t0eXBlXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc3VsdCArPSBydWxlc1t0b2tlbnNbaV0udHlwZV0odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJUb2tlbih0b2tlbnMsIGksIG9wdGlvbnMsIGVudik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyZXI7XG4iLCIvKipcbiAqIGNsYXNzIFJ1bGVyXG4gKlxuICogSGVscGVyIGNsYXNzLCB1c2VkIGJ5IFtbTWFya2Rvd25JdCNjb3JlXV0sIFtbTWFya2Rvd25JdCNibG9ja11dIGFuZFxuICogW1tNYXJrZG93bkl0I2lubGluZV1dIHRvIG1hbmFnZSBzZXF1ZW5jZXMgb2YgZnVuY3Rpb25zIChydWxlcyk6XG4gKlxuICogLSBrZWVwIHJ1bGVzIGluIGRlZmluZWQgb3JkZXJcbiAqIC0gYXNzaWduIHRoZSBuYW1lIHRvIGVhY2ggcnVsZVxuICogLSBlbmFibGUvZGlzYWJsZSBydWxlc1xuICogLSBhZGQvcmVwbGFjZSBydWxlc1xuICogLSBhbGxvdyBhc3NpZ24gcnVsZXMgdG8gYWRkaXRpb25hbCBuYW1lZCBjaGFpbnMgKGluIHRoZSBzYW1lKVxuICogLSBjYWNoZWluZyBsaXN0cyBvZiBhY3RpdmUgcnVsZXNcbiAqXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSB1bnRpbCB3cml0ZSBwbHVnaW5zLiBGb3Igc2ltcGxlXG4gKiBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dLCBbW01hcmtkb3duSXQuZW5hYmxlXV0gYW5kXG4gKiBbW01hcmtkb3duSXQudXNlXV0uXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxuLyoqXG4gKiBuZXcgUnVsZXIoKVxuICoqL1xuZnVuY3Rpb24gUnVsZXIoKSB7XG4gIC8vIExpc3Qgb2YgYWRkZWQgcnVsZXMuIEVhY2ggZWxlbWVudCBpczpcbiAgLy9cbiAgLy8ge1xuICAvLyAgIG5hbWU6IFhYWCxcbiAgLy8gICBlbmFibGVkOiBCb29sZWFuLFxuICAvLyAgIGZuOiBGdW5jdGlvbigpLFxuICAvLyAgIGFsdDogWyBuYW1lMiwgbmFtZTMgXVxuICAvLyB9XG4gIC8vXG4gIHRoaXMuX19ydWxlc19fID0gW107XG5cbiAgLy8gQ2FjaGVkIHJ1bGUgY2hhaW5zLlxuICAvL1xuICAvLyBGaXJzdCBsZXZlbCAtIGNoYWluIG5hbWUsICcnIGZvciBkZWZhdWx0LlxuICAvLyBTZWNvbmQgbGV2ZWwgLSBkaWdpbmFsIGFuY2hvciBmb3IgZmFzdCBmaWx0ZXJpbmcgYnkgY2hhcmNvZGVzLlxuICAvL1xuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXIgbWV0aG9kcywgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5XG5cblxuLy8gRmluZCBydWxlIGluZGV4IGJ5IG5hbWVcbi8vXG5SdWxlci5wcm90b3R5cGUuX19maW5kX18gPSBmdW5jdGlvbiAobmFtZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX19ydWxlc19fLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMuX19ydWxlc19fW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbi8vIEJ1aWxkIHJ1bGVzIGxvb2t1cCBjYWNoZVxuLy9cblJ1bGVyLnByb3RvdHlwZS5fX2NvbXBpbGVfXyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2hhaW5zID0gWyAnJyBdO1xuXG4gIC8vIGNvbGxlY3QgdW5pcXVlIG5hbWVzXG4gIHNlbGYuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICBpZiAoIXJ1bGUuZW5hYmxlZCkgeyByZXR1cm47IH1cblxuICAgIHJ1bGUuYWx0LmZvckVhY2goZnVuY3Rpb24gKGFsdE5hbWUpIHtcbiAgICAgIGlmIChjaGFpbnMuaW5kZXhPZihhbHROYW1lKSA8IDApIHtcbiAgICAgICAgY2hhaW5zLnB1c2goYWx0TmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHNlbGYuX19jYWNoZV9fID0ge307XG5cbiAgY2hhaW5zLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgc2VsZi5fX2NhY2hlX19bY2hhaW5dID0gW107XG4gICAgc2VsZi5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgaWYgKCFydWxlLmVuYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIGlmIChjaGFpbiAmJiBydWxlLmFsdC5pbmRleE9mKGNoYWluKSA8IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHNlbGYuX19jYWNoZV9fW2NoYWluXS5wdXNoKHJ1bGUuZm4pO1xuICAgIH0pO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5hdChuYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gbmFtZSAoU3RyaW5nKTogcnVsZSBuYW1lIHRvIHJlcGxhY2UuXG4gKiAtIGZuIChGdW5jdGlvbik6IG5ldyBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBuZXcgcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBSZXBsYWNlIHJ1bGUgYnkgbmFtZSB3aXRoIG5ldyBmdW5jdGlvbiAmIG9wdGlvbnMuIFRocm93cyBlcnJvciBpZiBuYW1lIG5vdFxuICogZm91bmQuXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBSZXBsYWNlIGV4aXN0aW5nIHR5cG9ncmFwaGVyIHJlcGxhY2VtZW50IHJ1bGUgd2l0aCBuZXcgb25lOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5jb3JlLnJ1bGVyLmF0KCdyZXBsYWNlbWVudHMnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gKiAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYFxuICoqL1xuUnVsZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX19maW5kX18obmFtZSk7XG4gIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHsgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgcnVsZSBub3QgZm91bmQ6ICcgKyBuYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fW2luZGV4XS5mbiA9IGZuO1xuICB0aGlzLl9fcnVsZXNfX1tpbmRleF0uYWx0ID0gb3B0LmFsdCB8fCBbXTtcbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmJlZm9yZShiZWZvcmVOYW1lLCBydWxlTmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIGJlZm9yZU5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYmVmb3JlIHRoaXMgb25lLlxuICogLSBydWxlTmFtZSAoU3RyaW5nKTogbmFtZSBvZiBhZGRlZCBydWxlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxuICpcbiAqIEFkZCBuZXcgcnVsZSB0byBjaGFpbiBiZWZvcmUgb25lIHdpdGggZ2l2ZW4gbmFtZS4gU2VlIGFsc29cbiAqIFtbUnVsZXIuYWZ0ZXJdXSwgW1tSdWxlci5wdXNoXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuYmxvY2sucnVsZXIuYmVmb3JlKCdwYXJhZ3JhcGgnLCAnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYmVmb3JlID0gZnVuY3Rpb24gKGJlZm9yZU5hbWUsIHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fZmluZF9fKGJlZm9yZU5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYmVmb3JlTmFtZSk7IH1cblxuICB0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaW5kZXgsIDAsIHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmFmdGVyKGFmdGVyTmFtZSwgcnVsZU5hbWUsIGZuIFssIG9wdGlvbnNdKVxuICogLSBhZnRlck5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYWZ0ZXIgdGhpcyBvbmUuXG4gKiAtIHJ1bGVOYW1lIChTdHJpbmcpOiBuYW1lIG9mIGFkZGVkIHJ1bGUuXG4gKiAtIGZuIChGdW5jdGlvbik6IHJ1bGUgZnVuY3Rpb24uXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogQWRkIG5ldyBydWxlIHRvIGNoYWluIGFmdGVyIG9uZSB3aXRoIGdpdmVuIG5hbWUuIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLnB1c2hdXS5cbiAqXG4gKiAjIyMjIyBPcHRpb25zOlxuICpcbiAqIC0gX19hbHRfXyAtIGFycmF5IHdpdGggbmFtZXMgb2YgXCJhbHRlcm5hdGVcIiBjaGFpbnMuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5pbmxpbmUucnVsZXIuYWZ0ZXIoJ3RleHQnLCAnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYWZ0ZXIgPSBmdW5jdGlvbiAoYWZ0ZXJOYW1lLCBydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2ZpbmRfXyhhZnRlck5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYWZ0ZXJOYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fLnNwbGljZShpbmRleCArIDEsIDAsIHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuLyoqXG4gKiBSdWxlci5wdXNoKHJ1bGVOYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gcnVsZU5hbWUgKFN0cmluZyk6IG5hbWUgb2YgYWRkZWQgcnVsZS5cbiAqIC0gZm4gKEZ1bmN0aW9uKTogcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBQdXNoIG5ldyBydWxlIHRvIHRoZSBlbmQgb2YgY2hhaW4uIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLmFmdGVyXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuY29yZS5ydWxlci5wdXNoKCdteV9ydWxlJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLl9fcnVsZXNfXy5wdXNoKHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmVuYWJsZShsaXN0IFssIGlnbm9yZUludmFsaWRdKSAtPiBBcnJheVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZW5hYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRW5hYmxlIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMuIElmIGFueSBydWxlIG5hbWUgbm90IGZvdW5kIC0gdGhyb3cgRXJyb3IuXG4gKiBFcnJvcnMgY2FuIGJlIGRpc2FibGVkIGJ5IHNlY29uZCBwYXJhbS5cbiAqXG4gKiBSZXR1cm5zIGxpc3Qgb2YgZm91bmQgcnVsZSBuYW1lcyAoaWYgbm8gZXhjZXB0aW9uIGhhcHBlbmVkKS5cbiAqXG4gKiBTZWUgYWxzbyBbW1J1bGVyLmRpc2FibGVdXSwgW1tSdWxlci5lbmFibGVPbmx5XV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcblxuICAvLyBTZWFyY2ggYnkgbmFtZSBhbmQgZW5hYmxlXG4gIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBpZHggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIGlmIChpZ25vcmVJbnZhbGlkKSB7IHJldHVybjsgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdWxlcyBtYW5hZ2VyOiBpbnZhbGlkIHJ1bGUgbmFtZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX19ydWxlc19fW2lkeF0uZW5hYmxlZCA9IHRydWU7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5lbmFibGVPbmx5KGxpc3QgWywgaWdub3JlSW52YWxpZF0pXG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGUgKHdoaXRlbGlzdCkuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBFbmFibGUgcnVsZXMgd2l0aCBnaXZlbiBuYW1lcywgYW5kIGRpc2FibGUgZXZlcnl0aGluZyBlbHNlLiBJZiBhbnkgcnVsZSBuYW1lXG4gKiBub3QgZm91bmQgLSB0aHJvdyBFcnJvci4gRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5kaXNhYmxlXV0sIFtbUnVsZXIuZW5hYmxlXV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZW5hYmxlT25seSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB0aGlzLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7IHJ1bGUuZW5hYmxlZCA9IGZhbHNlOyB9KTtcblxuICB0aGlzLmVuYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKTtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5kaXNhYmxlKGxpc3QgWywgaWdub3JlSW52YWxpZF0pIC0+IEFycmF5XG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBkaXNhYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRGlzYWJsZSBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBhbnkgcnVsZSBuYW1lIG5vdCBmb3VuZCAtIHRocm93IEVycm9yLlxuICogRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogUmV0dXJucyBsaXN0IG9mIGZvdW5kIHJ1bGUgbmFtZXMgKGlmIG5vIGV4Y2VwdGlvbiBoYXBwZW5lZCkuXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5lbmFibGVdXSwgW1tSdWxlci5lbmFibGVPbmx5XV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgLy8gU2VhcmNoIGJ5IG5hbWUgYW5kIGRpc2FibGVcbiAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX19maW5kX18obmFtZSk7XG5cbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgaWYgKGlnbm9yZUludmFsaWQpIHsgcmV0dXJuOyB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGVzIG1hbmFnZXI6IGludmFsaWQgcnVsZSBuYW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgdGhpcy5fX3J1bGVzX19baWR4XS5lbmFibGVkID0gZmFsc2U7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5nZXRSdWxlcyhjaGFpbk5hbWUpIC0+IEFycmF5XG4gKlxuICogUmV0dXJuIGFycmF5IG9mIGFjdGl2ZSBmdW5jdGlvbnMgKHJ1bGVzKSBmb3IgZ2l2ZW4gY2hhaW4gbmFtZS4gSXQgYW5hbHl6ZXNcbiAqIHJ1bGVzIGNvbmZpZ3VyYXRpb24sIGNvbXBpbGVzIGNhY2hlcyBpZiBub3QgZXhpc3RzIGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBEZWZhdWx0IGNoYWluIG5hbWUgaXMgYCcnYCAoZW1wdHkgc3RyaW5nKS4gSXQgY2FuJ3QgYmUgc2tpcHBlZC4gVGhhdCdzXG4gKiBkb25lIGludGVudGlvbmFsbHksIHRvIGtlZXAgc2lnbmF0dXJlIG1vbm9tb3JwaGljIGZvciBoaWdoIHNwZWVkLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmdldFJ1bGVzID0gZnVuY3Rpb24gKGNoYWluTmFtZSkge1xuICBpZiAodGhpcy5fX2NhY2hlX18gPT09IG51bGwpIHtcbiAgICB0aGlzLl9fY29tcGlsZV9fKCk7XG4gIH1cblxuICAvLyBDaGFpbiBjYW4gYmUgZW1wdHksIGlmIHJ1bGVzIGRpc2FibGVkLiBCdXQgd2Ugc3RpbGwgaGF2ZSB0byByZXR1cm4gQXJyYXkuXG4gIHJldHVybiB0aGlzLl9fY2FjaGVfX1tjaGFpbk5hbWVdIHx8IFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSdWxlcjtcbiIsIi8vIEJsb2NrIHF1b3Rlc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJsb2NrcXVvdGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBhZGp1c3RUYWIsXG4gICAgICBjaCxcbiAgICAgIGksXG4gICAgICBpbml0aWFsLFxuICAgICAgbCxcbiAgICAgIGxhc3RMaW5lRW1wdHksXG4gICAgICBsaW5lcyxcbiAgICAgIG5leHRMaW5lLFxuICAgICAgb2Zmc2V0LFxuICAgICAgb2xkQk1hcmtzLFxuICAgICAgb2xkQlNDb3VudCxcbiAgICAgIG9sZEluZGVudCxcbiAgICAgIG9sZFBhcmVudFR5cGUsXG4gICAgICBvbGRTQ291bnQsXG4gICAgICBvbGRUU2hpZnQsXG4gICAgICBzcGFjZUFmdGVyTWFya2VyLFxuICAgICAgdGVybWluYXRlLFxuICAgICAgdGVybWluYXRvclJ1bGVzLFxuICAgICAgdG9rZW4sXG4gICAgICBpc091dGRlbnRlZCxcbiAgICAgIG9sZExpbmVNYXggPSBzdGF0ZS5saW5lTWF4LFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGNoZWNrIHRoZSBibG9jayBxdW90ZSBtYXJrZXJcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKSAhPT0gMHgzRS8qID4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gd2Uga25vdyB0aGF0IGl0J3MgZ29pbmcgdG8gYmUgYSB2YWxpZCBibG9ja3F1b3RlLFxuICAvLyBzbyBubyBwb2ludCB0cnlpbmcgdG8gZmluZCB0aGUgZW5kIG9mIGl0IGluIHNpbGVudCBtb2RlXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBzZXQgb2Zmc2V0IHBhc3Qgc3BhY2VzIGFuZCBcIj5cIlxuICBpbml0aWFsID0gb2Zmc2V0ID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gKyAxO1xuXG4gIC8vIHNraXAgb25lIG9wdGlvbmFsIHNwYWNlIGFmdGVyICc+J1xuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCAvKiBzcGFjZSAqLykge1xuICAgIC8vICcgPiAgIHRlc3QgJ1xuICAgIC8vICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZTpcbiAgICBwb3MrKztcbiAgICBpbml0aWFsKys7XG4gICAgb2Zmc2V0Kys7XG4gICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG4gIH0gZWxzZSBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwOSAvKiB0YWIgKi8pIHtcbiAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcblxuICAgIGlmICgoc3RhdGUuYnNDb3VudFtzdGFydExpbmVdICsgb2Zmc2V0KSAlIDQgPT09IDMpIHtcbiAgICAgIC8vICcgID5cXHQgIHRlc3QgJ1xuICAgICAgLy8gICAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKHRhYiBoYXMgd2lkdGg9PT0xKVxuICAgICAgcG9zKys7XG4gICAgICBpbml0aWFsKys7XG4gICAgICBvZmZzZXQrKztcbiAgICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAnID5cXHQgIHRlc3QgJ1xuICAgICAgLy8gICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKyBzaGlmdCBic0NvdW50IHNsaWdodGx5XG4gICAgICAvLyAgICAgICAgIHRvIG1ha2UgZXh0cmEgc3BhY2UgYXBwZWFyXG4gICAgICBhZGp1c3RUYWIgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzcGFjZUFmdGVyTWFya2VyID0gZmFsc2U7XG4gIH1cblxuICBvbGRCTWFya3MgPSBbIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdIF07XG4gIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdID0gcG9zO1xuXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gKyAoYWRqdXN0VGFiID8gMSA6IDApKSAlIDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBvbGRCU0NvdW50ID0gWyBzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUuYnNDb3VudFtzdGFydExpbmVdID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gKyAxICsgKHNwYWNlQWZ0ZXJNYXJrZXIgPyAxIDogMCk7XG5cbiAgbGFzdExpbmVFbXB0eSA9IHBvcyA+PSBtYXg7XG5cbiAgb2xkU0NvdW50ID0gWyBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9mZnNldCAtIGluaXRpYWw7XG5cbiAgb2xkVFNoaWZ0ID0gWyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IHBvcyAtIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdO1xuXG4gIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdibG9ja3F1b3RlJyk7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAnYmxvY2txdW90ZSc7XG5cbiAgLy8gU2VhcmNoIHRoZSBlbmQgb2YgdGhlIGJsb2NrXG4gIC8vXG4gIC8vIEJsb2NrIGVuZHMgd2l0aCBlaXRoZXI6XG4gIC8vICAxLiBhbiBlbXB0eSBsaW5lIG91dHNpZGU6XG4gIC8vICAgICBgYGBcbiAgLy8gICAgID4gdGVzdFxuICAvL1xuICAvLyAgICAgYGBgXG4gIC8vICAyLiBhbiBlbXB0eSBsaW5lIGluc2lkZTpcbiAgLy8gICAgIGBgYFxuICAvLyAgICAgPlxuICAvLyAgICAgdGVzdFxuICAvLyAgICAgYGBgXG4gIC8vICAzLiBhbm90aGVyIHRhZzpcbiAgLy8gICAgIGBgYFxuICAvLyAgICAgPiB0ZXN0XG4gIC8vICAgICAgLSAtIC1cbiAgLy8gICAgIGBgYFxuICBmb3IgKG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTsgbmV4dExpbmUgPCBlbmRMaW5lOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gY2hlY2sgaWYgaXQncyBvdXRkZW50ZWQsIGkuZS4gaXQncyBpbnNpZGUgbGlzdCBpdGVtIGFuZCBpbmRlbnRlZFxuICAgIC8vIGxlc3MgdGhhbiBzYWlkIGxpc3QgaXRlbTpcbiAgICAvL1xuICAgIC8vIGBgYFxuICAgIC8vIDEuIGFueXRoaW5nXG4gICAgLy8gICAgPiBjdXJyZW50IGJsb2NrcXVvdGVcbiAgICAvLyAyLiBjaGVja2luZyB0aGlzIGxpbmVcbiAgICAvLyBgYGBcbiAgICBpc091dGRlbnRlZCA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQ7XG5cbiAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgaWYgKHBvcyA+PSBtYXgpIHtcbiAgICAgIC8vIENhc2UgMTogbGluZSBpcyBub3QgaW5zaWRlIHRoZSBibG9ja3F1b3RlLCBhbmQgdGhpcyBsaW5lIGlzIGVtcHR5LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKSA9PT0gMHgzRS8qID4gKi8gJiYgIWlzT3V0ZGVudGVkKSB7XG4gICAgICAvLyBUaGlzIGxpbmUgaXMgaW5zaWRlIHRoZSBibG9ja3F1b3RlLlxuXG4gICAgICAvLyBzZXQgb2Zmc2V0IHBhc3Qgc3BhY2VzIGFuZCBcIj5cIlxuICAgICAgaW5pdGlhbCA9IG9mZnNldCA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gKyAxO1xuXG4gICAgICAvLyBza2lwIG9uZSBvcHRpb25hbCBzcGFjZSBhZnRlciAnPidcbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDIwIC8qIHNwYWNlICovKSB7XG4gICAgICAgIC8vICcgPiAgIHRlc3QgJ1xuICAgICAgICAvLyAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmU6XG4gICAgICAgIHBvcysrO1xuICAgICAgICBpbml0aWFsKys7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MDkgLyogdGFiICovKSB7XG4gICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuXG4gICAgICAgIGlmICgoc3RhdGUuYnNDb3VudFtuZXh0TGluZV0gKyBvZmZzZXQpICUgNCA9PT0gMykge1xuICAgICAgICAgIC8vICcgID5cXHQgIHRlc3QgJ1xuICAgICAgICAgIC8vICAgICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlICh0YWIgaGFzIHdpZHRoPT09MSlcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBpbml0aWFsKys7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gJyA+XFx0ICB0ZXN0ICdcbiAgICAgICAgICAvLyAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSArIHNoaWZ0IGJzQ291bnQgc2xpZ2h0bHlcbiAgICAgICAgICAvLyAgICAgICAgIHRvIG1ha2UgZXh0cmEgc3BhY2UgYXBwZWFyXG4gICAgICAgICAgYWRqdXN0VGFiID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gPSBwb3M7XG5cbiAgICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQgLSAob2Zmc2V0ICsgc3RhdGUuYnNDb3VudFtuZXh0TGluZV0gKyAoYWRqdXN0VGFiID8gMSA6IDApKSAlIDQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuXG4gICAgICBsYXN0TGluZUVtcHR5ID0gcG9zID49IG1heDtcblxuICAgICAgb2xkQlNDb3VudC5wdXNoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLmJzQ291bnRbbmV4dExpbmVdID0gc3RhdGUuc0NvdW50W25leHRMaW5lXSArIDEgKyAoc3BhY2VBZnRlck1hcmtlciA/IDEgOiAwKTtcblxuICAgICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS5zQ291bnRbbmV4dExpbmVdID0gb2Zmc2V0IC0gaW5pdGlhbDtcblxuICAgICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS50U2hpZnRbbmV4dExpbmVdID0gcG9zIC0gc3RhdGUuYk1hcmtzW25leHRMaW5lXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIENhc2UgMjogbGluZSBpcyBub3QgaW5zaWRlIHRoZSBibG9ja3F1b3RlLCBhbmQgdGhlIGxhc3QgbGluZSB3YXMgZW1wdHkuXG4gICAgaWYgKGxhc3RMaW5lRW1wdHkpIHsgYnJlYWs7IH1cblxuICAgIC8vIENhc2UgMzogYW5vdGhlciB0YWcgZm91bmQuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGVybWluYXRlKSB7XG4gICAgICAvLyBRdWlyayB0byBlbmZvcmNlIFwiaGFyZCB0ZXJtaW5hdGlvbiBtb2RlXCIgZm9yIHBhcmFncmFwaHM7XG4gICAgICAvLyBub3JtYWxseSBpZiB5b3UgY2FsbCBgdG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgbmV4dExpbmUpYCxcbiAgICAgIC8vIHBhcmFncmFwaHMgd2lsbCBsb29rIGJlbG93IG5leHRMaW5lIGZvciBwYXJhZ3JhcGggY29udGludWF0aW9uLFxuICAgICAgLy8gYnV0IGlmIGJsb2NrcXVvdGUgaXMgdGVybWluYXRlZCBieSBhbm90aGVyIHRhZywgdGhleSBzaG91bGRuJ3RcbiAgICAgIHN0YXRlLmxpbmVNYXggPSBuZXh0TGluZTtcblxuICAgICAgaWYgKHN0YXRlLmJsa0luZGVudCAhPT0gMCkge1xuICAgICAgICAvLyBzdGF0ZS5ibGtJbmRlbnQgd2FzIG5vbi16ZXJvLCB3ZSBub3cgc2V0IGl0IHRvIHplcm8sXG4gICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gcmUtY2FsY3VsYXRlIGFsbCBvZmZzZXRzIHRvIGFwcGVhciBhc1xuICAgICAgICAvLyBpZiBpbmRlbnQgd2Fzbid0IGNoYW5nZWRcbiAgICAgICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuICAgICAgICBvbGRTQ291bnQucHVzaChzdGF0ZS5zQ291bnRbbmV4dExpbmVdKTtcbiAgICAgICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSAtPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG9sZEJNYXJrcy5wdXNoKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pO1xuICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG4gICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG5cbiAgICAvLyBBIG5lZ2F0aXZlIGluZGVudGF0aW9uIG1lYW5zIHRoYXQgdGhpcyBpcyBhIHBhcmFncmFwaCBjb250aW51YXRpb25cbiAgICAvL1xuICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPSAtMTtcbiAgfVxuXG4gIG9sZEluZGVudCA9IHN0YXRlLmJsa0luZGVudDtcbiAgc3RhdGUuYmxrSW5kZW50ID0gMDtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdibG9ja3F1b3RlX29wZW4nLCAnYmxvY2txdW90ZScsIDEpO1xuICB0b2tlbi5tYXJrdXAgPSAnPic7XG4gIHRva2VuLm1hcCAgICA9IGxpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcblxuICBzdGF0ZS5tZC5ibG9jay50b2tlbml6ZShzdGF0ZSwgc3RhcnRMaW5lLCBuZXh0TGluZSk7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnYmxvY2txdW90ZV9jbG9zZScsICdibG9ja3F1b3RlJywgLTEpO1xuICB0b2tlbi5tYXJrdXAgPSAnPic7XG5cbiAgc3RhdGUubGluZU1heCA9IG9sZExpbmVNYXg7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuICBsaW5lc1sxXSA9IHN0YXRlLmxpbmU7XG5cbiAgLy8gUmVzdG9yZSBvcmlnaW5hbCB0U2hpZnQ7IHRoaXMgbWlnaHQgbm90IGJlIG5lY2Vzc2FyeSBzaW5jZSB0aGUgcGFyc2VyXG4gIC8vIGhhcyBhbHJlYWR5IGJlZW4gaGVyZSwgYnV0IGp1c3QgdG8gbWFrZSBzdXJlIHdlIGNhbiBkbyB0aGF0LlxuICBmb3IgKGkgPSAwOyBpIDwgb2xkVFNoaWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3RhdGUuYk1hcmtzW2kgKyBzdGFydExpbmVdID0gb2xkQk1hcmtzW2ldO1xuICAgIHN0YXRlLnRTaGlmdFtpICsgc3RhcnRMaW5lXSA9IG9sZFRTaGlmdFtpXTtcbiAgICBzdGF0ZS5zQ291bnRbaSArIHN0YXJ0TGluZV0gPSBvbGRTQ291bnRbaV07XG4gICAgc3RhdGUuYnNDb3VudFtpICsgc3RhcnRMaW5lXSA9IG9sZEJTQ291bnRbaV07XG4gIH1cbiAgc3RhdGUuYmxrSW5kZW50ID0gb2xkSW5kZW50O1xuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIENvZGUgYmxvY2sgKDQgc3BhY2VzIHBhZGRlZClcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29kZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLyosIHNpbGVudCovKSB7XG4gIHZhciBuZXh0TGluZSwgbGFzdCwgdG9rZW47XG5cbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50IDwgNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsYXN0ID0gbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIHdoaWxlIChuZXh0TGluZSA8IGVuZExpbmUpIHtcbiAgICBpZiAoc3RhdGUuaXNFbXB0eShuZXh0TGluZSkpIHtcbiAgICAgIG5leHRMaW5lKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICBuZXh0TGluZSsrO1xuICAgICAgbGFzdCA9IG5leHRMaW5lO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUubGluZSA9IGxhc3Q7XG5cbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2NvZGVfYmxvY2snLCAnY29kZScsIDApO1xuICB0b2tlbi5jb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBsYXN0LCA0ICsgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkgKyAnXFxuJztcbiAgdG9rZW4ubWFwICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gZmVuY2VzIChgYGAgbGFuZywgfn5+IGxhbmcpXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZlbmNlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgbWFya2VyLCBsZW4sIHBhcmFtcywgbmV4dExpbmUsIG1lbSwgdG9rZW4sIG1hcmt1cCxcbiAgICAgIGhhdmVFbmRNYXJrZXIgPSBmYWxzZSxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAocG9zICsgMyA+IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChtYXJrZXIgIT09IDB4N0UvKiB+ICovICYmIG1hcmtlciAhPT0gMHg2MCAvKiBgICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gc2NhbiBtYXJrZXIgbGVuZ3RoXG4gIG1lbSA9IHBvcztcbiAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcblxuICBsZW4gPSBwb3MgLSBtZW07XG5cbiAgaWYgKGxlbiA8IDMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbWFya3VwID0gc3RhdGUuc3JjLnNsaWNlKG1lbSwgcG9zKTtcbiAgcGFyYW1zID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KTtcblxuICBpZiAobWFya2VyID09PSAweDYwIC8qIGAgKi8pIHtcbiAgICBpZiAocGFyYW1zLmluZGV4T2YoU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpKSA+PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gU2luY2Ugc3RhcnQgaXMgZm91bmQsIHdlIGNhbiByZXBvcnQgc3VjY2VzcyBoZXJlIGluIHZhbGlkYXRpb24gbW9kZVxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gc2VhcmNoIGVuZCBvZiBibG9ja1xuICBuZXh0TGluZSA9IHN0YXJ0TGluZTtcblxuICBmb3IgKDs7KSB7XG4gICAgbmV4dExpbmUrKztcbiAgICBpZiAobmV4dExpbmUgPj0gZW5kTGluZSkge1xuICAgICAgLy8gdW5jbG9zZWQgYmxvY2sgc2hvdWxkIGJlIGF1dG9jbG9zZWQgYnkgZW5kIG9mIGRvY3VtZW50LlxuICAgICAgLy8gYWxzbyBibG9jayBzZWVtcyB0byBiZSBhdXRvY2xvc2VkIGJ5IGVuZCBvZiBwYXJlbnRcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHBvcyA9IG1lbSA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICAgIC8vIG5vbi1lbXB0eSBsaW5lIHdpdGggbmVnYXRpdmUgaW5kZW50IHNob3VsZCBzdG9wIHRoZSBsaXN0OlxuICAgICAgLy8gLSBgYGBcbiAgICAgIC8vICB0ZXN0XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gbWFya2VyKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICAvLyBjbG9zaW5nIGZlbmNlIHNob3VsZCBiZSBpbmRlbnRlZCBsZXNzIHRoYW4gNCBzcGFjZXNcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcik7XG5cbiAgICAvLyBjbG9zaW5nIGNvZGUgZmVuY2UgbXVzdCBiZSBhdCBsZWFzdCBhcyBsb25nIGFzIHRoZSBvcGVuaW5nIG9uZVxuICAgIGlmIChwb3MgLSBtZW0gPCBsZW4pIHsgY29udGludWU7IH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0YWlsIGhhcyBzcGFjZXMgb25seVxuICAgIHBvcyA9IHN0YXRlLnNraXBTcGFjZXMocG9zKTtcblxuICAgIGlmIChwb3MgPCBtYXgpIHsgY29udGludWU7IH1cblxuICAgIGhhdmVFbmRNYXJrZXIgPSB0cnVlO1xuICAgIC8vIGZvdW5kIVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gSWYgYSBmZW5jZSBoYXMgaGVhZGluZyBzcGFjZXMsIHRoZXkgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBpdHMgaW5uZXIgYmxvY2tcbiAgbGVuID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV07XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lICsgKGhhdmVFbmRNYXJrZXIgPyAxIDogMCk7XG5cbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2ZlbmNlJywgJ2NvZGUnLCAwKTtcbiAgdG9rZW4uaW5mbyAgICA9IHBhcmFtcztcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSArIDEsIG5leHRMaW5lLCBsZW4sIHRydWUpO1xuICB0b2tlbi5tYXJrdXAgID0gbWFya3VwO1xuICB0b2tlbi5tYXAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBoZWFkaW5nICgjLCAjIywgLi4uKVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhlYWRpbmcoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgbGV2ZWwsIHRtcCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgY2ggID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAoY2ggIT09IDB4MjMvKiAjICovIHx8IHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gY291bnQgaGVhZGluZyBsZXZlbFxuICBsZXZlbCA9IDE7XG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoKytwb3MpO1xuICB3aGlsZSAoY2ggPT09IDB4MjMvKiAjICovICYmIHBvcyA8IG1heCAmJiBsZXZlbCA8PSA2KSB7XG4gICAgbGV2ZWwrKztcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KCsrcG9zKTtcbiAgfVxuXG4gIGlmIChsZXZlbCA+IDYgfHwgKHBvcyA8IG1heCAmJiAhaXNTcGFjZShjaCkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBMZXQncyBjdXQgdGFpbHMgbGlrZSAnICAgICMjIyAgJyBmcm9tIHRoZSBlbmQgb2Ygc3RyaW5nXG5cbiAgbWF4ID0gc3RhdGUuc2tpcFNwYWNlc0JhY2sobWF4LCBwb3MpO1xuICB0bXAgPSBzdGF0ZS5za2lwQ2hhcnNCYWNrKG1heCwgMHgyMywgcG9zKTsgLy8gI1xuICBpZiAodG1wID4gcG9zICYmIGlzU3BhY2Uoc3RhdGUuc3JjLmNoYXJDb2RlQXQodG1wIC0gMSkpKSB7XG4gICAgbWF4ID0gdG1wO1xuICB9XG5cbiAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19vcGVuJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgMSk7XG4gIHRva2VuLm1hcmt1cCA9ICcjIyMjIyMjIycuc2xpY2UoMCwgbGV2ZWwpO1xuICB0b2tlbi5tYXAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ICA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCkudHJpbSgpO1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG4gIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19jbG9zZScsICdoJyArIFN0cmluZyhsZXZlbCksIC0xKTtcbiAgdG9rZW4ubWFya3VwID0gJyMjIyMjIyMjJy5zbGljZSgwLCBsZXZlbCk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gSG9yaXpvbnRhbCBydWxlXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHIoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBtYXJrZXIsIGNudCwgY2gsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICAvLyBDaGVjayBociBtYXJrZXJcbiAgaWYgKG1hcmtlciAhPT0gMHgyQS8qICogKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHg1Ri8qIF8gKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBtYXJrZXJzIGNhbiBiZSBtaXhlZCB3aXRoIHNwYWNlcywgYnV0IHRoZXJlIHNob3VsZCBiZSBhdCBsZWFzdCAzIG9mIHRoZW1cblxuICBjbnQgPSAxO1xuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgaWYgKGNoICE9PSBtYXJrZXIgJiYgIWlzU3BhY2UoY2gpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmIChjaCA9PT0gbWFya2VyKSB7IGNudCsrOyB9XG4gIH1cblxuICBpZiAoY250IDwgMykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnaHInLCAnaHInLCAwKTtcbiAgdG9rZW4ubWFwICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcbiAgdG9rZW4ubWFya3VwID0gQXJyYXkoY250ICsgMSkuam9pbihTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcikpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIEhUTUwgYmxvY2tcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBibG9ja19uYW1lcyA9IHJlcXVpcmUoJy4uL2NvbW1vbi9odG1sX2Jsb2NrcycpO1xudmFyIEhUTUxfT1BFTl9DTE9TRV9UQUdfUkUgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbF9yZScpLkhUTUxfT1BFTl9DTE9TRV9UQUdfUkU7XG5cbi8vIEFuIGFycmF5IG9mIG9wZW5pbmcgYW5kIGNvcnJlc3BvbmRpbmcgY2xvc2luZyBzZXF1ZW5jZXMgZm9yIGh0bWwgdGFncyxcbi8vIGxhc3QgYXJndW1lbnQgZGVmaW5lcyB3aGV0aGVyIGl0IGNhbiB0ZXJtaW5hdGUgYSBwYXJhZ3JhcGggb3Igbm90XG4vL1xudmFyIEhUTUxfU0VRVUVOQ0VTID0gW1xuICBbIC9ePChzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKSg/PShcXHN8PnwkKSkvaSwgLzxcXC8oc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSk+L2ksIHRydWUgXSxcbiAgWyAvXjwhLS0vLCAgICAgICAgLy0tPi8sICAgdHJ1ZSBdLFxuICBbIC9ePFxcPy8sICAgICAgICAgL1xcPz4vLCAgIHRydWUgXSxcbiAgWyAvXjwhW0EtWl0vLCAgICAgLz4vLCAgICAgdHJ1ZSBdLFxuICBbIC9ePCFcXFtDREFUQVxcWy8sIC9cXF1cXF0+LywgdHJ1ZSBdLFxuICBbIG5ldyBSZWdFeHAoJ148Lz8oJyArIGJsb2NrX25hbWVzLmpvaW4oJ3wnKSArICcpKD89KFxcXFxzfC8/PnwkKSknLCAnaScpLCAvXiQvLCB0cnVlIF0sXG4gIFsgbmV3IFJlZ0V4cChIVE1MX09QRU5fQ0xPU0VfVEFHX1JFLnNvdXJjZSArICdcXFxccyokJyksICAvXiQvLCBmYWxzZSBdXG5dO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHRtbF9ibG9jayhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGksIG5leHRMaW5lLCB0b2tlbiwgbGluZVRleHQsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmh0bWwpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxpbmVUZXh0ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KTtcblxuICBmb3IgKGkgPSAwOyBpIDwgSFRNTF9TRVFVRU5DRVMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoSFRNTF9TRVFVRU5DRVNbaV1bMF0udGVzdChsaW5lVGV4dCkpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIGlmIChpID09PSBIVE1MX1NFUVVFTkNFUy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkge1xuICAgIC8vIHRydWUgaWYgdGhpcyBzZXF1ZW5jZSBjYW4gYmUgYSB0ZXJtaW5hdG9yLCBmYWxzZSBvdGhlcndpc2VcbiAgICByZXR1cm4gSFRNTF9TRVFVRU5DRVNbaV1bMl07XG4gIH1cblxuICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgLy8gSWYgd2UgYXJlIGhlcmUgLSB3ZSBkZXRlY3RlZCBIVE1MIGJsb2NrLlxuICAvLyBMZXQncyByb2xsIGRvd24gdGlsbCBibG9jayBlbmQuXG4gIGlmICghSFRNTF9TRVFVRU5DRVNbaV1bMV0udGVzdChsaW5lVGV4dCkpIHtcbiAgICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lOyBuZXh0TGluZSsrKSB7XG4gICAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG4gICAgICBsaW5lVGV4dCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCk7XG5cbiAgICAgIGlmIChIVE1MX1NFUVVFTkNFU1tpXVsxXS50ZXN0KGxpbmVUZXh0KSkge1xuICAgICAgICBpZiAobGluZVRleHQubGVuZ3RoICE9PSAwKSB7IG5leHRMaW5lKys7IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuXG4gIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdodG1sX2Jsb2NrJywgJycsIDApO1xuICB0b2tlbi5tYXAgICAgID0gWyBzdGFydExpbmUsIG5leHRMaW5lIF07XG4gIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIHRydWUpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIGxoZWFkaW5nICgtLS0sID09PSlcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGhlYWRpbmcoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZS8qLCBzaWxlbnQqLykge1xuICB2YXIgY29udGVudCwgdGVybWluYXRlLCBpLCBsLCB0b2tlbiwgcG9zLCBtYXgsIGxldmVsLCBtYXJrZXIsXG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDEsIG9sZFBhcmVudFR5cGUsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygncGFyYWdyYXBoJyk7XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAncGFyYWdyYXBoJzsgLy8gdXNlIHBhcmFncmFwaCB0byBtYXRjaCB0ZXJtaW5hdG9yUnVsZXNcblxuICAvLyBqdW1wIGxpbmUtYnktbGluZSB1bnRpbCBlbXB0eSBvbmUgb3IgRU9GXG4gIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcbiAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBjb250aW51ZTsgfVxuXG4gICAgLy9cbiAgICAvLyBDaGVjayBmb3IgdW5kZXJsaW5lIGluIHNldGV4dCBoZWFkZXJcbiAgICAvL1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdID49IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgICBpZiAocG9zIDwgbWF4KSB7XG4gICAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgICAgaWYgKG1hcmtlciA9PT0gMHgyRC8qIC0gKi8gfHwgbWFya2VyID09PSAweDNELyogPSAqLykge1xuICAgICAgICAgIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcik7XG4gICAgICAgICAgcG9zID0gc3RhdGUuc2tpcFNwYWNlcyhwb3MpO1xuXG4gICAgICAgICAgaWYgKHBvcyA+PSBtYXgpIHtcbiAgICAgICAgICAgIGxldmVsID0gKG1hcmtlciA9PT0gMHgzRC8qID0gKi8gPyAxIDogMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBxdWlyayBmb3IgYmxvY2txdW90ZXMsIHRoaXMgbGluZSBzaG91bGQgYWxyZWFkeSBiZSBjaGVja2VkIGJ5IHRoYXQgcnVsZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgMCkgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gU29tZSB0YWdzIGNhbiB0ZXJtaW5hdGUgcGFyYWdyYXBoIHdpdGhvdXQgZW1wdHkgbGluZS5cbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG4gIH1cblxuICBpZiAoIWxldmVsKSB7XG4gICAgLy8gRGlkbid0IGZpbmQgdmFsaWQgdW5kZXJsaW5lXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmUgKyAxO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19vcGVuJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgMSk7XG4gIHRva2VuLm1hcmt1cCAgID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgID0gY29udGVudDtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSAtIDEgXTtcbiAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfY2xvc2UnLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAtMSk7XG4gIHRva2VuLm1hcmt1cCAgID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIExpc3RzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbi8vIFNlYXJjaCBgWy0rKl1bXFxuIF1gLCByZXR1cm5zIG5leHQgcG9zIGFmdGVyIG1hcmtlciBvbiBzdWNjZXNzXG4vLyBvciAtMSBvbiBmYWlsLlxuZnVuY3Rpb24gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkge1xuICB2YXIgbWFya2VyLCBwb3MsIG1heCwgY2g7XG5cbiAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuICAvLyBDaGVjayBidWxsZXRcbiAgaWYgKG1hcmtlciAhPT0gMHgyQS8qICogKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyQi8qICsgKi8pIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKCFpc1NwYWNlKGNoKSkge1xuICAgICAgLy8gXCIgLXRlc3QgXCIgLSBpcyBub3QgYSBsaXN0IGl0ZW1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcG9zO1xufVxuXG4vLyBTZWFyY2ggYFxcZCtbLildW1xcbiBdYCwgcmV0dXJucyBuZXh0IHBvcyBhZnRlciBtYXJrZXIgb24gc3VjY2Vzc1xuLy8gb3IgLTEgb24gZmFpbC5cbmZ1bmN0aW9uIHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSB7XG4gIHZhciBjaCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIHBvcyA9IHN0YXJ0LFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gTGlzdCBtYXJrZXIgc2hvdWxkIGhhdmUgYXQgbGVhc3QgMiBjaGFycyAoZGlnaXQgKyBkb3QpXG4gIGlmIChwb3MgKyAxID49IG1heCkgeyByZXR1cm4gLTE7IH1cblxuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICBpZiAoY2ggPCAweDMwLyogMCAqLyB8fCBjaCA+IDB4MzkvKiA5ICovKSB7IHJldHVybiAtMTsgfVxuXG4gIGZvciAoOzspIHtcbiAgICAvLyBFT0wgLT4gZmFpbFxuICAgIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiAtMTsgfVxuXG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG5cbiAgICBpZiAoY2ggPj0gMHgzMC8qIDAgKi8gJiYgY2ggPD0gMHgzOS8qIDkgKi8pIHtcblxuICAgICAgLy8gTGlzdCBtYXJrZXIgc2hvdWxkIGhhdmUgbm8gbW9yZSB0aGFuIDkgZGlnaXRzXG4gICAgICAvLyAocHJldmVudHMgaW50ZWdlciBvdmVyZmxvdyBpbiBicm93c2VycylcbiAgICAgIGlmIChwb3MgLSBzdGFydCA+PSAxMCkgeyByZXR1cm4gLTE7IH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZm91bmQgdmFsaWQgbWFya2VyXG4gICAgaWYgKGNoID09PSAweDI5LyogKSAqLyB8fCBjaCA9PT0gMHgyZS8qIC4gKi8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG5cbiAgaWYgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmICghaXNTcGFjZShjaCkpIHtcbiAgICAgIC8vIFwiIDEudGVzdCBcIiAtIGlzIG5vdCBhIGxpc3QgaXRlbVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcG9zO1xufVxuXG5mdW5jdGlvbiBtYXJrVGlnaHRQYXJhZ3JhcGhzKHN0YXRlLCBpZHgpIHtcbiAgdmFyIGksIGwsXG4gICAgICBsZXZlbCA9IHN0YXRlLmxldmVsICsgMjtcblxuICBmb3IgKGkgPSBpZHggKyAyLCBsID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDI7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoc3RhdGUudG9rZW5zW2ldLmxldmVsID09PSBsZXZlbCAmJiBzdGF0ZS50b2tlbnNbaV0udHlwZSA9PT0gJ3BhcmFncmFwaF9vcGVuJykge1xuICAgICAgc3RhdGUudG9rZW5zW2kgKyAyXS5oaWRkZW4gPSB0cnVlO1xuICAgICAgc3RhdGUudG9rZW5zW2ldLmhpZGRlbiA9IHRydWU7XG4gICAgICBpICs9IDI7XG4gICAgfVxuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaXN0KHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsXG4gICAgICBjb250ZW50U3RhcnQsXG4gICAgICBpLFxuICAgICAgaW5kZW50LFxuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIsXG4gICAgICBpbml0aWFsLFxuICAgICAgaXNPcmRlcmVkLFxuICAgICAgaXRlbUxpbmVzLFxuICAgICAgbCxcbiAgICAgIGxpc3RMaW5lcyxcbiAgICAgIGxpc3RUb2tJZHgsXG4gICAgICBtYXJrZXJDaGFyQ29kZSxcbiAgICAgIG1hcmtlclZhbHVlLFxuICAgICAgbWF4LFxuICAgICAgbmV4dExpbmUsXG4gICAgICBvZmZzZXQsXG4gICAgICBvbGRMaXN0SW5kZW50LFxuICAgICAgb2xkUGFyZW50VHlwZSxcbiAgICAgIG9sZFNDb3VudCxcbiAgICAgIG9sZFRTaGlmdCxcbiAgICAgIG9sZFRpZ2h0LFxuICAgICAgcG9zLFxuICAgICAgcG9zQWZ0ZXJNYXJrZXIsXG4gICAgICBwcmV2RW1wdHlFbmQsXG4gICAgICBzdGFydCxcbiAgICAgIHRlcm1pbmF0ZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyxcbiAgICAgIHRva2VuLFxuICAgICAgaXNUZXJtaW5hdGluZ1BhcmFncmFwaCA9IGZhbHNlLFxuICAgICAgdGlnaHQgPSB0cnVlO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFNwZWNpYWwgY2FzZTpcbiAgLy8gIC0gaXRlbSAxXG4gIC8vICAgLSBpdGVtIDJcbiAgLy8gICAgLSBpdGVtIDNcbiAgLy8gICAgIC0gaXRlbSA0XG4gIC8vICAgICAgLSB0aGlzIG9uZSBpcyBhIHBhcmFncmFwaCBjb250aW51YXRpb25cbiAgaWYgKHN0YXRlLmxpc3RJbmRlbnQgPj0gMCAmJlxuICAgICAgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5saXN0SW5kZW50ID49IDQgJiZcbiAgICAgIHN0YXRlLnNDb3VudFtzdGFydExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gbGltaXQgY29uZGl0aW9ucyB3aGVuIGxpc3QgY2FuIGludGVycnVwdFxuICAvLyBhIHBhcmFncmFwaCAodmFsaWRhdGlvbiBtb2RlIG9ubHkpXG4gIGlmIChzaWxlbnQgJiYgc3RhdGUucGFyZW50VHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAvLyBOZXh0IGxpc3QgaXRlbSBzaG91bGQgc3RpbGwgdGVybWluYXRlIHByZXZpb3VzIGxpc3QgaXRlbTtcbiAgICAvL1xuICAgIC8vIFRoaXMgY29kZSBjYW4gZmFpbCBpZiBwbHVnaW5zIHVzZSBibGtJbmRlbnQgYXMgd2VsbCBhcyBsaXN0cyxcbiAgICAvLyBidXQgSSBob3BlIHRoZSBzcGVjIGdldHMgZml4ZWQgbG9uZyBiZWZvcmUgdGhhdCBoYXBwZW5zLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdID49IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgaXNUZXJtaW5hdGluZ1BhcmFncmFwaCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gRGV0ZWN0IGxpc3QgdHlwZSBhbmQgcG9zaXRpb24gYWZ0ZXIgbWFya2VyXG4gIGlmICgocG9zQWZ0ZXJNYXJrZXIgPSBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkpID49IDApIHtcbiAgICBpc09yZGVyZWQgPSB0cnVlO1xuICAgIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgICBtYXJrZXJWYWx1ZSA9IE51bWJlcihzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvc0FmdGVyTWFya2VyIC0gMSkpO1xuXG4gICAgLy8gSWYgd2UncmUgc3RhcnRpbmcgYSBuZXcgb3JkZXJlZCBsaXN0IHJpZ2h0IGFmdGVyXG4gICAgLy8gYSBwYXJhZ3JhcGgsIGl0IHNob3VsZCBzdGFydCB3aXRoIDEuXG4gICAgaWYgKGlzVGVybWluYXRpbmdQYXJhZ3JhcGggJiYgbWFya2VyVmFsdWUgIT09IDEpIHJldHVybiBmYWxzZTtcblxuICB9IGVsc2UgaWYgKChwb3NBZnRlck1hcmtlciA9IHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpKSA+PSAwKSB7XG4gICAgaXNPcmRlcmVkID0gZmFsc2U7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBzdGFydGluZyBhIG5ldyB1bm9yZGVyZWQgbGlzdCByaWdodCBhZnRlclxuICAvLyBhIHBhcmFncmFwaCwgZmlyc3QgbGluZSBzaG91bGQgbm90IGJlIGVtcHR5LlxuICBpZiAoaXNUZXJtaW5hdGluZ1BhcmFncmFwaCkge1xuICAgIGlmIChzdGF0ZS5za2lwU3BhY2VzKHBvc0FmdGVyTWFya2VyKSA+PSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gV2Ugc2hvdWxkIHRlcm1pbmF0ZSBsaXN0IG9uIHN0eWxlIGNoYW5nZS4gUmVtZW1iZXIgZmlyc3Qgb25lIHRvIGNvbXBhcmUuXG4gIG1hcmtlckNoYXJDb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zQWZ0ZXJNYXJrZXIgLSAxKTtcblxuICAvLyBGb3IgdmFsaWRhdGlvbiBtb2RlIHdlIGNhbiB0ZXJtaW5hdGUgaW1tZWRpYXRlbHlcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIFN0YXJ0IGxpc3RcbiAgbGlzdFRva0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGg7XG5cbiAgaWYgKGlzT3JkZXJlZCkge1xuICAgIHRva2VuICAgICAgID0gc3RhdGUucHVzaCgnb3JkZXJlZF9saXN0X29wZW4nLCAnb2wnLCAxKTtcbiAgICBpZiAobWFya2VyVmFsdWUgIT09IDEpIHtcbiAgICAgIHRva2VuLmF0dHJzID0gWyBbICdzdGFydCcsIG1hcmtlclZhbHVlIF0gXTtcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICB0b2tlbiAgICAgICA9IHN0YXRlLnB1c2goJ2J1bGxldF9saXN0X29wZW4nLCAndWwnLCAxKTtcbiAgfVxuXG4gIHRva2VuLm1hcCAgICA9IGxpc3RMaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG4gIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuXG4gIC8vXG4gIC8vIEl0ZXJhdGUgbGlzdCBpdGVtc1xuICAvL1xuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lO1xuICBwcmV2RW1wdHlFbmQgPSBmYWxzZTtcbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ2xpc3QnKTtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdsaXN0JztcblxuICB3aGlsZSAobmV4dExpbmUgPCBlbmRMaW5lKSB7XG4gICAgcG9zID0gcG9zQWZ0ZXJNYXJrZXI7XG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgcG9zQWZ0ZXJNYXJrZXIgLSAoc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSk7XG5cbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSkgJSA0O1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMCkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICB9XG5cbiAgICBjb250ZW50U3RhcnQgPSBwb3M7XG5cbiAgICBpZiAoY29udGVudFN0YXJ0ID49IG1heCkge1xuICAgICAgLy8gdHJpbW1pbmcgc3BhY2UgaW4gXCItICAgIFxcbiAgM1wiIGNhc2UsIGluZGVudCBpcyAxIGhlcmVcbiAgICAgIGluZGVudEFmdGVyTWFya2VyID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIgPSBvZmZzZXQgLSBpbml0aWFsO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIDQgc3BhY2VzLCB0aGUgaW5kZW50IGlzIDFcbiAgICAvLyAodGhlIHJlc3QgaXMganVzdCBpbmRlbnRlZCBjb2RlIGJsb2NrKVxuICAgIGlmIChpbmRlbnRBZnRlck1hcmtlciA+IDQpIHsgaW5kZW50QWZ0ZXJNYXJrZXIgPSAxOyB9XG5cbiAgICAvLyBcIiAgLSAgdGVzdFwiXG4gICAgLy8gIF5eXl5eIC0gY2FsY3VsYXRpbmcgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdGhpbmdcbiAgICBpbmRlbnQgPSBpbml0aWFsICsgaW5kZW50QWZ0ZXJNYXJrZXI7XG5cbiAgICAvLyBSdW4gc3VicGFyc2VyICYgd3JpdGUgdG9rZW5zXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlzdF9pdGVtX29wZW4nLCAnbGknLCAxKTtcbiAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcbiAgICB0b2tlbi5tYXAgICAgPSBpdGVtTGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuICAgIGlmIChpc09yZGVyZWQpIHtcbiAgICAgIHRva2VuLmluZm8gPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvc0FmdGVyTWFya2VyIC0gMSk7XG4gICAgfVxuXG4gICAgLy8gY2hhbmdlIGN1cnJlbnQgc3RhdGUsIHRoZW4gcmVzdG9yZSBpdCBhZnRlciBwYXJzZXIgc3ViY2FsbFxuICAgIG9sZFRpZ2h0ID0gc3RhdGUudGlnaHQ7XG4gICAgb2xkVFNoaWZ0ID0gc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gICAgb2xkU0NvdW50ID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV07XG5cbiAgICAvLyAgLSBleGFtcGxlIGxpc3RcbiAgICAvLyBeIGxpc3RJbmRlbnQgcG9zaXRpb24gd2lsbCBiZSBoZXJlXG4gICAgLy8gICBeIGJsa0luZGVudCBwb3NpdGlvbiB3aWxsIGJlIGhlcmVcbiAgICAvL1xuICAgIG9sZExpc3RJbmRlbnQgPSBzdGF0ZS5saXN0SW5kZW50O1xuICAgIHN0YXRlLmxpc3RJbmRlbnQgPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gICAgc3RhdGUuYmxrSW5kZW50ID0gaW5kZW50O1xuXG4gICAgc3RhdGUudGlnaHQgPSB0cnVlO1xuICAgIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gY29udGVudFN0YXJ0IC0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG4gICAgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gPSBvZmZzZXQ7XG5cbiAgICBpZiAoY29udGVudFN0YXJ0ID49IG1heCAmJiBzdGF0ZS5pc0VtcHR5KHN0YXJ0TGluZSArIDEpKSB7XG4gICAgICAvLyB3b3JrYXJvdW5kIGZvciB0aGlzIGNhc2VcbiAgICAgIC8vIChsaXN0IGl0ZW0gaXMgZW1wdHksIGxpc3QgdGVybWluYXRlcyBiZWZvcmUgXCJmb29cIik6XG4gICAgICAvLyB+fn5+fn5+flxuICAgICAgLy8gICAtXG4gICAgICAvL1xuICAgICAgLy8gICAgIGZvb1xuICAgICAgLy8gfn5+fn5+fn5cbiAgICAgIHN0YXRlLmxpbmUgPSBNYXRoLm1pbihzdGF0ZS5saW5lICsgMiwgZW5kTGluZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLm1kLmJsb2NrLnRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIElmIGFueSBvZiBsaXN0IGl0ZW0gaXMgdGlnaHQsIG1hcmsgbGlzdCBhcyB0aWdodFxuICAgIGlmICghc3RhdGUudGlnaHQgfHwgcHJldkVtcHR5RW5kKSB7XG4gICAgICB0aWdodCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBJdGVtIGJlY29tZSBsb29zZSBpZiBmaW5pc2ggd2l0aCBlbXB0eSBsaW5lLFxuICAgIC8vIGJ1dCB3ZSBzaG91bGQgZmlsdGVyIGxhc3QgZWxlbWVudCwgYmVjYXVzZSBpdCBtZWFucyBsaXN0IGZpbmlzaFxuICAgIHByZXZFbXB0eUVuZCA9IChzdGF0ZS5saW5lIC0gc3RhcnRMaW5lKSA+IDEgJiYgc3RhdGUuaXNFbXB0eShzdGF0ZS5saW5lIC0gMSk7XG5cbiAgICBzdGF0ZS5ibGtJbmRlbnQgPSBzdGF0ZS5saXN0SW5kZW50O1xuICAgIHN0YXRlLmxpc3RJbmRlbnQgPSBvbGRMaXN0SW5kZW50O1xuICAgIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gb2xkVFNoaWZ0O1xuICAgIHN0YXRlLnNDb3VudFtzdGFydExpbmVdID0gb2xkU0NvdW50O1xuICAgIHN0YXRlLnRpZ2h0ID0gb2xkVGlnaHQ7XG5cbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaXN0X2l0ZW1fY2xvc2UnLCAnbGknLCAtMSk7XG4gICAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG5cbiAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSA9IHN0YXRlLmxpbmU7XG4gICAgaXRlbUxpbmVzWzFdID0gbmV4dExpbmU7XG4gICAgY29udGVudFN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG5cbiAgICBpZiAobmV4dExpbmUgPj0gZW5kTGluZSkgeyBicmVhazsgfVxuXG4gICAgLy9cbiAgICAvLyBUcnkgdG8gY2hlY2sgaWYgbGlzdCBpcyB0ZXJtaW5hdGVkIG9yIGNvbnRpbnVlZC5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICAgIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBmYWlsIGlmIHRlcm1pbmF0aW5nIGJsb2NrIGZvdW5kXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuXG4gICAgLy8gZmFpbCBpZiBsaXN0IGhhcyBhbm90aGVyIHR5cGVcbiAgICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgICBwb3NBZnRlck1hcmtlciA9IHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgbmV4dExpbmUpO1xuICAgICAgaWYgKHBvc0FmdGVyTWFya2VyIDwgMCkgeyBicmVhazsgfVxuICAgICAgc3RhcnQgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zQWZ0ZXJNYXJrZXIgPSBza2lwQnVsbGV0TGlzdE1hcmtlcihzdGF0ZSwgbmV4dExpbmUpO1xuICAgICAgaWYgKHBvc0FmdGVyTWFya2VyIDwgMCkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIGlmIChtYXJrZXJDaGFyQ29kZSAhPT0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zQWZ0ZXJNYXJrZXIgLSAxKSkgeyBicmVhazsgfVxuICB9XG5cbiAgLy8gRmluYWxpemUgbGlzdFxuICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCdvcmRlcmVkX2xpc3RfY2xvc2UnLCAnb2wnLCAtMSk7XG4gIH0gZWxzZSB7XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCdidWxsZXRfbGlzdF9jbG9zZScsICd1bCcsIC0xKTtcbiAgfVxuICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcblxuICBsaXN0TGluZXNbMV0gPSBuZXh0TGluZTtcbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gIC8vIG1hcmsgcGFyYWdyYXBocyB0aWdodCBpZiBuZWVkZWRcbiAgaWYgKHRpZ2h0KSB7XG4gICAgbWFya1RpZ2h0UGFyYWdyYXBocyhzdGF0ZSwgbGlzdFRva0lkeCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBQYXJhZ3JhcGhcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyYWdyYXBoKHN0YXRlLCBzdGFydExpbmUvKiwgZW5kTGluZSovKSB7XG4gIHZhciBjb250ZW50LCB0ZXJtaW5hdGUsIGksIGwsIHRva2VuLCBvbGRQYXJlbnRUeXBlLFxuICAgICAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxLFxuICAgICAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ3BhcmFncmFwaCcpLFxuICAgICAgZW5kTGluZSA9IHN0YXRlLmxpbmVNYXg7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAncGFyYWdyYXBoJztcblxuICAvLyBqdW1wIGxpbmUtYnktbGluZSB1bnRpbCBlbXB0eSBvbmUgb3IgRU9GXG4gIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcbiAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gcXVpcmsgZm9yIGJsb2NrcXVvdGVzLCB0aGlzIGxpbmUgc2hvdWxkIGFscmVhZHkgYmUgY2hlY2tlZCBieSB0aGF0IHJ1bGVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IDApIHsgY29udGludWU7IH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gdGVybWluYXRlIHBhcmFncmFwaCB3aXRob3V0IGVtcHR5IGxpbmUuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuICB9XG5cbiAgY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdwYXJhZ3JhcGhfb3BlbicsICdwJywgMSk7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCAgPSBjb250ZW50O1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG4gIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdwYXJhZ3JhcGhfY2xvc2UnLCAncCcsIC0xKTtcblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xudmFyIGlzU3BhY2UgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlZmVyZW5jZShzdGF0ZSwgc3RhcnRMaW5lLCBfZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGRlc3RFbmRQb3MsXG4gICAgICBkZXN0RW5kTGluZU5vLFxuICAgICAgZW5kTGluZSxcbiAgICAgIGhyZWYsXG4gICAgICBpLFxuICAgICAgbCxcbiAgICAgIGxhYmVsLFxuICAgICAgbGFiZWxFbmQsXG4gICAgICBvbGRQYXJlbnRUeXBlLFxuICAgICAgcmVzLFxuICAgICAgc3RhcnQsXG4gICAgICBzdHIsXG4gICAgICB0ZXJtaW5hdGUsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMsXG4gICAgICB0aXRsZSxcbiAgICAgIGxpbmVzID0gMCxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXSxcbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gU2ltcGxlIGNoZWNrIHRvIHF1aWNrbHkgaW50ZXJydXB0IHNjYW4gb24gW2xpbmtdKHVybCkgYXQgdGhlIHN0YXJ0IG9mIGxpbmUuXG4gIC8vIENhbiBiZSB1c2VmdWwgb24gcHJhY3RpY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9pc3N1ZXMvNTRcbiAgd2hpbGUgKCsrcG9zIDwgbWF4KSB7XG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUQgLyogXSAqLyAmJlxuICAgICAgICBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgLSAxKSAhPT0gMHg1Qy8qIFxcICovKSB7XG4gICAgICBpZiAocG9zICsgMSA9PT0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpICE9PSAweDNBLyogOiAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGVuZExpbmUgPSBzdGF0ZS5saW5lTWF4O1xuXG4gIC8vIGp1bXAgbGluZS1ieS1saW5lIHVudGlsIGVtcHR5IG9uZSBvciBFT0ZcbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ3JlZmVyZW5jZScpO1xuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ3JlZmVyZW5jZSc7XG5cbiAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSk7IG5leHRMaW5lKyspIHtcbiAgICAvLyB0aGlzIHdvdWxkIGJlIGEgY29kZSBibG9jayBub3JtYWxseSwgYnV0IGFmdGVyIHBhcmFncmFwaFxuICAgIC8vIGl0J3MgY29uc2lkZXJlZCBhIGxhenkgY29udGludWF0aW9uIHJlZ2FyZGxlc3Mgb2Ygd2hhdCdzIHRoZXJlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBxdWlyayBmb3IgYmxvY2txdW90ZXMsIHRoaXMgbGluZSBzaG91bGQgYWxyZWFkeSBiZSBjaGVja2VkIGJ5IHRoYXQgcnVsZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgMCkgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gU29tZSB0YWdzIGNhbiB0ZXJtaW5hdGUgcGFyYWdyYXBoIHdpdGhvdXQgZW1wdHkgbGluZS5cbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG4gIH1cblxuICBzdHIgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIGZhbHNlKS50cmltKCk7XG4gIG1heCA9IHN0ci5sZW5ndGg7XG5cbiAgZm9yIChwb3MgPSAxOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjaCA9PT0gMHg1QiAvKiBbICovKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg1RCAvKiBdICovKSB7XG4gICAgICBsYWJlbEVuZCA9IHBvcztcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MEEgLyogXFxuICovKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUMgLyogXFwgKi8pIHtcbiAgICAgIHBvcysrO1xuICAgICAgaWYgKHBvcyA8IG1heCAmJiBzdHIuY2hhckNvZGVBdChwb3MpID09PSAweDBBKSB7XG4gICAgICAgIGxpbmVzKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGxhYmVsRW5kIDwgMCB8fCBzdHIuY2hhckNvZGVBdChsYWJlbEVuZCArIDEpICE9PSAweDNBLyogOiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgIF5eXiBza2lwIG9wdGlvbmFsIHdoaXRlc3BhY2UgaGVyZVxuICBmb3IgKHBvcyA9IGxhYmVsRW5kICsgMjsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY2ggPT09IDB4MEEpIHtcbiAgICAgIGxpbmVzKys7XG4gICAgfSBlbHNlIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgLyplc2xpbnQgbm8tZW1wdHk6MCovXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgICAgXl5eXl5eXl5eXl4gcGFyc2UgdGhpc1xuICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0ciwgcG9zLCBtYXgpO1xuICBpZiAoIXJlcy5vaykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBocmVmID0gc3RhdGUubWQubm9ybWFsaXplTGluayhyZXMuc3RyKTtcbiAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoaHJlZikpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gcmVzLnBvcztcbiAgbGluZXMgKz0gcmVzLmxpbmVzO1xuXG4gIC8vIHNhdmUgY3Vyc29yIHN0YXRlLCB3ZSBjb3VsZCByZXF1aXJlIHRvIHJvbGxiYWNrIGxhdGVyXG4gIGRlc3RFbmRQb3MgPSBwb3M7XG4gIGRlc3RFbmRMaW5lTm8gPSBsaW5lcztcblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgICAgICAgICAgICAgICAgXl5eIHNraXBwaW5nIHRob3NlIHNwYWNlc1xuICBzdGFydCA9IHBvcztcbiAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNoID09PSAweDBBKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgIC8qZXNsaW50IG5vLWVtcHR5OjAqL1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXiBwYXJzZSB0aGlzXG4gIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RyLCBwb3MsIG1heCk7XG4gIGlmIChwb3MgPCBtYXggJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcbiAgICB0aXRsZSA9IHJlcy5zdHI7XG4gICAgcG9zID0gcmVzLnBvcztcbiAgICBsaW5lcyArPSByZXMubGluZXM7XG4gIH0gZWxzZSB7XG4gICAgdGl0bGUgPSAnJztcbiAgICBwb3MgPSBkZXN0RW5kUG9zO1xuICAgIGxpbmVzID0gZGVzdEVuZExpbmVObztcbiAgfVxuXG4gIC8vIHNraXAgdHJhaWxpbmcgc3BhY2VzIHVudGlsIHRoZSByZXN0IG9mIHRoZSBsaW5lXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHBvcyA8IG1heCAmJiBzdHIuY2hhckNvZGVBdChwb3MpICE9PSAweDBBKSB7XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICAvLyBnYXJiYWdlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUgYWZ0ZXIgdGl0bGUsXG4gICAgICAvLyBidXQgaXQgY291bGQgc3RpbGwgYmUgYSB2YWxpZCByZWZlcmVuY2UgaWYgd2Ugcm9sbCBiYWNrXG4gICAgICB0aXRsZSA9ICcnO1xuICAgICAgcG9zID0gZGVzdEVuZFBvcztcbiAgICAgIGxpbmVzID0gZGVzdEVuZExpbmVObztcbiAgICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChwb3MgPCBtYXggJiYgc3RyLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgwQSkge1xuICAgIC8vIGdhcmJhZ2UgYXQgdGhlIGVuZCBvZiB0aGUgbGluZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGxhYmVsID0gbm9ybWFsaXplUmVmZXJlbmNlKHN0ci5zbGljZSgxLCBsYWJlbEVuZCkpO1xuICBpZiAoIWxhYmVsKSB7XG4gICAgLy8gQ29tbW9uTWFyayAwLjIwIGRpc2FsbG93cyBlbXB0eSBsYWJlbHNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBSZWZlcmVuY2UgY2FuIG5vdCB0ZXJtaW5hdGUgYW55dGhpbmcuIFRoaXMgY2hlY2sgaXMgZm9yIHNhZmV0eSBvbmx5LlxuICAvKmlzdGFuYnVsIGlnbm9yZSBpZiovXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzID09PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXRlLmVudi5yZWZlcmVuY2VzID0ge307XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlc1tsYWJlbF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhdGUuZW52LnJlZmVyZW5jZXNbbGFiZWxdID0geyB0aXRsZTogdGl0bGUsIGhyZWY6IGhyZWYgfTtcbiAgfVxuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyBsaW5lcyArIDE7XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIFBhcnNlciBzdGF0ZSBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4uL3Rva2VuJyk7XG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxuZnVuY3Rpb24gU3RhdGVCbG9jayhzcmMsIG1kLCBlbnYsIHRva2Vucykge1xuICB2YXIgY2gsIHMsIHN0YXJ0LCBwb3MsIGxlbiwgaW5kZW50LCBvZmZzZXQsIGluZGVudF9mb3VuZDtcblxuICB0aGlzLnNyYyA9IHNyYztcblxuICAvLyBsaW5rIHRvIHBhcnNlciBpbnN0YW5jZVxuICB0aGlzLm1kICAgICA9IG1kO1xuXG4gIHRoaXMuZW52ID0gZW52O1xuXG4gIC8vXG4gIC8vIEludGVybmFsIHN0YXRlIHZhcnRpYWJsZXNcbiAgLy9cblxuICB0aGlzLnRva2VucyA9IHRva2VucztcblxuICB0aGlzLmJNYXJrcyA9IFtdOyAgLy8gbGluZSBiZWdpbiBvZmZzZXRzIGZvciBmYXN0IGp1bXBzXG4gIHRoaXMuZU1hcmtzID0gW107ICAvLyBsaW5lIGVuZCBvZmZzZXRzIGZvciBmYXN0IGp1bXBzXG4gIHRoaXMudFNoaWZ0ID0gW107ICAvLyBvZmZzZXRzIG9mIHRoZSBmaXJzdCBub24tc3BhY2UgY2hhcmFjdGVycyAodGFicyBub3QgZXhwYW5kZWQpXG4gIHRoaXMuc0NvdW50ID0gW107ICAvLyBpbmRlbnRzIGZvciBlYWNoIGxpbmUgKHRhYnMgZXhwYW5kZWQpXG5cbiAgLy8gQW4gYW1vdW50IG9mIHZpcnR1YWwgc3BhY2VzICh0YWJzIGV4cGFuZGVkKSBiZXR3ZWVuIGJlZ2lubmluZ1xuICAvLyBvZiBlYWNoIGxpbmUgKGJNYXJrcykgYW5kIHJlYWwgYmVnaW5uaW5nIG9mIHRoYXQgbGluZS5cbiAgLy9cbiAgLy8gSXQgZXhpc3RzIG9ubHkgYXMgYSBoYWNrIGJlY2F1c2UgYmxvY2txdW90ZXMgb3ZlcnJpZGUgYk1hcmtzXG4gIC8vIGxvc2luZyBpbmZvcm1hdGlvbiBpbiB0aGUgcHJvY2Vzcy5cbiAgLy9cbiAgLy8gSXQncyB1c2VkIG9ubHkgd2hlbiBleHBhbmRpbmcgdGFicywgeW91IGNhbiB0aGluayBhYm91dCBpdCBhc1xuICAvLyBhbiBpbml0aWFsIHRhYiBsZW5ndGgsIGUuZy4gYnNDb3VudD0yMSBhcHBsaWVkIHRvIHN0cmluZyBgXFx0MTIzYFxuICAvLyBtZWFucyBmaXJzdCB0YWIgc2hvdWxkIGJlIGV4cGFuZGVkIHRvIDQtMjElNCA9PT0gMyBzcGFjZXMuXG4gIC8vXG4gIHRoaXMuYnNDb3VudCA9IFtdO1xuXG4gIC8vIGJsb2NrIHBhcnNlciB2YXJpYWJsZXNcbiAgdGhpcy5ibGtJbmRlbnQgID0gMDsgLy8gcmVxdWlyZWQgYmxvY2sgY29udGVudCBpbmRlbnQgKGZvciBleGFtcGxlLCBpZiB3ZSBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zaWRlIGEgbGlzdCwgaXQgd291bGQgYmUgcG9zaXRpb25lZCBhZnRlciBsaXN0IG1hcmtlcilcbiAgdGhpcy5saW5lICAgICAgID0gMDsgLy8gbGluZSBpbmRleCBpbiBzcmNcbiAgdGhpcy5saW5lTWF4ICAgID0gMDsgLy8gbGluZXMgY291bnRcbiAgdGhpcy50aWdodCAgICAgID0gZmFsc2U7ICAvLyBsb29zZS90aWdodCBtb2RlIGZvciBsaXN0c1xuICB0aGlzLmRkSW5kZW50ICAgPSAtMTsgLy8gaW5kZW50IG9mIHRoZSBjdXJyZW50IGRkIGJsb2NrICgtMSBpZiB0aGVyZSBpc24ndCBhbnkpXG4gIHRoaXMubGlzdEluZGVudCA9IC0xOyAvLyBpbmRlbnQgb2YgdGhlIGN1cnJlbnQgbGlzdCBibG9jayAoLTEgaWYgdGhlcmUgaXNuJ3QgYW55KVxuXG4gIC8vIGNhbiBiZSAnYmxvY2txdW90ZScsICdsaXN0JywgJ3Jvb3QnLCAncGFyYWdyYXBoJyBvciAncmVmZXJlbmNlJ1xuICAvLyB1c2VkIGluIGxpc3RzIHRvIGRldGVybWluZSBpZiB0aGV5IGludGVycnVwdCBhIHBhcmFncmFwaFxuICB0aGlzLnBhcmVudFR5cGUgPSAncm9vdCc7XG5cbiAgdGhpcy5sZXZlbCA9IDA7XG5cbiAgLy8gcmVuZGVyZXJcbiAgdGhpcy5yZXN1bHQgPSAnJztcblxuICAvLyBDcmVhdGUgY2FjaGVzXG4gIC8vIEdlbmVyYXRlIG1hcmtlcnMuXG4gIHMgPSB0aGlzLnNyYztcbiAgaW5kZW50X2ZvdW5kID0gZmFsc2U7XG5cbiAgZm9yIChzdGFydCA9IHBvcyA9IGluZGVudCA9IG9mZnNldCA9IDAsIGxlbiA9IHMubGVuZ3RoOyBwb3MgPCBsZW47IHBvcysrKSB7XG4gICAgY2ggPSBzLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmICghaW5kZW50X2ZvdW5kKSB7XG4gICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgaW5kZW50Kys7XG5cbiAgICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IDQgLSBvZmZzZXQgJSA0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZW50X2ZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IDB4MEEgfHwgcG9zID09PSBsZW4gLSAxKSB7XG4gICAgICBpZiAoY2ggIT09IDB4MEEpIHsgcG9zKys7IH1cbiAgICAgIHRoaXMuYk1hcmtzLnB1c2goc3RhcnQpO1xuICAgICAgdGhpcy5lTWFya3MucHVzaChwb3MpO1xuICAgICAgdGhpcy50U2hpZnQucHVzaChpbmRlbnQpO1xuICAgICAgdGhpcy5zQ291bnQucHVzaChvZmZzZXQpO1xuICAgICAgdGhpcy5ic0NvdW50LnB1c2goMCk7XG5cbiAgICAgIGluZGVudF9mb3VuZCA9IGZhbHNlO1xuICAgICAgaW5kZW50ID0gMDtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgfVxuICB9XG5cbiAgLy8gUHVzaCBmYWtlIGVudHJ5IHRvIHNpbXBsaWZ5IGNhY2hlIGJvdW5kcyBjaGVja3NcbiAgdGhpcy5iTWFya3MucHVzaChzLmxlbmd0aCk7XG4gIHRoaXMuZU1hcmtzLnB1c2gocy5sZW5ndGgpO1xuICB0aGlzLnRTaGlmdC5wdXNoKDApO1xuICB0aGlzLnNDb3VudC5wdXNoKDApO1xuICB0aGlzLmJzQ291bnQucHVzaCgwKTtcblxuICB0aGlzLmxpbmVNYXggPSB0aGlzLmJNYXJrcy5sZW5ndGggLSAxOyAvLyBkb24ndCBjb3VudCBsYXN0IGZha2UgbGluZVxufVxuXG4vLyBQdXNoIG5ldyB0b2tlbiB0byBcInN0cmVhbVwiLlxuLy9cblN0YXRlQmxvY2sucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodHlwZSwgdGFnLCBuZXN0aW5nKSB7XG4gIHZhciB0b2tlbiA9IG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpO1xuICB0b2tlbi5ibG9jayA9IHRydWU7XG5cbiAgaWYgKG5lc3RpbmcgPCAwKSB0aGlzLmxldmVsLS07IC8vIGNsb3NpbmcgdGFnXG4gIHRva2VuLmxldmVsID0gdGhpcy5sZXZlbDtcbiAgaWYgKG5lc3RpbmcgPiAwKSB0aGlzLmxldmVsKys7IC8vIG9wZW5pbmcgdGFnXG5cbiAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblN0YXRlQmxvY2sucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KGxpbmUpIHtcbiAgcmV0dXJuIHRoaXMuYk1hcmtzW2xpbmVdICsgdGhpcy50U2hpZnRbbGluZV0gPj0gdGhpcy5lTWFya3NbbGluZV07XG59O1xuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwRW1wdHlMaW5lcyA9IGZ1bmN0aW9uIHNraXBFbXB0eUxpbmVzKGZyb20pIHtcbiAgZm9yICh2YXIgbWF4ID0gdGhpcy5saW5lTWF4OyBmcm9tIDwgbWF4OyBmcm9tKyspIHtcbiAgICBpZiAodGhpcy5iTWFya3NbZnJvbV0gKyB0aGlzLnRTaGlmdFtmcm9tXSA8IHRoaXMuZU1hcmtzW2Zyb21dKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZyb207XG59O1xuXG4vLyBTa2lwIHNwYWNlcyBmcm9tIGdpdmVuIHBvc2l0aW9uLlxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcFNwYWNlcyA9IGZ1bmN0aW9uIHNraXBTcGFjZXMocG9zKSB7XG4gIHZhciBjaDtcblxuICBmb3IgKHZhciBtYXggPSB0aGlzLnNyYy5sZW5ndGg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgc3BhY2VzIGZyb20gZ2l2ZW4gcG9zaXRpb24gaW4gcmV2ZXJzZS5cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBTcGFjZXNCYWNrID0gZnVuY3Rpb24gc2tpcFNwYWNlc0JhY2socG9zLCBtaW4pIHtcbiAgaWYgKHBvcyA8PSBtaW4pIHsgcmV0dXJuIHBvczsgfVxuXG4gIHdoaWxlIChwb3MgPiBtaW4pIHtcbiAgICBpZiAoIWlzU3BhY2UodGhpcy5zcmMuY2hhckNvZGVBdCgtLXBvcykpKSB7IHJldHVybiBwb3MgKyAxOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgY2hhciBjb2RlcyBmcm9tIGdpdmVuIHBvc2l0aW9uXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwQ2hhcnMgPSBmdW5jdGlvbiBza2lwQ2hhcnMocG9zLCBjb2RlKSB7XG4gIGZvciAodmFyIG1heCA9IHRoaXMuc3JjLmxlbmd0aDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGlmICh0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IGNvZGUpIHsgYnJlYWs7IH1cbiAgfVxuICByZXR1cm4gcG9zO1xufTtcblxuLy8gU2tpcCBjaGFyIGNvZGVzIHJldmVyc2UgZnJvbSBnaXZlbiBwb3NpdGlvbiAtIDFcblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBDaGFyc0JhY2sgPSBmdW5jdGlvbiBza2lwQ2hhcnNCYWNrKHBvcywgY29kZSwgbWluKSB7XG4gIGlmIChwb3MgPD0gbWluKSB7IHJldHVybiBwb3M7IH1cblxuICB3aGlsZSAocG9zID4gbWluKSB7XG4gICAgaWYgKGNvZGUgIT09IHRoaXMuc3JjLmNoYXJDb2RlQXQoLS1wb3MpKSB7IHJldHVybiBwb3MgKyAxOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIGN1dCBsaW5lcyByYW5nZSBmcm9tIHNvdXJjZS5cblN0YXRlQmxvY2sucHJvdG90eXBlLmdldExpbmVzID0gZnVuY3Rpb24gZ2V0TGluZXMoYmVnaW4sIGVuZCwgaW5kZW50LCBrZWVwTGFzdExGKSB7XG4gIHZhciBpLCBsaW5lSW5kZW50LCBjaCwgZmlyc3QsIGxhc3QsIHF1ZXVlLCBsaW5lU3RhcnQsXG4gICAgICBsaW5lID0gYmVnaW47XG5cbiAgaWYgKGJlZ2luID49IGVuZCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHF1ZXVlID0gbmV3IEFycmF5KGVuZCAtIGJlZ2luKTtcblxuICBmb3IgKGkgPSAwOyBsaW5lIDwgZW5kOyBsaW5lKyssIGkrKykge1xuICAgIGxpbmVJbmRlbnQgPSAwO1xuICAgIGxpbmVTdGFydCA9IGZpcnN0ID0gdGhpcy5iTWFya3NbbGluZV07XG5cbiAgICBpZiAobGluZSArIDEgPCBlbmQgfHwga2VlcExhc3RMRikge1xuICAgICAgLy8gTm8gbmVlZCBmb3IgYm91bmRzIGNoZWNrIGJlY2F1c2Ugd2UgaGF2ZSBmYWtlIGVudHJ5IG9uIHRhaWwuXG4gICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV0gKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV07XG4gICAgfVxuXG4gICAgd2hpbGUgKGZpcnN0IDwgbGFzdCAmJiBsaW5lSW5kZW50IDwgaW5kZW50KSB7XG4gICAgICBjaCA9IHRoaXMuc3JjLmNoYXJDb2RlQXQoZmlyc3QpO1xuXG4gICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgICAgbGluZUluZGVudCArPSA0IC0gKGxpbmVJbmRlbnQgKyB0aGlzLmJzQ291bnRbbGluZV0pICUgNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lSW5kZW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlyc3QgLSBsaW5lU3RhcnQgPCB0aGlzLnRTaGlmdFtsaW5lXSkge1xuICAgICAgICAvLyBwYXRjaGVkIHRTaGlmdCBtYXNrZWQgY2hhcmFjdGVycyB0byBsb29rIGxpa2Ugc3BhY2VzIChibG9ja3F1b3RlcywgbGlzdCBtYXJrZXJzKVxuICAgICAgICBsaW5lSW5kZW50Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZmlyc3QrKztcbiAgICB9XG5cbiAgICBpZiAobGluZUluZGVudCA+IGluZGVudCkge1xuICAgICAgLy8gcGFydGlhbGx5IGV4cGFuZGluZyB0YWJzIGluIGNvZGUgYmxvY2tzLCBlLmcgJ1xcdFxcdGZvb2JhcidcbiAgICAgIC8vIHdpdGggaW5kZW50PTIgYmVjb21lcyAnICBcXHRmb29iYXInXG4gICAgICBxdWV1ZVtpXSA9IG5ldyBBcnJheShsaW5lSW5kZW50IC0gaW5kZW50ICsgMSkuam9pbignICcpICsgdGhpcy5zcmMuc2xpY2UoZmlyc3QsIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZVtpXSA9IHRoaXMuc3JjLnNsaWNlKGZpcnN0LCBsYXN0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcXVldWUuam9pbignJyk7XG59O1xuXG4vLyByZS1leHBvcnQgVG9rZW4gY2xhc3MgdG8gdXNlIGluIGJsb2NrIHJ1bGVzXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5Ub2tlbiA9IFRva2VuO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVCbG9jaztcbiIsIi8vIEdGTSB0YWJsZSwgaHR0cHM6Ly9naXRodWIuZ2l0aHViLmNvbS9nZm0vI3RhYmxlcy1leHRlbnNpb24tXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbmZ1bmN0aW9uIGdldExpbmUoc3RhdGUsIGxpbmUpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLmJNYXJrc1tsaW5lXSArIHN0YXRlLnRTaGlmdFtsaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tsaW5lXTtcblxuICByZXR1cm4gc3RhdGUuc3JjLnN1YnN0cihwb3MsIG1heCAtIHBvcyk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZWRTcGxpdChzdHIpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgcG9zID0gMCxcbiAgICAgIG1heCA9IHN0ci5sZW5ndGgsXG4gICAgICBjaCxcbiAgICAgIGlzRXNjYXBlZCA9IGZhbHNlLFxuICAgICAgbGFzdFBvcyA9IDAsXG4gICAgICBjdXJyZW50ID0gJyc7XG5cbiAgY2ggID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgaWYgKGNoID09PSAweDdjLyogfCAqLykge1xuICAgICAgaWYgKCFpc0VzY2FwZWQpIHtcbiAgICAgICAgLy8gcGlwZSBzZXBhcmF0aW5nIGNlbGxzLCAnfCdcbiAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCArIHN0ci5zdWJzdHJpbmcobGFzdFBvcywgcG9zKSk7XG4gICAgICAgIGN1cnJlbnQgPSAnJztcbiAgICAgICAgbGFzdFBvcyA9IHBvcyArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlc2NhcGVkIHBpcGUsICdcXHwnXG4gICAgICAgIGN1cnJlbnQgKz0gc3RyLnN1YnN0cmluZyhsYXN0UG9zLCBwb3MgLSAxKTtcbiAgICAgICAgbGFzdFBvcyA9IHBvcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc0VzY2FwZWQgPSAoY2ggPT09IDB4NWMvKiBcXCAqLyk7XG4gICAgcG9zKys7XG5cbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gIH1cblxuICByZXN1bHQucHVzaChjdXJyZW50ICsgc3RyLnN1YnN0cmluZyhsYXN0UG9zKSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRhYmxlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsIGxpbmVUZXh0LCBwb3MsIGksIGwsIG5leHRMaW5lLCBjb2x1bW5zLCBjb2x1bW5Db3VudCwgdG9rZW4sXG4gICAgICBhbGlnbnMsIHQsIHRhYmxlTGluZXMsIHRib2R5TGluZXMsIG9sZFBhcmVudFR5cGUsIHRlcm1pbmF0ZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcywgZmlyc3RDaCwgc2Vjb25kQ2g7XG5cbiAgLy8gc2hvdWxkIGhhdmUgYXQgbGVhc3QgdHdvIGxpbmVzXG4gIGlmIChzdGFydExpbmUgKyAyID4gZW5kTGluZSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHNlY29uZCBsaW5lIHNob3VsZCBiZSAnfCcsICctJywgJzonLFxuICAvLyBhbmQgbm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgYWxsb3dlZCBidXQgc3BhY2VzO1xuICAvLyBiYXNpY2FsbHksIHRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgL15bLTp8XVstOnxcXHNdKiQvIHJlZ2V4cFxuXG4gIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICBpZiAocG9zID49IHN0YXRlLmVNYXJrc1tuZXh0TGluZV0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgZmlyc3RDaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgaWYgKGZpcnN0Q2ggIT09IDB4N0MvKiB8ICovICYmIGZpcnN0Q2ggIT09IDB4MkQvKiAtICovICYmIGZpcnN0Q2ggIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChwb3MgPj0gc3RhdGUuZU1hcmtzW25leHRMaW5lXSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBzZWNvbmRDaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgaWYgKHNlY29uZENoICE9PSAweDdDLyogfCAqLyAmJiBzZWNvbmRDaCAhPT0gMHgyRC8qIC0gKi8gJiYgc2Vjb25kQ2ggIT09IDB4M0EvKiA6ICovICYmICFpc1NwYWNlKHNlY29uZENoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGlmIGZpcnN0IGNoYXJhY3RlciBpcyAnLScsIHRoZW4gc2Vjb25kIGNoYXJhY3RlciBtdXN0IG5vdCBiZSBhIHNwYWNlXG4gIC8vIChkdWUgdG8gcGFyc2luZyBhbWJpZ3VpdHkgd2l0aCBsaXN0KVxuICBpZiAoZmlyc3RDaCA9PT0gMHgyRC8qIC0gKi8gJiYgaXNTcGFjZShzZWNvbmRDaCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgd2hpbGUgKHBvcyA8IHN0YXRlLmVNYXJrc1tuZXh0TGluZV0pIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoY2ggIT09IDB4N0MvKiB8ICovICYmIGNoICE9PSAweDJELyogLSAqLyAmJiBjaCAhPT0gMHgzQS8qIDogKi8gJiYgIWlzU3BhY2UoY2gpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIHN0YXJ0TGluZSArIDEpO1xuXG4gIGNvbHVtbnMgPSBsaW5lVGV4dC5zcGxpdCgnfCcpO1xuICBhbGlnbnMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICB0ID0gY29sdW1uc1tpXS50cmltKCk7XG4gICAgaWYgKCF0KSB7XG4gICAgICAvLyBhbGxvdyBlbXB0eSBjb2x1bW5zIGJlZm9yZSBhbmQgYWZ0ZXIgdGFibGUsIGJ1dCBub3QgaW4gYmV0d2VlbiBjb2x1bW5zO1xuICAgICAgLy8gZS5nLiBhbGxvdyBgIHwtLS18IGAsIGRpc2FsbG93IGAgLS0tfHwtLS0gYFxuICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gY29sdW1ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL146Py0rOj8kLy50ZXN0KHQpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmICh0LmNoYXJDb2RlQXQodC5sZW5ndGggLSAxKSA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGFsaWducy5wdXNoKHQuY2hhckNvZGVBdCgwKSA9PT0gMHgzQS8qIDogKi8gPyAnY2VudGVyJyA6ICdyaWdodCcpO1xuICAgIH0gZWxzZSBpZiAodC5jaGFyQ29kZUF0KDApID09PSAweDNBLyogOiAqLykge1xuICAgICAgYWxpZ25zLnB1c2goJ2xlZnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxpZ25zLnB1c2goJycpO1xuICAgIH1cbiAgfVxuXG4gIGxpbmVUZXh0ID0gZ2V0TGluZShzdGF0ZSwgc3RhcnRMaW5lKS50cmltKCk7XG4gIGlmIChsaW5lVGV4dC5pbmRleE9mKCd8JykgPT09IC0xKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29sdW1ucyA9IGVzY2FwZWRTcGxpdChsaW5lVGV4dCk7XG4gIGlmIChjb2x1bW5zLmxlbmd0aCAmJiBjb2x1bW5zWzBdID09PSAnJykgY29sdW1ucy5zaGlmdCgpO1xuICBpZiAoY29sdW1ucy5sZW5ndGggJiYgY29sdW1uc1tjb2x1bW5zLmxlbmd0aCAtIDFdID09PSAnJykgY29sdW1ucy5wb3AoKTtcblxuICAvLyBoZWFkZXIgcm93IHdpbGwgZGVmaW5lIGFuIGFtb3VudCBvZiBjb2x1bW5zIGluIHRoZSBlbnRpcmUgdGFibGUsXG4gIC8vIGFuZCBhbGlnbiByb3cgc2hvdWxkIGJlIGV4YWN0bHkgdGhlIHNhbWUgKHRoZSByZXN0IG9mIHRoZSByb3dzIGNhbiBkaWZmZXIpXG4gIGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGg7XG4gIGlmIChjb2x1bW5Db3VudCA9PT0gMCB8fCBjb2x1bW5Db3VudCAhPT0gYWxpZ25zLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAndGFibGUnO1xuXG4gIC8vIHVzZSAnYmxvY2txdW90ZScgbGlzdHMgZm9yIHRlcm1pbmF0aW9uIGJlY2F1c2UgaXQnc1xuICAvLyB0aGUgbW9zdCBzaW1pbGFyIHRvIHRhYmxlc1xuICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygnYmxvY2txdW90ZScpO1xuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RhYmxlX29wZW4nLCAndGFibGUnLCAxKTtcbiAgdG9rZW4ubWFwID0gdGFibGVMaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGhlYWRfb3BlbicsICd0aGVhZCcsIDEpO1xuICB0b2tlbi5tYXAgPSBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdO1xuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RyX29wZW4nLCAndHInLCAxKTtcbiAgdG9rZW4ubWFwID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgndGhfb3BlbicsICd0aCcsIDEpO1xuICAgIGlmIChhbGlnbnNbaV0pIHtcbiAgICAgIHRva2VuLmF0dHJzICA9IFsgWyAnc3R5bGUnLCAndGV4dC1hbGlnbjonICsgYWxpZ25zW2ldIF0gXTtcbiAgICB9XG5cbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ICA9IGNvbHVtbnNbaV0udHJpbSgpO1xuICAgIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RoX2Nsb3NlJywgJ3RoJywgLTEpO1xuICB9XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndHJfY2xvc2UnLCAndHInLCAtMSk7XG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RoZWFkX2Nsb3NlJywgJ3RoZWFkJywgLTEpO1xuXG4gIGZvciAobmV4dExpbmUgPSBzdGFydExpbmUgKyAyOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG4gICAgbGluZVRleHQgPSBnZXRMaW5lKHN0YXRlLCBuZXh0TGluZSkudHJpbSgpO1xuICAgIGlmICghbGluZVRleHQpIHsgYnJlYWs7IH1cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IGJyZWFrOyB9XG4gICAgY29sdW1ucyA9IGVzY2FwZWRTcGxpdChsaW5lVGV4dCk7XG4gICAgaWYgKGNvbHVtbnMubGVuZ3RoICYmIGNvbHVtbnNbMF0gPT09ICcnKSBjb2x1bW5zLnNoaWZ0KCk7XG4gICAgaWYgKGNvbHVtbnMubGVuZ3RoICYmIGNvbHVtbnNbY29sdW1ucy5sZW5ndGggLSAxXSA9PT0gJycpIGNvbHVtbnMucG9wKCk7XG5cbiAgICBpZiAobmV4dExpbmUgPT09IHN0YXJ0TGluZSArIDIpIHtcbiAgICAgIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3Rib2R5X29wZW4nLCAndGJvZHknLCAxKTtcbiAgICAgIHRva2VuLm1hcCA9IHRib2R5TGluZXMgPSBbIHN0YXJ0TGluZSArIDIsIDAgXTtcbiAgICB9XG5cbiAgICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0cl9vcGVuJywgJ3RyJywgMSk7XG4gICAgdG9rZW4ubWFwID0gWyBuZXh0TGluZSwgbmV4dExpbmUgKyAxIF07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZF9vcGVuJywgJ3RkJywgMSk7XG4gICAgICBpZiAoYWxpZ25zW2ldKSB7XG4gICAgICAgIHRva2VuLmF0dHJzICA9IFsgWyAnc3R5bGUnLCAndGV4dC1hbGlnbjonICsgYWxpZ25zW2ldIF0gXTtcbiAgICAgIH1cblxuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ICA9IGNvbHVtbnNbaV0gPyBjb2x1bW5zW2ldLnRyaW0oKSA6ICcnO1xuICAgICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZF9jbG9zZScsICd0ZCcsIC0xKTtcbiAgICB9XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0cl9jbG9zZScsICd0cicsIC0xKTtcbiAgfVxuXG4gIGlmICh0Ym9keUxpbmVzKSB7XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0Ym9keV9jbG9zZScsICd0Ym9keScsIC0xKTtcbiAgICB0Ym9keUxpbmVzWzFdID0gbmV4dExpbmU7XG4gIH1cblxuICB0b2tlbiA9IHN0YXRlLnB1c2goJ3RhYmxlX2Nsb3NlJywgJ3RhYmxlJywgLTEpO1xuICB0YWJsZUxpbmVzWzFdID0gbmV4dExpbmU7XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvY2soc3RhdGUpIHtcbiAgdmFyIHRva2VuO1xuXG4gIGlmIChzdGF0ZS5pbmxpbmVNb2RlKSB7XG4gICAgdG9rZW4gICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2lubGluZScsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ICA9IHN0YXRlLnNyYztcbiAgICB0b2tlbi5tYXAgICAgICA9IFsgMCwgMSBdO1xuICAgIHRva2VuLmNoaWxkcmVuID0gW107XG4gICAgc3RhdGUudG9rZW5zLnB1c2godG9rZW4pO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLm1kLmJsb2NrLnBhcnNlKHN0YXRlLnNyYywgc3RhdGUubWQsIHN0YXRlLmVudiwgc3RhdGUudG9rZW5zKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmxpbmUoc3RhdGUpIHtcbiAgdmFyIHRva2VucyA9IHN0YXRlLnRva2VucywgdG9rLCBpLCBsO1xuXG4gIC8vIFBhcnNlIGlubGluZXNcbiAgZm9yIChpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB0b2sgPSB0b2tlbnNbaV07XG4gICAgaWYgKHRvay50eXBlID09PSAnaW5saW5lJykge1xuICAgICAgc3RhdGUubWQuaW5saW5lLnBhcnNlKHRvay5jb250ZW50LCBzdGF0ZS5tZCwgc3RhdGUuZW52LCB0b2suY2hpbGRyZW4pO1xuICAgIH1cbiAgfVxufTtcbiIsIi8vIFJlcGxhY2UgbGluay1saWtlIHRleHRzIHdpdGggbGluayBub2Rlcy5cbi8vXG4vLyBDdXJyZW50bHkgcmVzdHJpY3RlZCBieSBgbWQudmFsaWRhdGVMaW5rKClgIHRvIGh0dHAvaHR0cHMvZnRwXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBhcnJheVJlcGxhY2VBdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmFycmF5UmVwbGFjZUF0O1xuXG5cbmZ1bmN0aW9uIGlzTGlua09wZW4oc3RyKSB7XG4gIHJldHVybiAvXjxhWz5cXHNdL2kudGVzdChzdHIpO1xufVxuZnVuY3Rpb24gaXNMaW5rQ2xvc2Uoc3RyKSB7XG4gIHJldHVybiAvXjxcXC9hXFxzKj4vaS50ZXN0KHN0cik7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5raWZ5KHN0YXRlKSB7XG4gIHZhciBpLCBqLCBsLCB0b2tlbnMsIHRva2VuLCBjdXJyZW50VG9rZW4sIG5vZGVzLCBsbiwgdGV4dCwgcG9zLCBsYXN0UG9zLFxuICAgICAgbGV2ZWwsIGh0bWxMaW5rTGV2ZWwsIHVybCwgZnVsbFVybCwgdXJsVGV4dCxcbiAgICAgIGJsb2NrVG9rZW5zID0gc3RhdGUudG9rZW5zLFxuICAgICAgbGlua3M7XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmxpbmtpZnkpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChqID0gMCwgbCA9IGJsb2NrVG9rZW5zLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgIGlmIChibG9ja1Rva2Vuc1tqXS50eXBlICE9PSAnaW5saW5lJyB8fFxuICAgICAgICAhc3RhdGUubWQubGlua2lmeS5wcmV0ZXN0KGJsb2NrVG9rZW5zW2pdLmNvbnRlbnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0b2tlbnMgPSBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlbjtcblxuICAgIGh0bWxMaW5rTGV2ZWwgPSAwO1xuXG4gICAgLy8gV2Ugc2NhbiBmcm9tIHRoZSBlbmQsIHRvIGtlZXAgcG9zaXRpb24gd2hlbiBuZXcgdGFncyBhZGRlZC5cbiAgICAvLyBVc2UgcmV2ZXJzZWQgbG9naWMgaW4gbGlua3Mgc3RhcnQvZW5kIG1hdGNoXG4gICAgZm9yIChpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjdXJyZW50VG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIC8vIFNraXAgY29udGVudCBvZiBtYXJrZG93biBsaW5rc1xuICAgICAgaWYgKGN1cnJlbnRUb2tlbi50eXBlID09PSAnbGlua19jbG9zZScpIHtcbiAgICAgICAgaS0tO1xuICAgICAgICB3aGlsZSAodG9rZW5zW2ldLmxldmVsICE9PSBjdXJyZW50VG9rZW4ubGV2ZWwgJiYgdG9rZW5zW2ldLnR5cGUgIT09ICdsaW5rX29wZW4nKSB7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGNvbnRlbnQgb2YgaHRtbCB0YWcgbGlua3NcbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ2h0bWxfaW5saW5lJykge1xuICAgICAgICBpZiAoaXNMaW5rT3BlbihjdXJyZW50VG9rZW4uY29udGVudCkgJiYgaHRtbExpbmtMZXZlbCA+IDApIHtcbiAgICAgICAgICBodG1sTGlua0xldmVsLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGlua0Nsb3NlKGN1cnJlbnRUb2tlbi5jb250ZW50KSkge1xuICAgICAgICAgIGh0bWxMaW5rTGV2ZWwrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGh0bWxMaW5rTGV2ZWwgPiAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIHN0YXRlLm1kLmxpbmtpZnkudGVzdChjdXJyZW50VG9rZW4uY29udGVudCkpIHtcblxuICAgICAgICB0ZXh0ID0gY3VycmVudFRva2VuLmNvbnRlbnQ7XG4gICAgICAgIGxpbmtzID0gc3RhdGUubWQubGlua2lmeS5tYXRjaCh0ZXh0KTtcblxuICAgICAgICAvLyBOb3cgc3BsaXQgc3RyaW5nIHRvIG5vZGVzXG4gICAgICAgIG5vZGVzID0gW107XG4gICAgICAgIGxldmVsID0gY3VycmVudFRva2VuLmxldmVsO1xuICAgICAgICBsYXN0UG9zID0gMDtcblxuICAgICAgICBmb3IgKGxuID0gMDsgbG4gPCBsaW5rcy5sZW5ndGg7IGxuKyspIHtcblxuICAgICAgICAgIHVybCA9IGxpbmtzW2xuXS51cmw7XG4gICAgICAgICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsodXJsKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdXJsVGV4dCA9IGxpbmtzW2xuXS50ZXh0O1xuXG4gICAgICAgICAgLy8gTGlua2lmaWVyIG1pZ2h0IHNlbmQgcmF3IGhvc3RuYW1lcyBsaWtlIFwiZXhhbXBsZS5jb21cIiwgd2hlcmUgdXJsXG4gICAgICAgICAgLy8gc3RhcnRzIHdpdGggZG9tYWluIG5hbWUuIFNvIHdlIHByZXBlbmQgaHR0cDovLyBpbiB0aG9zZSBjYXNlcyxcbiAgICAgICAgICAvLyBhbmQgcmVtb3ZlIGl0IGFmdGVyd2FyZHMuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBpZiAoIWxpbmtzW2xuXS5zY2hlbWEpIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCgnaHR0cDovLycgKyB1cmxUZXh0KS5yZXBsYWNlKC9eaHR0cDpcXC9cXC8vLCAnJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaW5rc1tsbl0uc2NoZW1hID09PSAnbWFpbHRvOicgJiYgIS9ebWFpbHRvOi9pLnRlc3QodXJsVGV4dCkpIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCgnbWFpbHRvOicgKyB1cmxUZXh0KS5yZXBsYWNlKC9ebWFpbHRvOi8sICcnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJsVGV4dCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybFRleHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvcyA9IGxpbmtzW2xuXS5pbmRleDtcblxuICAgICAgICAgIGlmIChwb3MgPiBsYXN0UG9zKSB7XG4gICAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHRleHQuc2xpY2UobGFzdFBvcywgcG9zKTtcbiAgICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgICAgICAgdG9rZW4uYXR0cnMgICA9IFsgWyAnaHJlZicsIGZ1bGxVcmwgXSBdO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbCsrO1xuICAgICAgICAgIHRva2VuLm1hcmt1cCAgPSAnbGlua2lmeSc7XG4gICAgICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ3RleHQnLCAnJywgMCk7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHVybFRleHQ7XG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IGxldmVsO1xuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuXG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbignbGlua19jbG9zZScsICdhJywgLTEpO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSAtLWxldmVsO1xuICAgICAgICAgIHRva2VuLm1hcmt1cCAgPSAnbGlua2lmeSc7XG4gICAgICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIGxhc3RQb3MgPSBsaW5rc1tsbl0ubGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UG9zIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB0ZXh0LnNsaWNlKGxhc3RQb3MpO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2UgY3VycmVudCBub2RlXG4gICAgICAgIGJsb2NrVG9rZW5zW2pdLmNoaWxkcmVuID0gdG9rZW5zID0gYXJyYXlSZXBsYWNlQXQodG9rZW5zLCBpLCBub2Rlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuIiwiLy8gTm9ybWFsaXplIGlucHV0IHN0cmluZ1xuXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gaHR0cHM6Ly9zcGVjLmNvbW1vbm1hcmsub3JnLzAuMjkvI2xpbmUtZW5kaW5nXG52YXIgTkVXTElORVNfUkUgID0gL1xcclxcbj98XFxuL2c7XG52YXIgTlVMTF9SRSAgICAgID0gL1xcMC9nO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplKHN0YXRlKSB7XG4gIHZhciBzdHI7XG5cbiAgLy8gTm9ybWFsaXplIG5ld2xpbmVzXG4gIHN0ciA9IHN0YXRlLnNyYy5yZXBsYWNlKE5FV0xJTkVTX1JFLCAnXFxuJyk7XG5cbiAgLy8gUmVwbGFjZSBOVUxMIGNoYXJhY3RlcnNcbiAgc3RyID0gc3RyLnJlcGxhY2UoTlVMTF9SRSwgJ1xcdUZGRkQnKTtcblxuICBzdGF0ZS5zcmMgPSBzdHI7XG59O1xuIiwiLy8gU2ltcGxlIHR5cG9ncmFwaGljIHJlcGxhY2VtZW50c1xuLy9cbi8vIChjKSAoQykg4oaSIMKpXG4vLyAodG0pIChUTSkg4oaSIOKEolxuLy8gKHIpIChSKSDihpIgwq5cbi8vICstIOKGkiDCsVxuLy8gKHApIChQKSAtPiDCp1xuLy8gLi4uIOKGkiDigKYgKGFsc28gPy4uLi4g4oaSID8uLiwgIS4uLi4g4oaSICEuLilcbi8vID8/Pz8/Pz8/IOKGkiA/Pz8sICEhISEhIOKGkiAhISEsIGAsLGAg4oaSIGAsYFxuLy8gLS0g4oaSICZuZGFzaDssIC0tLSDihpIgJm1kYXNoO1xuLy9cbid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETzpcbi8vIC0gZnJhY3Rpb25hbHMgMS8yLCAxLzQsIDMvNCAtPiDCvSwgwrwsIMK+XG4vLyAtIG1pbHRpcGxpY2F0aW9uIDIgeCA0IC0+IDIgw5cgNFxuXG52YXIgUkFSRV9SRSA9IC9cXCstfFxcLlxcLnxcXD9cXD9cXD9cXD98ISEhIXwsLHwtLS87XG5cbi8vIFdvcmthcm91bmQgZm9yIHBoYW50b21qcyAtIG5lZWQgcmVnZXggd2l0aG91dCAvZyBmbGFnLFxuLy8gb3Igcm9vdCBjaGVjayB3aWxsIGZhaWwgZXZlcnkgc2Vjb25kIHRpbWVcbnZhciBTQ09QRURfQUJCUl9URVNUX1JFID0gL1xcKChjfHRtfHJ8cClcXCkvaTtcblxudmFyIFNDT1BFRF9BQkJSX1JFID0gL1xcKChjfHRtfHJ8cClcXCkvaWc7XG52YXIgU0NPUEVEX0FCQlIgPSB7XG4gIGM6ICfCqScsXG4gIHI6ICfCricsXG4gIHA6ICfCpycsXG4gIHRtOiAn4oSiJ1xufTtcblxuZnVuY3Rpb24gcmVwbGFjZUZuKG1hdGNoLCBuYW1lKSB7XG4gIHJldHVybiBTQ09QRURfQUJCUltuYW1lLnRvTG93ZXJDYXNlKCldO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlX3Njb3BlZChpbmxpbmVUb2tlbnMpIHtcbiAgdmFyIGksIHRva2VuLCBpbnNpZGVfYXV0b2xpbmsgPSAwO1xuXG4gIGZvciAoaSA9IGlubGluZVRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHRva2VuID0gaW5saW5lVG9rZW5zW2ldO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiAhaW5zaWRlX2F1dG9saW5rKSB7XG4gICAgICB0b2tlbi5jb250ZW50ID0gdG9rZW4uY29udGVudC5yZXBsYWNlKFNDT1BFRF9BQkJSX1JFLCByZXBsYWNlRm4pO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19vcGVuJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluay0tO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19jbG9zZScgJiYgdG9rZW4uaW5mbyA9PT0gJ2F1dG8nKSB7XG4gICAgICBpbnNpZGVfYXV0b2xpbmsrKztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZV9yYXJlKGlubGluZVRva2Vucykge1xuICB2YXIgaSwgdG9rZW4sIGluc2lkZV9hdXRvbGluayA9IDA7XG5cbiAgZm9yIChpID0gaW5saW5lVG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdG9rZW4gPSBpbmxpbmVUb2tlbnNbaV07XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RleHQnICYmICFpbnNpZGVfYXV0b2xpbmspIHtcbiAgICAgIGlmIChSQVJFX1JFLnRlc3QodG9rZW4uY29udGVudCkpIHtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHRva2VuLmNvbnRlbnRcbiAgICAgICAgICAucmVwbGFjZSgvXFwrLS9nLCAnwrEnKVxuICAgICAgICAgIC8vIC4uLCAuLi4sIC4uLi4uLi4gLT4g4oCmXG4gICAgICAgICAgLy8gYnV0ID8uLi4uLiAmICEuLi4uLiAtPiA/Li4gJiAhLi5cbiAgICAgICAgICAucmVwbGFjZSgvXFwuezIsfS9nLCAn4oCmJykucmVwbGFjZSgvKFs/IV0p4oCmL2csICckMS4uJylcbiAgICAgICAgICAucmVwbGFjZSgvKFs/IV0pezQsfS9nLCAnJDEkMSQxJykucmVwbGFjZSgvLHsyLH0vZywgJywnKVxuICAgICAgICAgIC8vIGVtLWRhc2hcbiAgICAgICAgICAucmVwbGFjZSgvKF58W14tXSktLS0oPz1bXi1dfCQpL21nLCAnJDFcXHUyMDE0JylcbiAgICAgICAgICAvLyBlbi1kYXNoXG4gICAgICAgICAgLnJlcGxhY2UoLyhefFxccyktLSg/PVxcc3wkKS9tZywgJyQxXFx1MjAxMycpXG4gICAgICAgICAgLnJlcGxhY2UoLyhefFteLVxcc10pLS0oPz1bXi1cXHNdfCQpL21nLCAnJDFcXHUyMDEzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX29wZW4nICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rLS07XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX2Nsb3NlJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluaysrO1xuICAgIH1cbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICB2YXIgYmxrSWR4O1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy50eXBvZ3JhcGhlcikgeyByZXR1cm47IH1cblxuICBmb3IgKGJsa0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAxOyBibGtJZHggPj0gMDsgYmxrSWR4LS0pIHtcblxuICAgIGlmIChzdGF0ZS50b2tlbnNbYmxrSWR4XS50eXBlICE9PSAnaW5saW5lJykgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKFNDT1BFRF9BQkJSX1RFU1RfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgcmVwbGFjZV9zY29wZWQoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIGlmIChSQVJFX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcbiAgICAgIHJlcGxhY2VfcmFyZShzdGF0ZS50b2tlbnNbYmxrSWR4XS5jaGlsZHJlbik7XG4gICAgfVxuXG4gIH1cbn07XG4iLCIvLyBDb252ZXJ0IHN0cmFpZ2h0IHF1b3RhdGlvbiBtYXJrcyB0byB0eXBvZ3JhcGhpYyBvbmVzXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBpc1doaXRlU3BhY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzV2hpdGVTcGFjZTtcbnZhciBpc1B1bmN0Q2hhciAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzUHVuY3RDaGFyO1xudmFyIGlzTWRBc2NpaVB1bmN0ID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNNZEFzY2lpUHVuY3Q7XG5cbnZhciBRVU9URV9URVNUX1JFID0gL1snXCJdLztcbnZhciBRVU9URV9SRSA9IC9bJ1wiXS9nO1xudmFyIEFQT1NUUk9QSEUgPSAnXFx1MjAxOSc7IC8qIOKAmSAqL1xuXG5cbmZ1bmN0aW9uIHJlcGxhY2VBdChzdHIsIGluZGV4LCBjaCkge1xuICByZXR1cm4gc3RyLnN1YnN0cigwLCBpbmRleCkgKyBjaCArIHN0ci5zdWJzdHIoaW5kZXggKyAxKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc19pbmxpbmVzKHRva2Vucywgc3RhdGUpIHtcbiAgdmFyIGksIHRva2VuLCB0ZXh0LCB0LCBwb3MsIG1heCwgdGhpc0xldmVsLCBpdGVtLCBsYXN0Q2hhciwgbmV4dENoYXIsXG4gICAgICBpc0xhc3RQdW5jdENoYXIsIGlzTmV4dFB1bmN0Q2hhciwgaXNMYXN0V2hpdGVTcGFjZSwgaXNOZXh0V2hpdGVTcGFjZSxcbiAgICAgIGNhbk9wZW4sIGNhbkNsb3NlLCBqLCBpc1NpbmdsZSwgc3RhY2ssIG9wZW5RdW90ZSwgY2xvc2VRdW90ZTtcblxuICBzdGFjayA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIHRoaXNMZXZlbCA9IHRva2Vuc1tpXS5sZXZlbDtcblxuICAgIGZvciAoaiA9IHN0YWNrLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICBpZiAoc3RhY2tbal0ubGV2ZWwgPD0gdGhpc0xldmVsKSB7IGJyZWFrOyB9XG4gICAgfVxuICAgIHN0YWNrLmxlbmd0aCA9IGogKyAxO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgIT09ICd0ZXh0JykgeyBjb250aW51ZTsgfVxuXG4gICAgdGV4dCA9IHRva2VuLmNvbnRlbnQ7XG4gICAgcG9zID0gMDtcbiAgICBtYXggPSB0ZXh0Lmxlbmd0aDtcblxuICAgIC8qZXNsaW50IG5vLWxhYmVsczowLGJsb2NrLXNjb3BlZC12YXI6MCovXG4gICAgT1VURVI6XG4gICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgUVVPVEVfUkUubGFzdEluZGV4ID0gcG9zO1xuICAgICAgdCA9IFFVT1RFX1JFLmV4ZWModGV4dCk7XG4gICAgICBpZiAoIXQpIHsgYnJlYWs7IH1cblxuICAgICAgY2FuT3BlbiA9IGNhbkNsb3NlID0gdHJ1ZTtcbiAgICAgIHBvcyA9IHQuaW5kZXggKyAxO1xuICAgICAgaXNTaW5nbGUgPSAodFswXSA9PT0gXCInXCIpO1xuXG4gICAgICAvLyBGaW5kIHByZXZpb3VzIGNoYXJhY3RlcixcbiAgICAgIC8vIGRlZmF1bHQgdG8gc3BhY2UgaWYgaXQncyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lXG4gICAgICAvL1xuICAgICAgbGFzdENoYXIgPSAweDIwO1xuXG4gICAgICBpZiAodC5pbmRleCAtIDEgPj0gMCkge1xuICAgICAgICBsYXN0Q2hhciA9IHRleHQuY2hhckNvZGVBdCh0LmluZGV4IC0gMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBpZiAodG9rZW5zW2pdLnR5cGUgPT09ICdzb2Z0YnJlYWsnIHx8IHRva2Vuc1tqXS50eXBlID09PSAnaGFyZGJyZWFrJykgYnJlYWs7IC8vIGxhc3RDaGFyIGRlZmF1bHRzIHRvIDB4MjBcbiAgICAgICAgICBpZiAoIXRva2Vuc1tqXS5jb250ZW50KSBjb250aW51ZTsgLy8gc2hvdWxkIHNraXAgYWxsIHRva2VucyBleGNlcHQgJ3RleHQnLCAnaHRtbF9pbmxpbmUnIG9yICdjb2RlX2lubGluZSdcblxuICAgICAgICAgIGxhc3RDaGFyID0gdG9rZW5zW2pdLmNvbnRlbnQuY2hhckNvZGVBdCh0b2tlbnNbal0uY29udGVudC5sZW5ndGggLSAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIG5leHQgY2hhcmFjdGVyLFxuICAgICAgLy8gZGVmYXVsdCB0byBzcGFjZSBpZiBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICAgIC8vXG4gICAgICBuZXh0Q2hhciA9IDB4MjA7XG5cbiAgICAgIGlmIChwb3MgPCBtYXgpIHtcbiAgICAgICAgbmV4dENoYXIgPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgdG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHRva2Vuc1tqXS50eXBlID09PSAnc29mdGJyZWFrJyB8fCB0b2tlbnNbal0udHlwZSA9PT0gJ2hhcmRicmVhaycpIGJyZWFrOyAvLyBuZXh0Q2hhciBkZWZhdWx0cyB0byAweDIwXG4gICAgICAgICAgaWYgKCF0b2tlbnNbal0uY29udGVudCkgY29udGludWU7IC8vIHNob3VsZCBza2lwIGFsbCB0b2tlbnMgZXhjZXB0ICd0ZXh0JywgJ2h0bWxfaW5saW5lJyBvciAnY29kZV9pbmxpbmUnXG5cbiAgICAgICAgICBuZXh0Q2hhciA9IHRva2Vuc1tqXS5jb250ZW50LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXNMYXN0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobGFzdENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobGFzdENoYXIpKTtcbiAgICAgIGlzTmV4dFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KG5leHRDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyKSk7XG5cbiAgICAgIGlzTGFzdFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobGFzdENoYXIpO1xuICAgICAgaXNOZXh0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XG5cbiAgICAgIGlmIChpc05leHRXaGl0ZVNwYWNlKSB7XG4gICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXh0UHVuY3RDaGFyKSB7XG4gICAgICAgIGlmICghKGlzTGFzdFdoaXRlU3BhY2UgfHwgaXNMYXN0UHVuY3RDaGFyKSkge1xuICAgICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNMYXN0V2hpdGVTcGFjZSkge1xuICAgICAgICBjYW5DbG9zZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc0xhc3RQdW5jdENoYXIpIHtcbiAgICAgICAgaWYgKCEoaXNOZXh0V2hpdGVTcGFjZSB8fCBpc05leHRQdW5jdENoYXIpKSB7XG4gICAgICAgICAgY2FuQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV4dENoYXIgPT09IDB4MjIgLyogXCIgKi8gJiYgdFswXSA9PT0gJ1wiJykge1xuICAgICAgICBpZiAobGFzdENoYXIgPj0gMHgzMCAvKiAwICovICYmIGxhc3RDaGFyIDw9IDB4MzkgLyogOSAqLykge1xuICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZTogMVwiXCIgLSBjb3VudCBmaXJzdCBxdW90ZSBhcyBhbiBpbmNoXG4gICAgICAgICAgY2FuQ2xvc2UgPSBjYW5PcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNhbk9wZW4gJiYgY2FuQ2xvc2UpIHtcbiAgICAgICAgLy8gUmVwbGFjZSBxdW90ZXMgaW4gdGhlIG1pZGRsZSBvZiBwdW5jdHVhdGlvbiBzZXF1ZW5jZSwgYnV0IG5vdFxuICAgICAgICAvLyBpbiB0aGUgbWlkZGxlIG9mIHRoZSB3b3JkcywgaS5lLjpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gMS4gZm9vIFwiIGJhciBcIiBiYXogLSBub3QgcmVwbGFjZWRcbiAgICAgICAgLy8gMi4gZm9vLVwiLWJhci1cIi1iYXogLSByZXBsYWNlZFxuICAgICAgICAvLyAzLiBmb29cImJhclwiYmF6ICAgICAtIG5vdCByZXBsYWNlZFxuICAgICAgICAvL1xuICAgICAgICBjYW5PcGVuID0gaXNMYXN0UHVuY3RDaGFyO1xuICAgICAgICBjYW5DbG9zZSA9IGlzTmV4dFB1bmN0Q2hhcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjYW5PcGVuICYmICFjYW5DbG9zZSkge1xuICAgICAgICAvLyBtaWRkbGUgb2Ygd29yZFxuICAgICAgICBpZiAoaXNTaW5nbGUpIHtcbiAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIEFQT1NUUk9QSEUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FuQ2xvc2UpIHtcbiAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSBhIGNsb3NpbmcgcXVvdGUsIHJld2luZCB0aGUgc3RhY2sgdG8gZ2V0IGEgbWF0Y2hcbiAgICAgICAgZm9yIChqID0gc3RhY2subGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBpdGVtID0gc3RhY2tbal07XG4gICAgICAgICAgaWYgKHN0YWNrW2pdLmxldmVsIDwgdGhpc0xldmVsKSB7IGJyZWFrOyB9XG4gICAgICAgICAgaWYgKGl0ZW0uc2luZ2xlID09PSBpc1NpbmdsZSAmJiBzdGFja1tqXS5sZXZlbCA9PT0gdGhpc0xldmVsKSB7XG4gICAgICAgICAgICBpdGVtID0gc3RhY2tbal07XG5cbiAgICAgICAgICAgIGlmIChpc1NpbmdsZSkge1xuICAgICAgICAgICAgICBvcGVuUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1syXTtcbiAgICAgICAgICAgICAgY2xvc2VRdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzNdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3BlblF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbMF07XG4gICAgICAgICAgICAgIGNsb3NlUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVwbGFjZSB0b2tlbi5jb250ZW50ICpiZWZvcmUqIHRva2Vuc1tpdGVtLnRva2VuXS5jb250ZW50LFxuICAgICAgICAgICAgLy8gYmVjYXVzZSwgaWYgdGhleSBhcmUgcG9pbnRpbmcgYXQgdGhlIHNhbWUgdG9rZW4sIHJlcGxhY2VBdFxuICAgICAgICAgICAgLy8gY291bGQgbWVzcyB1cCBpbmRpY2VzIHdoZW4gcXVvdGUgbGVuZ3RoICE9IDFcbiAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW4uY29udGVudCwgdC5pbmRleCwgY2xvc2VRdW90ZSk7XG4gICAgICAgICAgICB0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCA9IHJlcGxhY2VBdChcbiAgICAgICAgICAgICAgdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQsIGl0ZW0ucG9zLCBvcGVuUXVvdGUpO1xuXG4gICAgICAgICAgICBwb3MgKz0gY2xvc2VRdW90ZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW4gPT09IGkpIHsgcG9zICs9IG9wZW5RdW90ZS5sZW5ndGggLSAxOyB9XG5cbiAgICAgICAgICAgIHRleHQgPSB0b2tlbi5jb250ZW50O1xuICAgICAgICAgICAgbWF4ID0gdGV4dC5sZW5ndGg7XG5cbiAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IGo7XG4gICAgICAgICAgICBjb250aW51ZSBPVVRFUjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNhbk9wZW4pIHtcbiAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgdG9rZW46IGksXG4gICAgICAgICAgcG9zOiB0LmluZGV4LFxuICAgICAgICAgIHNpbmdsZTogaXNTaW5nbGUsXG4gICAgICAgICAgbGV2ZWw6IHRoaXNMZXZlbFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuQ2xvc2UgJiYgaXNTaW5nbGUpIHtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBBUE9TVFJPUEhFKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNtYXJ0cXVvdGVzKHN0YXRlKSB7XG4gIC8qZXNsaW50IG1heC1kZXB0aDowKi9cbiAgdmFyIGJsa0lkeDtcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMudHlwb2dyYXBoZXIpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChibGtJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMTsgYmxrSWR4ID49IDA7IGJsa0lkeC0tKSB7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2Jsa0lkeF0udHlwZSAhPT0gJ2lubGluZScgfHxcbiAgICAgICAgIVFVT1RFX1RFU1RfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcHJvY2Vzc19pbmxpbmVzKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuLCBzdGF0ZSk7XG4gIH1cbn07XG4iLCIvLyBDb3JlIHN0YXRlIG9iamVjdFxuLy9cbid1c2Ugc3RyaWN0JztcblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi4vdG9rZW4nKTtcblxuXG5mdW5jdGlvbiBTdGF0ZUNvcmUoc3JjLCBtZCwgZW52KSB7XG4gIHRoaXMuc3JjID0gc3JjO1xuICB0aGlzLmVudiA9IGVudjtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy5pbmxpbmVNb2RlID0gZmFsc2U7XG4gIHRoaXMubWQgPSBtZDsgLy8gbGluayB0byBwYXJzZXIgaW5zdGFuY2Vcbn1cblxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBjb3JlIHJ1bGVzXG5TdGF0ZUNvcmUucHJvdG90eXBlLlRva2VuID0gVG9rZW47XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUNvcmU7XG4iLCIvLyBQcm9jZXNzIGF1dG9saW5rcyAnPHByb3RvY29sOi4uLj4nXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vKmVzbGludCBtYXgtbGVuOjAqL1xudmFyIEVNQUlMX1JFICAgID0gL14oW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKikkLztcbnZhciBBVVRPTElOS19SRSA9IC9eKFthLXpBLVpdW2EtekEtWjAtOSsuXFwtXXsxLDMxfSk6KFtePD5cXHgwMC1cXHgyMF0qKSQvO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXV0b2xpbmsoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgdXJsLCBmdWxsVXJsLCB0b2tlbiwgY2gsIHN0YXJ0LCBtYXgsXG4gICAgICBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgZm9yICg7Oykge1xuICAgIGlmICgrK3BvcyA+PSBtYXgpIHJldHVybiBmYWxzZTtcblxuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjaCA9PT0gMHgzQyAvKiA8ICovKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGNoID09PSAweDNFIC8qID4gKi8pIGJyZWFrO1xuICB9XG5cbiAgdXJsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0ICsgMSwgcG9zKTtcblxuICBpZiAoQVVUT0xJTktfUkUudGVzdCh1cmwpKSB7XG4gICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsodXJsKTtcbiAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsKTtcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgKz0gdXJsLmxlbmd0aCArIDI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoRU1BSUxfUkUudGVzdCh1cmwpKSB7XG4gICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsoJ21haWx0bzonICsgdXJsKTtcbiAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsKTtcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgKz0gdXJsLmxlbmd0aCArIDI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiLy8gUGFyc2UgYmFja3RpY2tzXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJhY2t0aWNrKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHN0YXJ0LCBtYXgsIG1hcmtlciwgdG9rZW4sIG1hdGNoU3RhcnQsIG1hdGNoRW5kLCBvcGVuZXJMZW5ndGgsIGNsb3Nlckxlbmd0aCxcbiAgICAgIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAoY2ggIT09IDB4NjAvKiBgICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHN0YXJ0ID0gcG9zO1xuICBwb3MrKztcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIC8vIHNjYW4gbWFya2VyIGxlbmd0aFxuICB3aGlsZSAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NjAvKiBgICovKSB7IHBvcysrOyB9XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MpO1xuICBvcGVuZXJMZW5ndGggPSBtYXJrZXIubGVuZ3RoO1xuXG4gIGlmIChzdGF0ZS5iYWNrdGlja3NTY2FubmVkICYmIChzdGF0ZS5iYWNrdGlja3Nbb3BlbmVyTGVuZ3RoXSB8fCAwKSA8PSBzdGFydCkge1xuICAgIGlmICghc2lsZW50KSBzdGF0ZS5wZW5kaW5nICs9IG1hcmtlcjtcbiAgICBzdGF0ZS5wb3MgKz0gb3BlbmVyTGVuZ3RoO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgbWF0Y2hTdGFydCA9IG1hdGNoRW5kID0gcG9zO1xuXG4gIC8vIE5vdGhpbmcgZm91bmQgaW4gdGhlIGNhY2hlLCBzY2FuIHVudGlsIHRoZSBlbmQgb2YgdGhlIGxpbmUgKG9yIHVudGlsIG1hcmtlciBpcyBmb3VuZClcbiAgd2hpbGUgKChtYXRjaFN0YXJ0ID0gc3RhdGUuc3JjLmluZGV4T2YoJ2AnLCBtYXRjaEVuZCkpICE9PSAtMSkge1xuICAgIG1hdGNoRW5kID0gbWF0Y2hTdGFydCArIDE7XG5cbiAgICAvLyBzY2FuIG1hcmtlciBsZW5ndGhcbiAgICB3aGlsZSAobWF0Y2hFbmQgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQobWF0Y2hFbmQpID09PSAweDYwLyogYCAqLykgeyBtYXRjaEVuZCsrOyB9XG5cbiAgICBjbG9zZXJMZW5ndGggPSBtYXRjaEVuZCAtIG1hdGNoU3RhcnQ7XG5cbiAgICBpZiAoY2xvc2VyTGVuZ3RoID09PSBvcGVuZXJMZW5ndGgpIHtcbiAgICAgIC8vIEZvdW5kIG1hdGNoaW5nIGNsb3NlciBsZW5ndGguXG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCdjb2RlX2lubGluZScsICdjb2RlJywgMCk7XG4gICAgICAgIHRva2VuLm1hcmt1cCAgPSBtYXJrZXI7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXRjaFN0YXJ0KVxuICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgJyAnKVxuICAgICAgICAgIC5yZXBsYWNlKC9eICguKykgJC8sICckMScpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gbWF0Y2hFbmQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBTb21lIGRpZmZlcmVudCBsZW5ndGggZm91bmQsIHB1dCBpdCBpbiBjYWNoZSBhcyB1cHBlciBsaW1pdCBvZiB3aGVyZSBjbG9zZXIgY2FuIGJlIGZvdW5kXG4gICAgc3RhdGUuYmFja3RpY2tzW2Nsb3Nlckxlbmd0aF0gPSBtYXRjaFN0YXJ0O1xuICB9XG5cbiAgLy8gU2Nhbm5lZCB0aHJvdWdoIHRoZSBlbmQsIGRpZG4ndCBmaW5kIGFueXRoaW5nXG4gIHN0YXRlLmJhY2t0aWNrc1NjYW5uZWQgPSB0cnVlO1xuXG4gIGlmICghc2lsZW50KSBzdGF0ZS5wZW5kaW5nICs9IG1hcmtlcjtcbiAgc3RhdGUucG9zICs9IG9wZW5lckxlbmd0aDtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gRm9yIGVhY2ggb3BlbmluZyBlbXBoYXNpcy1saWtlIG1hcmtlciBmaW5kIGEgbWF0Y2hpbmcgY2xvc2luZyBvbmVcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gcHJvY2Vzc0RlbGltaXRlcnMoc3RhdGUsIGRlbGltaXRlcnMpIHtcbiAgdmFyIGNsb3NlcklkeCwgb3BlbmVySWR4LCBjbG9zZXIsIG9wZW5lciwgbWluT3BlbmVySWR4LCBuZXdNaW5PcGVuZXJJZHgsXG4gICAgICBpc09kZE1hdGNoLCBsYXN0SnVtcCxcbiAgICAgIG9wZW5lcnNCb3R0b20gPSB7fSxcbiAgICAgIG1heCA9IGRlbGltaXRlcnMubGVuZ3RoO1xuXG4gIGlmICghbWF4KSByZXR1cm47XG5cbiAgLy8gaGVhZGVySWR4IGlzIHRoZSBmaXJzdCBkZWxpbWl0ZXIgb2YgdGhlIGN1cnJlbnQgKHdoZXJlIGNsb3NlciBpcykgZGVsaW1pdGVyIHJ1blxuICB2YXIgaGVhZGVySWR4ID0gMDtcbiAgdmFyIGxhc3RUb2tlbklkeCA9IC0yOyAvLyBuZWVkcyBhbnkgdmFsdWUgbG93ZXIgdGhhbiAtMVxuICB2YXIganVtcHMgPSBbXTtcblxuICBmb3IgKGNsb3NlcklkeCA9IDA7IGNsb3NlcklkeCA8IG1heDsgY2xvc2VySWR4KyspIHtcbiAgICBjbG9zZXIgPSBkZWxpbWl0ZXJzW2Nsb3NlcklkeF07XG5cbiAgICBqdW1wcy5wdXNoKDApO1xuXG4gICAgLy8gbWFya2VycyBiZWxvbmcgdG8gc2FtZSBkZWxpbWl0ZXIgcnVuIGlmOlxuICAgIC8vICAtIHRoZXkgaGF2ZSBhZGphY2VudCB0b2tlbnNcbiAgICAvLyAgLSBBTkQgbWFya2VycyBhcmUgdGhlIHNhbWVcbiAgICAvL1xuICAgIGlmIChkZWxpbWl0ZXJzW2hlYWRlcklkeF0ubWFya2VyICE9PSBjbG9zZXIubWFya2VyIHx8IGxhc3RUb2tlbklkeCAhPT0gY2xvc2VyLnRva2VuIC0gMSkge1xuICAgICAgaGVhZGVySWR4ID0gY2xvc2VySWR4O1xuICAgIH1cblxuICAgIGxhc3RUb2tlbklkeCA9IGNsb3Nlci50b2tlbjtcblxuICAgIC8vIExlbmd0aCBpcyBvbmx5IHVzZWQgZm9yIGVtcGhhc2lzLXNwZWNpZmljIFwicnVsZSBvZiAzXCIsXG4gICAgLy8gaWYgaXQncyBub3QgZGVmaW5lZCAoaW4gc3RyaWtldGhyb3VnaCBvciAzcmQgcGFydHkgcGx1Z2lucyksXG4gICAgLy8gd2UgY2FuIGRlZmF1bHQgaXQgdG8gMCB0byBkaXNhYmxlIHRob3NlIGNoZWNrcy5cbiAgICAvL1xuICAgIGNsb3Nlci5sZW5ndGggPSBjbG9zZXIubGVuZ3RoIHx8IDA7XG5cbiAgICBpZiAoIWNsb3Nlci5jbG9zZSkgY29udGludWU7XG5cbiAgICAvLyBQcmV2aW91c2x5IGNhbGN1bGF0ZWQgbG93ZXIgYm91bmRzIChwcmV2aW91cyBmYWlscylcbiAgICAvLyBmb3IgZWFjaCBtYXJrZXIsIGVhY2ggZGVsaW1pdGVyIGxlbmd0aCBtb2R1bG8gMyxcbiAgICAvLyBhbmQgZm9yIHdoZXRoZXIgdGhpcyBjbG9zZXIgY2FuIGJlIGFuIG9wZW5lcjtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY29tbW9ubWFyay9jbWFyay9jb21taXQvMzQyNTBlMTJjY2ViZGM2MzcyYjhiNDljNDRmYWI1N2M3MjQ0MzQ2MFxuICAgIGlmICghb3BlbmVyc0JvdHRvbS5oYXNPd25Qcm9wZXJ0eShjbG9zZXIubWFya2VyKSkge1xuICAgICAgb3BlbmVyc0JvdHRvbVtjbG9zZXIubWFya2VyXSA9IFsgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSBdO1xuICAgIH1cblxuICAgIG1pbk9wZW5lcklkeCA9IG9wZW5lcnNCb3R0b21bY2xvc2VyLm1hcmtlcl1bKGNsb3Nlci5vcGVuID8gMyA6IDApICsgKGNsb3Nlci5sZW5ndGggJSAzKV07XG5cbiAgICBvcGVuZXJJZHggPSBoZWFkZXJJZHggLSBqdW1wc1toZWFkZXJJZHhdIC0gMTtcblxuICAgIG5ld01pbk9wZW5lcklkeCA9IG9wZW5lcklkeDtcblxuICAgIGZvciAoOyBvcGVuZXJJZHggPiBtaW5PcGVuZXJJZHg7IG9wZW5lcklkeCAtPSBqdW1wc1tvcGVuZXJJZHhdICsgMSkge1xuICAgICAgb3BlbmVyID0gZGVsaW1pdGVyc1tvcGVuZXJJZHhdO1xuXG4gICAgICBpZiAob3BlbmVyLm1hcmtlciAhPT0gY2xvc2VyLm1hcmtlcikgY29udGludWU7XG5cbiAgICAgIGlmIChvcGVuZXIub3BlbiAmJiBvcGVuZXIuZW5kIDwgMCkge1xuXG4gICAgICAgIGlzT2RkTWF0Y2ggPSBmYWxzZTtcblxuICAgICAgICAvLyBmcm9tIHNwZWM6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIG9uZSBvZiB0aGUgZGVsaW1pdGVycyBjYW4gYm90aCBvcGVuIGFuZCBjbG9zZSBlbXBoYXNpcywgdGhlbiB0aGVcbiAgICAgICAgLy8gc3VtIG9mIHRoZSBsZW5ndGhzIG9mIHRoZSBkZWxpbWl0ZXIgcnVucyBjb250YWluaW5nIHRoZSBvcGVuaW5nIGFuZFxuICAgICAgICAvLyBjbG9zaW5nIGRlbGltaXRlcnMgbXVzdCBub3QgYmUgYSBtdWx0aXBsZSBvZiAzIHVubGVzcyBib3RoIGxlbmd0aHNcbiAgICAgICAgLy8gYXJlIG11bHRpcGxlcyBvZiAzLlxuICAgICAgICAvL1xuICAgICAgICBpZiAob3BlbmVyLmNsb3NlIHx8IGNsb3Nlci5vcGVuKSB7XG4gICAgICAgICAgaWYgKChvcGVuZXIubGVuZ3RoICsgY2xvc2VyLmxlbmd0aCkgJSAzID09PSAwKSB7XG4gICAgICAgICAgICBpZiAob3BlbmVyLmxlbmd0aCAlIDMgIT09IDAgfHwgY2xvc2VyLmxlbmd0aCAlIDMgIT09IDApIHtcbiAgICAgICAgICAgICAgaXNPZGRNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc09kZE1hdGNoKSB7XG4gICAgICAgICAgLy8gSWYgcHJldmlvdXMgZGVsaW1pdGVyIGNhbm5vdCBiZSBhbiBvcGVuZXIsIHdlIGNhbiBzYWZlbHkgc2tpcFxuICAgICAgICAgIC8vIHRoZSBlbnRpcmUgc2VxdWVuY2UgaW4gZnV0dXJlIGNoZWNrcy4gVGhpcyBpcyByZXF1aXJlZCB0byBtYWtlXG4gICAgICAgICAgLy8gc3VyZSBhbGdvcml0aG0gaGFzIGxpbmVhciBjb21wbGV4aXR5IChzZWUgKl8qXypfKl8qXy4uLiBjYXNlKS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIGxhc3RKdW1wID0gb3BlbmVySWR4ID4gMCAmJiAhZGVsaW1pdGVyc1tvcGVuZXJJZHggLSAxXS5vcGVuID9cbiAgICAgICAgICAgIGp1bXBzW29wZW5lcklkeCAtIDFdICsgMSA6XG4gICAgICAgICAgICAwO1xuXG4gICAgICAgICAganVtcHNbY2xvc2VySWR4XSA9IGNsb3NlcklkeCAtIG9wZW5lcklkeCArIGxhc3RKdW1wO1xuICAgICAgICAgIGp1bXBzW29wZW5lcklkeF0gPSBsYXN0SnVtcDtcblxuICAgICAgICAgIGNsb3Nlci5vcGVuICA9IGZhbHNlO1xuICAgICAgICAgIG9wZW5lci5lbmQgICA9IGNsb3NlcklkeDtcbiAgICAgICAgICBvcGVuZXIuY2xvc2UgPSBmYWxzZTtcbiAgICAgICAgICBuZXdNaW5PcGVuZXJJZHggPSAtMTtcbiAgICAgICAgICAvLyB0cmVhdCBuZXh0IHRva2VuIGFzIHN0YXJ0IG9mIHJ1bixcbiAgICAgICAgICAvLyBpdCBvcHRpbWl6ZXMgc2tpcHMgaW4gKio8Li4uPioqYSoqPC4uLj4qKiBwYXRob2xvZ2ljYWwgY2FzZVxuICAgICAgICAgIGxhc3RUb2tlbklkeCA9IC0yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5ld01pbk9wZW5lcklkeCAhPT0gLTEpIHtcbiAgICAgIC8vIElmIG1hdGNoIGZvciB0aGlzIGRlbGltaXRlciBydW4gZmFpbGVkLCB3ZSB3YW50IHRvIHNldCBsb3dlciBib3VuZCBmb3JcbiAgICAgIC8vIGZ1dHVyZSBsb29rdXBzLiBUaGlzIGlzIHJlcXVpcmVkIHRvIG1ha2Ugc3VyZSBhbGdvcml0aG0gaGFzIGxpbmVhclxuICAgICAgLy8gY29tcGxleGl0eS5cbiAgICAgIC8vXG4gICAgICAvLyBTZWUgZGV0YWlscyBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvbW1vbm1hcmsvY21hcmsvaXNzdWVzLzE3OCNpc3N1ZWNvbW1lbnQtMjcwNDE3NDQyXG4gICAgICAvL1xuICAgICAgb3BlbmVyc0JvdHRvbVtjbG9zZXIubWFya2VyXVsoY2xvc2VyLm9wZW4gPyAzIDogMCkgKyAoKGNsb3Nlci5sZW5ndGggfHwgMCkgJSAzKV0gPSBuZXdNaW5PcGVuZXJJZHg7XG4gICAgfVxuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5rX3BhaXJzKHN0YXRlKSB7XG4gIHZhciBjdXJyLFxuICAgICAgdG9rZW5zX21ldGEgPSBzdGF0ZS50b2tlbnNfbWV0YSxcbiAgICAgIG1heCA9IHN0YXRlLnRva2Vuc19tZXRhLmxlbmd0aDtcblxuICBwcm9jZXNzRGVsaW1pdGVycyhzdGF0ZSwgc3RhdGUuZGVsaW1pdGVycyk7XG5cbiAgZm9yIChjdXJyID0gMDsgY3VyciA8IG1heDsgY3VycisrKSB7XG4gICAgaWYgKHRva2Vuc19tZXRhW2N1cnJdICYmIHRva2Vuc19tZXRhW2N1cnJdLmRlbGltaXRlcnMpIHtcbiAgICAgIHByb2Nlc3NEZWxpbWl0ZXJzKHN0YXRlLCB0b2tlbnNfbWV0YVtjdXJyXS5kZWxpbWl0ZXJzKTtcbiAgICB9XG4gIH1cbn07XG4iLCIvLyBQcm9jZXNzICp0aGlzKiBhbmQgX3RoYXRfXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIEluc2VydCBlYWNoIG1hcmtlciBhcyBhIHNlcGFyYXRlIHRleHQgdG9rZW4sIGFuZCBhZGQgaXQgdG8gZGVsaW1pdGVyIGxpc3Rcbi8vXG5tb2R1bGUuZXhwb3J0cy50b2tlbml6ZSA9IGZ1bmN0aW9uIGVtcGhhc2lzKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGksIHNjYW5uZWQsIHRva2VuLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAobWFya2VyICE9PSAweDVGIC8qIF8gKi8gJiYgbWFya2VyICE9PSAweDJBIC8qICogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc2Nhbm5lZCA9IHN0YXRlLnNjYW5EZWxpbXMoc3RhdGUucG9zLCBtYXJrZXIgPT09IDB4MkEpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzY2FubmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcblxuICAgIHN0YXRlLmRlbGltaXRlcnMucHVzaCh7XG4gICAgICAvLyBDaGFyIGNvZGUgb2YgdGhlIHN0YXJ0aW5nIG1hcmtlciAobnVtYmVyKS5cbiAgICAgIC8vXG4gICAgICBtYXJrZXI6IG1hcmtlcixcblxuICAgICAgLy8gVG90YWwgbGVuZ3RoIG9mIHRoZXNlIHNlcmllcyBvZiBkZWxpbWl0ZXJzLlxuICAgICAgLy9cbiAgICAgIGxlbmd0aDogc2Nhbm5lZC5sZW5ndGgsXG5cbiAgICAgIC8vIEEgcG9zaXRpb24gb2YgdGhlIHRva2VuIHRoaXMgZGVsaW1pdGVyIGNvcnJlc3BvbmRzIHRvLlxuICAgICAgLy9cbiAgICAgIHRva2VuOiAgc3RhdGUudG9rZW5zLmxlbmd0aCAtIDEsXG5cbiAgICAgIC8vIElmIHRoaXMgZGVsaW1pdGVyIGlzIG1hdGNoZWQgYXMgYSB2YWxpZCBvcGVuZXIsIGBlbmRgIHdpbGwgYmVcbiAgICAgIC8vIGVxdWFsIHRvIGl0cyBwb3NpdGlvbiwgb3RoZXJ3aXNlIGl0J3MgYC0xYC5cbiAgICAgIC8vXG4gICAgICBlbmQ6ICAgIC0xLFxuXG4gICAgICAvLyBCb29sZWFuIGZsYWdzIHRoYXQgZGV0ZXJtaW5lIGlmIHRoaXMgZGVsaW1pdGVyIGNvdWxkIG9wZW4gb3IgY2xvc2VcbiAgICAgIC8vIGFuIGVtcGhhc2lzLlxuICAgICAgLy9cbiAgICAgIG9wZW46ICAgc2Nhbm5lZC5jYW5fb3BlbixcbiAgICAgIGNsb3NlOiAgc2Nhbm5lZC5jYW5fY2xvc2VcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRlLnBvcyArPSBzY2FubmVkLmxlbmd0aDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuZnVuY3Rpb24gcG9zdFByb2Nlc3Moc3RhdGUsIGRlbGltaXRlcnMpIHtcbiAgdmFyIGksXG4gICAgICBzdGFydERlbGltLFxuICAgICAgZW5kRGVsaW0sXG4gICAgICB0b2tlbixcbiAgICAgIGNoLFxuICAgICAgaXNTdHJvbmcsXG4gICAgICBtYXggPSBkZWxpbWl0ZXJzLmxlbmd0aDtcblxuICBmb3IgKGkgPSBtYXggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHN0YXJ0RGVsaW0gPSBkZWxpbWl0ZXJzW2ldO1xuXG4gICAgaWYgKHN0YXJ0RGVsaW0ubWFya2VyICE9PSAweDVGLyogXyAqLyAmJiBzdGFydERlbGltLm1hcmtlciAhPT0gMHgyQS8qICogKi8pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3Mgb25seSBvcGVuaW5nIG1hcmtlcnNcbiAgICBpZiAoc3RhcnREZWxpbS5lbmQgPT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBlbmREZWxpbSA9IGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmRdO1xuXG4gICAgLy8gSWYgdGhlIHByZXZpb3VzIGRlbGltaXRlciBoYXMgdGhlIHNhbWUgbWFya2VyIGFuZCBpcyBhZGphY2VudCB0byB0aGlzIG9uZSxcbiAgICAvLyBtZXJnZSB0aG9zZSBpbnRvIG9uZSBzdHJvbmcgZGVsaW1pdGVyLlxuICAgIC8vXG4gICAgLy8gYDxlbT48ZW0+d2hhdGV2ZXI8L2VtPjwvZW0+YCAtPiBgPHN0cm9uZz53aGF0ZXZlcjwvc3Ryb25nPmBcbiAgICAvL1xuICAgIGlzU3Ryb25nID0gaSA+IDAgJiZcbiAgICAgICAgICAgICAgIGRlbGltaXRlcnNbaSAtIDFdLmVuZCA9PT0gc3RhcnREZWxpbS5lbmQgKyAxICYmXG4gICAgICAgICAgICAgICAvLyBjaGVjayB0aGF0IGZpcnN0IHR3byBtYXJrZXJzIG1hdGNoIGFuZCBhZGphY2VudFxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tpIC0gMV0ubWFya2VyID09PSBzdGFydERlbGltLm1hcmtlciAmJlxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tpIC0gMV0udG9rZW4gPT09IHN0YXJ0RGVsaW0udG9rZW4gLSAxICYmXG4gICAgICAgICAgICAgICAvLyBjaGVjayB0aGF0IGxhc3QgdHdvIG1hcmtlcnMgYXJlIGFkamFjZW50ICh3ZSBjYW4gc2FmZWx5IGFzc3VtZSB0aGV5IG1hdGNoKVxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tzdGFydERlbGltLmVuZCArIDFdLnRva2VuID09PSBlbmREZWxpbS50b2tlbiArIDE7XG5cbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnREZWxpbS5tYXJrZXIpO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tzdGFydERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nX29wZW4nIDogJ2VtX29wZW4nO1xuICAgIHRva2VuLnRhZyAgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmcnIDogJ2VtJztcbiAgICB0b2tlbi5uZXN0aW5nID0gMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gaXNTdHJvbmcgPyBjaCArIGNoIDogY2g7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZ19jbG9zZScgOiAnZW1fY2xvc2UnO1xuICAgIHRva2VuLnRhZyAgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmcnIDogJ2VtJztcbiAgICB0b2tlbi5uZXN0aW5nID0gLTE7XG4gICAgdG9rZW4ubWFya3VwICA9IGlzU3Ryb25nID8gY2ggKyBjaCA6IGNoO1xuICAgIHRva2VuLmNvbnRlbnQgPSAnJztcblxuICAgIGlmIChpc1N0cm9uZykge1xuICAgICAgc3RhdGUudG9rZW5zW2RlbGltaXRlcnNbaSAtIDFdLnRva2VuXS5jb250ZW50ID0gJyc7XG4gICAgICBzdGF0ZS50b2tlbnNbZGVsaW1pdGVyc1tzdGFydERlbGltLmVuZCArIDFdLnRva2VuXS5jb250ZW50ID0gJyc7XG4gICAgICBpLS07XG4gICAgfVxuICB9XG59XG5cblxuLy8gV2FsayB0aHJvdWdoIGRlbGltaXRlciBsaXN0IGFuZCByZXBsYWNlIHRleHQgdG9rZW5zIHdpdGggdGFnc1xuLy9cbm1vZHVsZS5leHBvcnRzLnBvc3RQcm9jZXNzID0gZnVuY3Rpb24gZW1waGFzaXMoc3RhdGUpIHtcbiAgdmFyIGN1cnIsXG4gICAgICB0b2tlbnNfbWV0YSA9IHN0YXRlLnRva2Vuc19tZXRhLFxuICAgICAgbWF4ID0gc3RhdGUudG9rZW5zX21ldGEubGVuZ3RoO1xuXG4gIHBvc3RQcm9jZXNzKHN0YXRlLCBzdGF0ZS5kZWxpbWl0ZXJzKTtcblxuICBmb3IgKGN1cnIgPSAwOyBjdXJyIDwgbWF4OyBjdXJyKyspIHtcbiAgICBpZiAodG9rZW5zX21ldGFbY3Vycl0gJiYgdG9rZW5zX21ldGFbY3Vycl0uZGVsaW1pdGVycykge1xuICAgICAgcG9zdFByb2Nlc3Moc3RhdGUsIHRva2Vuc19tZXRhW2N1cnJdLmRlbGltaXRlcnMpO1xuICAgIH1cbiAgfVxufTtcbiIsIi8vIFByb2Nlc3MgaHRtbCBlbnRpdHkgLSAmIzEyMzssICYjeEFGOywgJnF1b3Q7LCAuLi5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW50aXRpZXMgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vZW50aXRpZXMnKTtcbnZhciBoYXMgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmhhcztcbnZhciBpc1ZhbGlkRW50aXR5Q29kZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzVmFsaWRFbnRpdHlDb2RlO1xudmFyIGZyb21Db2RlUG9pbnQgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuZnJvbUNvZGVQb2ludDtcblxuXG52YXIgRElHSVRBTF9SRSA9IC9eJiMoKD86eFthLWYwLTldezEsNn18WzAtOV17MSw3fSkpOy9pO1xudmFyIE5BTUVEX1JFICAgPSAvXiYoW2Etel1bYS16MC05XXsxLDMxfSk7L2k7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbnRpdHkoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgY2gsIGNvZGUsIG1hdGNoLCBwb3MgPSBzdGF0ZS5wb3MsIG1heCA9IHN0YXRlLnBvc01heDtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyNi8qICYgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHBvcyArIDEgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuXG4gICAgaWYgKGNoID09PSAweDIzIC8qICMgKi8pIHtcbiAgICAgIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goRElHSVRBTF9SRSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICBjb2RlID0gbWF0Y2hbMV1bMF0udG9Mb3dlckNhc2UoKSA9PT0gJ3gnID8gcGFyc2VJbnQobWF0Y2hbMV0uc2xpY2UoMSksIDE2KSA6IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICAgICAgc3RhdGUucGVuZGluZyArPSBpc1ZhbGlkRW50aXR5Q29kZShjb2RlKSA/IGZyb21Db2RlUG9pbnQoY29kZSkgOiBmcm9tQ29kZVBvaW50KDB4RkZGRCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goTkFNRURfUkUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGlmIChoYXMoZW50aXRpZXMsIG1hdGNoWzFdKSkge1xuICAgICAgICAgIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gZW50aXRpZXNbbWF0Y2hbMV1dOyB9XG4gICAgICAgICAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gJyYnOyB9XG4gIHN0YXRlLnBvcysrO1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBQcm9jZXNzIGVzY2FwZWQgY2hhcnMgYW5kIGhhcmRicmVha3NcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cbnZhciBFU0NBUEVEID0gW107XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHsgRVNDQVBFRC5wdXNoKDApOyB9XG5cbidcXFxcIVwiIyQlJlxcJygpKissLi86Ozw9Pj9AW11eX2B7fH1+LSdcbiAgLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaCkgeyBFU0NBUEVEW2NoLmNoYXJDb2RlQXQoMCldID0gMTsgfSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlc2NhcGUoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgY2gsIHBvcyA9IHN0YXRlLnBvcywgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDVDLyogXFwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zKys7XG5cbiAgaWYgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjaCA8IDI1NiAmJiBFU0NBUEVEW2NoXSAhPT0gMCkge1xuICAgICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmNbcG9zXTsgfVxuICAgICAgc3RhdGUucG9zICs9IDI7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IDB4MEEpIHtcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHN0YXRlLnB1c2goJ2hhcmRicmVhaycsICdicicsIDApO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICAgIC8vIHNraXAgbGVhZGluZyB3aGl0ZXNwYWNlcyBmcm9tIG5leHQgbGluZVxuICAgICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjaCkpIHsgYnJlYWs7IH1cbiAgICAgICAgcG9zKys7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnBvcyA9IHBvcztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gJ1xcXFwnOyB9XG4gIHN0YXRlLnBvcysrO1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBQcm9jZXNzIGh0bWwgdGFnc1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIEhUTUxfVEFHX1JFID0gcmVxdWlyZSgnLi4vY29tbW9uL2h0bWxfcmUnKS5IVE1MX1RBR19SRTtcblxuXG5mdW5jdGlvbiBpc0xldHRlcihjaCkge1xuICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuICB2YXIgbGMgPSBjaCB8IDB4MjA7IC8vIHRvIGxvd2VyIGNhc2VcbiAgcmV0dXJuIChsYyA+PSAweDYxLyogYSAqLykgJiYgKGxjIDw9IDB4N2EvKiB6ICovKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGh0bWxfaW5saW5lKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBtYXRjaCwgbWF4LCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLnBvcztcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuaHRtbCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBDaGVjayBzdGFydFxuICBtYXggPSBzdGF0ZS5wb3NNYXg7XG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDNDLyogPCAqLyB8fFxuICAgICAgcG9zICsgMiA+PSBtYXgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBRdWljayBmYWlsIG9uIHNlY29uZCBjaGFyXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gIGlmIChjaCAhPT0gMHgyMS8qICEgKi8gJiZcbiAgICAgIGNoICE9PSAweDNGLyogPyAqLyAmJlxuICAgICAgY2ggIT09IDB4MkYvKiAvICovICYmXG4gICAgICAhaXNMZXR0ZXIoY2gpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChIVE1MX1RBR19SRSk7XG4gIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnaHRtbF9pbmxpbmUnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIHBvcyArIG1hdGNoWzBdLmxlbmd0aCk7XG4gIH1cbiAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gUHJvY2VzcyAhW2ltYWdlXSg8c3JjPiBcInRpdGxlXCIpXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xudmFyIGlzU3BhY2UgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGltYWdlKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGF0dHJzLFxuICAgICAgY29kZSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsRW5kLFxuICAgICAgbGFiZWxTdGFydCxcbiAgICAgIHBvcyxcbiAgICAgIHJlZixcbiAgICAgIHJlcyxcbiAgICAgIHRpdGxlLFxuICAgICAgdG9rZW4sXG4gICAgICB0b2tlbnMsXG4gICAgICBzdGFydCxcbiAgICAgIGhyZWYgPSAnJyxcbiAgICAgIG9sZFBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heDtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSAhPT0gMHgyMS8qICEgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MgKyAxKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFiZWxTdGFydCA9IHN0YXRlLnBvcyArIDI7XG4gIGxhYmVsRW5kID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhdGUucG9zICsgMSwgZmFsc2UpO1xuXG4gIC8vIHBhcnNlciBmYWlsZWQgdG8gZmluZCAnXScsIHNvIGl0J3Mgbm90IGEgdmFsaWQgbGlua1xuICBpZiAobGFiZWxFbmQgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDI4LyogKCAqLykge1xuICAgIC8vXG4gICAgLy8gSW5saW5lIGxpbmtcbiAgICAvL1xuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgcG9zKys7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgIF5eXl5eXiBwYXJzaW5nIGxpbmsgZGVzdGluYXRpb25cbiAgICBzdGFydCA9IHBvcztcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChyZXMub2spIHtcbiAgICAgIGhyZWYgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHJlcy5zdHIpO1xuICAgICAgaWYgKHN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkge1xuICAgICAgICBwb3MgPSByZXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHJlZiA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgICAgICAgICAgXl5eXl5eXiBwYXJzaW5nIGxpbmsgdGl0bGVcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcbiAgICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICAgIHBvcyA9IHJlcy5wb3M7XG5cbiAgICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZSA9ICcnO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gbWF4IHx8IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjkvKiApICovKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHBvcysrO1xuICB9IGVsc2Uge1xuICAgIC8vXG4gICAgLy8gTGluayByZWZlcmVuY2VcbiAgICAvL1xuICAgIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDVCLyogWyAqLykge1xuICAgICAgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgcG9zID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgcG9zKTtcbiAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgfVxuXG4gICAgLy8gY292ZXJzIGxhYmVsID09PSAnJyBhbmQgbGFiZWwgPT09IHVuZGVmaW5lZFxuICAgIC8vIChjb2xsYXBzZWQgcmVmZXJlbmNlIGxpbmsgYW5kIHNob3J0Y3V0IHJlZmVyZW5jZSBsaW5rIHJlc3BlY3RpdmVseSlcbiAgICBpZiAoIWxhYmVsKSB7IGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKGxhYmVsU3RhcnQsIGxhYmVsRW5kKTsgfVxuXG4gICAgcmVmID0gc3RhdGUuZW52LnJlZmVyZW5jZXNbbm9ybWFsaXplUmVmZXJlbmNlKGxhYmVsKV07XG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaHJlZiA9IHJlZi5ocmVmO1xuICAgIHRpdGxlID0gcmVmLnRpdGxlO1xuICB9XG5cbiAgLy9cbiAgLy8gV2UgZm91bmQgdGhlIGVuZCBvZiB0aGUgbGluaywgYW5kIGtub3cgZm9yIGEgZmFjdCBpdCdzIGEgdmFsaWQgbGluaztcbiAgLy8gc28gYWxsIHRoYXQncyBsZWZ0IHRvIGRvIGlzIHRvIGNhbGwgdG9rZW5pemVyLlxuICAvL1xuICBpZiAoIXNpbGVudCkge1xuICAgIGNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpO1xuXG4gICAgc3RhdGUubWQuaW5saW5lLnBhcnNlKFxuICAgICAgY29udGVudCxcbiAgICAgIHN0YXRlLm1kLFxuICAgICAgc3RhdGUuZW52LFxuICAgICAgdG9rZW5zID0gW11cbiAgICApO1xuXG4gICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbWFnZScsICdpbWcnLCAwKTtcbiAgICB0b2tlbi5hdHRycyAgICA9IGF0dHJzID0gWyBbICdzcmMnLCBocmVmIF0sIFsgJ2FsdCcsICcnIF0gXTtcbiAgICB0b2tlbi5jaGlsZHJlbiA9IHRva2VucztcbiAgICB0b2tlbi5jb250ZW50ICA9IGNvbnRlbnQ7XG5cbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGF0dHJzLnB1c2goWyAndGl0bGUnLCB0aXRsZSBdKTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG4gIHN0YXRlLnBvc01heCA9IG1heDtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gUHJvY2VzcyBbbGlua10oPHRvPiBcInN0dWZmXCIpXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xudmFyIGlzU3BhY2UgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpbmsoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgYXR0cnMsXG4gICAgICBjb2RlLFxuICAgICAgbGFiZWwsXG4gICAgICBsYWJlbEVuZCxcbiAgICAgIGxhYmVsU3RhcnQsXG4gICAgICBwb3MsXG4gICAgICByZXMsXG4gICAgICByZWYsXG4gICAgICB0b2tlbixcbiAgICAgIGhyZWYgPSAnJyxcbiAgICAgIHRpdGxlID0gJycsXG4gICAgICBvbGRQb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcyxcbiAgICAgIHBhcnNlUmVmZXJlbmNlID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFiZWxTdGFydCA9IHN0YXRlLnBvcyArIDE7XG4gIGxhYmVsRW5kID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhdGUucG9zLCB0cnVlKTtcblxuICAvLyBwYXJzZXIgZmFpbGVkIHRvIGZpbmQgJ10nLCBzbyBpdCdzIG5vdCBhIHZhbGlkIGxpbmtcbiAgaWYgKGxhYmVsRW5kIDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyOC8qICggKi8pIHtcbiAgICAvL1xuICAgIC8vIElubGluZSBsaW5rXG4gICAgLy9cblxuICAgIC8vIG1pZ2h0IGhhdmUgZm91bmQgYSB2YWxpZCBzaG9ydGN1dCBsaW5rLCBkaXNhYmxlIHJlZmVyZW5jZSBwYXJzaW5nXG4gICAgcGFyc2VSZWZlcmVuY2UgPSBmYWxzZTtcblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgIHBvcysrO1xuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgfVxuICAgIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICBeXl5eXl4gcGFyc2luZyBsaW5rIGRlc3RpbmF0aW9uXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtEZXN0aW5hdGlvbihzdGF0ZS5zcmMsIHBvcywgc3RhdGUucG9zTWF4KTtcbiAgICBpZiAocmVzLm9rKSB7XG4gICAgICBocmVmID0gc3RhdGUubWQubm9ybWFsaXplTGluayhyZXMuc3RyKTtcbiAgICAgIGlmIChzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoaHJlZikpIHtcbiAgICAgICAgcG9zID0gcmVzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhyZWYgPSAnJztcbiAgICAgIH1cblxuICAgICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAgIC8vICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgICAgc3RhcnQgPSBwb3M7XG4gICAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICAgIH1cblxuICAgICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgXl5eXl5eXiBwYXJzaW5nIGxpbmsgdGl0bGVcbiAgICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXJ0ICE9PSBwb3MgJiYgcmVzLm9rKSB7XG4gICAgICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICAgICAgcG9zID0gcmVzLnBvcztcblxuICAgICAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICAgICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSBtYXggfHwgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyOS8qICkgKi8pIHtcbiAgICAgIC8vIHBhcnNpbmcgYSB2YWxpZCBzaG9ydGN1dCBsaW5rIGZhaWxlZCwgZmFsbGJhY2sgdG8gcmVmZXJlbmNlXG4gICAgICBwYXJzZVJlZmVyZW5jZSA9IHRydWU7XG4gICAgfVxuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHBhcnNlUmVmZXJlbmNlKSB7XG4gICAgLy9cbiAgICAvLyBMaW5rIHJlZmVyZW5jZVxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUIvKiBbICovKSB7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgICBwb3MgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBwb3MpO1xuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICB9XG5cbiAgICAvLyBjb3ZlcnMgbGFiZWwgPT09ICcnIGFuZCBsYWJlbCA9PT0gdW5kZWZpbmVkXG4gICAgLy8gKGNvbGxhcHNlZCByZWZlcmVuY2UgbGluayBhbmQgc2hvcnRjdXQgcmVmZXJlbmNlIGxpbmsgcmVzcGVjdGl2ZWx5KVxuICAgIGlmICghbGFiZWwpIHsgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpOyB9XG5cbiAgICByZWYgPSBzdGF0ZS5lbnYucmVmZXJlbmNlc1tub3JtYWxpemVSZWZlcmVuY2UobGFiZWwpXTtcbiAgICBpZiAoIXJlZikge1xuICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBocmVmID0gcmVmLmhyZWY7XG4gICAgdGl0bGUgPSByZWYudGl0bGU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBmb3VuZCB0aGUgZW5kIG9mIHRoZSBsaW5rLCBhbmQga25vdyBmb3IgYSBmYWN0IGl0J3MgYSB2YWxpZCBsaW5rO1xuICAvLyBzbyBhbGwgdGhhdCdzIGxlZnQgdG8gZG8gaXMgdG8gY2FsbCB0b2tlbml6ZXIuXG4gIC8vXG4gIGlmICghc2lsZW50KSB7XG4gICAgc3RhdGUucG9zID0gbGFiZWxTdGFydDtcbiAgICBzdGF0ZS5wb3NNYXggPSBsYWJlbEVuZDtcblxuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgdG9rZW4uYXR0cnMgID0gYXR0cnMgPSBbIFsgJ2hyZWYnLCBocmVmIF0gXTtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGF0dHJzLnB1c2goWyAndGl0bGUnLCB0aXRsZSBdKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5tZC5pbmxpbmUudG9rZW5pemUoc3RhdGUpO1xuXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlua19jbG9zZScsICdhJywgLTEpO1xuICB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuICBzdGF0ZS5wb3NNYXggPSBtYXg7XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIFByb2NlZXNzICdcXG4nXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbmV3bGluZShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBwbWF4LCBtYXgsIHdzLCBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEvKiBcXG4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG1heCA9IHN0YXRlLnBlbmRpbmcubGVuZ3RoIC0gMTtcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIC8vICcgIFxcbicgLT4gaGFyZGJyZWFrXG4gIC8vIExvb2t1cCBpbiBwZW5kaW5nIGNoYXJzIGlzIGJhZCBwcmFjdGljZSEgRG9uJ3QgY29weSB0byBvdGhlciBydWxlcyFcbiAgLy8gUGVuZGluZyBzdHJpbmcgaXMgc3RvcmVkIGluIGNvbmNhdCBtb2RlLCBpbmRleGVkIGxvb2t1cHMgd2lsbCBjYXVzZVxuICAvLyBjb252ZXJ0aW9uIHRvIGZsYXQgbW9kZS5cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICBpZiAocG1heCA+PSAwICYmIHN0YXRlLnBlbmRpbmcuY2hhckNvZGVBdChwbWF4KSA9PT0gMHgyMCkge1xuICAgICAgaWYgKHBtYXggPj0gMSAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQocG1heCAtIDEpID09PSAweDIwKSB7XG4gICAgICAgIC8vIEZpbmQgd2hpdGVzcGFjZXMgdGFpbCBvZiBwZW5kaW5nIGNoYXJzLlxuICAgICAgICB3cyA9IHBtYXggLSAxO1xuICAgICAgICB3aGlsZSAod3MgPj0gMSAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQod3MgLSAxKSA9PT0gMHgyMCkgd3MtLTtcblxuICAgICAgICBzdGF0ZS5wZW5kaW5nID0gc3RhdGUucGVuZGluZy5zbGljZSgwLCB3cyk7XG4gICAgICAgIHN0YXRlLnB1c2goJ2hhcmRicmVhaycsICdicicsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucGVuZGluZyA9IHN0YXRlLnBlbmRpbmcuc2xpY2UoMCwgLTEpO1xuICAgICAgICBzdGF0ZS5wdXNoKCdzb2Z0YnJlYWsnLCAnYnInLCAwKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wdXNoKCdzb2Z0YnJlYWsnLCAnYnInLCAwKTtcbiAgICB9XG4gIH1cblxuICBwb3MrKztcblxuICAvLyBza2lwIGhlYWRpbmcgc3BhY2VzIGZvciBuZXh0IGxpbmVcbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBpc1NwYWNlKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykpKSB7IHBvcysrOyB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBJbmxpbmUgcGFyc2VyIHN0YXRlXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgVG9rZW4gICAgICAgICAgPSByZXF1aXJlKCcuLi90b2tlbicpO1xudmFyIGlzV2hpdGVTcGFjZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNXaGl0ZVNwYWNlO1xudmFyIGlzUHVuY3RDaGFyICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNQdW5jdENoYXI7XG52YXIgaXNNZEFzY2lpUHVuY3QgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc01kQXNjaWlQdW5jdDtcblxuXG5mdW5jdGlvbiBTdGF0ZUlubGluZShzcmMsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB0aGlzLnNyYyA9IHNyYztcbiAgdGhpcy5lbnYgPSBlbnY7XG4gIHRoaXMubWQgPSBtZDtcbiAgdGhpcy50b2tlbnMgPSBvdXRUb2tlbnM7XG4gIHRoaXMudG9rZW5zX21ldGEgPSBBcnJheShvdXRUb2tlbnMubGVuZ3RoKTtcblxuICB0aGlzLnBvcyA9IDA7XG4gIHRoaXMucG9zTWF4ID0gdGhpcy5zcmMubGVuZ3RoO1xuICB0aGlzLmxldmVsID0gMDtcbiAgdGhpcy5wZW5kaW5nID0gJyc7XG4gIHRoaXMucGVuZGluZ0xldmVsID0gMDtcblxuICAvLyBTdG9yZXMgeyBzdGFydDogZW5kIH0gcGFpcnMuIFVzZWZ1bCBmb3IgYmFja3RyYWNrXG4gIC8vIG9wdGltaXphdGlvbiBvZiBwYWlycyBwYXJzZSAoZW1waGFzaXMsIHN0cmlrZXMpLlxuICB0aGlzLmNhY2hlID0ge307XG5cbiAgLy8gTGlzdCBvZiBlbXBoYXNpcy1saWtlIGRlbGltaXRlcnMgZm9yIGN1cnJlbnQgdGFnXG4gIHRoaXMuZGVsaW1pdGVycyA9IFtdO1xuXG4gIC8vIFN0YWNrIG9mIGRlbGltaXRlciBsaXN0cyBmb3IgdXBwZXIgbGV2ZWwgdGFnc1xuICB0aGlzLl9wcmV2X2RlbGltaXRlcnMgPSBbXTtcblxuICAvLyBiYWNrdGljayBsZW5ndGggPT4gbGFzdCBzZWVuIHBvc2l0aW9uXG4gIHRoaXMuYmFja3RpY2tzID0ge307XG4gIHRoaXMuYmFja3RpY2tzU2Nhbm5lZCA9IGZhbHNlO1xufVxuXG5cbi8vIEZsdXNoIHBlbmRpbmcgdGV4dFxuLy9cblN0YXRlSW5saW5lLnByb3RvdHlwZS5wdXNoUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKCd0ZXh0JywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ID0gdGhpcy5wZW5kaW5nO1xuICB0b2tlbi5sZXZlbCA9IHRoaXMucGVuZGluZ0xldmVsO1xuICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgdGhpcy5wZW5kaW5nID0gJyc7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblxuLy8gUHVzaCBuZXcgdG9rZW4gdG8gXCJzdHJlYW1cIi5cbi8vIElmIHBlbmRpbmcgdGV4dCBleGlzdHMgLSBmbHVzaCBpdCBhcyB0ZXh0IHRva2VuXG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodHlwZSwgdGFnLCBuZXN0aW5nKSB7XG4gIGlmICh0aGlzLnBlbmRpbmcpIHtcbiAgICB0aGlzLnB1c2hQZW5kaW5nKCk7XG4gIH1cblxuICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKTtcbiAgdmFyIHRva2VuX21ldGEgPSBudWxsO1xuXG4gIGlmIChuZXN0aW5nIDwgMCkge1xuICAgIC8vIGNsb3NpbmcgdGFnXG4gICAgdGhpcy5sZXZlbC0tO1xuICAgIHRoaXMuZGVsaW1pdGVycyA9IHRoaXMuX3ByZXZfZGVsaW1pdGVycy5wb3AoKTtcbiAgfVxuXG4gIHRva2VuLmxldmVsID0gdGhpcy5sZXZlbDtcblxuICBpZiAobmVzdGluZyA+IDApIHtcbiAgICAvLyBvcGVuaW5nIHRhZ1xuICAgIHRoaXMubGV2ZWwrKztcbiAgICB0aGlzLl9wcmV2X2RlbGltaXRlcnMucHVzaCh0aGlzLmRlbGltaXRlcnMpO1xuICAgIHRoaXMuZGVsaW1pdGVycyA9IFtdO1xuICAgIHRva2VuX21ldGEgPSB7IGRlbGltaXRlcnM6IHRoaXMuZGVsaW1pdGVycyB9O1xuICB9XG5cbiAgdGhpcy5wZW5kaW5nTGV2ZWwgPSB0aGlzLmxldmVsO1xuICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgdGhpcy50b2tlbnNfbWV0YS5wdXNoKHRva2VuX21ldGEpO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5cbi8vIFNjYW4gYSBzZXF1ZW5jZSBvZiBlbXBoYXNpcy1saWtlIG1hcmtlcnMsIGFuZCBkZXRlcm1pbmUgd2hldGhlclxuLy8gaXQgY2FuIHN0YXJ0IGFuIGVtcGhhc2lzIHNlcXVlbmNlIG9yIGVuZCBhbiBlbXBoYXNpcyBzZXF1ZW5jZS5cbi8vXG4vLyAgLSBzdGFydCAtIHBvc2l0aW9uIHRvIHNjYW4gZnJvbSAoaXQgc2hvdWxkIHBvaW50IGF0IGEgdmFsaWQgbWFya2VyKTtcbi8vICAtIGNhblNwbGl0V29yZCAtIGRldGVybWluZSBpZiB0aGVzZSBtYXJrZXJzIGNhbiBiZSBmb3VuZCBpbnNpZGUgYSB3b3JkXG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLnNjYW5EZWxpbXMgPSBmdW5jdGlvbiAoc3RhcnQsIGNhblNwbGl0V29yZCkge1xuICB2YXIgcG9zID0gc3RhcnQsIGxhc3RDaGFyLCBuZXh0Q2hhciwgY291bnQsIGNhbl9vcGVuLCBjYW5fY2xvc2UsXG4gICAgICBpc0xhc3RXaGl0ZVNwYWNlLCBpc0xhc3RQdW5jdENoYXIsXG4gICAgICBpc05leHRXaGl0ZVNwYWNlLCBpc05leHRQdW5jdENoYXIsXG4gICAgICBsZWZ0X2ZsYW5raW5nID0gdHJ1ZSxcbiAgICAgIHJpZ2h0X2ZsYW5raW5nID0gdHJ1ZSxcbiAgICAgIG1heCA9IHRoaXMucG9zTWF4LFxuICAgICAgbWFya2VyID0gdGhpcy5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgLy8gdHJlYXQgYmVnaW5uaW5nIG9mIHRoZSBsaW5lIGFzIGEgd2hpdGVzcGFjZVxuICBsYXN0Q2hhciA9IHN0YXJ0ID4gMCA/IHRoaXMuc3JjLmNoYXJDb2RlQXQoc3RhcnQgLSAxKSA6IDB4MjA7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCAmJiB0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IG1hcmtlcikgeyBwb3MrKzsgfVxuXG4gIGNvdW50ID0gcG9zIC0gc3RhcnQ7XG5cbiAgLy8gdHJlYXQgZW5kIG9mIHRoZSBsaW5lIGFzIGEgd2hpdGVzcGFjZVxuICBuZXh0Q2hhciA9IHBvcyA8IG1heCA/IHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKSA6IDB4MjA7XG5cbiAgaXNMYXN0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobGFzdENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobGFzdENoYXIpKTtcbiAgaXNOZXh0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobmV4dENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXIpKTtcblxuICBpc0xhc3RXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKGxhc3RDaGFyKTtcbiAgaXNOZXh0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XG5cbiAgaWYgKGlzTmV4dFdoaXRlU3BhY2UpIHtcbiAgICBsZWZ0X2ZsYW5raW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNOZXh0UHVuY3RDaGFyKSB7XG4gICAgaWYgKCEoaXNMYXN0V2hpdGVTcGFjZSB8fCBpc0xhc3RQdW5jdENoYXIpKSB7XG4gICAgICBsZWZ0X2ZsYW5raW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTGFzdFdoaXRlU3BhY2UpIHtcbiAgICByaWdodF9mbGFua2luZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzTGFzdFB1bmN0Q2hhcikge1xuICAgIGlmICghKGlzTmV4dFdoaXRlU3BhY2UgfHwgaXNOZXh0UHVuY3RDaGFyKSkge1xuICAgICAgcmlnaHRfZmxhbmtpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNhblNwbGl0V29yZCkge1xuICAgIGNhbl9vcGVuICA9IGxlZnRfZmxhbmtpbmcgICYmICghcmlnaHRfZmxhbmtpbmcgfHwgaXNMYXN0UHVuY3RDaGFyKTtcbiAgICBjYW5fY2xvc2UgPSByaWdodF9mbGFua2luZyAmJiAoIWxlZnRfZmxhbmtpbmcgIHx8IGlzTmV4dFB1bmN0Q2hhcik7XG4gIH0gZWxzZSB7XG4gICAgY2FuX29wZW4gID0gbGVmdF9mbGFua2luZztcbiAgICBjYW5fY2xvc2UgPSByaWdodF9mbGFua2luZztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2FuX29wZW46ICBjYW5fb3BlbixcbiAgICBjYW5fY2xvc2U6IGNhbl9jbG9zZSxcbiAgICBsZW5ndGg6ICAgIGNvdW50XG4gIH07XG59O1xuXG5cbi8vIHJlLWV4cG9ydCBUb2tlbiBjbGFzcyB0byB1c2UgaW4gYmxvY2sgcnVsZXNcblN0YXRlSW5saW5lLnByb3RvdHlwZS5Ub2tlbiA9IFRva2VuO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVJbmxpbmU7XG4iLCIvLyB+fnN0cmlrZSB0aHJvdWdofn5cbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gSW5zZXJ0IGVhY2ggbWFya2VyIGFzIGEgc2VwYXJhdGUgdGV4dCB0b2tlbiwgYW5kIGFkZCBpdCB0byBkZWxpbWl0ZXIgbGlzdFxuLy9cbm1vZHVsZS5leHBvcnRzLnRva2VuaXplID0gZnVuY3Rpb24gc3RyaWtldGhyb3VnaChzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBpLCBzY2FubmVkLCB0b2tlbiwgbGVuLCBjaCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zLFxuICAgICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQpO1xuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKG1hcmtlciAhPT0gMHg3RS8qIH4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc2Nhbm5lZCA9IHN0YXRlLnNjYW5EZWxpbXMoc3RhdGUucG9zLCB0cnVlKTtcbiAgbGVuID0gc2Nhbm5lZC5sZW5ndGg7XG4gIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuXG4gIGlmIChsZW4gPCAyKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChsZW4gJSAyKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IGNoO1xuICAgIGxlbi0tO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IGNoICsgY2g7XG5cbiAgICBzdGF0ZS5kZWxpbWl0ZXJzLnB1c2goe1xuICAgICAgbWFya2VyOiBtYXJrZXIsXG4gICAgICBsZW5ndGg6IDAsICAgICAvLyBkaXNhYmxlIFwicnVsZSBvZiAzXCIgbGVuZ3RoIGNoZWNrcyBtZWFudCBmb3IgZW1waGFzaXNcbiAgICAgIHRva2VuOiAgc3RhdGUudG9rZW5zLmxlbmd0aCAtIDEsXG4gICAgICBlbmQ6ICAgIC0xLFxuICAgICAgb3BlbjogICBzY2FubmVkLmNhbl9vcGVuLFxuICAgICAgY2xvc2U6ICBzY2FubmVkLmNhbl9jbG9zZVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGUucG9zICs9IHNjYW5uZWQubGVuZ3RoO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5mdW5jdGlvbiBwb3N0UHJvY2VzcyhzdGF0ZSwgZGVsaW1pdGVycykge1xuICB2YXIgaSwgaixcbiAgICAgIHN0YXJ0RGVsaW0sXG4gICAgICBlbmREZWxpbSxcbiAgICAgIHRva2VuLFxuICAgICAgbG9uZU1hcmtlcnMgPSBbXSxcbiAgICAgIG1heCA9IGRlbGltaXRlcnMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIHN0YXJ0RGVsaW0gPSBkZWxpbWl0ZXJzW2ldO1xuXG4gICAgaWYgKHN0YXJ0RGVsaW0ubWFya2VyICE9PSAweDdFLyogfiAqLykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0RGVsaW0uZW5kID09PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZW5kRGVsaW0gPSBkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kXTtcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbc3RhcnREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9ICdzX29wZW4nO1xuICAgIHRva2VuLnRhZyAgICAgPSAncyc7XG4gICAgdG9rZW4ubmVzdGluZyA9IDE7XG4gICAgdG9rZW4ubWFya3VwICA9ICd+fic7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9ICdzX2Nsb3NlJztcbiAgICB0b2tlbi50YWcgICAgID0gJ3MnO1xuICAgIHRva2VuLm5lc3RpbmcgPSAtMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gJ35+JztcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuIC0gMV0udHlwZSA9PT0gJ3RleHQnICYmXG4gICAgICAgIHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbiAtIDFdLmNvbnRlbnQgPT09ICd+Jykge1xuXG4gICAgICBsb25lTWFya2Vycy5wdXNoKGVuZERlbGltLnRva2VuIC0gMSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgYSBtYXJrZXIgc2VxdWVuY2UgaGFzIGFuIG9kZCBudW1iZXIgb2YgY2hhcmFjdGVycywgaXQncyBzcGxpdHRlZFxuICAvLyBsaWtlIHRoaXM6IGB+fn5+fmAgLT4gYH5gICsgYH5+YCArIGB+fmAsIGxlYXZpbmcgb25lIG1hcmtlciBhdCB0aGVcbiAgLy8gc3RhcnQgb2YgdGhlIHNlcXVlbmNlLlxuICAvL1xuICAvLyBTbywgd2UgaGF2ZSB0byBtb3ZlIGFsbCB0aG9zZSBtYXJrZXJzIGFmdGVyIHN1YnNlcXVlbnQgc19jbG9zZSB0YWdzLlxuICAvL1xuICB3aGlsZSAobG9uZU1hcmtlcnMubGVuZ3RoKSB7XG4gICAgaSA9IGxvbmVNYXJrZXJzLnBvcCgpO1xuICAgIGogPSBpICsgMTtcblxuICAgIHdoaWxlIChqIDwgc3RhdGUudG9rZW5zLmxlbmd0aCAmJiBzdGF0ZS50b2tlbnNbal0udHlwZSA9PT0gJ3NfY2xvc2UnKSB7XG4gICAgICBqKys7XG4gICAgfVxuXG4gICAgai0tO1xuXG4gICAgaWYgKGkgIT09IGopIHtcbiAgICAgIHRva2VuID0gc3RhdGUudG9rZW5zW2pdO1xuICAgICAgc3RhdGUudG9rZW5zW2pdID0gc3RhdGUudG9rZW5zW2ldO1xuICAgICAgc3RhdGUudG9rZW5zW2ldID0gdG9rZW47XG4gICAgfVxuICB9XG59XG5cblxuLy8gV2FsayB0aHJvdWdoIGRlbGltaXRlciBsaXN0IGFuZCByZXBsYWNlIHRleHQgdG9rZW5zIHdpdGggdGFnc1xuLy9cbm1vZHVsZS5leHBvcnRzLnBvc3RQcm9jZXNzID0gZnVuY3Rpb24gc3RyaWtldGhyb3VnaChzdGF0ZSkge1xuICB2YXIgY3VycixcbiAgICAgIHRva2Vuc19tZXRhID0gc3RhdGUudG9rZW5zX21ldGEsXG4gICAgICBtYXggPSBzdGF0ZS50b2tlbnNfbWV0YS5sZW5ndGg7XG5cbiAgcG9zdFByb2Nlc3Moc3RhdGUsIHN0YXRlLmRlbGltaXRlcnMpO1xuXG4gIGZvciAoY3VyciA9IDA7IGN1cnIgPCBtYXg7IGN1cnIrKykge1xuICAgIGlmICh0b2tlbnNfbWV0YVtjdXJyXSAmJiB0b2tlbnNfbWV0YVtjdXJyXS5kZWxpbWl0ZXJzKSB7XG4gICAgICBwb3N0UHJvY2VzcyhzdGF0ZSwgdG9rZW5zX21ldGFbY3Vycl0uZGVsaW1pdGVycyk7XG4gICAgfVxuICB9XG59O1xuIiwiLy8gU2tpcCB0ZXh0IGNoYXJhY3RlcnMgZm9yIHRleHQgdG9rZW4sIHBsYWNlIHRob3NlIHRvIHBlbmRpbmcgYnVmZmVyXG4vLyBhbmQgaW5jcmVtZW50IGN1cnJlbnQgcG9zXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vLyBSdWxlIHRvIHNraXAgcHVyZSB0ZXh0XG4vLyAne30kJUB+Kz06JyByZXNlcnZlZCBmb3IgZXh0ZW50aW9uc1xuXG4vLyAhLCBcIiwgIywgJCwgJSwgJiwgJywgKCwgKSwgKiwgKywgLCwgLSwgLiwgLywgOiwgOywgPCwgPSwgPiwgPywgQCwgWywgXFwsIF0sIF4sIF8sIGAsIHssIHwsIH0sIG9yIH5cblxuLy8gISEhISBEb24ndCBjb25mdXNlIHdpdGggXCJNYXJrZG93biBBU0NJSSBQdW5jdHVhdGlvblwiIGNoYXJzXG4vLyBodHRwOi8vc3BlYy5jb21tb25tYXJrLm9yZy8wLjE1LyNhc2NpaS1wdW5jdHVhdGlvbi1jaGFyYWN0ZXJcbmZ1bmN0aW9uIGlzVGVybWluYXRvckNoYXIoY2gpIHtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMHgwQS8qIFxcbiAqLzpcbiAgICBjYXNlIDB4MjEvKiAhICovOlxuICAgIGNhc2UgMHgyMy8qICMgKi86XG4gICAgY2FzZSAweDI0LyogJCAqLzpcbiAgICBjYXNlIDB4MjUvKiAlICovOlxuICAgIGNhc2UgMHgyNi8qICYgKi86XG4gICAgY2FzZSAweDJBLyogKiAqLzpcbiAgICBjYXNlIDB4MkIvKiArICovOlxuICAgIGNhc2UgMHgyRC8qIC0gKi86XG4gICAgY2FzZSAweDNBLyogOiAqLzpcbiAgICBjYXNlIDB4M0MvKiA8ICovOlxuICAgIGNhc2UgMHgzRC8qID0gKi86XG4gICAgY2FzZSAweDNFLyogPiAqLzpcbiAgICBjYXNlIDB4NDAvKiBAICovOlxuICAgIGNhc2UgMHg1Qi8qIFsgKi86XG4gICAgY2FzZSAweDVDLyogXFwgKi86XG4gICAgY2FzZSAweDVELyogXSAqLzpcbiAgICBjYXNlIDB4NUUvKiBeICovOlxuICAgIGNhc2UgMHg1Ri8qIF8gKi86XG4gICAgY2FzZSAweDYwLyogYCAqLzpcbiAgICBjYXNlIDB4N0IvKiB7ICovOlxuICAgIGNhc2UgMHg3RC8qIH0gKi86XG4gICAgY2FzZSAweDdFLyogfiAqLzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLnBvcztcblxuICB3aGlsZSAocG9zIDwgc3RhdGUucG9zTWF4ICYmICFpc1Rlcm1pbmF0b3JDaGFyKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAocG9zID09PSBzdGF0ZS5wb3MpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhdGUucG9zLCBwb3MpOyB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gQWx0ZXJuYXRpdmUgaW1wbGVtZW50YXRpb24sIGZvciBtZW1vcnkuXG4vL1xuLy8gSXQgY29zdHMgMTAlIG9mIHBlcmZvcm1hbmNlLCBidXQgYWxsb3dzIGV4dGVuZCB0ZXJtaW5hdG9ycyBsaXN0LCBpZiBwbGFjZSBpdFxuLy8gdG8gYFBhcmNlcklubGluZWAgcHJvcGVydHkuIFByb2JhYmx5LCB3aWxsIHN3aXRjaCB0byBpdCBzb21ldGltZSwgc3VjaFxuLy8gZmxleGliaWxpdHkgcmVxdWlyZWQuXG5cbi8qXG52YXIgVEVSTUlOQVRPUl9SRSA9IC9bXFxuISMkJSYqK1xcLTo8PT5AW1xcXFxcXF1eX2B7fX5dLztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIGlkeCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLnNlYXJjaChURVJNSU5BVE9SX1JFKTtcblxuICAvLyBmaXJzdCBjaGFyIGlzIHRlcm1pbmF0b3IgLT4gZW1wdHkgdGV4dFxuICBpZiAoaWR4ID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIG5vIHRlcm1pbmF0b3IgLT4gdGV4dCB0aWxsIGVuZCBvZiBzdHJpbmdcbiAgaWYgKGlkeCA8IDApIHtcbiAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShwb3MpOyB9XG4gICAgc3RhdGUucG9zID0gc3RhdGUuc3JjLmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjLnNsaWNlKHBvcywgcG9zICsgaWR4KTsgfVxuXG4gIHN0YXRlLnBvcyArPSBpZHg7XG5cbiAgcmV0dXJuIHRydWU7XG59OyovXG4iLCIvLyBDbGVhbiB1cCB0b2tlbnMgYWZ0ZXIgZW1waGFzaXMgYW5kIHN0cmlrZXRocm91Z2ggcG9zdHByb2Nlc3Npbmc6XG4vLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzIGludG8gb25lIGFuZCByZS1jYWxjdWxhdGUgYWxsIHRva2VuIGxldmVsc1xuLy9cbi8vIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgaW5pdGlhbGx5IGVtcGhhc2lzIGRlbGltaXRlciBtYXJrZXJzICgqLCBfLCB+KVxuLy8gYXJlIHRyZWF0ZWQgYXMgdGhlaXIgb3duIHNlcGFyYXRlIHRleHQgdG9rZW5zLiBUaGVuIGVtcGhhc2lzIHJ1bGUgZWl0aGVyXG4vLyBsZWF2ZXMgdGhlbSBhcyB0ZXh0IChuZWVkZWQgdG8gbWVyZ2Ugd2l0aCBhZGphY2VudCB0ZXh0KSBvciB0dXJucyB0aGVtXG4vLyBpbnRvIG9wZW5pbmcvY2xvc2luZyB0YWdzICh3aGljaCBtZXNzZXMgdXAgbGV2ZWxzIGluc2lkZSkuXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGV4dF9jb2xsYXBzZShzdGF0ZSkge1xuICB2YXIgY3VyciwgbGFzdCxcbiAgICAgIGxldmVsID0gMCxcbiAgICAgIHRva2VucyA9IHN0YXRlLnRva2VucyxcbiAgICAgIG1heCA9IHN0YXRlLnRva2Vucy5sZW5ndGg7XG5cbiAgZm9yIChjdXJyID0gbGFzdCA9IDA7IGN1cnIgPCBtYXg7IGN1cnIrKykge1xuICAgIC8vIHJlLWNhbGN1bGF0ZSBsZXZlbHMgYWZ0ZXIgZW1waGFzaXMvc3RyaWtldGhyb3VnaCB0dXJucyBzb21lIHRleHQgbm9kZXNcbiAgICAvLyBpbnRvIG9wZW5pbmcvY2xvc2luZyB0YWdzXG4gICAgaWYgKHRva2Vuc1tjdXJyXS5uZXN0aW5nIDwgMCkgbGV2ZWwtLTsgLy8gY2xvc2luZyB0YWdcbiAgICB0b2tlbnNbY3Vycl0ubGV2ZWwgPSBsZXZlbDtcbiAgICBpZiAodG9rZW5zW2N1cnJdLm5lc3RpbmcgPiAwKSBsZXZlbCsrOyAvLyBvcGVuaW5nIHRhZ1xuXG4gICAgaWYgKHRva2Vuc1tjdXJyXS50eXBlID09PSAndGV4dCcgJiZcbiAgICAgICAgY3VyciArIDEgPCBtYXggJiZcbiAgICAgICAgdG9rZW5zW2N1cnIgKyAxXS50eXBlID09PSAndGV4dCcpIHtcblxuICAgICAgLy8gY29sbGFwc2UgdHdvIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgIHRva2Vuc1tjdXJyICsgMV0uY29udGVudCA9IHRva2Vuc1tjdXJyXS5jb250ZW50ICsgdG9rZW5zW2N1cnIgKyAxXS5jb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY3VyciAhPT0gbGFzdCkgeyB0b2tlbnNbbGFzdF0gPSB0b2tlbnNbY3Vycl07IH1cblxuICAgICAgbGFzdCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyICE9PSBsYXN0KSB7XG4gICAgdG9rZW5zLmxlbmd0aCA9IGxhc3Q7XG4gIH1cbn07XG4iLCIvLyBUb2tlbiBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cblxuLyoqXG4gKiBjbGFzcyBUb2tlblxuICoqL1xuXG4vKipcbiAqIG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpXG4gKlxuICogQ3JlYXRlIG5ldyB0b2tlbiBhbmQgZmlsbCBwYXNzZWQgcHJvcGVydGllcy5cbiAqKi9cbmZ1bmN0aW9uIFRva2VuKHR5cGUsIHRhZywgbmVzdGluZykge1xuICAvKipcbiAgICogVG9rZW4jdHlwZSAtPiBTdHJpbmdcbiAgICpcbiAgICogVHlwZSBvZiB0aGUgdG9rZW4gKHN0cmluZywgZS5nLiBcInBhcmFncmFwaF9vcGVuXCIpXG4gICAqKi9cbiAgdGhpcy50eXBlICAgICA9IHR5cGU7XG5cbiAgLyoqXG4gICAqIFRva2VuI3RhZyAtPiBTdHJpbmdcbiAgICpcbiAgICogaHRtbCB0YWcgbmFtZSwgZS5nLiBcInBcIlxuICAgKiovXG4gIHRoaXMudGFnICAgICAgPSB0YWc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2F0dHJzIC0+IEFycmF5XG4gICAqXG4gICAqIEh0bWwgYXR0cmlidXRlcy4gRm9ybWF0OiBgWyBbIG5hbWUxLCB2YWx1ZTEgXSwgWyBuYW1lMiwgdmFsdWUyIF0gXWBcbiAgICoqL1xuICB0aGlzLmF0dHJzICAgID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jbWFwIC0+IEFycmF5XG4gICAqXG4gICAqIFNvdXJjZSBtYXAgaW5mby4gRm9ybWF0OiBgWyBsaW5lX2JlZ2luLCBsaW5lX2VuZCBdYFxuICAgKiovXG4gIHRoaXMubWFwICAgICAgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNuZXN0aW5nIC0+IE51bWJlclxuICAgKlxuICAgKiBMZXZlbCBjaGFuZ2UgKG51bWJlciBpbiB7LTEsIDAsIDF9IHNldCksIHdoZXJlOlxuICAgKlxuICAgKiAtICBgMWAgbWVhbnMgdGhlIHRhZyBpcyBvcGVuaW5nXG4gICAqIC0gIGAwYCBtZWFucyB0aGUgdGFnIGlzIHNlbGYtY2xvc2luZ1xuICAgKiAtIGAtMWAgbWVhbnMgdGhlIHRhZyBpcyBjbG9zaW5nXG4gICAqKi9cbiAgdGhpcy5uZXN0aW5nICA9IG5lc3Rpbmc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2xldmVsIC0+IE51bWJlclxuICAgKlxuICAgKiBuZXN0aW5nIGxldmVsLCB0aGUgc2FtZSBhcyBgc3RhdGUubGV2ZWxgXG4gICAqKi9cbiAgdGhpcy5sZXZlbCAgICA9IDA7XG5cbiAgLyoqXG4gICAqIFRva2VuI2NoaWxkcmVuIC0+IEFycmF5XG4gICAqXG4gICAqIEFuIGFycmF5IG9mIGNoaWxkIG5vZGVzIChpbmxpbmUgYW5kIGltZyB0b2tlbnMpXG4gICAqKi9cbiAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI2NvbnRlbnQgLT4gU3RyaW5nXG4gICAqXG4gICAqIEluIGEgY2FzZSBvZiBzZWxmLWNsb3NpbmcgdGFnIChjb2RlLCBodG1sLCBmZW5jZSwgZXRjLiksXG4gICAqIGl0IGhhcyBjb250ZW50cyBvZiB0aGlzIHRhZy5cbiAgICoqL1xuICB0aGlzLmNvbnRlbnQgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI21hcmt1cCAtPiBTdHJpbmdcbiAgICpcbiAgICogJyonIG9yICdfJyBmb3IgZW1waGFzaXMsIGZlbmNlIHN0cmluZyBmb3IgZmVuY2UsIGV0Yy5cbiAgICoqL1xuICB0aGlzLm1hcmt1cCAgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2luZm8gLT4gU3RyaW5nXG4gICAqXG4gICAqIEFkZGl0aW9uYWwgaW5mb3JtYXRpb246XG4gICAqXG4gICAqIC0gSW5mbyBzdHJpbmcgZm9yIFwiZmVuY2VcIiB0b2tlbnNcbiAgICogLSBUaGUgdmFsdWUgXCJhdXRvXCIgZm9yIGF1dG9saW5rIFwibGlua19vcGVuXCIgYW5kIFwibGlua19jbG9zZVwiIHRva2Vuc1xuICAgKiAtIFRoZSBzdHJpbmcgdmFsdWUgb2YgdGhlIGl0ZW0gbWFya2VyIGZvciBvcmRlcmVkLWxpc3QgXCJsaXN0X2l0ZW1fb3BlblwiIHRva2Vuc1xuICAgKiovXG4gIHRoaXMuaW5mbyAgICAgPSAnJztcblxuICAvKipcbiAgICogVG9rZW4jbWV0YSAtPiBPYmplY3RcbiAgICpcbiAgICogQSBwbGFjZSBmb3IgcGx1Z2lucyB0byBzdG9yZSBhbiBhcmJpdHJhcnkgZGF0YVxuICAgKiovXG4gIHRoaXMubWV0YSAgICAgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNibG9jayAtPiBCb29sZWFuXG4gICAqXG4gICAqIFRydWUgZm9yIGJsb2NrLWxldmVsIHRva2VucywgZmFsc2UgZm9yIGlubGluZSB0b2tlbnMuXG4gICAqIFVzZWQgaW4gcmVuZGVyZXIgdG8gY2FsY3VsYXRlIGxpbmUgYnJlYWtzXG4gICAqKi9cbiAgdGhpcy5ibG9jayAgICA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNoaWRkZW4gLT4gQm9vbGVhblxuICAgKlxuICAgKiBJZiBpdCdzIHRydWUsIGlnbm9yZSB0aGlzIGVsZW1lbnQgd2hlbiByZW5kZXJpbmcuIFVzZWQgZm9yIHRpZ2h0IGxpc3RzXG4gICAqIHRvIGhpZGUgcGFyYWdyYXBocy5cbiAgICoqL1xuICB0aGlzLmhpZGRlbiAgID0gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRySW5kZXgobmFtZSkgLT4gTnVtYmVyXG4gKlxuICogU2VhcmNoIGF0dHJpYnV0ZSBpbmRleCBieSBuYW1lLlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJJbmRleCA9IGZ1bmN0aW9uIGF0dHJJbmRleChuYW1lKSB7XG4gIHZhciBhdHRycywgaSwgbGVuO1xuXG4gIGlmICghdGhpcy5hdHRycykgeyByZXR1cm4gLTE7IH1cblxuICBhdHRycyA9IHRoaXMuYXR0cnM7XG5cbiAgZm9yIChpID0gMCwgbGVuID0gYXR0cnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoYXR0cnNbaV1bMF0gPT09IG5hbWUpIHsgcmV0dXJuIGk7IH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0clB1c2goYXR0ckRhdGEpXG4gKlxuICogQWRkIGBbIG5hbWUsIHZhbHVlIF1gIGF0dHJpYnV0ZSB0byBsaXN0LiBJbml0IGF0dHJzIGlmIG5lY2Vzc2FyeVxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJQdXNoID0gZnVuY3Rpb24gYXR0clB1c2goYXR0ckRhdGEpIHtcbiAgaWYgKHRoaXMuYXR0cnMpIHtcbiAgICB0aGlzLmF0dHJzLnB1c2goYXR0ckRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYXR0cnMgPSBbIGF0dHJEYXRhIF07XG4gIH1cbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRyU2V0KG5hbWUsIHZhbHVlKVxuICpcbiAqIFNldCBgbmFtZWAgYXR0cmlidXRlIHRvIGB2YWx1ZWAuIE92ZXJyaWRlIG9sZCB2YWx1ZSBpZiBleGlzdHMuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0clNldCA9IGZ1bmN0aW9uIGF0dHJTZXQobmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkeCA9IHRoaXMuYXR0ckluZGV4KG5hbWUpLFxuICAgICAgYXR0ckRhdGEgPSBbIG5hbWUsIHZhbHVlIF07XG5cbiAgaWYgKGlkeCA8IDApIHtcbiAgICB0aGlzLmF0dHJQdXNoKGF0dHJEYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmF0dHJzW2lkeF0gPSBhdHRyRGF0YTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFRva2VuLmF0dHJHZXQobmFtZSlcbiAqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGF0dHJpYnV0ZSBgbmFtZWAsIG9yIG51bGwgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0ckdldCA9IGZ1bmN0aW9uIGF0dHJHZXQobmFtZSkge1xuICB2YXIgaWR4ID0gdGhpcy5hdHRySW5kZXgobmFtZSksIHZhbHVlID0gbnVsbDtcbiAgaWYgKGlkeCA+PSAwKSB7XG4gICAgdmFsdWUgPSB0aGlzLmF0dHJzW2lkeF1bMV07XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuXG4vKipcbiAqIFRva2VuLmF0dHJKb2luKG5hbWUsIHZhbHVlKVxuICpcbiAqIEpvaW4gdmFsdWUgdG8gZXhpc3RpbmcgYXR0cmlidXRlIHZpYSBzcGFjZS4gT3IgY3JlYXRlIG5ldyBhdHRyaWJ1dGUgaWYgbm90XG4gKiBleGlzdHMuIFVzZWZ1bCB0byBvcGVyYXRlIHdpdGggdG9rZW4gY2xhc3Nlcy5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRySm9pbiA9IGZ1bmN0aW9uIGF0dHJKb2luKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKTtcblxuICBpZiAoaWR4IDwgMCkge1xuICAgIHRoaXMuYXR0clB1c2goWyBuYW1lLCB2YWx1ZSBdKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmF0dHJzW2lkeF1bMV0gPSB0aGlzLmF0dHJzW2lkeF1bMV0gKyAnICcgKyB2YWx1ZTtcbiAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFRva2VuO1xuIiwiXG4ndXNlIHN0cmljdCc7XG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG52YXIgZGVjb2RlQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVjb2RlQ2FjaGUoZXhjbHVkZSkge1xuICB2YXIgaSwgY2gsIGNhY2hlID0gZGVjb2RlQ2FjaGVbZXhjbHVkZV07XG4gIGlmIChjYWNoZSkgeyByZXR1cm4gY2FjaGU7IH1cblxuICBjYWNoZSA9IGRlY29kZUNhY2hlW2V4Y2x1ZGVdID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IDEyODsgaSsrKSB7XG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgIGNhY2hlLnB1c2goY2gpO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4Y2x1ZGUubGVuZ3RoOyBpKyspIHtcbiAgICBjaCA9IGV4Y2x1ZGUuY2hhckNvZGVBdChpKTtcbiAgICBjYWNoZVtjaF0gPSAnJScgKyAoJzAnICsgY2gudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZTtcbn1cblxuXG4vLyBEZWNvZGUgcGVyY2VudC1lbmNvZGVkIHN0cmluZy5cbi8vXG5mdW5jdGlvbiBkZWNvZGUoc3RyaW5nLCBleGNsdWRlKSB7XG4gIHZhciBjYWNoZTtcblxuICBpZiAodHlwZW9mIGV4Y2x1ZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgZXhjbHVkZSA9IGRlY29kZS5kZWZhdWx0Q2hhcnM7XG4gIH1cblxuICBjYWNoZSA9IGdldERlY29kZUNhY2hlKGV4Y2x1ZGUpO1xuXG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKCVbYS1mMC05XXsyfSkrL2dpLCBmdW5jdGlvbihzZXEpIHtcbiAgICB2YXIgaSwgbCwgYjEsIGIyLCBiMywgYjQsIGNocixcbiAgICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gc2VxLmxlbmd0aDsgaSA8IGw7IGkgKz0gMykge1xuICAgICAgYjEgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDEsIGkgKyAzKSwgMTYpO1xuXG4gICAgICBpZiAoYjEgPCAweDgwKSB7XG4gICAgICAgIHJlc3VsdCArPSBjYWNoZVtiMV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGIxICYgMHhFMCkgPT09IDB4QzAgJiYgKGkgKyAzIDwgbCkpIHtcbiAgICAgICAgLy8gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuXG4gICAgICAgIGlmICgoYjIgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgIGNociA9ICgoYjEgPDwgNikgJiAweDdDMCkgfCAoYjIgJiAweDNGKTtcblxuICAgICAgICAgIGlmIChjaHIgPCAweDgwKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKChiMSAmIDB4RjApID09PSAweEUwICYmIChpICsgNiA8IGwpKSB7XG4gICAgICAgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgIGIyID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA0LCBpICsgNiksIDE2KTtcbiAgICAgICAgYjMgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDcsIGkgKyA5KSwgMTYpO1xuXG4gICAgICAgIGlmICgoYjIgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjMgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgIGNociA9ICgoYjEgPDwgMTIpICYgMHhGMDAwKSB8ICgoYjIgPDwgNikgJiAweEZDMCkgfCAoYjMgJiAweDNGKTtcblxuICAgICAgICAgIGlmIChjaHIgPCAweDgwMCB8fCAoY2hyID49IDB4RDgwMCAmJiBjaHIgPD0gMHhERkZGKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkXFx1ZmZmZFxcdWZmZmQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gNjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKGIxICYgMHhGOCkgPT09IDB4RjAgJiYgKGkgKyA5IDwgbCkpIHtcbiAgICAgICAgLy8gMTExMTEweHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuICAgICAgICBiMyA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNywgaSArIDkpLCAxNik7XG4gICAgICAgIGI0ID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyAxMCwgaSArIDEyKSwgMTYpO1xuXG4gICAgICAgIGlmICgoYjIgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjMgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjQgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgIGNociA9ICgoYjEgPDwgMTgpICYgMHgxQzAwMDApIHwgKChiMiA8PCAxMikgJiAweDNGMDAwKSB8ICgoYjMgPDwgNikgJiAweEZDMCkgfCAoYjQgJiAweDNGKTtcblxuICAgICAgICAgIGlmIChjaHIgPCAweDEwMDAwIHx8IGNociA+IDB4MTBGRkZGKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkXFx1ZmZmZFxcdWZmZmQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCArIChjaHIgPj4gMTApLCAweERDMDAgKyAoY2hyICYgMHgzRkYpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkJztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbn1cblxuXG5kZWNvZGUuZGVmYXVsdENoYXJzICAgPSAnOy8/OkAmPSskLCMnO1xuZGVjb2RlLmNvbXBvbmVudENoYXJzID0gJyc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBkZWNvZGU7XG4iLCJcbid1c2Ugc3RyaWN0JztcblxuXG52YXIgZW5jb2RlQ2FjaGUgPSB7fTtcblxuXG4vLyBDcmVhdGUgYSBsb29rdXAgYXJyYXkgd2hlcmUgYW55dGhpbmcgYnV0IGNoYXJhY3RlcnMgaW4gYGNoYXJzYCBzdHJpbmdcbi8vIGFuZCBhbHBoYW51bWVyaWMgY2hhcnMgaXMgcGVyY2VudC1lbmNvZGVkLlxuLy9cbmZ1bmN0aW9uIGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpIHtcbiAgdmFyIGksIGNoLCBjYWNoZSA9IGVuY29kZUNhY2hlW2V4Y2x1ZGVdO1xuICBpZiAoY2FjaGUpIHsgcmV0dXJuIGNhY2hlOyB9XG5cbiAgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXSA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcblxuICAgIGlmICgvXlswLTlhLXpdJC9pLnRlc3QoY2gpKSB7XG4gICAgICAvLyBhbHdheXMgYWxsb3cgdW5lbmNvZGVkIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICBjYWNoZS5wdXNoKGNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGUucHVzaCgnJScgKyAoJzAnICsgaS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhjbHVkZS5sZW5ndGg7IGkrKykge1xuICAgIGNhY2hlW2V4Y2x1ZGUuY2hhckNvZGVBdChpKV0gPSBleGNsdWRlW2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5cbi8vIEVuY29kZSB1bnNhZmUgY2hhcmFjdGVycyB3aXRoIHBlcmNlbnQtZW5jb2RpbmcsIHNraXBwaW5nIGFscmVhZHlcbi8vIGVuY29kZWQgc2VxdWVuY2VzLlxuLy9cbi8vICAtIHN0cmluZyAgICAgICAtIHN0cmluZyB0byBlbmNvZGVcbi8vICAtIGV4Y2x1ZGUgICAgICAtIGxpc3Qgb2YgY2hhcmFjdGVycyB0byBpZ25vcmUgKGluIGFkZGl0aW9uIHRvIGEtekEtWjAtOSlcbi8vICAtIGtlZXBFc2NhcGVkICAtIGRvbid0IGVuY29kZSAnJScgaW4gYSBjb3JyZWN0IGVzY2FwZSBzZXF1ZW5jZSAoZGVmYXVsdDogdHJ1ZSlcbi8vXG5mdW5jdGlvbiBlbmNvZGUoc3RyaW5nLCBleGNsdWRlLCBrZWVwRXNjYXBlZCkge1xuICB2YXIgaSwgbCwgY29kZSwgbmV4dENvZGUsIGNhY2hlLFxuICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgaWYgKHR5cGVvZiBleGNsdWRlICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGVuY29kZShzdHJpbmcsIGtlZXBFc2NhcGVkKVxuICAgIGtlZXBFc2NhcGVkICA9IGV4Y2x1ZGU7XG4gICAgZXhjbHVkZSA9IGVuY29kZS5kZWZhdWx0Q2hhcnM7XG4gIH1cblxuICBpZiAodHlwZW9mIGtlZXBFc2NhcGVkID09PSAndW5kZWZpbmVkJykge1xuICAgIGtlZXBFc2NhcGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGNhY2hlID0gZ2V0RW5jb2RlQ2FjaGUoZXhjbHVkZSk7XG5cbiAgZm9yIChpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoa2VlcEVzY2FwZWQgJiYgY29kZSA9PT0gMHgyNSAvKiAlICovICYmIGkgKyAyIDwgbCkge1xuICAgICAgaWYgKC9eWzAtOWEtZl17Mn0kL2kudGVzdChzdHJpbmcuc2xpY2UoaSArIDEsIGkgKyAzKSkpIHtcbiAgICAgICAgcmVzdWx0ICs9IHN0cmluZy5zbGljZShpLCBpICsgMyk7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPCAxMjgpIHtcbiAgICAgIHJlc3VsdCArPSBjYWNoZVtjb2RlXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REZGRikge1xuICAgICAgaWYgKGNvZGUgPj0gMHhEODAwICYmIGNvZGUgPD0gMHhEQkZGICYmIGkgKyAxIDwgbCkge1xuICAgICAgICBuZXh0Q29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgaWYgKG5leHRDb2RlID49IDB4REMwMCAmJiBuZXh0Q29kZSA8PSAweERGRkYpIHtcbiAgICAgICAgICByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ1tpXSArIHN0cmluZ1tpICsgMV0pO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0ICs9ICclRUYlQkYlQkQnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZW5jb2RlLmRlZmF1bHRDaGFycyAgID0gXCI7Lz86QCY9KyQsLV8uIX4qJygpI1wiO1xuZW5jb2RlLmNvbXBvbmVudENoYXJzID0gXCItXy4hfionKClcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZTtcbiIsIlxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9ybWF0KHVybCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgcmVzdWx0ICs9IHVybC5wcm90b2NvbCB8fCAnJztcbiAgcmVzdWx0ICs9IHVybC5zbGFzaGVzID8gJy8vJyA6ICcnO1xuICByZXN1bHQgKz0gdXJsLmF1dGggPyB1cmwuYXV0aCArICdAJyA6ICcnO1xuXG4gIGlmICh1cmwuaG9zdG5hbWUgJiYgdXJsLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTEpIHtcbiAgICAvLyBpcHY2IGFkZHJlc3NcbiAgICByZXN1bHQgKz0gJ1snICsgdXJsLmhvc3RuYW1lICsgJ10nO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCArPSB1cmwuaG9zdG5hbWUgfHwgJyc7XG4gIH1cblxuICByZXN1bHQgKz0gdXJsLnBvcnQgPyAnOicgKyB1cmwucG9ydCA6ICcnO1xuICByZXN1bHQgKz0gdXJsLnBhdGhuYW1lIHx8ICcnO1xuICByZXN1bHQgKz0gdXJsLnNlYXJjaCB8fCAnJztcbiAgcmVzdWx0ICs9IHVybC5oYXNoIHx8ICcnO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzLmVuY29kZSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG5tb2R1bGUuZXhwb3J0cy5kZWNvZGUgPSByZXF1aXJlKCcuL2RlY29kZScpO1xubW9kdWxlLmV4cG9ydHMuZm9ybWF0ID0gcmVxdWlyZSgnLi9mb3JtYXQnKTtcbm1vZHVsZS5leHBvcnRzLnBhcnNlICA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vXG4vLyBDaGFuZ2VzIGZyb20gam95ZW50L25vZGU6XG4vL1xuLy8gMS4gTm8gbGVhZGluZyBzbGFzaCBpbiBwYXRocyxcbi8vICAgIGUuZy4gaW4gYHVybC5wYXJzZSgnaHR0cDovL2Zvbz9iYXInKWAgcGF0aG5hbWUgaXMgYGAsIG5vdCBgL2Bcbi8vXG4vLyAyLiBCYWNrc2xhc2hlcyBhcmUgbm90IHJlcGxhY2VkIHdpdGggc2xhc2hlcyxcbi8vICAgIHNvIGBodHRwOlxcXFxleGFtcGxlLm9yZ1xcYCBpcyB0cmVhdGVkIGxpa2UgYSByZWxhdGl2ZSBwYXRoXG4vL1xuLy8gMy4gVHJhaWxpbmcgY29sb24gaXMgdHJlYXRlZCBsaWtlIGEgcGFydCBvZiB0aGUgcGF0aCxcbi8vICAgIGkuZS4gaW4gYGh0dHA6Ly9leGFtcGxlLm9yZzpmb29gIHBhdGhuYW1lIGlzIGA6Zm9vYFxuLy9cbi8vIDQuIE5vdGhpbmcgaXMgVVJMLWVuY29kZWQgaW4gdGhlIHJlc3VsdGluZyBvYmplY3QsXG4vLyAgICAoaW4gam95ZW50L25vZGUgc29tZSBjaGFycyBpbiBhdXRoIGFuZCBwYXRocyBhcmUgZW5jb2RlZClcbi8vXG4vLyA1LiBgdXJsLnBhcnNlKClgIGRvZXMgbm90IGhhdmUgYHBhcnNlUXVlcnlTdHJpbmdgIGFyZ3VtZW50XG4vL1xuLy8gNi4gUmVtb3ZlZCBleHRyYW5lb3VzIHJlc3VsdCBwcm9wZXJ0aWVzOiBgaG9zdGAsIGBwYXRoYCwgYHF1ZXJ5YCwgZXRjLixcbi8vICAgIHdoaWNoIGNhbiBiZSBjb25zdHJ1Y3RlZCB1c2luZyBvdGhlciBwYXJ0cyBvZiB0aGUgdXJsLlxuLy9cblxuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyAnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCcgXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyAneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnIF0uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsgJ1xcJycgXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsgJyUnLCAnLycsICc/JywgJzsnLCAnIycgXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWyAnLycsICc/JywgJyMnIF0sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zY3JpcHQtdXJsICovXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9O1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2NyaXB0LXVybCAqL1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSB7IHJldHVybiB1cmw7IH1cblxuICB2YXIgdSA9IG5ldyBVcmwoKTtcbiAgdS5wYXJzZSh1cmwsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIHZhciBpLCBsLCBsb3dlclByb3RvLCBoZWMsIHNsYXNoZXMsXG4gICAgICByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IHByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yIChpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIHtcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yIChpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIHtcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChyZXN0W2hvc3RFbmQgLSAxXSA9PT0gJzonKSB7IGhvc3RFbmQtLTsgfVxuICAgIHZhciBob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoaG9zdCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgeyBjb250aW51ZTsgfVxuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICB9XG4gIH1cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH1cbiAgaWYgKHJlc3QpIHsgdGhpcy5wYXRobmFtZSA9IHJlc3Q7IH1cbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnJztcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbihob3N0KSB7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB7IHRoaXMuaG9zdG5hbWUgPSBob3N0OyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybFBhcnNlO1xuIiwibW9kdWxlLmV4cG9ydHM9L1tcXDAtXFx4MUZcXHg3Ri1cXHg5Rl0vIiwibW9kdWxlLmV4cG9ydHM9L1tcXHhBRFxcdTA2MDAtXFx1MDYwNVxcdTA2MUNcXHUwNkREXFx1MDcwRlxcdTA4RTJcXHUxODBFXFx1MjAwQi1cXHUyMDBGXFx1MjAyQS1cXHUyMDJFXFx1MjA2MC1cXHUyMDY0XFx1MjA2Ni1cXHUyMDZGXFx1RkVGRlxcdUZGRjktXFx1RkZGQl18XFx1RDgwNFtcXHVEQ0JEXFx1RENDRF18XFx1RDgyRltcXHVEQ0EwLVxcdURDQTNdfFxcdUQ4MzRbXFx1REQ3My1cXHVERDdBXXxcXHVEQjQwW1xcdURDMDFcXHVEQzIwLVxcdURDN0ZdLyIsIm1vZHVsZS5leHBvcnRzPS9bIS0jJS1cXCosLVxcLzo7XFw/QFxcWy1cXF1fXFx7XFx9XFx4QTFcXHhBN1xceEFCXFx4QjZcXHhCN1xceEJCXFx4QkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNThBXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFFXFx1MDYxRlxcdTA2NkEtXFx1MDY2RFxcdTA2RDRcXHUwNzAwLVxcdTA3MERcXHUwN0Y3LVxcdTA3RjlcXHUwODMwLVxcdTA4M0VcXHUwODVFXFx1MDk2NFxcdTA5NjVcXHUwOTcwXFx1MDlGRFxcdTBBNzZcXHUwQUYwXFx1MEM4NFxcdTBERjRcXHUwRTRGXFx1MEU1QVxcdTBFNUJcXHUwRjA0LVxcdTBGMTJcXHUwRjE0XFx1MEYzQS1cXHUwRjNEXFx1MEY4NVxcdTBGRDAtXFx1MEZENFxcdTBGRDlcXHUwRkRBXFx1MTA0QS1cXHUxMDRGXFx1MTBGQlxcdTEzNjAtXFx1MTM2OFxcdTE0MDBcXHUxNjZEXFx1MTY2RVxcdTE2OUJcXHUxNjlDXFx1MTZFQi1cXHUxNkVEXFx1MTczNVxcdTE3MzZcXHUxN0Q0LVxcdTE3RDZcXHUxN0Q4LVxcdTE3REFcXHUxODAwLVxcdTE4MEFcXHUxOTQ0XFx1MTk0NVxcdTFBMUVcXHUxQTFGXFx1MUFBMC1cXHUxQUE2XFx1MUFBOC1cXHUxQUFEXFx1MUI1QS1cXHUxQjYwXFx1MUJGQy1cXHUxQkZGXFx1MUMzQi1cXHUxQzNGXFx1MUM3RVxcdTFDN0ZcXHUxQ0MwLVxcdTFDQzdcXHUxQ0QzXFx1MjAxMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDQzXFx1MjA0NS1cXHUyMDUxXFx1MjA1My1cXHUyMDVFXFx1MjA3RFxcdTIwN0VcXHUyMDhEXFx1MjA4RVxcdTIzMDgtXFx1MjMwQlxcdTIzMjlcXHUyMzJBXFx1Mjc2OC1cXHUyNzc1XFx1MjdDNVxcdTI3QzZcXHUyN0U2LVxcdTI3RUZcXHUyOTgzLVxcdTI5OThcXHUyOUQ4LVxcdTI5REJcXHUyOUZDXFx1MjlGRFxcdTJDRjktXFx1MkNGQ1xcdTJDRkVcXHUyQ0ZGXFx1MkQ3MFxcdTJFMDAtXFx1MkUyRVxcdTJFMzAtXFx1MkU0RVxcdTMwMDEtXFx1MzAwM1xcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdTMwMzBcXHUzMDNEXFx1MzBBMFxcdTMwRkJcXHVBNEZFXFx1QTRGRlxcdUE2MEQtXFx1QTYwRlxcdUE2NzNcXHVBNjdFXFx1QTZGMi1cXHVBNkY3XFx1QTg3NC1cXHVBODc3XFx1QThDRVxcdUE4Q0ZcXHVBOEY4LVxcdUE4RkFcXHVBOEZDXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjVdfFxcdUQ4MDBbXFx1REQwMC1cXHVERDAyXFx1REY5RlxcdURGRDBdfFxcdUQ4MDFcXHVERDZGfFxcdUQ4MDJbXFx1REM1N1xcdUREMUZcXHVERDNGXFx1REU1MC1cXHVERTU4XFx1REU3RlxcdURFRjAtXFx1REVGNlxcdURGMzktXFx1REYzRlxcdURGOTktXFx1REY5Q118XFx1RDgwM1tcXHVERjU1LVxcdURGNTldfFxcdUQ4MDRbXFx1REM0Ny1cXHVEQzREXFx1RENCQlxcdURDQkNcXHVEQ0JFLVxcdURDQzFcXHVERDQwLVxcdURENDNcXHVERDc0XFx1REQ3NVxcdUREQzUtXFx1RERDOFxcdUREQ0RcXHVERERCXFx1RERERC1cXHVERERGXFx1REUzOC1cXHVERTNEXFx1REVBOV18XFx1RDgwNVtcXHVEQzRCLVxcdURDNEZcXHVEQzVCXFx1REM1RFxcdURDQzZcXHVEREMxLVxcdURERDdcXHVERTQxLVxcdURFNDNcXHVERTYwLVxcdURFNkNcXHVERjNDLVxcdURGM0VdfFxcdUQ4MDZbXFx1REMzQlxcdURFM0YtXFx1REU0NlxcdURFOUEtXFx1REU5Q1xcdURFOUUtXFx1REVBMl18XFx1RDgwN1tcXHVEQzQxLVxcdURDNDVcXHVEQzcwXFx1REM3MVxcdURFRjdcXHVERUY4XXxcXHVEODA5W1xcdURDNzAtXFx1REM3NF18XFx1RDgxQVtcXHVERTZFXFx1REU2RlxcdURFRjVcXHVERjM3LVxcdURGM0JcXHVERjQ0XXxcXHVEODFCW1xcdURFOTctXFx1REU5QV18XFx1RDgyRlxcdURDOUZ8XFx1RDgzNltcXHVERTg3LVxcdURFOEJdfFxcdUQ4M0FbXFx1REQ1RVxcdURENUZdLyIsIm1vZHVsZS5leHBvcnRzPS9bIFxceEEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwQVxcdTIwMjhcXHUyMDI5XFx1MjAyRlxcdTIwNUZcXHUzMDAwXS8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuQW55ID0gcmVxdWlyZSgnLi9wcm9wZXJ0aWVzL0FueS9yZWdleCcpO1xuZXhwb3J0cy5DYyAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvQ2MvcmVnZXgnKTtcbmV4cG9ydHMuQ2YgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL0NmL3JlZ2V4Jyk7XG5leHBvcnRzLlAgICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9QL3JlZ2V4Jyk7XG5leHBvcnRzLlogICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9aL3JlZ2V4Jyk7XG4iLCJtb2R1bGUuZXhwb3J0cz0vW1xcMC1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdLyIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkxvZ2luUmVxdWVzdFJlc3BvbnNlID0gZXhwb3J0cy5FcnJvclJlc3BvbnNlID0gZXhwb3J0cy5TdWNjZXNzUmVzcG9uc2UgPSBleHBvcnRzLkFjdGl2aXR5UmVzcG9uc2UgPSBleHBvcnRzLkFjdGl2aXR5UmVxdWVzdEVycm9yID0gZXhwb3J0cy5BY3Rpdml0eVJlcXVlc3RUcmlnZ2VyID0gdm9pZCAwO1xyXG52YXIgQWN0aXZpdHlSZXF1ZXN0VHJpZ2dlcjtcclxuKGZ1bmN0aW9uIChBY3Rpdml0eVJlcXVlc3RUcmlnZ2VyKSB7XHJcbiAgICBBY3Rpdml0eVJlcXVlc3RUcmlnZ2VyW1wiQXV0b21hdGljXCJdID0gXCJhdXRvbWF0aWNcIjtcclxuICAgIEFjdGl2aXR5UmVxdWVzdFRyaWdnZXJbXCJNYW51YWxcIl0gPSBcIm1hbnVhbFwiO1xyXG59KShBY3Rpdml0eVJlcXVlc3RUcmlnZ2VyID0gZXhwb3J0cy5BY3Rpdml0eVJlcXVlc3RUcmlnZ2VyIHx8IChleHBvcnRzLkFjdGl2aXR5UmVxdWVzdFRyaWdnZXIgPSB7fSkpO1xyXG52YXIgQWN0aXZpdHlSZXF1ZXN0RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBY3Rpdml0eVJlcXVlc3RFcnJvcihjb2RlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEFjdGl2aXR5UmVxdWVzdEVycm9yO1xyXG59KCkpO1xyXG5leHBvcnRzLkFjdGl2aXR5UmVxdWVzdEVycm9yID0gQWN0aXZpdHlSZXF1ZXN0RXJyb3I7XHJcbnZhciBBY3Rpdml0eVJlc3BvbnNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHlSZXNwb25zZShyZXF1ZXN0KSB7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcclxuICAgIH1cclxuICAgIHJldHVybiBBY3Rpdml0eVJlc3BvbnNlO1xyXG59KCkpO1xyXG5leHBvcnRzLkFjdGl2aXR5UmVzcG9uc2UgPSBBY3Rpdml0eVJlc3BvbnNlO1xyXG52YXIgU3VjY2Vzc1Jlc3BvbnNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFN1Y2Nlc3NSZXNwb25zZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFN1Y2Nlc3NSZXNwb25zZShyZXF1ZXN0LCByYXdDb250ZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcmVxdWVzdCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcclxuICAgICAgICBfdGhpcy5yYXdDb250ZW50ID0gcmF3Q29udGVudDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3VjY2Vzc1Jlc3BvbnNlO1xyXG59KEFjdGl2aXR5UmVzcG9uc2UpKTtcclxuZXhwb3J0cy5TdWNjZXNzUmVzcG9uc2UgPSBTdWNjZXNzUmVzcG9uc2U7XHJcbnZhciBFcnJvclJlc3BvbnNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEVycm9yUmVzcG9uc2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBFcnJvclJlc3BvbnNlKHJlcXVlc3QsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcmVxdWVzdCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcclxuICAgICAgICBfdGhpcy5lcnJvciA9IGVycm9yO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBFcnJvclJlc3BvbnNlO1xyXG59KEFjdGl2aXR5UmVzcG9uc2UpKTtcclxuZXhwb3J0cy5FcnJvclJlc3BvbnNlID0gRXJyb3JSZXNwb25zZTtcclxudmFyIExvZ2luUmVxdWVzdFJlc3BvbnNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKExvZ2luUmVxdWVzdFJlc3BvbnNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTG9naW5SZXF1ZXN0UmVzcG9uc2UocmVxdWVzdCwgYXV0aCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJlcXVlc3QpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XHJcbiAgICAgICAgX3RoaXMuX2F1dGggPSBhdXRoO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBfdGhpcy5fYXV0aC5idXR0b25zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgYnV0dG9uID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBpZiAoYnV0dG9uLnR5cGUgPT09IFwic2lnbmluXCIgJiYgYnV0dG9uLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IFVSTChidXR0b24udmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNpZ25pbkJ1dHRvbiA9IGJ1dHRvbjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHBhcnNpbmcgZXJyb3JcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9naW5SZXF1ZXN0UmVzcG9uc2UucHJvdG90eXBlLCBcInRva2VuRXhjaGFuZ2VSZXNvdXJjZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdXRoLnRva2VuRXhjaGFuZ2VSZXNvdXJjZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gTG9naW5SZXF1ZXN0UmVzcG9uc2U7XHJcbn0oQWN0aXZpdHlSZXNwb25zZSkpO1xyXG5leHBvcnRzLkxvZ2luUmVxdWVzdFJlc3BvbnNlID0gTG9naW5SZXF1ZXN0UmVzcG9uc2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGl2aXR5LXJlcXVlc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuQWRhcHRpdmVBcHBsZXQgPSB2b2lkIDA7XHJcbi8vIENvcHlyaWdodCAoQykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbnZhciBFbnVtcyA9IHJlcXVpcmUoXCIuL2VudW1zXCIpO1xyXG52YXIgVXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcclxudmFyIHNoYXJlZF8xID0gcmVxdWlyZShcIi4vc2hhcmVkXCIpO1xyXG52YXIgYWN0aXZpdHlfcmVxdWVzdF8xID0gcmVxdWlyZShcIi4vYWN0aXZpdHktcmVxdWVzdFwiKTtcclxudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ3NcIik7XHJcbnZhciBjYXJkX2VsZW1lbnRzXzEgPSByZXF1aXJlKFwiLi9jYXJkLWVsZW1lbnRzXCIpO1xyXG52YXIgc2VyaWFsaXphdGlvbl8xID0gcmVxdWlyZShcIi4vc2VyaWFsaXphdGlvblwiKTtcclxuZnVuY3Rpb24gbG9nRXZlbnQobGV2ZWwsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBvcHRpb25hbFBhcmFtcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBvcHRpb25hbFBhcmFtc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIGlmIChzaGFyZWRfMS5HbG9iYWxTZXR0aW5ncy5hcHBsZXRzLmxvZ0VuYWJsZWQpIHtcclxuICAgICAgICBpZiAoc2hhcmVkXzEuR2xvYmFsU2V0dGluZ3MuYXBwbGV0cy5vbkxvZ0V2ZW50KSB7XHJcbiAgICAgICAgICAgIHNoYXJlZF8xLkdsb2JhbFNldHRpbmdzLmFwcGxldHMub25Mb2dFdmVudChsZXZlbCwgbWVzc2FnZSwgb3B0aW9uYWxQYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGxldmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVudW1zLkxvZ0xldmVsLldhcm5pbmc6XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UsIG9wdGlvbmFsUGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRW51bXMuTG9nTGV2ZWwuRXJyb3I6XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCBvcHRpb25hbFBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UsIG9wdGlvbmFsUGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxudmFyIEFjdGl2aXR5UmVxdWVzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFjdGl2aXR5UmVxdWVzdChhY3Rpb24sIHRyaWdnZXIsIGNvbnNlY3V0aXZlUmVmcmVzaGVzKSB7XHJcbiAgICAgICAgdGhpcy5hY3Rpb24gPSBhY3Rpb247XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyID0gdHJpZ2dlcjtcclxuICAgICAgICB0aGlzLmNvbnNlY3V0aXZlUmVmcmVzaGVzID0gY29uc2VjdXRpdmVSZWZyZXNoZXM7XHJcbiAgICAgICAgdGhpcy5hdHRlbXB0TnVtYmVyID0gMDtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVxdWlyZS1hd2FpdFxyXG4gICAgQWN0aXZpdHlSZXF1ZXN0LnByb3RvdHlwZS5yZXRyeUFzeW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25TZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNlbmQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBY3Rpdml0eVJlcXVlc3Q7XHJcbn0oKSk7XHJcbnZhciBBZGFwdGl2ZUFwcGxldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFkYXB0aXZlQXBwbGV0KCkge1xyXG4gICAgICAgIHRoaXMuX2FsbG93QXV0b21hdGljQ2FyZFVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudC5jbGFzc05hbWUgPSBcImFhZi1jYXJkSG9zdFwiO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcclxuICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudC5zdHlsZS5mbGV4RGlyZWN0aW9uID0gXCJjb2x1bW5cIjtcclxuICAgICAgICB0aGlzLl9jYXJkSG9zdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIHRoaXMuX3JlZnJlc2hCdXR0b25Ib3N0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgdGhpcy5fcmVmcmVzaEJ1dHRvbkhvc3RFbGVtZW50LmNsYXNzTmFtZSA9IFwiYWFmLXJlZnJlc2hCdXR0b25Ib3N0XCI7XHJcbiAgICAgICAgdGhpcy5fcmVmcmVzaEJ1dHRvbkhvc3RFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9jYXJkSG9zdEVsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3JlZnJlc2hCdXR0b25Ib3N0RWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICBBZGFwdGl2ZUFwcGxldC5wcm90b3R5cGUuZGlzcGxheUNhcmQgPSBmdW5jdGlvbiAoY2FyZCkge1xyXG4gICAgICAgIGlmIChjYXJkLnJlbmRlcmVkRWxlbWVudCkge1xyXG4gICAgICAgICAgICBVdGlscy5jbGVhckVsZW1lbnRDaGlsZHJlbih0aGlzLl9jYXJkSG9zdEVsZW1lbnQpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoQnV0dG9uSG9zdEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgICAgICB0aGlzLl9jYXJkSG9zdEVsZW1lbnQuYXBwZW5kQ2hpbGQoY2FyZC5yZW5kZXJlZEVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzcGxheUNhcmQ6IHVuZGVmaW5lZCBjYXJkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWRhcHRpdmVBcHBsZXQucHJvdG90eXBlLnNob3dNYW51YWxSZWZyZXNoQnV0dG9uID0gZnVuY3Rpb24gKHJlZnJlc2hBY3Rpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBkaXNwbGF5QnVpbHRJbk1hbnVhbFJlZnJlc2hCdXR0b24gPSB0aGlzLm9uU2hvd01hbnVhbFJlZnJlc2hCdXR0b25cclxuICAgICAgICAgICAgPyB0aGlzLm9uU2hvd01hbnVhbFJlZnJlc2hCdXR0b24odGhpcylcclxuICAgICAgICAgICAgOiB0cnVlO1xyXG4gICAgICAgIGlmIChkaXNwbGF5QnVpbHRJbk1hbnVhbFJlZnJlc2hCdXR0b24pIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVmcmVzaEJ1dHRvbkhvc3RFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICAgICAgdmFyIHJlbmRlcmVkUmVmcmVzaEJ1dHRvbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKHRoaXMub25SZW5kZXJNYW51YWxSZWZyZXNoQnV0dG9uKSB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlZFJlZnJlc2hCdXR0b24gPSB0aGlzLm9uUmVuZGVyTWFudWFsUmVmcmVzaEJ1dHRvbih0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gc3RyaW5nc18xLlN0cmluZ3MucnVudGltZS5yZWZyZXNoVGhpc0NhcmQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChzaGFyZWRfMS5HbG9iYWxTZXR0aW5ncy5hcHBsZXRzLnJlZnJlc2gubW9kZSA9PT0gRW51bXMuUmVmcmVzaE1vZGUuQXV0b21hdGljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF1dG9SZWZyZXNoUGF1c2VkTWVzc2FnZSA9IHN0cmluZ3NfMS5TdHJpbmdzLnJ1bnRpbWUuYXV0b21hdGljUmVmcmVzaFBhdXNlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdXRvUmVmcmVzaFBhdXNlZE1lc3NhZ2VbYXV0b1JlZnJlc2hQYXVzZWRNZXNzYWdlLmxlbmd0aCAtIDFdICE9PSBcIiBcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvUmVmcmVzaFBhdXNlZE1lc3NhZ2UgKz0gXCIgXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBzdHJpbmdzXzEuU3RyaW5ncy5ydW50aW1lLmNsY2tUb1Jlc3RhcnRBdXRvbWF0aWNSZWZyZXNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FyZFBheWxvYWQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJBZGFwdGl2ZUNhcmRcIixcclxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBcIjEuMlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJSaWNoVGV4dEJsb2NrXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsQWxpZ25tZW50OiBcInJpZ2h0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmxpbmVzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlRleHRSdW5cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0QWN0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkFjdGlvbi5TdWJtaXRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInJlZnJlc2hDYXJkXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FyZCA9IG5ldyBjYXJkX2VsZW1lbnRzXzEuQWRhcHRpdmVDYXJkKCk7XHJcbiAgICAgICAgICAgICAgICBjYXJkLnBhcnNlKGNhcmRQYXlsb2FkLCBuZXcgY2FyZF9lbGVtZW50c18xLlNlcmlhbGl6YXRpb25Db250ZXh0KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8yKSk7XHJcbiAgICAgICAgICAgICAgICBjYXJkLm9uRXhlY3V0ZUFjdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLmlkID09PSBcInJlZnJlc2hDYXJkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMuY2xlYXJFbGVtZW50Q2hpbGRyZW4oX3RoaXMuX3JlZnJlc2hCdXR0b25Ib3N0RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmludGVybmFsRXhlY3V0ZUFjdGlvbihyZWZyZXNoQWN0aW9uLCBhY3Rpdml0eV9yZXF1ZXN0XzEuQWN0aXZpdHlSZXF1ZXN0VHJpZ2dlci5BdXRvbWF0aWMsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlZFJlZnJlc2hCdXR0b24gPSBjYXJkLnJlbmRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZW5kZXJlZFJlZnJlc2hCdXR0b24pIHtcclxuICAgICAgICAgICAgICAgIFV0aWxzLmNsZWFyRWxlbWVudENoaWxkcmVuKHRoaXMuX3JlZnJlc2hCdXR0b25Ib3N0RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWZyZXNoQnV0dG9uSG9zdEVsZW1lbnQuYXBwZW5kQ2hpbGQocmVuZGVyZWRSZWZyZXNoQnV0dG9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hCdXR0b25Ib3N0RWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImRpc3BsYXlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWRhcHRpdmVBcHBsZXQucHJvdG90eXBlLmNyZWF0ZUFjdGl2aXR5UmVxdWVzdCA9IGZ1bmN0aW9uIChhY3Rpb24sIHRyaWdnZXIsIGNvbnNlY3V0aXZlUmVmcmVzaGVzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5jYXJkKSB7XHJcbiAgICAgICAgICAgIHZhciByZXF1ZXN0XzEgPSBuZXcgQWN0aXZpdHlSZXF1ZXN0KGFjdGlvbiwgdHJpZ2dlciwgY29uc2VjdXRpdmVSZWZyZXNoZXMpO1xyXG4gICAgICAgICAgICByZXF1ZXN0XzEub25TZW5kID0gZnVuY3Rpb24gKHNlbmRlcikge1xyXG4gICAgICAgICAgICAgICAgc2VuZGVyLmF0dGVtcHROdW1iZXIrKztcclxuICAgICAgICAgICAgICAgIHZvaWQgX3RoaXMuaW50ZXJuYWxTZW5kQWN0aXZpdHlSZXF1ZXN0QXN5bmMocmVxdWVzdF8xKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGNhbmNlbCA9IHRoaXMub25QcmVwYXJlQWN0aXZpdHlSZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICA/ICF0aGlzLm9uUHJlcGFyZUFjdGl2aXR5UmVxdWVzdCh0aGlzLCByZXF1ZXN0XzEsIGFjdGlvbilcclxuICAgICAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiBjYW5jZWwgPyB1bmRlZmluZWQgOiByZXF1ZXN0XzE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjcmVhdGVBY3Rpdml0eVJlcXVlc3Q6IG5vIGNhcmQgaGFzIGJlZW4gc2V0LlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWRhcHRpdmVBcHBsZXQucHJvdG90eXBlLmNyZWF0ZU1hZ2ljQ29kZUlucHV0Q2FyZCA9IGZ1bmN0aW9uIChhdHRlbXB0TnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIHBheWxvYWQgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiQWRhcHRpdmVDYXJkXCIsXHJcbiAgICAgICAgICAgIHZlcnNpb246IFwiMS4wXCIsXHJcbiAgICAgICAgICAgIGJvZHk6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlRleHRCbG9ja1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcImF0dGVudGlvblwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGF0dGVtcHROdW1iZXIgPT09IDEgPyB1bmRlZmluZWQgOiBcIlRoYXQgZGlkbid0IHdvcmsuLi4gbGV0J3MgdHJ5IGFnYWluLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHdyYXA6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgaG9yaXpvbnRhbEFsaWdubWVudDogXCJjZW50ZXJcIlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlRleHRCbG9ja1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICdQbGVhc2UgbG9naW4gaW4gdGhlIHBvcHVwLiBZb3Ugd2lsbCBvYnRhaW4gYSBtYWdpYyBjb2RlLiBQYXN0ZSB0aGF0IGNvZGUgYmVsb3cgYW5kIHNlbGVjdCBcIlN1Ym1pdFwiJyxcclxuICAgICAgICAgICAgICAgICAgICB3cmFwOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGhvcml6b250YWxBbGlnbm1lbnQ6IFwiY2VudGVyXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJJbnB1dC5UZXh0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IFwibWFnaWNDb2RlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiRW50ZXIgbWFnaWMgY29kZVwiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiQWN0aW9uU2V0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgaG9yaXpvbnRhbEFsaWdubWVudDogXCJjZW50ZXJcIixcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiQWN0aW9uLlN1Ym1pdFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IEFkYXB0aXZlQXBwbGV0Ll9zdWJtaXRNYWdpY0NvZGVBY3Rpb25JZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlN1Ym1pdFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiQWN0aW9uLlN1Ym1pdFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IEFkYXB0aXZlQXBwbGV0Ll9jYW5jZWxNYWdpY0NvZGVBdXRoQWN0aW9uSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJDYW5jZWxcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgY2FyZCA9IG5ldyBjYXJkX2VsZW1lbnRzXzEuQWRhcHRpdmVDYXJkKCk7XHJcbiAgICAgICAgY2FyZC5wYXJzZShwYXlsb2FkKTtcclxuICAgICAgICByZXR1cm4gY2FyZDtcclxuICAgIH07XHJcbiAgICBBZGFwdGl2ZUFwcGxldC5wcm90b3R5cGUuY2FuY2VsQXV0b21hdGljUmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fYWxsb3dBdXRvbWF0aWNDYXJkVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIGxvZ0V2ZW50KEVudW1zLkxvZ0xldmVsLldhcm5pbmcsIFwiQXV0b21hdGljIGNhcmQgcmVmcmVzaCBoYXMgYmVlbiBjYW5jZWxsZWQgYXMgYSByZXN1bHQgb2YgdGhlIHVzZXIgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgY2FyZC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2FsbG93QXV0b21hdGljQ2FyZFVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIEFkYXB0aXZlQXBwbGV0LnByb3RvdHlwZS5jcmVhdGVTZXJpYWxpemF0aW9uQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vbkNyZWF0ZVNlcmlhbGl6YXRpb25Db250ZXh0XHJcbiAgICAgICAgICAgID8gdGhpcy5vbkNyZWF0ZVNlcmlhbGl6YXRpb25Db250ZXh0KHRoaXMpXHJcbiAgICAgICAgICAgIDogbmV3IGNhcmRfZWxlbWVudHNfMS5TZXJpYWxpemF0aW9uQ29udGV4dCgpO1xyXG4gICAgfTtcclxuICAgIEFkYXB0aXZlQXBwbGV0LnByb3RvdHlwZS5pbnRlcm5hbFNldENhcmQgPSBmdW5jdGlvbiAocGF5bG9hZCwgY29uc2VjdXRpdmVSZWZyZXNoZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gXCJvYmplY3RcIiAmJiBwYXlsb2FkW1widHlwZVwiXSA9PT0gXCJBZGFwdGl2ZUNhcmRcIikge1xyXG4gICAgICAgICAgICB0aGlzLl9jYXJkUGF5bG9hZCA9IHBheWxvYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9jYXJkUGF5bG9hZCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhcmQgPSBuZXcgY2FyZF9lbGVtZW50c18xLkFkYXB0aXZlQ2FyZCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaG9zdENvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhcmQuaG9zdENvbmZpZyA9IHRoaXMuaG9zdENvbmZpZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemF0aW9uQ29udGV4dCA9IHRoaXMuY3JlYXRlU2VyaWFsaXphdGlvbkNvbnRleHQoKTtcclxuICAgICAgICAgICAgICAgIGNhcmQucGFyc2UodGhpcy5fY2FyZFBheWxvYWQsIHNlcmlhbGl6YXRpb25Db250ZXh0KTtcclxuICAgICAgICAgICAgICAgIHZhciBkb0NoYW5nZUNhcmQgPSB0aGlzLm9uQ2FyZENoYW5naW5nXHJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm9uQ2FyZENoYW5naW5nKHRoaXMsIHRoaXMuX2NhcmRQYXlsb2FkKVxyXG4gICAgICAgICAgICAgICAgICAgIDogdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChkb0NoYW5nZUNhcmQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXJkID0gY2FyZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FyZC5hdXRoZW50aWNhdGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXJkLmF1dGhlbnRpY2F0aW9uLnRva2VuRXhjaGFuZ2VSZXNvdXJjZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUHJlZmV0Y2hTU09Ub2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUHJlZmV0Y2hTU09Ub2tlbih0aGlzLCB0aGlzLl9jYXJkLmF1dGhlbnRpY2F0aW9uLnRva2VuRXhjaGFuZ2VSZXNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhcmQub25FeGVjdXRlQWN0aW9uID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlciB0YWtlcyBhbiBhY3Rpb24sIGNhbmNlbCBhbnkgcGVuZGluZyBhdXRvbWF0aWMgcmVmcmVzaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jYW5jZWxBdXRvbWF0aWNSZWZyZXNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmludGVybmFsRXhlY3V0ZUFjdGlvbihhY3Rpb24sIGFjdGl2aXR5X3JlcXVlc3RfMS5BY3Rpdml0eVJlcXVlc3RUcmlnZ2VyLk1hbnVhbCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXJkLm9uSW5wdXRWYWx1ZUNoYW5nZWQgPSBmdW5jdGlvbiAoX2lucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIG1vZGlmaWVzIGFuIGlucHV0LCBjYW5jZWwgYW55IHBlbmRpbmcgYXV0b21hdGljIHJlZnJlc2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2FuY2VsQXV0b21hdGljUmVmcmVzaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FyZC5yZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FyZC5yZW5kZXJlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5Q2FyZCh0aGlzLl9jYXJkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub25DYXJkQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNhcmRDaGFuZ2VkKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYXJkLnJlZnJlc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGFyZWRfMS5HbG9iYWxTZXR0aW5ncy5hcHBsZXRzLnJlZnJlc2gubW9kZSA9PT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbnVtcy5SZWZyZXNoTW9kZS5BdXRvbWF0aWMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zZWN1dGl2ZVJlZnJlc2hlcyA8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZF8xLkdsb2JhbFNldHRpbmdzLmFwcGxldHMucmVmcmVzaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1heGltdW1Db25zZWN1dGl2ZUF1dG9tYXRpY1JlZnJlc2hlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGFyZWRfMS5HbG9iYWxTZXR0aW5ncy5hcHBsZXRzLnJlZnJlc2gudGltZUJldHdlZW5BdXRvbWF0aWNSZWZyZXNoZXMgPD1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dFdmVudChFbnVtcy5Mb2dMZXZlbC5JbmZvLCBcIlRyaWdnZXJpbmcgYXV0b21hdGljIGNhcmQgcmVmcmVzaCBudW1iZXIgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbnNlY3V0aXZlUmVmcmVzaGVzICsgMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsRXhlY3V0ZUFjdGlvbih0aGlzLl9jYXJkLnJlZnJlc2guYWN0aW9uLCBhY3Rpdml0eV9yZXF1ZXN0XzEuQWN0aXZpdHlSZXF1ZXN0VHJpZ2dlci5BdXRvbWF0aWMsIGNvbnNlY3V0aXZlUmVmcmVzaGVzICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dFdmVudChFbnVtcy5Mb2dMZXZlbC5JbmZvLCBcIlNjaGVkdWxpbmcgYXV0b21hdGljIGNhcmQgcmVmcmVzaCBudW1iZXIgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbnNlY3V0aXZlUmVmcmVzaGVzICsgMSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgaW4gXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVkXzEuR2xvYmFsU2V0dGluZ3MuYXBwbGV0cy5yZWZyZXNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRpbWVCZXR3ZWVuQXV0b21hdGljUmVmcmVzaGVzICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb25fMSA9IHRoaXMuX2NhcmQucmVmcmVzaC5hY3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FsbG93QXV0b21hdGljQ2FyZFVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fYWxsb3dBdXRvbWF0aWNDYXJkVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW50ZXJuYWxFeGVjdXRlQWN0aW9uKGFjdGlvbl8xLCBhY3Rpdml0eV9yZXF1ZXN0XzEuQWN0aXZpdHlSZXF1ZXN0VHJpZ2dlci5BdXRvbWF0aWMsIGNvbnNlY3V0aXZlUmVmcmVzaGVzICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHNoYXJlZF8xLkdsb2JhbFNldHRpbmdzLmFwcGxldHMucmVmcmVzaC50aW1lQmV0d2VlbkF1dG9tYXRpY1JlZnJlc2hlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcmVkXzEuR2xvYmFsU2V0dGluZ3MuYXBwbGV0cy5yZWZyZXNoLm1vZGUgIT09IEVudW1zLlJlZnJlc2hNb2RlLkRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNlY3V0aXZlUmVmcmVzaGVzID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dFdmVudChFbnVtcy5Mb2dMZXZlbC5XYXJuaW5nLCBcIlN0b3BwaW5nIGF1dG9tYXRpYyByZWZyZXNoZXMgYWZ0ZXIgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc2VjdXRpdmVSZWZyZXNoZXMgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgY29uc2VjdXRpdmUgcmVmcmVzaGVzLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V2ZW50KEVudW1zLkxvZ0xldmVsLldhcm5pbmcsIFwiVGhlIGNhcmQgaGFzIGEgcmVmcmVzaCBzZWN0aW9uLCBidXQgYXV0b21hdGljIHJlZnJlc2hlcyBhcmUgZGlzYWJsZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcmVkXzEuR2xvYmFsU2V0dGluZ3MuYXBwbGV0cy5yZWZyZXNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hbGxvd01hbnVhbFJlZnJlc2hlc0FmdGVyQXV0b21hdGljUmVmcmVzaGVzIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZF8xLkdsb2JhbFNldHRpbmdzLmFwcGxldHMucmVmcmVzaC5tb2RlID09PSBFbnVtcy5SZWZyZXNoTW9kZS5NYW51YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXZlbnQoRW51bXMuTG9nTGV2ZWwuSW5mbywgXCJTaG93aW5nIG1hbnVhbCByZWZyZXNoIGJ1dHRvbi5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd01hbnVhbFJlZnJlc2hCdXR0b24odGhpcy5fY2FyZC5yZWZyZXNoLmFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGFsbCBlcnJvcnNcclxuICAgICAgICAgICAgICAgIGxvZ0V2ZW50KEVudW1zLkxvZ0xldmVsLkVycm9yLCBcInNldENhcmQ6IFwiICsgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFkYXB0aXZlQXBwbGV0LnByb3RvdHlwZS5pbnRlcm5hbEV4ZWN1dGVBY3Rpb24gPSBmdW5jdGlvbiAoYWN0aW9uLCB0cmlnZ2VyLCBjb25zZWN1dGl2ZVJlZnJlc2hlcykge1xyXG4gICAgICAgIGlmIChhY3Rpb24gaW5zdGFuY2VvZiBjYXJkX2VsZW1lbnRzXzEuRXhlY3V0ZUFjdGlvbikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsQWRhcHRlcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLmNyZWF0ZUFjdGl2aXR5UmVxdWVzdChhY3Rpb24sIHRyaWdnZXIsIGNvbnNlY3V0aXZlUmVmcmVzaGVzKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCByZXF1ZXN0LnJldHJ5QXN5bmMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsRXhlY3V0ZUFjdGlvbjogTm8gY2hhbm5lbCBhZGFwdGVyIHNldC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub25BY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5vbkFjdGlvbih0aGlzLCBhY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBZGFwdGl2ZUFwcGxldC5wcm90b3R5cGUuY3JlYXRlUHJvZ3Jlc3NPdmVybGF5ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3Byb2dyZXNzT3ZlcmxheSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vbkNyZWF0ZVByb2dyZXNzT3ZlcmxheSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPdmVybGF5ID0gdGhpcy5vbkNyZWF0ZVByb2dyZXNzT3ZlcmxheSh0aGlzLCByZXF1ZXN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzT3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9ncmVzc092ZXJsYXkuY2xhc3NOYW1lID0gXCJhYWYtcHJvZ3Jlc3Mtb3ZlcmxheVwiO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICAgICAgc3Bpbm5lci5jbGFzc05hbWUgPSBcImFhZi1zcGlubmVyXCI7XHJcbiAgICAgICAgICAgICAgICBzcGlubmVyLnN0eWxlLndpZHRoID0gXCIyOHB4XCI7XHJcbiAgICAgICAgICAgICAgICBzcGlubmVyLnN0eWxlLmhlaWdodCA9IFwiMjhweFwiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPdmVybGF5LmFwcGVuZENoaWxkKHNwaW5uZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9ncmVzc092ZXJsYXk7XHJcbiAgICB9O1xyXG4gICAgQWRhcHRpdmVBcHBsZXQucHJvdG90eXBlLnJlbW92ZVByb2dyZXNzT3ZlcmxheSA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMub25SZW1vdmVQcm9ncmVzc092ZXJsYXkpIHtcclxuICAgICAgICAgICAgdGhpcy5vblJlbW92ZVByb2dyZXNzT3ZlcmxheSh0aGlzLCByZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzT3ZlcmxheSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX3Byb2dyZXNzT3ZlcmxheSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzT3ZlcmxheSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWRhcHRpdmVBcHBsZXQucHJvdG90eXBlLmFjdGl2aXR5UmVxdWVzdFN1Y2NlZWRlZCA9IGZ1bmN0aW9uIChyZXNwb25zZSwgcGFyc2VkQ29udGVudCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9uQWN0aXZpdHlSZXF1ZXN0U3VjY2VlZGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25BY3Rpdml0eVJlcXVlc3RTdWNjZWVkZWQodGhpcywgcmVzcG9uc2UsIHBhcnNlZENvbnRlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBZGFwdGl2ZUFwcGxldC5wcm90b3R5cGUuYWN0aXZpdHlSZXF1ZXN0RmFpbGVkID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub25BY3Rpdml0eVJlcXVlc3RGYWlsZWRcclxuICAgICAgICAgICAgPyB0aGlzLm9uQWN0aXZpdHlSZXF1ZXN0RmFpbGVkKHRoaXMsIHJlc3BvbnNlKVxyXG4gICAgICAgICAgICA6IHNoYXJlZF8xLkdsb2JhbFNldHRpbmdzLmFwcGxldHMuZGVmYXVsdFRpbWVCZXR3ZWVuUmV0cnlBdHRlbXB0cztcclxuICAgIH07XHJcbiAgICBBZGFwdGl2ZUFwcGxldC5wcm90b3R5cGUuc2hvd0F1dGhDb2RlSW5wdXREaWFsb2cgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHNob3dCdWlsdEluQXV0aENvZGVJbnB1dENhcmQgPSB0aGlzLm9uU2hvd0F1dGhDb2RlSW5wdXREaWFsb2dcclxuICAgICAgICAgICAgPyB0aGlzLm9uU2hvd0F1dGhDb2RlSW5wdXREaWFsb2codGhpcywgcmVxdWVzdClcclxuICAgICAgICAgICAgOiB0cnVlO1xyXG4gICAgICAgIGlmIChzaG93QnVpbHRJbkF1dGhDb2RlSW5wdXRDYXJkKSB7XHJcbiAgICAgICAgICAgIHZhciBhdXRoQ29kZUlucHV0Q2FyZCA9IHRoaXMuY3JlYXRlTWFnaWNDb2RlSW5wdXRDYXJkKHJlcXVlc3QuYXR0ZW1wdE51bWJlcik7XHJcbiAgICAgICAgICAgIGF1dGhDb2RlSW5wdXRDYXJkLnJlbmRlcigpO1xyXG4gICAgICAgICAgICBhdXRoQ29kZUlucHV0Q2FyZC5vbkV4ZWN1dGVBY3Rpb24gPSBmdW5jdGlvbiAoc3VibWl0TWFnaWNDb2RlQWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY2FyZCAmJiBzdWJtaXRNYWdpY0NvZGVBY3Rpb24gaW5zdGFuY2VvZiBjYXJkX2VsZW1lbnRzXzEuU3VibWl0QWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdWJtaXRNYWdpY0NvZGVBY3Rpb24uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBZGFwdGl2ZUFwcGxldC5fc3VibWl0TWFnaWNDb2RlQWN0aW9uSWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXV0aENvZGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VibWl0TWFnaWNDb2RlQWN0aW9uLmRhdGEgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygc3VibWl0TWFnaWNDb2RlQWN0aW9uLmRhdGFbXCJtYWdpY0NvZGVcIl0gPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoQ29kZSA9IHN1Ym1pdE1hZ2ljQ29kZUFjdGlvbi5kYXRhW1wibWFnaWNDb2RlXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF1dGhDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzcGxheUNhcmQoX3RoaXMuY2FyZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hdXRoQ29kZSA9IGF1dGhDb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgcmVxdWVzdC5yZXRyeUFzeW5jKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydChcIlBsZWFzZSBlbnRlciB0aGUgbWFnaWMgY29kZSB5b3UgcmVjZWl2ZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQWRhcHRpdmVBcHBsZXQuX2NhbmNlbE1hZ2ljQ29kZUF1dGhBY3Rpb25JZDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V2ZW50KEVudW1zLkxvZ0xldmVsLldhcm5pbmcsIFwiQXV0aGVudGljYXRpb24gY2FuY2VsbGVkIGJ5IHVzZXIuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzcGxheUNhcmQoX3RoaXMuY2FyZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V2ZW50KEVudW1zLkxvZ0xldmVsLkVycm9yLCBcIlVuZXhwZWN0ZWQgYWN0aW9uIHRha2VuIGZyb20gbWFnaWMgY29kZSBpbnB1dCBjYXJkIChpZCA9IFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJtaXRNYWdpY0NvZGVBY3Rpb24uaWQgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KHN0cmluZ3NfMS5TdHJpbmdzLm1hZ2ljQ29kZUlucHV0Q2FyZC5zb21ldGhpbmdXZW50V3JvbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheUNhcmQoYXV0aENvZGVJbnB1dENhcmQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBZGFwdGl2ZUFwcGxldC5wcm90b3R5cGUuaW50ZXJuYWxTZW5kQWN0aXZpdHlSZXF1ZXN0QXN5bmMgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG92ZXJsYXksIGRvbmUsIF9sb29wXzEsIHRoaXNfMSwgc3RhdGVfMTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNoYW5uZWxBZGFwdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnRlcm5hbFNlbmRBY3Rpdml0eVJlcXVlc3RBc3luYzogY2hhbm5lbEFkYXB0ZXIgaXMgbm90IHNldC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9IHRoaXMuY3JlYXRlUHJvZ3Jlc3NPdmVybGF5KHJlcXVlc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudC5hcHBlbmRDaGlsZChvdmVybGF5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UsIGVycm9yXzEsIHBhcnNlZENvbnRlbnQsIHJldHJ5SW5fMSwgYXR0ZW1wdE9BdXRoLCBsZWZ0LCB0b3BfMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuYXR0ZW1wdE51bWJlciA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V2ZW50KEVudW1zLkxvZ0xldmVsLkluZm8sIFwiU2VuZGluZyBhY3Rpdml0eSByZXF1ZXN0IHRvIGNoYW5uZWwgKGF0dGVtcHQgXCIgKyByZXF1ZXN0LmF0dGVtcHROdW1iZXIgKyBcIilcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dFdmVudChFbnVtcy5Mb2dMZXZlbC5JbmZvLCBcIlJlLXNlbmRpbmcgYWN0aXZpdHkgcmVxdWVzdCB0byBjaGFubmVsIChhdHRlbXB0IFwiICsgcmVxdWVzdC5hdHRlbXB0TnVtYmVyICsgXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpc18xLmNoYW5uZWxBZGFwdGVyLnNlbmRSZXF1ZXN0QXN5bmMocmVxdWVzdCldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXZlbnQoRW51bXMuTG9nTGV2ZWwuRXJyb3IsIFwiQWN0aXZpdHkgcmVxdWVzdCBmYWlsZWQ6IFwiICsgZXJyb3JfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEucmVtb3ZlUHJvZ3Jlc3NPdmVybGF5KHJlcXVlc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiBhY3Rpdml0eV9yZXF1ZXN0XzEuU3VjY2Vzc1Jlc3BvbnNlKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEucmVtb3ZlUHJvZ3Jlc3NPdmVybGF5KHJlcXVlc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnJhd0NvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsU2VuZEFjdGl2aXR5UmVxdWVzdEFzeW5jOiBBY3Rpb24uRXhlY3V0ZSByZXN1bHQgaXMgdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkQ29udGVudCA9IHJlc3BvbnNlLnJhd0NvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZENvbnRlbnQgPSBKU09OLnBhcnNlKHJlc3BvbnNlLnJhd0NvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF9jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVhdmUgcGFyc2VDb250ZW50IGFzIGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlZENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dFdmVudChFbnVtcy5Mb2dMZXZlbC5JbmZvLCBcIlRoZSBhY3Rpdml0eSByZXF1ZXN0IHJldHVybmVkIGEgc3RyaW5nIGFmdGVyIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hdHRlbXB0TnVtYmVyICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYXR0ZW1wdChzKS5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLmFjdGl2aXR5UmVxdWVzdFN1Y2NlZWRlZChyZXNwb25zZSwgcGFyc2VkQ29udGVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGFyc2VkQ29udGVudCA9PT0gXCJvYmplY3RcIiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZENvbnRlbnRbXCJ0eXBlXCJdID09PSBcIkFkYXB0aXZlQ2FyZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXZlbnQoRW51bXMuTG9nTGV2ZWwuSW5mbywgXCJUaGUgYWN0aXZpdHkgcmVxdWVzdCByZXR1cm5lZCBhbiBBZGFwdGl2ZSBDYXJkIGFmdGVyIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hdHRlbXB0TnVtYmVyICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYXR0ZW1wdChzKS5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLmludGVybmFsU2V0Q2FyZChwYXJzZWRDb250ZW50LCByZXF1ZXN0LmNvbnNlY3V0aXZlUmVmcmVzaGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEuYWN0aXZpdHlSZXF1ZXN0U3VjY2VlZGVkKHJlc3BvbnNlLCB0aGlzXzEuY2FyZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnRlcm5hbFNlbmRBY3Rpdml0eVJlcXVlc3RBc3luYzogQWN0aW9uLkV4ZWN1dGUgcmVzdWx0IGlzIG9mIHVuc3VwcG9ydGVkIHR5cGUgKFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlc3BvbnNlLnJhd0NvbnRlbnQgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIilcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiBhY3Rpdml0eV9yZXF1ZXN0XzEuRXJyb3JSZXNwb25zZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlJbl8xID0gdGhpc18xLmFjdGl2aXR5UmVxdWVzdEZhaWxlZChyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXRyeUluXzEgPj0gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuYXR0ZW1wdE51bWJlciA8IHNoYXJlZF8xLkdsb2JhbFNldHRpbmdzLmFwcGxldHMubWF4aW11bVJldHJ5QXR0ZW1wdHMpKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V2ZW50KEVudW1zLkxvZ0xldmVsLldhcm5pbmcsIFwiQWN0aXZpdHkgcmVxdWVzdCBmYWlsZWQ6IFwiLmNvbmNhdChyZXNwb25zZS5lcnJvci5tZXNzYWdlLCBcIi4gUmV0cnlpbmcgaW4gXCIpLmNvbmNhdChyZXRyeUluXzEsIFwibXNcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hdHRlbXB0TnVtYmVyKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgX3JlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJldHJ5SW5fMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXZlbnQoRW51bXMuTG9nTGV2ZWwuRXJyb3IsIFwiQWN0aXZpdHkgcmVxdWVzdCBmYWlsZWQ6IFwiLmNvbmNhdChyZXNwb25zZS5lcnJvci5tZXNzYWdlLCBcIi4gR2l2aW5nIHVwIGFmdGVyIFwiKS5jb25jYXQocmVxdWVzdC5hdHRlbXB0TnVtYmVyLCBcIiBhdHRlbXB0KHMpXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5yZW1vdmVQcm9ncmVzc092ZXJsYXkocmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gODtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzMgLypicmVhayovLCAxMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIGFjdGl2aXR5X3JlcXVlc3RfMS5Mb2dpblJlcXVlc3RSZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V2ZW50KEVudW1zLkxvZ0xldmVsLkluZm8sIFwiVGhlIGFjdGl2aXR5IHJlcXVlc3QgcmV0dXJuZWQgYSBMb2dpblJlcXVlc3RSZXNwb25zZSBhZnRlciBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuYXR0ZW1wdE51bWJlciArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGF0dGVtcHQocykuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmF0dGVtcHROdW1iZXIgPD0gc2hhcmVkXzEuR2xvYmFsU2V0dGluZ3MuYXBwbGV0cy5tYXhpbXVtUmV0cnlBdHRlbXB0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRlbXB0T0F1dGggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudG9rZW5FeGNoYW5nZVJlc291cmNlICYmIHRoaXNfMS5vblNTT1Rva2VuTmVlZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIHVzZSBTU08uIFRoZSBob3N0IHdpbGwgcmV0dXJuIHRydWUgaWYgaXQgY2FuIGhhbmRsZSBTU08sIGluIHdoaWNoIGNhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGJ5cGFzcyBPQXV0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdE9BdXRoID0gIXRoaXNfMS5vblNTT1Rva2VuTmVlZGVkKHRoaXNfMSwgcmVxdWVzdCwgcmVzcG9uc2UudG9rZW5FeGNoYW5nZVJlc291cmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdE9BdXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIHVzZSBPQXV0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLnJlbW92ZVByb2dyZXNzT3ZlcmxheShyZXF1ZXN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zaWduaW5CdXR0b24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsU2VuZEFjdGl2aXR5UmVxdWVzdEFzeW5jOiB0aGUgbG9naW4gcmVxdWVzdCBkb2Vzbid0IGNvbnRhaW4gYSB2YWxpZCBzaWduaW4gVVJMLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V2ZW50KEVudW1zLkxvZ0xldmVsLkluZm8sIFwiTG9naW4gcmVxdWlyZWQgYXQgXCIgKyByZXNwb25zZS5zaWduaW5CdXR0b24udmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNfMS5vblNob3dTaWduaW5Qcm9tcHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCeXBhc3MgdGhlIGJ1aWx0LWluIGF1dGggcHJvbXB0IGlmIHRoZSBob3N0IGFwcCBoYW5kbGVzIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLm9uU2hvd1NpZ25pblByb21wdCh0aGlzXzEsIHJlcXVlc3QsIHJlc3BvbnNlLnNpZ25pbkJ1dHRvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEuc2hvd0F1dGhDb2RlSW5wdXREaWFsb2cocmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHdpbmRvdy5zY3JlZW5YICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdpbmRvdy5vdXRlcldpZHRoIC0gc2hhcmVkXzEuR2xvYmFsU2V0dGluZ3MuYXBwbGV0cy5hdXRoUHJvbXB0V2lkdGgpIC9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wXzEgPSB3aW5kb3cuc2NyZWVuWSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh3aW5kb3cub3V0ZXJIZWlnaHQgLSBzaGFyZWRfMS5HbG9iYWxTZXR0aW5ncy5hcHBsZXRzLmF1dGhQcm9tcHRIZWlnaHQpIC9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9wZW4ocmVzcG9uc2Uuc2lnbmluQnV0dG9uLnZhbHVlLCByZXNwb25zZS5zaWduaW5CdXR0b24udGl0bGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZS5zaWduaW5CdXR0b24udGl0bGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlNpZ24gaW5cIiwgXCJ3aWR0aD1cIi5jb25jYXQoc2hhcmVkXzEuR2xvYmFsU2V0dGluZ3MuYXBwbGV0cy5hdXRoUHJvbXB0V2lkdGgsIFwiLGhlaWdodD1cIikuY29uY2F0KHNoYXJlZF8xLkdsb2JhbFNldHRpbmdzLmFwcGxldHMuYXV0aFByb21wdEhlaWdodCwgXCIsbGVmdD1cIikuY29uY2F0KGxlZnQsIFwiLHRvcD1cIikuY29uY2F0KHRvcF8xKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V2ZW50KEVudW1zLkxvZ0xldmVsLkVycm9yLCBcIkF1dGhlbnRpY2F0aW9uIGZhaWxlZC4gR2l2aW5nIHVwIGFmdGVyIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuYXR0ZW1wdE51bWJlciArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBhdHRlbXB0KHMpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydChzdHJpbmdzXzEuU3RyaW5ncy5tYWdpY0NvZGVJbnB1dENhcmQuYXV0aGVudGljYXRpb25GYWlsZWQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBcImJyZWFrXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5oYW5kbGVkIHJlc3BvbnNlIHR5cGU6IFwiICsgSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhZG9uZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNSAvKnlpZWxkKiovLCBfbG9vcF8xKCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVfMSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlXzEgPT09IFwiYnJlYWtcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQWRhcHRpdmVBcHBsZXQucHJvdG90eXBlLnJlZnJlc2hDYXJkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jYXJkICYmIHRoaXMuX2NhcmQucmVmcmVzaCkge1xyXG4gICAgICAgICAgICB0aGlzLmludGVybmFsRXhlY3V0ZUFjdGlvbih0aGlzLl9jYXJkLnJlZnJlc2guYWN0aW9uLCBhY3Rpdml0eV9yZXF1ZXN0XzEuQWN0aXZpdHlSZXF1ZXN0VHJpZ2dlci5NYW51YWwsIDApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBZGFwdGl2ZUFwcGxldC5wcm90b3R5cGUuc2V0Q2FyZCA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbFNldENhcmQocGF5bG9hZCwgMCk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFkYXB0aXZlQXBwbGV0LnByb3RvdHlwZSwgXCJjYXJkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcmQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQWRhcHRpdmVBcHBsZXQuX3N1Ym1pdE1hZ2ljQ29kZUFjdGlvbklkID0gXCJzdWJtaXRNYWdpY0NvZGVcIjtcclxuICAgIEFkYXB0aXZlQXBwbGV0Ll9jYW5jZWxNYWdpY0NvZGVBdXRoQWN0aW9uSWQgPSBcImNhbmNlbE1hZ2ljQ29kZUF1dGhcIjtcclxuICAgIHJldHVybiBBZGFwdGl2ZUFwcGxldDtcclxufSgpKTtcclxuZXhwb3J0cy5BZGFwdGl2ZUFwcGxldCA9IEFkYXB0aXZlQXBwbGV0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGFwdGl2ZS1hcHBsZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XHJcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xyXG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pKTtcclxudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3N0cmluZ3NcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZW51bXNcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2hhcmVkXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NlcmlhbGl6YXRpb25cIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9zdC1jYXBhYmlsaXRpZXNcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaG9zdC1jb25maWdcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmVnaXN0cnlcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2FyZC1vYmplY3RcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2FyZC1lbGVtZW50c1wiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90YWJsZVwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jaGFubmVsLWFkYXB0ZXJcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWN0aXZpdHktcmVxdWVzdFwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hZGFwdGl2ZS1hcHBsZXRcIiksIGV4cG9ydHMpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGFwdGl2ZWNhcmRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5Db250YWluZXJXaXRoQWN0aW9ucyA9IGV4cG9ydHMuQ29sdW1uU2V0ID0gZXhwb3J0cy5Db2x1bW4gPSBleHBvcnRzLkNvbnRhaW5lciA9IGV4cG9ydHMuQmFja2dyb3VuZEltYWdlID0gZXhwb3J0cy5Db250YWluZXJCYXNlID0gZXhwb3J0cy5TdHlsYWJsZUNhcmRFbGVtZW50Q29udGFpbmVyID0gZXhwb3J0cy5Db250YWluZXJTdHlsZVByb3BlcnR5ID0gZXhwb3J0cy5BY3Rpb25TZXQgPSBleHBvcnRzLlNob3dDYXJkQWN0aW9uID0gZXhwb3J0cy5IdHRwQWN0aW9uID0gZXhwb3J0cy5IdHRwSGVhZGVyID0gZXhwb3J0cy5Ub2dnbGVWaXNpYmlsaXR5QWN0aW9uID0gZXhwb3J0cy5PcGVuVXJsQWN0aW9uID0gZXhwb3J0cy5FeGVjdXRlQWN0aW9uID0gZXhwb3J0cy5TdWJtaXRBY3Rpb24gPSBleHBvcnRzLlN1Ym1pdEFjdGlvbkJhc2UgPSBleHBvcnRzLkFjdGlvbiA9IGV4cG9ydHMuVGltZUlucHV0ID0gZXhwb3J0cy5UaW1lUHJvcGVydHkgPSBleHBvcnRzLkRhdGVJbnB1dCA9IGV4cG9ydHMuTnVtYmVySW5wdXQgPSBleHBvcnRzLkNob2ljZVNldElucHV0ID0gZXhwb3J0cy5DaG9pY2UgPSBleHBvcnRzLlRvZ2dsZUlucHV0ID0gZXhwb3J0cy5UZXh0SW5wdXQgPSBleHBvcnRzLklucHV0ID0gZXhwb3J0cy5NZWRpYSA9IGV4cG9ydHMuWW91VHViZVBsYXllciA9IGV4cG9ydHMuRGFpbHltb3Rpb25QbGF5ZXIgPSBleHBvcnRzLlZpbWVvUGxheWVyID0gZXhwb3J0cy5JRnJhbWVNZWRpYU1lZGlhUGxheWVyID0gZXhwb3J0cy5DdXN0b21NZWRpYVBsYXllciA9IGV4cG9ydHMuSFRNTDVNZWRpYVBsYXllciA9IGV4cG9ydHMuTWVkaWFQbGF5ZXIgPSBleHBvcnRzLk1lZGlhU291cmNlID0gZXhwb3J0cy5DYXB0aW9uU291cmNlID0gZXhwb3J0cy5Db250ZW50U291cmNlID0gZXhwb3J0cy5JbWFnZVNldCA9IGV4cG9ydHMuQ2FyZEVsZW1lbnRDb250YWluZXIgPSBleHBvcnRzLkltYWdlID0gZXhwb3J0cy5GYWN0U2V0ID0gZXhwb3J0cy5GYWN0ID0gZXhwb3J0cy5SaWNoVGV4dEJsb2NrID0gZXhwb3J0cy5UZXh0UnVuID0gZXhwb3J0cy5UZXh0QmxvY2sgPSBleHBvcnRzLkJhc2VUZXh0QmxvY2sgPSBleHBvcnRzLkFjdGlvblByb3BlcnR5ID0gZXhwb3J0cy5DYXJkRWxlbWVudCA9IGV4cG9ydHMucmVuZGVyU2VwYXJhdGlvbiA9IHZvaWQgMDtcclxuZXhwb3J0cy5TZXJpYWxpemF0aW9uQ29udGV4dCA9IGV4cG9ydHMuQWRhcHRpdmVDYXJkID0gZXhwb3J0cy5BdXRoZW50aWNhdGlvbiA9IGV4cG9ydHMuVG9rZW5FeGNoYW5nZVJlc291cmNlID0gZXhwb3J0cy5BdXRoQ2FyZEJ1dHRvbiA9IGV4cG9ydHMuUmVmcmVzaERlZmluaXRpb24gPSBleHBvcnRzLlJlZnJlc2hBY3Rpb25Qcm9wZXJ0eSA9IHZvaWQgMDtcclxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxudmFyIEVudW1zID0gcmVxdWlyZShcIi4vZW51bXNcIik7XHJcbnZhciBzaGFyZWRfMSA9IHJlcXVpcmUoXCIuL3NoYXJlZFwiKTtcclxudmFyIFV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XHJcbnZhciBob3N0X2NvbmZpZ18xID0gcmVxdWlyZShcIi4vaG9zdC1jb25maWdcIik7XHJcbnZhciBUZXh0Rm9ybWF0dGVycyA9IHJlcXVpcmUoXCIuL3RleHQtZm9ybWF0dGVyc1wiKTtcclxudmFyIGNhcmRfb2JqZWN0XzEgPSByZXF1aXJlKFwiLi9jYXJkLW9iamVjdFwiKTtcclxudmFyIHNlcmlhbGl6YXRpb25fMSA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6YXRpb25cIik7XHJcbnZhciByZWdpc3RyeV8xID0gcmVxdWlyZShcIi4vcmVnaXN0cnlcIik7XHJcbnZhciBzdHJpbmdzXzEgPSByZXF1aXJlKFwiLi9zdHJpbmdzXCIpO1xyXG52YXIgY29udHJvbHNfMSA9IHJlcXVpcmUoXCIuL2NvbnRyb2xzXCIpO1xyXG5mdW5jdGlvbiBjbGVhckVsZW1lbnQoZWxlbWVudCkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIHZhciB0cnVzdGVkSHRtbCA9ICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgPyBcIlwiIDogKChfYiA9IChfYSA9IHdpbmRvdy50cnVzdGVkVHlwZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbXB0eUhUTUwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCIpO1xyXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSB0cnVzdGVkSHRtbDtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJTZXBhcmF0aW9uKGhvc3RDb25maWcsIHNlcGFyYXRpb25EZWZpbml0aW9uLCBvcmllbnRhdGlvbikge1xyXG4gICAgaWYgKHNlcGFyYXRpb25EZWZpbml0aW9uLnNwYWNpbmcgPiAwIHx8XHJcbiAgICAgICAgKHNlcGFyYXRpb25EZWZpbml0aW9uLmxpbmVUaGlja25lc3MgJiYgc2VwYXJhdGlvbkRlZmluaXRpb24ubGluZVRoaWNrbmVzcyA+IDApKSB7XHJcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgc2VwYXJhdG9yLmNsYXNzTmFtZSA9IGhvc3RDb25maWcubWFrZUNzc0NsYXNzTmFtZShcImFjLVwiICtcclxuICAgICAgICAgICAgKG9yaWVudGF0aW9uID09PSBFbnVtcy5PcmllbnRhdGlvbi5Ib3Jpem9udGFsID8gXCJob3Jpem9udGFsXCIgOiBcInZlcnRpY2FsXCIpICtcclxuICAgICAgICAgICAgXCItc2VwYXJhdG9yXCIpO1xyXG4gICAgICAgIHNlcGFyYXRvci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XHJcbiAgICAgICAgdmFyIGNvbG9yID0gc2VwYXJhdGlvbkRlZmluaXRpb24ubGluZUNvbG9yXHJcbiAgICAgICAgICAgID8gVXRpbHMuc3RyaW5nVG9Dc3NDb2xvcihzZXBhcmF0aW9uRGVmaW5pdGlvbi5saW5lQ29sb3IpXHJcbiAgICAgICAgICAgIDogXCJcIjtcclxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT09IEVudW1zLk9yaWVudGF0aW9uLkhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgaWYgKHNlcGFyYXRpb25EZWZpbml0aW9uLmxpbmVUaGlja25lc3MpIHtcclxuICAgICAgICAgICAgICAgIHNlcGFyYXRvci5zdHlsZS5wYWRkaW5nVG9wID0gc2VwYXJhdGlvbkRlZmluaXRpb24uc3BhY2luZyAvIDIgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3Iuc3R5bGUubWFyZ2luQm90dG9tID0gc2VwYXJhdGlvbkRlZmluaXRpb24uc3BhY2luZyAvIDIgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3Iuc3R5bGUuYm9yZGVyQm90dG9tID1cclxuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0aW9uRGVmaW5pdGlvbi5saW5lVGhpY2tuZXNzICsgXCJweCBzb2xpZCBcIiArIGNvbG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yLnN0eWxlLmhlaWdodCA9IHNlcGFyYXRpb25EZWZpbml0aW9uLnNwYWNpbmcgKyBcInB4XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChzZXBhcmF0aW9uRGVmaW5pdGlvbi5saW5lVGhpY2tuZXNzKSB7XHJcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3Iuc3R5bGUucGFkZGluZ0xlZnQgPSBzZXBhcmF0aW9uRGVmaW5pdGlvbi5zcGFjaW5nIC8gMiArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIHNlcGFyYXRvci5zdHlsZS5tYXJnaW5SaWdodCA9IHNlcGFyYXRpb25EZWZpbml0aW9uLnNwYWNpbmcgLyAyICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yLnN0eWxlLmJvcmRlclJpZ2h0ID1cclxuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0aW9uRGVmaW5pdGlvbi5saW5lVGhpY2tuZXNzICsgXCJweCBzb2xpZCBcIiArIGNvbG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yLnN0eWxlLndpZHRoID0gc2VwYXJhdGlvbkRlZmluaXRpb24uc3BhY2luZyArIFwicHhcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZXBhcmF0b3Iuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xyXG4gICAgICAgIHNlcGFyYXRvci5zdHlsZS5mbGV4ID0gXCIwIDAgYXV0b1wiO1xyXG4gICAgICAgIHJldHVybiBzZXBhcmF0b3I7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMucmVuZGVyU2VwYXJhdGlvbiA9IHJlbmRlclNlcGFyYXRpb247XHJcbnZhciBDYXJkRWxlbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDYXJkRWxlbWVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENhcmRFbGVtZW50KCkge1xyXG4gICAgICAgIC8vI3JlZ2lvbiBTY2hlbWFcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fdHJ1bmNhdGVkRHVlVG9PdmVyZmxvdyA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXJkRWxlbWVudC5wcm90b3R5cGUsIFwibGFuZ1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBsYW5nID0gdGhpcy5nZXRWYWx1ZShDYXJkRWxlbWVudC5sYW5nUHJvcGVydHkpO1xyXG4gICAgICAgICAgICBpZiAobGFuZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubGFuZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUoQ2FyZEVsZW1lbnQubGFuZ1Byb3BlcnR5LCB2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhcmRFbGVtZW50LnByb3RvdHlwZSwgXCJpc1Zpc2libGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZShDYXJkRWxlbWVudC5pc1Zpc2libGVQcm9wZXJ0eSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBnb2luZyB0byBiZSBoaWRkZW4sIHJlc2V0IGFueSBjaGFuZ2VzIHRoYXQgd2VyZSBkdWVcclxuICAgICAgICAgICAgLy8gdG8gb3ZlcmZsb3cgdHJ1bmNhdGlvbiAodGhpcyBlbnN1cmVzIHRoYXQgaWYgdGhlIGVsZW1lbnQgaXMgbGF0ZXJcclxuICAgICAgICAgICAgLy8gdW4taGlkZGVuIGl0IGhhcyB0aGUgcmlnaHQgY29udGVudClcclxuICAgICAgICAgICAgaWYgKHNoYXJlZF8xLkdsb2JhbFNldHRpbmdzLnVzZUFkdmFuY2VkQ2FyZEJvdHRvbVRydW5jYXRpb24gJiYgIXZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuZG9PdmVyZmxvd1RydW5jYXRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlKENhcmRFbGVtZW50LmlzVmlzaWJsZVByb3BlcnR5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlbmRlcmVkRWxlbWVudFZpc2liaWxpdHkoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZW5kZXJlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByYWlzZUVsZW1lbnRWaXNpYmlsaXR5Q2hhbmdlZEV2ZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZW5kZXJlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIHZhbHVlLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQ2FyZEVsZW1lbnQucHJvdG90eXBlLmludGVybmFsUmVuZGVyU2VwYXJhdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZW5kZXJlZFNlcGFyYXRvciA9IHJlbmRlclNlcGFyYXRpb24odGhpcy5ob3N0Q29uZmlnLCB7XHJcbiAgICAgICAgICAgIHNwYWNpbmc6IHRoaXMuaG9zdENvbmZpZy5nZXRFZmZlY3RpdmVTcGFjaW5nKHRoaXMuc3BhY2luZyksXHJcbiAgICAgICAgICAgIGxpbmVUaGlja25lc3M6IHRoaXMuc2VwYXJhdG9yID8gdGhpcy5ob3N0Q29uZmlnLnNlcGFyYXRvci5saW5lVGhpY2tuZXNzIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBsaW5lQ29sb3I6IHRoaXMuc2VwYXJhdG9yID8gdGhpcy5ob3N0Q29uZmlnLnNlcGFyYXRvci5saW5lQ29sb3IgOiB1bmRlZmluZWRcclxuICAgICAgICB9LCB0aGlzLnNlcGFyYXRvck9yaWVudGF0aW9uKTtcclxuICAgICAgICBpZiAoc2hhcmVkXzEuR2xvYmFsU2V0dGluZ3MuYWx3YXlzQmxlZWRTZXBhcmF0b3JzICYmXHJcbiAgICAgICAgICAgIHJlbmRlcmVkU2VwYXJhdG9yICYmXHJcbiAgICAgICAgICAgIHRoaXMuc2VwYXJhdG9yT3JpZW50YXRpb24gPT09IEVudW1zLk9yaWVudGF0aW9uLkhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgLy8gQWRqdXN0IHNlcGFyYXRvcidzIG1hcmdpbnMgaWYgdGhlIG9wdGlvbiB0byBhbHdheXMgYmxlZWQgc2VwYXJhdG9ycyBpcyB0dXJuZWQgb25cclxuICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHRoaXMuZ2V0UGFyZW50Q29udGFpbmVyKCk7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnRDb250YWluZXIgJiYgcGFyZW50Q29udGFpbmVyLmdldEVmZmVjdGl2ZVBhZGRpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFBoeXNpY2FsUGFkZGluZyA9IHRoaXMuaG9zdENvbmZpZy5wYWRkaW5nRGVmaW5pdGlvblRvU3BhY2luZ0RlZmluaXRpb24ocGFyZW50Q29udGFpbmVyLmdldEVmZmVjdGl2ZVBhZGRpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlZFNlcGFyYXRvci5zdHlsZS5tYXJnaW5MZWZ0ID0gXCItXCIgKyBwYXJlbnRQaHlzaWNhbFBhZGRpbmcubGVmdCArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVkU2VwYXJhdG9yLnN0eWxlLm1hcmdpblJpZ2h0ID0gXCItXCIgKyBwYXJlbnRQaHlzaWNhbFBhZGRpbmcucmlnaHQgKyBcInB4XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkU2VwYXJhdG9yO1xyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS51cGRhdGVSZW5kZXJlZEVsZW1lbnRWaXNpYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkaXNwbGF5TW9kZSA9IHRoaXMuaXNEZXNpZ25Nb2RlKCkgfHwgdGhpcy5pc1Zpc2libGVcclxuICAgICAgICAgICAgPyB0aGlzLl9kZWZhdWx0UmVuZGVyZWRFbGVtZW50RGlzcGxheU1vZGVcclxuICAgICAgICAgICAgOiBcIm5vbmVcIjtcclxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChkaXNwbGF5TW9kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZWRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5TW9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkRWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImRpc3BsYXlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3NlcGFyYXRvckVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmlzRmlyc3RFbGVtZW50KHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXBhcmF0b3JFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5TW9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlcGFyYXRvckVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXlNb2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VwYXJhdG9yRWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImRpc3BsYXlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnQucHJvdG90eXBlLmhpZGVFbGVtZW50RHVlVG9PdmVyZmxvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyZWRFbGVtZW50ICYmIHRoaXMuaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcclxuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmFpc2VFbGVtZW50VmlzaWJpbGl0eUNoYW5nZWRFdmVudCh0aGlzLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5zaG93RWxlbWVudEhpZGRlbkR1ZVRvT3ZlcmZsb3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlcmVkRWxlbWVudCAmJiAhdGhpcy5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZWRFbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwidmlzaWJpbGl0eVwiKTtcclxuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICByYWlzZUVsZW1lbnRWaXNpYmlsaXR5Q2hhbmdlZEV2ZW50KHRoaXMsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gTWFya2VkIHByaXZhdGUgdG8gZW11bGF0ZSBpbnRlcm5hbCBhY2Nlc3NcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5oYW5kbGVPdmVyZmxvdyA9IGZ1bmN0aW9uIChtYXhIZWlnaHQpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUgfHwgdGhpcy5pc0hpZGRlbkR1ZVRvT3ZlcmZsb3coKSkge1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlZCA9IHRoaXMudHJ1bmNhdGVPdmVyZmxvdyhtYXhIZWlnaHQpO1xyXG4gICAgICAgICAgICAvLyBFdmVuIGlmIHdlIHdlcmUgdW5hYmxlIHRvIHRydW5jYXRlIHRoZSBlbGVtZW50IHRvIGZpdCB0aGlzIHRpbWUsXHJcbiAgICAgICAgICAgIC8vIGl0IHN0aWxsIGNvdWxkIGhhdmUgYmVlbiBwcmV2aW91c2x5IHRydW5jYXRlZFxyXG4gICAgICAgICAgICB0aGlzLl90cnVuY2F0ZWREdWVUb092ZXJmbG93ID0gaGFuZGxlZCB8fCB0aGlzLl90cnVuY2F0ZWREdWVUb092ZXJmbG93O1xyXG4gICAgICAgICAgICBpZiAoIWhhbmRsZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUVsZW1lbnREdWVUb092ZXJmbG93KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaGFuZGxlZCAmJiAhdGhpcy5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0VsZW1lbnRIaWRkZW5EdWVUb092ZXJmbG93KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gTWFya2VkIHByaXZhdGUgdG8gZW11bGF0ZSBpbnRlcm5hbCBhY2Nlc3NcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5yZXNldE92ZXJmbG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzaXplQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLl90cnVuY2F0ZWREdWVUb092ZXJmbG93KSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5kb092ZXJmbG93VHJ1bmNhdGlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLl90cnVuY2F0ZWREdWVUb092ZXJmbG93ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNpemVDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNIaWRkZW5EdWVUb092ZXJmbG93KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zaG93RWxlbWVudEhpZGRlbkR1ZVRvT3ZlcmZsb3coKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNpemVDaGFuZ2VkO1xyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5nZXREZWZhdWx0U2VyaWFsaXphdGlvbkNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTZXJpYWxpemF0aW9uQ29udGV4dCgpO1xyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVQbGFjZWhvbGRlckVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHN0eWxlRGVmaW5pdGlvbiA9IHRoaXMuZ2V0RWZmZWN0aXZlU3R5bGVEZWZpbml0aW9uKCk7XHJcbiAgICAgICAgdmFyIGZvcmVncm91bmRDc3NDb2xvciA9IFV0aWxzLnN0cmluZ1RvQ3NzQ29sb3Ioc3R5bGVEZWZpbml0aW9uLmZvcmVncm91bmRDb2xvcnMuZGVmYXVsdC5zdWJ0bGUpO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICBlbGVtZW50LnN0eWxlLmJvcmRlciA9IFwiMXB4IGRhc2hlZCBcIiArIGZvcmVncm91bmRDc3NDb2xvcjtcclxuICAgICAgICBlbGVtZW50LnN0eWxlLnBhZGRpbmcgPSBcIjRweFwiO1xyXG4gICAgICAgIGVsZW1lbnQuc3R5bGUubWluSGVpZ2h0ID0gXCIzMnB4XCI7XHJcbiAgICAgICAgZWxlbWVudC5zdHlsZS5mb250U2l6ZSA9IFwiMTBweFwiO1xyXG4gICAgICAgIGlmIChmb3JlZ3JvdW5kQ3NzQ29sb3IpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5jb2xvciA9IGZvcmVncm91bmRDc3NDb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxlbWVudC5pbm5lclRleHQgPSBcIkVtcHR5IFwiICsgdGhpcy5nZXRKc29uVHlwZU5hbWUoKTtcclxuICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH07XHJcbiAgICBDYXJkRWxlbWVudC5wcm90b3R5cGUuYWRqdXN0UmVuZGVyZWRFbGVtZW50U2l6ZSA9IGZ1bmN0aW9uIChyZW5kZXJlZEVsZW1lbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5oZWlnaHQgPT09IFwiYXV0b1wiKSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVkRWxlbWVudC5zdHlsZS5mbGV4ID0gXCIwIDAgYXV0b1wiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVuZGVyZWRFbGVtZW50LnN0eWxlLmZsZXggPSBcIjEgMSBhdXRvXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5pc0Rpc3BsYXllZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX3JlbmRlcmVkRWxlbWVudCAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlICYmXHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkRWxlbWVudC5vZmZzZXRIZWlnaHQgPiAwKTtcclxuICAgIH07XHJcbiAgICBDYXJkRWxlbWVudC5wcm90b3R5cGUub3ZlcnJpZGVJbnRlcm5hbFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFJlbmRlcigpO1xyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5hcHBseVBhZGRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VwYXJhdG9yRWxlbWVudCAmJiB0aGlzLnNlcGFyYXRvck9yaWVudGF0aW9uID09PSBFbnVtcy5PcmllbnRhdGlvbi5Ib3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgIGlmIChzaGFyZWRfMS5HbG9iYWxTZXR0aW5ncy5hbHdheXNCbGVlZFNlcGFyYXRvcnMgJiYgIXRoaXMuaXNCbGVlZGluZygpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFkZGluZyA9IG5ldyBzaGFyZWRfMS5QYWRkaW5nRGVmaW5pdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRJbW1lZGlhdGVTdXJyb3VuZGluZ1BhZGRpbmcocGFkZGluZyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGh5c2ljYWxQYWRkaW5nID0gdGhpcy5ob3N0Q29uZmlnLnBhZGRpbmdEZWZpbml0aW9uVG9TcGFjaW5nRGVmaW5pdGlvbihwYWRkaW5nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VwYXJhdG9yRWxlbWVudC5zdHlsZS5tYXJnaW5MZWZ0ID0gXCItXCIgKyBwaHlzaWNhbFBhZGRpbmcubGVmdCArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VwYXJhdG9yRWxlbWVudC5zdHlsZS5tYXJnaW5SaWdodCA9IFwiLVwiICsgcGh5c2ljYWxQYWRkaW5nLnJpZ2h0ICsgXCJweFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXBhcmF0b3JFbGVtZW50LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCIwXCI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlcGFyYXRvckVsZW1lbnQuc3R5bGUubWFyZ2luTGVmdCA9IFwiMFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGlzIGVsZW1lbnQgb3ZlcmZsb3dzIHRoZSBib3R0b20gb2YgdGhlIGNhcmQuXHJcbiAgICAgKiBtYXhIZWlnaHQgd2lsbCBiZSB0aGUgYW1vdW50IG9mIHNwYWNlIHN0aWxsIGF2YWlsYWJsZSBvbiB0aGUgY2FyZCAoMCBpZlxyXG4gICAgICogdGhlIGVsZW1lbnQgaXMgZnVsbHkgb2ZmIHRoZSBjYXJkKS5cclxuICAgICAqL1xyXG4gICAgQ2FyZEVsZW1lbnQucHJvdG90eXBlLnRydW5jYXRlT3ZlcmZsb3cgPSBmdW5jdGlvbiAoX21heEhlaWdodCkge1xyXG4gICAgICAgIC8vIENoaWxkIGltcGxlbWVudGF0aW9ucyBzaG91bGQgcmV0dXJuIHRydWUgaWYgdGhlIGVsZW1lbnQgaGFuZGxlZFxyXG4gICAgICAgIC8vIHRoZSB0cnVuY2F0aW9uIHJlcXVlc3Qgc3VjaCB0aGF0IGl0cyBjb250ZW50IGZpdHMgd2l0aGluIG1heEhlaWdodCxcclxuICAgICAgICAvLyBmYWxzZSBpZiB0aGUgZWxlbWVudCBzaG91bGQgZmFsbCBiYWNrIHRvIGJlaW5nIGhpZGRlblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgICogVGhpcyBzaG91bGQgcmV2ZXJzZSBhbnkgY2hhbmdlcyBwZXJmb3JtZWQgaW4gdHJ1bmNhdGVPdmVyZmxvdygpLlxyXG4gICAgICovXHJcbiAgICBDYXJkRWxlbWVudC5wcm90b3R5cGUudW5kb092ZXJmbG93VHJ1bmNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnQucHJvdG90eXBlLmdldERlZmF1bHRQYWRkaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgc2hhcmVkXzEuUGFkZGluZ0RlZmluaXRpb24oKTtcclxuICAgIH07XHJcbiAgICBDYXJkRWxlbWVudC5wcm90b3R5cGUuZ2V0SGFzQmFja2dyb3VuZCA9IGZ1bmN0aW9uIChpZ25vcmVCYWNrZ3JvdW5kSW1hZ2VzKSB7XHJcbiAgICAgICAgaWYgKGlnbm9yZUJhY2tncm91bmRJbWFnZXMgPT09IHZvaWQgMCkgeyBpZ25vcmVCYWNrZ3JvdW5kSW1hZ2VzID0gZmFsc2U7IH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnQucHJvdG90eXBlLmdldEhhc0JvcmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnQucHJvdG90eXBlLmdldFBhZGRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnQucHJvdG90eXBlLnNldFBhZGRpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9wYWRkaW5nID0gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnQucHJvdG90eXBlLnNob3VsZFNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZWxlbWVudFJlZ2lzdHJ5LmZpbmRCeU5hbWUodGhpcy5nZXRKc29uVHlwZU5hbWUoKSkgIT09IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FyZEVsZW1lbnQucHJvdG90eXBlLCBcInVzZURlZmF1bHRTaXppbmdcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FyZEVsZW1lbnQucHJvdG90eXBlLCBcInNlcGFyYXRvck9yaWVudGF0aW9uXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEVudW1zLk9yaWVudGF0aW9uLkhvcml6b250YWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhcmRFbGVtZW50LnByb3RvdHlwZSwgXCJkZWZhdWx0U3R5bGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gRW51bXMuQ29udGFpbmVyU3R5bGUuRGVmYXVsdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBDYXJkRWxlbWVudC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5wYXJzZS5jYWxsKHRoaXMsIHNvdXJjZSwgY29udGV4dCA/IGNvbnRleHQgOiBuZXcgU2VyaWFsaXphdGlvbkNvbnRleHQoKSk7XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnQucHJvdG90eXBlLmFzU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5pc0JsZWVkaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBDYXJkRWxlbWVudC5wcm90b3R5cGUuZ2V0RWZmZWN0aXZlU3R5bGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRFZmZlY3RpdmVTdHlsZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0U3R5bGU7XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnQucHJvdG90eXBlLmdldEVmZmVjdGl2ZVN0eWxlRGVmaW5pdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ob3N0Q29uZmlnLmNvbnRhaW5lclN0eWxlcy5nZXRTdHlsZUJ5TmFtZSh0aGlzLmdldEVmZmVjdGl2ZVN0eWxlKCkpO1xyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5nZXRFZmZlY3RpdmVUZXh0U3R5bGVEZWZpbml0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0RWZmZWN0aXZlVGV4dFN0eWxlRGVmaW5pdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5ob3N0Q29uZmlnLnRleHRTdHlsZXMuZGVmYXVsdDtcclxuICAgIH07XHJcbiAgICBDYXJkRWxlbWVudC5wcm90b3R5cGUuZ2V0Rm9yYmlkZGVuQWN0aW9uVHlwZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5nZXRJbW1lZGlhdGVTdXJyb3VuZGluZ1BhZGRpbmcgPSBmdW5jdGlvbiAocmVzdWx0LCBwcm9jZXNzVG9wLCBwcm9jZXNzUmlnaHQsIHByb2Nlc3NCb3R0b20sIHByb2Nlc3NMZWZ0KSB7XHJcbiAgICAgICAgaWYgKHByb2Nlc3NUb3AgPT09IHZvaWQgMCkgeyBwcm9jZXNzVG9wID0gdHJ1ZTsgfVxyXG4gICAgICAgIGlmIChwcm9jZXNzUmlnaHQgPT09IHZvaWQgMCkgeyBwcm9jZXNzUmlnaHQgPSB0cnVlOyB9XHJcbiAgICAgICAgaWYgKHByb2Nlc3NCb3R0b20gPT09IHZvaWQgMCkgeyBwcm9jZXNzQm90dG9tID0gdHJ1ZTsgfVxyXG4gICAgICAgIGlmIChwcm9jZXNzTGVmdCA9PT0gdm9pZCAwKSB7IHByb2Nlc3NMZWZ0ID0gdHJ1ZTsgfVxyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICB2YXIgZG9Qcm9jZXNzVG9wID0gcHJvY2Vzc1RvcCAmJiB0aGlzLnBhcmVudC5pc1RvcEVsZW1lbnQodGhpcyk7XHJcbiAgICAgICAgICAgIHZhciBkb1Byb2Nlc3NSaWdodCA9IHByb2Nlc3NSaWdodCAmJiB0aGlzLnBhcmVudC5pc1JpZ2h0TW9zdEVsZW1lbnQodGhpcyk7XHJcbiAgICAgICAgICAgIHZhciBkb1Byb2Nlc3NCb3R0b20gPSBwcm9jZXNzQm90dG9tICYmIHRoaXMucGFyZW50LmlzQm90dG9tRWxlbWVudCh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIGRvUHJvY2Vzc0xlZnQgPSBwcm9jZXNzTGVmdCAmJiB0aGlzLnBhcmVudC5pc0xlZnRNb3N0RWxlbWVudCh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIGVmZmVjdGl2ZVBhZGRpbmcgPSB0aGlzLnBhcmVudC5nZXRFZmZlY3RpdmVQYWRkaW5nKCk7XHJcbiAgICAgICAgICAgIGlmIChlZmZlY3RpdmVQYWRkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9Qcm9jZXNzVG9wICYmIGVmZmVjdGl2ZVBhZGRpbmcudG9wICE9PSBFbnVtcy5TcGFjaW5nLk5vbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQudG9wID0gZWZmZWN0aXZlUGFkZGluZy50b3A7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9Qcm9jZXNzVG9wID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9Qcm9jZXNzUmlnaHQgJiYgZWZmZWN0aXZlUGFkZGluZy5yaWdodCAhPT0gRW51bXMuU3BhY2luZy5Ob25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJpZ2h0ID0gZWZmZWN0aXZlUGFkZGluZy5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICBkb1Byb2Nlc3NSaWdodCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRvUHJvY2Vzc0JvdHRvbSAmJiBlZmZlY3RpdmVQYWRkaW5nLmJvdHRvbSAhPT0gRW51bXMuU3BhY2luZy5Ob25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmJvdHRvbSA9IGVmZmVjdGl2ZVBhZGRpbmcuYm90dG9tO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvUHJvY2Vzc0JvdHRvbSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRvUHJvY2Vzc0xlZnQgJiYgZWZmZWN0aXZlUGFkZGluZy5sZWZ0ICE9PSBFbnVtcy5TcGFjaW5nLk5vbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQubGVmdCA9IGVmZmVjdGl2ZVBhZGRpbmcubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICBkb1Byb2Nlc3NMZWZ0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRvUHJvY2Vzc1RvcCB8fCBkb1Byb2Nlc3NSaWdodCB8fCBkb1Byb2Nlc3NCb3R0b20gfHwgZG9Qcm9jZXNzTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuZ2V0SW1tZWRpYXRlU3Vycm91bmRpbmdQYWRkaW5nKHJlc3VsdCwgZG9Qcm9jZXNzVG9wLCBkb1Byb2Nlc3NSaWdodCwgZG9Qcm9jZXNzQm90dG9tLCBkb1Byb2Nlc3NMZWZ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYXJkRWxlbWVudC5wcm90b3R5cGUuZ2V0QWN0aW9uQ291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnQucHJvdG90eXBlLmdldEFjdGlvbkF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy5pbmRleE91dE9mUmFuZ2UoaW5kZXgpKTtcclxuICAgIH07XHJcbiAgICBDYXJkRWxlbWVudC5wcm90b3R5cGUuaW5kZXhPZkFjdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ2V0QWN0aW9uQ291bnQoKTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEFjdGlvbkF0KGkpID09PSBhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH07XHJcbiAgICBDYXJkRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudCBpbnN0YW5jZW9mIENhcmRFbGVtZW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5yZW1vdmVJdGVtKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlZEVsZW1lbnQgPSB0aGlzLm92ZXJyaWRlSW50ZXJuYWxSZW5kZXIoKTtcclxuICAgICAgICB0aGlzLl9zZXBhcmF0b3JFbGVtZW50ID0gdGhpcy5pbnRlcm5hbFJlbmRlclNlcGFyYXRvcigpO1xyXG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkRWxlbWVudC5pZCA9IHRoaXMuaWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VzdG9tQ3NzU2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkRWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMuY3VzdG9tQ3NzU2VsZWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkRWxlbWVudC5zdHlsZS5ib3hTaXppbmcgPSBcImJvcmRlci1ib3hcIjtcclxuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdFJlbmRlcmVkRWxlbWVudERpc3BsYXlNb2RlID0gdGhpcy5fcmVuZGVyZWRFbGVtZW50LnN0eWxlLmRpc3BsYXlcclxuICAgICAgICAgICAgICAgID8gdGhpcy5fcmVuZGVyZWRFbGVtZW50LnN0eWxlLmRpc3BsYXlcclxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLmFkanVzdFJlbmRlcmVkRWxlbWVudFNpemUodGhpcy5fcmVuZGVyZWRFbGVtZW50KTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVMYXlvdXQoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzRGVzaWduTW9kZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkRWxlbWVudCA9IHRoaXMuY3JlYXRlUGxhY2Vob2xkZXJFbGVtZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ2V0Um9vdEVsZW1lbnQoKS51cGRhdGVBY3Rpb25zRW5hYmxlZFN0YXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVkRWxlbWVudDtcclxuICAgIH07XHJcbiAgICBDYXJkRWxlbWVudC5wcm90b3R5cGUudXBkYXRlTGF5b3V0ID0gZnVuY3Rpb24gKF9wcm9jZXNzQ2hpbGRyZW4pIHtcclxuICAgICAgICBpZiAoX3Byb2Nlc3NDaGlsZHJlbiA9PT0gdm9pZCAwKSB7IF9wcm9jZXNzQ2hpbGRyZW4gPSB0cnVlOyB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVSZW5kZXJlZEVsZW1lbnRWaXNpYmlsaXR5KCk7XHJcbiAgICAgICAgdGhpcy5hcHBseVBhZGRpbmcoKTtcclxuICAgIH07XHJcbiAgICBDYXJkRWxlbWVudC5wcm90b3R5cGUudXBkYXRlQWN0aW9uc0VuYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYWxsQWN0aW9ucyA9IHRoaXMuZ2V0Um9vdEVsZW1lbnQoKS5nZXRBbGxBY3Rpb25zKCk7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBhbGxBY3Rpb25zXzEgPSBhbGxBY3Rpb25zOyBfaSA8IGFsbEFjdGlvbnNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGFsbEFjdGlvbnNfMVtfaV07XHJcbiAgICAgICAgICAgIGFjdGlvbi51cGRhdGVFbmFibGVkU3RhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoX2NhcmRFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5pc0Rlc2lnbk1vZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJvb3RFbGVtZW50ID0gdGhpcy5nZXRSb290RWxlbWVudCgpO1xyXG4gICAgICAgIHJldHVybiByb290RWxlbWVudCBpbnN0YW5jZW9mIEFkYXB0aXZlQ2FyZCAmJiByb290RWxlbWVudC5kZXNpZ25Nb2RlO1xyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5pc0ZpcnN0RWxlbWVudCA9IGZ1bmN0aW9uIChfZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5pc0xhc3RFbGVtZW50ID0gZnVuY3Rpb24gKF9lbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnQucHJvdG90eXBlLmlzQXRUaGVWZXJ5TGVmdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRcclxuICAgICAgICAgICAgPyB0aGlzLnBhcmVudC5pc0xlZnRNb3N0RWxlbWVudCh0aGlzKSAmJiB0aGlzLnBhcmVudC5pc0F0VGhlVmVyeUxlZnQoKVxyXG4gICAgICAgICAgICA6IHRydWU7XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnQucHJvdG90eXBlLmlzQXRUaGVWZXJ5UmlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50XHJcbiAgICAgICAgICAgID8gdGhpcy5wYXJlbnQuaXNSaWdodE1vc3RFbGVtZW50KHRoaXMpICYmIHRoaXMucGFyZW50LmlzQXRUaGVWZXJ5UmlnaHQoKVxyXG4gICAgICAgICAgICA6IHRydWU7XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnQucHJvdG90eXBlLmlzQXRUaGVWZXJ5VG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudFxyXG4gICAgICAgICAgICA/IHRoaXMucGFyZW50LmlzRmlyc3RFbGVtZW50KHRoaXMpICYmIHRoaXMucGFyZW50LmlzQXRUaGVWZXJ5VG9wKClcclxuICAgICAgICAgICAgOiB0cnVlO1xyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5pc0F0VGhlVmVyeUJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRcclxuICAgICAgICAgICAgPyB0aGlzLnBhcmVudC5pc0xhc3RFbGVtZW50KHRoaXMpICYmIHRoaXMucGFyZW50LmlzQXRUaGVWZXJ5Qm90dG9tKClcclxuICAgICAgICAgICAgOiB0cnVlO1xyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5pc0JsZWVkaW5nQXRUb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5pc0JsZWVkaW5nQXRCb3R0b20gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5pc0xlZnRNb3N0RWxlbWVudCA9IGZ1bmN0aW9uIChfZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5pc1JpZ2h0TW9zdEVsZW1lbnQgPSBmdW5jdGlvbiAoX2VsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBDYXJkRWxlbWVudC5wcm90b3R5cGUuaXNUb3BFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0ZpcnN0RWxlbWVudChlbGVtZW50KTtcclxuICAgIH07XHJcbiAgICBDYXJkRWxlbWVudC5wcm90b3R5cGUuaXNCb3R0b21FbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0xhc3RFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5pc0hpZGRlbkR1ZVRvT3ZlcmZsb3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9yZW5kZXJlZEVsZW1lbnQgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlZEVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9PT0gXCJoaWRkZW5cIik7XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnQucHJvdG90eXBlLmdldFJvb3RFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFJvb3RPYmplY3QoKTtcclxuICAgIH07XHJcbiAgICBDYXJkRWxlbWVudC5wcm90b3R5cGUuZ2V0UGFyZW50Q29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjdXJyZW50RWxlbWVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50RWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudEVsZW1lbnQgaW5zdGFuY2VvZiBDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50RWxlbWVudCA9IGN1cnJlbnRFbGVtZW50LnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBDYXJkRWxlbWVudC5wcm90b3R5cGUuZ2V0QWxsSW5wdXRzID0gZnVuY3Rpb24gKHByb2Nlc3NBY3Rpb25zKSB7XHJcbiAgICAgICAgaWYgKHByb2Nlc3NBY3Rpb25zID09PSB2b2lkIDApIHsgcHJvY2Vzc0FjdGlvbnMgPSB0cnVlOyB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5nZXRBbGxBY3Rpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ2V0QWN0aW9uQ291bnQoKTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLmdldEFjdGlvbkF0KGkpO1xyXG4gICAgICAgICAgICBpZiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnQucHJvdG90eXBlLmdldFJlc291cmNlSW5mb3JtYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlkID09PSBpZCA/IHRoaXMgOiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnQucHJvdG90eXBlLmdldEFjdGlvbkJ5SWQgPSBmdW5jdGlvbiAoX2lkKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBDYXJkRWxlbWVudC5wcm90b3R5cGUuZ2V0RWZmZWN0aXZlUGFkZGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuZ2V0UGFkZGluZygpO1xyXG4gICAgICAgIHJldHVybiBwYWRkaW5nID8gcGFkZGluZyA6IHRoaXMuZ2V0RGVmYXVsdFBhZGRpbmcoKTtcclxuICAgIH07XHJcbiAgICBDYXJkRWxlbWVudC5wcm90b3R5cGUuZ2V0RWZmZWN0aXZlSG9yaXpvbnRhbEFsaWdubWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5ob3Jpem9udGFsQWxpZ25tZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaG9yaXpvbnRhbEFsaWdubWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRFZmZlY3RpdmVIb3Jpem9udGFsQWxpZ25tZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBFbnVtcy5Ib3Jpem9udGFsQWxpZ25tZW50LkxlZnQ7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhcmRFbGVtZW50LnByb3RvdHlwZSwgXCJob3N0Q29uZmlnXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2hvc3RDb25maWcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ob3N0Q29uZmlnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lmhvc3RDb25maWc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaG9zdF9jb25maWdfMS5kZWZhdWx0SG9zdENvbmZpZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5faG9zdENvbmZpZyA9IHZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXJkRWxlbWVudC5wcm90b3R5cGUsIFwiaW5kZXhcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5pbmRleE9mKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FyZEVsZW1lbnQucHJvdG90eXBlLCBcImlzSW50ZXJhY3RpdmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhcmRFbGVtZW50LnByb3RvdHlwZSwgXCJpc1N0YW5kYWxvbmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FyZEVsZW1lbnQucHJvdG90eXBlLCBcImlzSW5saW5lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXJkRWxlbWVudC5wcm90b3R5cGUsIFwiaGFzVmlzaWJsZVNlcGFyYXRvclwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnNlcGFyYXRvckVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5wYXJlbnQuaXNGaXJzdEVsZW1lbnQodGhpcykgJiYgKHRoaXMuaXNWaXNpYmxlIHx8IHRoaXMuaXNEZXNpZ25Nb2RlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhcmRFbGVtZW50LnByb3RvdHlwZSwgXCJzZXBhcmF0b3JFbGVtZW50XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlcGFyYXRvckVsZW1lbnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhcmRFbGVtZW50LnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIENhcmRFbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50U2luZ2xldG9uQmVoYXZpb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlZ2lzdHJ5XzEuRWxlbWVudFNpbmdsZXRvbkJlaGF2aW9yLk5vdEFsbG93ZWQ7XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnQubGFuZ1Byb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMSwgXCJsYW5nXCIsIHRydWUsIC9eW2Etel17MiwzfSQvZ2kpO1xyXG4gICAgQ2FyZEVsZW1lbnQuaXNWaXNpYmxlUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLkJvb2xQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMiwgXCJpc1Zpc2libGVcIiwgdHJ1ZSk7XHJcbiAgICBDYXJkRWxlbWVudC5zZXBhcmF0b3JQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuQm9vbFByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcInNlcGFyYXRvclwiLCBmYWxzZSk7XHJcbiAgICBDYXJkRWxlbWVudC5oZWlnaHRQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuVmFsdWVTZXRQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMSwgXCJoZWlnaHRcIiwgW3sgdmFsdWU6IFwiYXV0b1wiIH0sIHsgdmFsdWU6IFwic3RyZXRjaFwiIH1dLCBcImF1dG9cIik7XHJcbiAgICBDYXJkRWxlbWVudC5ob3Jpem9udGFsQWxpZ25tZW50UHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLkVudW1Qcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCwgXCJob3Jpem9udGFsQWxpZ25tZW50XCIsIEVudW1zLkhvcml6b250YWxBbGlnbm1lbnQpO1xyXG4gICAgQ2FyZEVsZW1lbnQuc3BhY2luZ1Byb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5FbnVtUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwic3BhY2luZ1wiLCBFbnVtcy5TcGFjaW5nLCBFbnVtcy5TcGFjaW5nLkRlZmF1bHQpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoQ2FyZEVsZW1lbnQuaG9yaXpvbnRhbEFsaWdubWVudFByb3BlcnR5KVxyXG4gICAgXSwgQ2FyZEVsZW1lbnQucHJvdG90eXBlLCBcImhvcml6b250YWxBbGlnbm1lbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKENhcmRFbGVtZW50LnNwYWNpbmdQcm9wZXJ0eSlcclxuICAgIF0sIENhcmRFbGVtZW50LnByb3RvdHlwZSwgXCJzcGFjaW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShDYXJkRWxlbWVudC5zZXBhcmF0b3JQcm9wZXJ0eSlcclxuICAgIF0sIENhcmRFbGVtZW50LnByb3RvdHlwZSwgXCJzZXBhcmF0b3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKENhcmRFbGVtZW50LmhlaWdodFByb3BlcnR5KVxyXG4gICAgXSwgQ2FyZEVsZW1lbnQucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoQ2FyZEVsZW1lbnQubGFuZ1Byb3BlcnR5KVxyXG4gICAgXSwgQ2FyZEVsZW1lbnQucHJvdG90eXBlLCBcImxhbmdcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShDYXJkRWxlbWVudC5pc1Zpc2libGVQcm9wZXJ0eSlcclxuICAgIF0sIENhcmRFbGVtZW50LnByb3RvdHlwZSwgXCJpc1Zpc2libGVcIiwgbnVsbCk7XHJcbiAgICByZXR1cm4gQ2FyZEVsZW1lbnQ7XHJcbn0oY2FyZF9vYmplY3RfMS5DYXJkT2JqZWN0KSk7XHJcbmV4cG9ydHMuQ2FyZEVsZW1lbnQgPSBDYXJkRWxlbWVudDtcclxudmFyIEFjdGlvblByb3BlcnR5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFjdGlvblByb3BlcnR5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWN0aW9uUHJvcGVydHkodGFyZ2V0VmVyc2lvbiwgbmFtZSwgZm9yYmlkZGVuQWN0aW9uVHlwZXMpIHtcclxuICAgICAgICBpZiAoZm9yYmlkZGVuQWN0aW9uVHlwZXMgPT09IHZvaWQgMCkgeyBmb3JiaWRkZW5BY3Rpb25UeXBlcyA9IFtdOyB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdGFyZ2V0VmVyc2lvbiwgbmFtZSwgdW5kZWZpbmVkKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnRhcmdldFZlcnNpb24gPSB0YXJnZXRWZXJzaW9uO1xyXG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIF90aGlzLmZvcmJpZGRlbkFjdGlvblR5cGVzID0gZm9yYmlkZGVuQWN0aW9uVHlwZXM7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQWN0aW9uUHJvcGVydHkucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNlbmRlciwgc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHNlbmRlcjtcclxuICAgICAgICByZXR1cm4gY29udGV4dC5wYXJzZUFjdGlvbihwYXJlbnQsIHNvdXJjZVt0aGlzLm5hbWVdLCB0aGlzLmZvcmJpZGRlbkFjdGlvblR5cGVzLCBwYXJlbnQuaXNEZXNpZ25Nb2RlKCkpO1xyXG4gICAgfTtcclxuICAgIEFjdGlvblByb3BlcnR5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoc2VuZGVyLCB0YXJnZXQsIHZhbHVlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgY29udGV4dC5zZXJpYWxpemVWYWx1ZSh0YXJnZXQsIHRoaXMubmFtZSwgdmFsdWUgPyB2YWx1ZS50b0pTT04oY29udGV4dCkgOiB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFjdGlvblByb3BlcnR5O1xyXG59KHNlcmlhbGl6YXRpb25fMS5Qcm9wZXJ0eURlZmluaXRpb24pKTtcclxuZXhwb3J0cy5BY3Rpb25Qcm9wZXJ0eSA9IEFjdGlvblByb3BlcnR5O1xyXG52YXIgQmFzZVRleHRCbG9jayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhCYXNlVGV4dEJsb2NrLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQmFzZVRleHRCbG9jayh0ZXh0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5hcmlhSGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRleHQpIHtcclxuICAgICAgICAgICAgX3RoaXMudGV4dCA9IHRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEJhc2VUZXh0QmxvY2sucHJvdG90eXBlLnBvcHVsYXRlU2NoZW1hID0gZnVuY3Rpb24gKHNjaGVtYSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucG9wdWxhdGVTY2hlbWEuY2FsbCh0aGlzLCBzY2hlbWEpO1xyXG4gICAgICAgIC8vIHNlbGVjdEFjdGlvbiBpcyBkZWNsYXJlZCBvbiBCYXNlVGV4dEJsb2NrIGJ1dCBpcyBvbmx5IGV4cG9zZWQgb24gVGV4dFJ1bixcclxuICAgICAgICAvLyBzbyB0aGUgcHJvcGVydHkgaXMgcmVtb3ZlZCBmcm9tIHRoZSBCYXNlVGV4dEJsb2NrIHNjaGVtYS5cclxuICAgICAgICBzY2hlbWEucmVtb3ZlKEJhc2VUZXh0QmxvY2suc2VsZWN0QWN0aW9uUHJvcGVydHkpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlVGV4dEJsb2NrLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoQmFzZVRleHRCbG9jay50ZXh0UHJvcGVydHkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRUZXh0KHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICAgIEJhc2VUZXh0QmxvY2sucHJvdG90eXBlLmdldEZvbnRTaXplID0gZnVuY3Rpb24gKGZvbnRUeXBlKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmVmZmVjdGl2ZVNpemUpIHtcclxuICAgICAgICAgICAgY2FzZSBFbnVtcy5UZXh0U2l6ZS5TbWFsbDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmb250VHlwZS5mb250U2l6ZXMuc21hbGw7XHJcbiAgICAgICAgICAgIGNhc2UgRW51bXMuVGV4dFNpemUuTWVkaXVtOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvbnRUeXBlLmZvbnRTaXplcy5tZWRpdW07XHJcbiAgICAgICAgICAgIGNhc2UgRW51bXMuVGV4dFNpemUuTGFyZ2U6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9udFR5cGUuZm9udFNpemVzLmxhcmdlO1xyXG4gICAgICAgICAgICBjYXNlIEVudW1zLlRleHRTaXplLkV4dHJhTGFyZ2U6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9udFR5cGUuZm9udFNpemVzLmV4dHJhTGFyZ2U7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9udFR5cGUuZm9udFNpemVzLmRlZmF1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJhc2VUZXh0QmxvY2sucHJvdG90eXBlLmdldENvbG9yRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIChjb2xvclNldCwgY29sb3IpIHtcclxuICAgICAgICBzd2l0Y2ggKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIGNhc2UgRW51bXMuVGV4dENvbG9yLkFjY2VudDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvclNldC5hY2NlbnQ7XHJcbiAgICAgICAgICAgIGNhc2UgRW51bXMuVGV4dENvbG9yLkRhcms6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3JTZXQuZGFyaztcclxuICAgICAgICAgICAgY2FzZSBFbnVtcy5UZXh0Q29sb3IuTGlnaHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3JTZXQubGlnaHQ7XHJcbiAgICAgICAgICAgIGNhc2UgRW51bXMuVGV4dENvbG9yLkdvb2Q6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3JTZXQuZ29vZDtcclxuICAgICAgICAgICAgY2FzZSBFbnVtcy5UZXh0Q29sb3IuV2FybmluZzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvclNldC53YXJuaW5nO1xyXG4gICAgICAgICAgICBjYXNlIEVudW1zLlRleHRDb2xvci5BdHRlbnRpb246XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3JTZXQuYXR0ZW50aW9uO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yU2V0LmRlZmF1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJhc2VUZXh0QmxvY2sucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnNldFZhbHVlKEJhc2VUZXh0QmxvY2sudGV4dFByb3BlcnR5LCB2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgQmFzZVRleHRCbG9jay5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICh0ZXh0RGVmaW5pdGlvbikge1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IHRleHREZWZpbml0aW9uLnNpemU7XHJcbiAgICAgICAgdGhpcy53ZWlnaHQgPSB0ZXh0RGVmaW5pdGlvbi53ZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IHRleHREZWZpbml0aW9uLmNvbG9yO1xyXG4gICAgICAgIHRoaXMuaXNTdWJ0bGUgPSB0ZXh0RGVmaW5pdGlvbi5pc1N1YnRsZTtcclxuICAgIH07XHJcbiAgICBCYXNlVGV4dEJsb2NrLnByb3RvdHlwZS5hc1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xyXG4gICAgfTtcclxuICAgIEJhc2VUZXh0QmxvY2sucHJvdG90eXBlLmFwcGx5U3R5bGVzVG8gPSBmdW5jdGlvbiAodGFyZ2V0RWxlbWVudCkge1xyXG4gICAgICAgIHZhciBmb250VHlwZSA9IHRoaXMuaG9zdENvbmZpZy5nZXRGb250VHlwZURlZmluaXRpb24odGhpcy5lZmZlY3RpdmVGb250VHlwZSk7XHJcbiAgICAgICAgaWYgKGZvbnRUeXBlLmZvbnRGYW1pbHkpIHtcclxuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5zdHlsZS5mb250RmFtaWx5ID0gZm9udFR5cGUuZm9udEZhbWlseTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGZvbnRTaXplO1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5lZmZlY3RpdmVTaXplKSB7XHJcbiAgICAgICAgICAgIGNhc2UgRW51bXMuVGV4dFNpemUuU21hbGw6XHJcbiAgICAgICAgICAgICAgICBmb250U2l6ZSA9IGZvbnRUeXBlLmZvbnRTaXplcy5zbWFsbDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEVudW1zLlRleHRTaXplLk1lZGl1bTpcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplID0gZm9udFR5cGUuZm9udFNpemVzLm1lZGl1bTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEVudW1zLlRleHRTaXplLkxhcmdlOlxyXG4gICAgICAgICAgICAgICAgZm9udFNpemUgPSBmb250VHlwZS5mb250U2l6ZXMubGFyZ2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBFbnVtcy5UZXh0U2l6ZS5FeHRyYUxhcmdlOlxyXG4gICAgICAgICAgICAgICAgZm9udFNpemUgPSBmb250VHlwZS5mb250U2l6ZXMuZXh0cmFMYXJnZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgZm9udFNpemUgPSBmb250VHlwZS5mb250U2l6ZXMuZGVmYXVsdDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0YXJnZXRFbGVtZW50LnN0eWxlLmZvbnRTaXplID0gZm9udFNpemUgKyBcInB4XCI7XHJcbiAgICAgICAgdmFyIGNvbG9yRGVmaW5pdGlvbiA9IHRoaXMuZ2V0Q29sb3JEZWZpbml0aW9uKHRoaXMuZ2V0RWZmZWN0aXZlU3R5bGVEZWZpbml0aW9uKCkuZm9yZWdyb3VuZENvbG9ycywgdGhpcy5lZmZlY3RpdmVDb2xvcik7XHJcbiAgICAgICAgdmFyIHRhcmdldENvbG9yID0gVXRpbHMuc3RyaW5nVG9Dc3NDb2xvcih0aGlzLmVmZmVjdGl2ZUlzU3VidGxlID8gY29sb3JEZWZpbml0aW9uLnN1YnRsZSA6IGNvbG9yRGVmaW5pdGlvbi5kZWZhdWx0KTtcclxuICAgICAgICBpZiAodGFyZ2V0Q29sb3IpIHtcclxuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5zdHlsZS5jb2xvciA9IHRhcmdldENvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZm9udFdlaWdodDtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuZWZmZWN0aXZlV2VpZ2h0KSB7XHJcbiAgICAgICAgICAgIGNhc2UgRW51bXMuVGV4dFdlaWdodC5MaWdodGVyOlxyXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodCA9IGZvbnRUeXBlLmZvbnRXZWlnaHRzLmxpZ2h0ZXI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBFbnVtcy5UZXh0V2VpZ2h0LkJvbGRlcjpcclxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQgPSBmb250VHlwZS5mb250V2VpZ2h0cy5ib2xkZXI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQgPSBmb250VHlwZS5mb250V2VpZ2h0cy5kZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRhcmdldEVsZW1lbnQuc3R5bGUuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQudG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAodGhpcy5hcmlhSGlkZGVuKSB7XHJcbiAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCYXNlVGV4dEJsb2NrLnByb3RvdHlwZS5nZXRBbGxBY3Rpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLmdldEFsbEFjdGlvbnMuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3RBY3Rpb24pIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5zZWxlY3RBY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlVGV4dEJsb2NrLnByb3RvdHlwZSwgXCJlZmZlY3RpdmVDb2xvclwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQgPyB0aGlzLmNvbG9yIDogdGhpcy5nZXRFZmZlY3RpdmVUZXh0U3R5bGVEZWZpbml0aW9uKCkuY29sb3I7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VUZXh0QmxvY2sucHJvdG90eXBlLCBcImVmZmVjdGl2ZUZvbnRUeXBlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9udFR5cGUgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyB0aGlzLmZvbnRUeXBlXHJcbiAgICAgICAgICAgICAgICA6IHRoaXMuZ2V0RWZmZWN0aXZlVGV4dFN0eWxlRGVmaW5pdGlvbigpLmZvbnRUeXBlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlVGV4dEJsb2NrLnByb3RvdHlwZSwgXCJlZmZlY3RpdmVJc1N1YnRsZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzU3VidGxlICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gdGhpcy5pc1N1YnRsZVxyXG4gICAgICAgICAgICAgICAgOiB0aGlzLmdldEVmZmVjdGl2ZVRleHRTdHlsZURlZmluaXRpb24oKS5pc1N1YnRsZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVRleHRCbG9jay5wcm90b3R5cGUsIFwiZWZmZWN0aXZlU2l6ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpemUgIT09IHVuZGVmaW5lZCA/IHRoaXMuc2l6ZSA6IHRoaXMuZ2V0RWZmZWN0aXZlVGV4dFN0eWxlRGVmaW5pdGlvbigpLnNpemU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VUZXh0QmxvY2sucHJvdG90eXBlLCBcImVmZmVjdGl2ZVdlaWdodFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlaWdodCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMud2VpZ2h0XHJcbiAgICAgICAgICAgICAgICA6IHRoaXMuZ2V0RWZmZWN0aXZlVGV4dFN0eWxlRGVmaW5pdGlvbigpLndlaWdodDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvLyNyZWdpb24gU2NoZW1hXHJcbiAgICBCYXNlVGV4dEJsb2NrLnRleHRQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuU3RyaW5nUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwidGV4dFwiLCB0cnVlKTtcclxuICAgIEJhc2VUZXh0QmxvY2suc2l6ZVByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5FbnVtUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwic2l6ZVwiLCBFbnVtcy5UZXh0U2l6ZSk7XHJcbiAgICBCYXNlVGV4dEJsb2NrLndlaWdodFByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5FbnVtUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwid2VpZ2h0XCIsIEVudW1zLlRleHRXZWlnaHQpO1xyXG4gICAgQmFzZVRleHRCbG9jay5jb2xvclByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5FbnVtUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwiY29sb3JcIiwgRW51bXMuVGV4dENvbG9yKTtcclxuICAgIEJhc2VUZXh0QmxvY2suaXNTdWJ0bGVQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuQm9vbFByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcImlzU3VidGxlXCIpO1xyXG4gICAgQmFzZVRleHRCbG9jay5mb250VHlwZVByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5FbnVtUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzIsIFwiZm9udFR5cGVcIiwgRW51bXMuRm9udFR5cGUpO1xyXG4gICAgQmFzZVRleHRCbG9jay5zZWxlY3RBY3Rpb25Qcm9wZXJ0eSA9IG5ldyBBY3Rpb25Qcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMSwgXCJzZWxlY3RBY3Rpb25cIiwgW1xyXG4gICAgICAgIFwiQWN0aW9uLlNob3dDYXJkXCJcclxuICAgIF0pO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoQmFzZVRleHRCbG9jay5zaXplUHJvcGVydHkpXHJcbiAgICBdLCBCYXNlVGV4dEJsb2NrLnByb3RvdHlwZSwgXCJzaXplXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShCYXNlVGV4dEJsb2NrLndlaWdodFByb3BlcnR5KVxyXG4gICAgXSwgQmFzZVRleHRCbG9jay5wcm90b3R5cGUsIFwid2VpZ2h0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShCYXNlVGV4dEJsb2NrLmNvbG9yUHJvcGVydHkpXHJcbiAgICBdLCBCYXNlVGV4dEJsb2NrLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoQmFzZVRleHRCbG9jay5mb250VHlwZVByb3BlcnR5KVxyXG4gICAgXSwgQmFzZVRleHRCbG9jay5wcm90b3R5cGUsIFwiZm9udFR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEJhc2VUZXh0QmxvY2suaXNTdWJ0bGVQcm9wZXJ0eSlcclxuICAgIF0sIEJhc2VUZXh0QmxvY2sucHJvdG90eXBlLCBcImlzU3VidGxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShCYXNlVGV4dEJsb2NrLnRleHRQcm9wZXJ0eSlcclxuICAgIF0sIEJhc2VUZXh0QmxvY2sucHJvdG90eXBlLCBcInRleHRcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShCYXNlVGV4dEJsb2NrLnNlbGVjdEFjdGlvblByb3BlcnR5KVxyXG4gICAgXSwgQmFzZVRleHRCbG9jay5wcm90b3R5cGUsIFwic2VsZWN0QWN0aW9uXCIsIHZvaWQgMCk7XHJcbiAgICByZXR1cm4gQmFzZVRleHRCbG9jaztcclxufShDYXJkRWxlbWVudCkpO1xyXG5leHBvcnRzLkJhc2VUZXh0QmxvY2sgPSBCYXNlVGV4dEJsb2NrO1xyXG52YXIgVGV4dEJsb2NrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFRleHRCbG9jaywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRleHRCbG9jaygpIHtcclxuICAgICAgICAvLyNyZWdpb24gU2NoZW1hXHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMud3JhcCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLl90cmVhdEFzUGxhaW5UZXh0ID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy51c2VNYXJrZG93biA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgVGV4dEJsb2NrLnByb3RvdHlwZS5yZXN0b3JlT3JpZ2luYWxDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWF4TGluZXMgJiYgdGhpcy5tYXhMaW5lcyA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50LnN0eWxlLm1heEhlaWdodCA9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcHV0ZWRMaW5lSGVpZ2h0ICogdGhpcy5tYXhMaW5lcyArIFwicHhcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxIdG1sID0gKF9iID0gKF9hID0gVGV4dEJsb2NrLl90dFJvdW5kdHJpcFBvbGljeSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNyZWF0ZUhUTUwodGhpcy5fb3JpZ2luYWxJbm5lckh0bWwpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLl9vcmlnaW5hbElubmVySHRtbDtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQuaW5uZXJIVE1MID0gb3JpZ2luYWxIdG1sO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUZXh0QmxvY2sucHJvdG90eXBlLnRydW5jYXRlSWZTdXBwb3J0ZWQgPSBmdW5jdGlvbiAobWF4SGVpZ2h0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gRm9yIG5vdywgb25seSB0cnVuY2F0ZSBUZXh0QmxvY2tzIHRoYXQgY29udGFpbiBqdXN0IGEgc2luZ2xlXHJcbiAgICAgICAgICAgIC8vIHBhcmFncmFwaCAtLSBzaW5jZSB0aGUgbWF4TGluZXMgY2FsY3VsYXRpb24gZG9lc24ndCB0YWtlIGludG9cclxuICAgICAgICAgICAgLy8gYWNjb3VudCBNYXJrZG93biBsaXN0c1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnJlbmRlcmVkRWxlbWVudC5jaGlsZHJlbjtcclxuICAgICAgICAgICAgdmFyIGlzVGV4dE9ubHkgPSAhY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgdHJ1bmNhdGlvblN1cHBvcnRlZCA9IGlzVGV4dE9ubHkgfHxcclxuICAgICAgICAgICAgICAgIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInBcIiAmJiAhY2hpbGRyZW5bMF0uY2hpbGRyZW4ubGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKHRydW5jYXRpb25TdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gaXNUZXh0T25seSA/IHRoaXMucmVuZGVyZWRFbGVtZW50IDogY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgICAgICBVdGlscy50cnVuY2F0ZVRleHQoZWxlbWVudCwgbWF4SGVpZ2h0LCB0aGlzLl9jb21wdXRlZExpbmVIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIFRleHRCbG9jay5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuc2V0VGV4dC5jYWxsKHRoaXMsIHZhbHVlKTtcclxuICAgICAgICB0aGlzLl9wcm9jZXNzZWRUZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIFRleHRCbG9jay5wcm90b3R5cGUuaW50ZXJuYWxSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NlZFRleHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKHRoaXMudGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgcHJlUHJvY2Vzc2VkVGV4dCA9IHRoaXMucHJlUHJvY2Vzc1Byb3BlcnR5VmFsdWUoQmFzZVRleHRCbG9jay50ZXh0UHJvcGVydHkpO1xyXG4gICAgICAgICAgICB2YXIgaG9zdENvbmZpZyA9IHRoaXMuaG9zdENvbmZpZztcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvckVsZW1lbnRJZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiKTtcclxuICAgICAgICAgICAgICAgIGxhYmVsRWxlbWVudC5odG1sRm9yID0gdGhpcy5mb3JFbGVtZW50SWQ7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gbGFiZWxFbGVtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGhvc3RDb25maWcubWFrZUNzc0NsYXNzTmFtZShcImFjLXRleHRCbG9ja1wiKSk7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5U3R5bGVzVG8oZWxlbWVudCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlID09PSBcImhlYWRpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiaGVhZGluZ1wiKTtcclxuICAgICAgICAgICAgICAgIHZhciBoZWFkaW5nTGV2ZWwgPSB0aGlzLmhvc3RDb25maWcudGV4dEJsb2NrLmhlYWRpbmdMZXZlbDtcclxuICAgICAgICAgICAgICAgIGlmIChoZWFkaW5nTGV2ZWwgIT09IHVuZGVmaW5lZCAmJiBoZWFkaW5nTGV2ZWwgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxldmVsXCIsIGhlYWRpbmdMZXZlbC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RBY3Rpb24gJiYgaG9zdENvbmZpZy5zdXBwb3J0c0ludGVyYWN0aXZpdHkpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnNlbGVjdEFjdGlvbiAmJiBfdGhpcy5zZWxlY3RBY3Rpb24uaXNFZmZlY3RpdmVseUVuYWJsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VsZWN0QWN0aW9uLmV4ZWN1dGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RBY3Rpb24uc2V0dXBFbGVtZW50Rm9yQWNjZXNzaWJpbGl0eShlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdEFjdGlvbi5pc0VmZmVjdGl2ZWx5RW5hYmxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGhvc3RDb25maWcubWFrZUNzc0NsYXNzTmFtZShcImFjLXNlbGVjdGFibGVcIikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fcHJvY2Vzc2VkVGV4dCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJlYXRBc1BsYWluVGV4dCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVkVGV4dCA9IFRleHRGb3JtYXR0ZXJzLmZvcm1hdFRleHQodGhpcy5sYW5nLCBwcmVQcm9jZXNzZWRUZXh0KTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZU1hcmtkb3duICYmIGZvcm1hdHRlZFRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcmVkXzEuR2xvYmFsU2V0dGluZ3MuYWxsb3dNYXJrRm9yVGV4dEhpZ2hsaWdodGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRUZXh0ID0gZm9ybWF0dGVkVGV4dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLzxtYXJrPi9nLCBcIj09PVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLzxcXC9tYXJrPi9nLCBcIi89PS9cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXJrZG93blByb2Nlc3NpbmdSZXN1bHQgPSBBZGFwdGl2ZUNhcmQuYXBwbHlNYXJrZG93bihmb3JtYXR0ZWRUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFya2Rvd25Qcm9jZXNzaW5nUmVzdWx0LmRpZFByb2Nlc3MgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2Rvd25Qcm9jZXNzaW5nUmVzdWx0Lm91dHB1dEh0bWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc2VkVGV4dCA9IG1hcmtkb3duUHJvY2Vzc2luZ1Jlc3VsdC5vdXRwdXRIdG1sO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmVhdEFzUGxhaW5UZXh0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VzcyA8bWFyaz4gdGFnIGlmIG1hcmtkb3duIHByb2Nlc3Npbmcgd2FzIGFwcGxpZWQgYmVjYXVzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXJrZG93biBwcm9jZXNzaW5nIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIHNhbml0aXppbmcgdGhlIGlucHV0IHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcmVkXzEuR2xvYmFsU2V0dGluZ3MuYWxsb3dNYXJrRm9yVGV4dEhpZ2hsaWdodGluZyAmJiB0aGlzLl9wcm9jZXNzZWRUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFya1N0eWxlID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZmZlY3RpdmVTdHlsZSA9IHRoaXMuZ2V0RWZmZWN0aXZlU3R5bGVEZWZpbml0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0aXZlU3R5bGUuaGlnaGxpZ2h0QmFja2dyb3VuZENvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya1N0eWxlICs9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvcjogXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0aXZlU3R5bGUuaGlnaGxpZ2h0QmFja2dyb3VuZENvbG9yICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiO1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVmZmVjdGl2ZVN0eWxlLmhpZ2hsaWdodEZvcmVncm91bmRDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtTdHlsZSArPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbG9yOiBcIiArIGVmZmVjdGl2ZVN0eWxlLmhpZ2hsaWdodEZvcmVncm91bmRDb2xvciArIFwiO1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtTdHlsZSA9ICdzdHlsZT1cIicgKyBtYXJrU3R5bGUgKyAnXCInO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc2VkVGV4dCA9IHRoaXMuX3Byb2Nlc3NlZFRleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPT09L2csIFwiPG1hcmsgXCIgKyBtYXJrU3R5bGUgKyBcIj5cIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwvPT1cXC8vZywgXCI8L21hcms+XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzZWRUZXh0ID0gZm9ybWF0dGVkVGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJlYXRBc1BsYWluVGV4dCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc2VkVGV4dCA9IGZvcm1hdHRlZFRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJlYXRBc1BsYWluVGV4dCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9wcm9jZXNzZWRUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzZWRUZXh0ID0gXCJcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fdHJlYXRBc1BsYWluVGV4dCkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5pbm5lclRleHQgPSB0aGlzLl9wcm9jZXNzZWRUZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb2Nlc3NlZEh0bWwgPSAoX2IgPSAoX2EgPSBUZXh0QmxvY2suX3R0TWFya2Rvd25Qb2xpY3kpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jcmVhdGVIVE1MKHRoaXMuX3Byb2Nlc3NlZFRleHQpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLl9wcm9jZXNzZWRUZXh0O1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBwcm9jZXNzZWRIdG1sO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaXJzdEVsZW1lbnRDaGlsZCA9IGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICBmaXJzdEVsZW1lbnRDaGlsZC5zdHlsZS5tYXJnaW5Ub3AgPSBcIjBweFwiO1xyXG4gICAgICAgICAgICAgICAgZmlyc3RFbGVtZW50Q2hpbGQuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy53cmFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFbGVtZW50Q2hpbGQuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0RWxlbWVudENoaWxkLnN0eWxlLnRleHRPdmVyZmxvdyA9IFwiZWxsaXBzaXNcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5sYXN0RWxlbWVudENoaWxkIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQubGFzdEVsZW1lbnRDaGlsZC5zdHlsZS5tYXJnaW5Cb3R0b20gPSBcIjBweFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhbmNob3JzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImFcIik7XHJcbiAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGFuY2hvcikge1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yLmNsYXNzTGlzdC5hZGQoaG9zdENvbmZpZy5tYWtlQ3NzQ2xhc3NOYW1lKFwiYWMtYW5jaG9yXCIpKTtcclxuICAgICAgICAgICAgICAgIGFuY2hvci50YXJnZXQgPSBcIl9ibGFua1wiO1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yLm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYWlzZUFuY2hvckNsaWNrZWRFdmVudChfdGhpcywgYW5jaG9yLCBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yLm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYWlzZUFuY2hvckNsaWNrZWRFdmVudChfdGhpcywgYW5jaG9yLCBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2MgPSBBcnJheS5mcm9tKGFuY2hvcnMpOyBfaSA8IF9jLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFuY2hvciA9IF9jW19pXTtcclxuICAgICAgICAgICAgICAgIF9sb29wXzEoYW5jaG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy53cmFwKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLndvcmRXcmFwID0gXCJicmVhay13b3JkXCI7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhMaW5lcyAmJiB0aGlzLm1heExpbmVzID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChVdGlscy5pc0ludGVybmV0RXhwbG9yZXIoKSB8fCAhc2hhcmVkXzEuR2xvYmFsU2V0dGluZ3MudXNlV2Via2l0TGluZUNsYW1wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUubWF4SGVpZ2h0ID0gdGhpcy5fY29tcHV0ZWRMaW5lSGVpZ2h0ICogdGhpcy5tYXhMaW5lcyArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoaWxlIG5vbiBzdGFuZGFyZCwgLS13ZWJraXQtbGluZS1jbGFtcCB3b3JrcyBpbiBldmVyeSBicm93c2VyIChleGNlcHQgSUUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBpcyBhIGdyZWF0IHNvbHV0aW9uIHRvIHN1cHBvcnQgdGhlIG1heExpbmVzIGZlYXR1cmUgd2l0aCBlbGxpcHNpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVuY2F0aW9uLiBXaXRoIC0td2Via2l0LWxpbmUtY2xhbXAgdGhlcmUgaXMgbmVlZCB0byB1c2UgZXhwbGljaXQgbGluZSBoZWlnaHRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJsaW5lLWhlaWdodFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCItd2Via2l0LWJveFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLndlYmtpdEJveE9yaWVudCA9IFwidmVydGljYWxcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS53ZWJraXRMaW5lQ2xhbXAgPSB0aGlzLm1heExpbmVzLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS53aGl0ZVNwYWNlID0gXCJub3dyYXBcIjtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUudGV4dE92ZXJmbG93ID0gXCJlbGxpcHNpc1wiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaGFyZWRfMS5HbG9iYWxTZXR0aW5ncy51c2VBZHZhbmNlZFRleHRCbG9ja1RydW5jYXRpb24gfHxcclxuICAgICAgICAgICAgICAgIHNoYXJlZF8xLkdsb2JhbFNldHRpbmdzLnVzZUFkdmFuY2VkQ2FyZEJvdHRvbVRydW5jYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsSW5uZXJIdG1sID0gZWxlbWVudC5pbm5lckhUTUw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUZXh0QmxvY2sucHJvdG90eXBlLnRydW5jYXRlT3ZlcmZsb3cgPSBmdW5jdGlvbiAobWF4SGVpZ2h0KSB7XHJcbiAgICAgICAgaWYgKG1heEhlaWdodCA+PSB0aGlzLl9jb21wdXRlZExpbmVIZWlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJ1bmNhdGVJZlN1cHBvcnRlZChtYXhIZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgVGV4dEJsb2NrLnByb3RvdHlwZS51bmRvT3ZlcmZsb3dUcnVuY2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucmVzdG9yZU9yaWdpbmFsQ29udGVudCgpO1xyXG4gICAgICAgIGlmIChzaGFyZWRfMS5HbG9iYWxTZXR0aW5ncy51c2VBZHZhbmNlZFRleHRCbG9ja1RydW5jYXRpb24gJiYgdGhpcy5tYXhMaW5lcykge1xyXG4gICAgICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gdGhpcy5fY29tcHV0ZWRMaW5lSGVpZ2h0ICogdGhpcy5tYXhMaW5lcztcclxuICAgICAgICAgICAgdGhpcy50cnVuY2F0ZUlmU3VwcG9ydGVkKG1heEhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRleHRCbG9jay5wcm90b3R5cGUuYXBwbHlTdHlsZXNUbyA9IGZ1bmN0aW9uICh0YXJnZXRFbGVtZW50KSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5hcHBseVN0eWxlc1RvLmNhbGwodGhpcywgdGFyZ2V0RWxlbWVudCk7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmdldEVmZmVjdGl2ZUhvcml6b250YWxBbGlnbm1lbnQoKSkge1xyXG4gICAgICAgICAgICBjYXNlIEVudW1zLkhvcml6b250YWxBbGlnbm1lbnQuQ2VudGVyOlxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRW51bXMuSG9yaXpvbnRhbEFsaWdubWVudC5SaWdodDpcclxuICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuc3R5bGUudGV4dEFsaWduID0gXCJlbmRcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSBcInN0YXJ0XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxpbmVIZWlnaHRzID0gdGhpcy5ob3N0Q29uZmlnLmxpbmVIZWlnaHRzO1xyXG4gICAgICAgIGlmIChsaW5lSGVpZ2h0cykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZWZmZWN0aXZlU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFbnVtcy5UZXh0U2l6ZS5TbWFsbDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb21wdXRlZExpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0cy5zbWFsbDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRW51bXMuVGV4dFNpemUuTWVkaXVtOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbXB1dGVkTGluZUhlaWdodCA9IGxpbmVIZWlnaHRzLm1lZGl1bTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRW51bXMuVGV4dFNpemUuTGFyZ2U6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcHV0ZWRMaW5lSGVpZ2h0ID0gbGluZUhlaWdodHMubGFyZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVudW1zLlRleHRTaXplLkV4dHJhTGFyZ2U6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcHV0ZWRMaW5lSGVpZ2h0ID0gbGluZUhlaWdodHMuZXh0cmFMYXJnZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcHV0ZWRMaW5lSGVpZ2h0ID0gbGluZUhlaWdodHMuZGVmYXVsdDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTG9va3MgbGlrZSAxLjMzIGlzIHRoZSBtYWdpYyBudW1iZXIgdG8gY29tcHV0ZSBsaW5lLWhlaWdodFxyXG4gICAgICAgICAgICAvLyBmcm9tIGZvbnQgc2l6ZS5cclxuICAgICAgICAgICAgdGhpcy5fY29tcHV0ZWRMaW5lSGVpZ2h0ID1cclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Rm9udFNpemUodGhpcy5ob3N0Q29uZmlnLmdldEZvbnRUeXBlRGVmaW5pdGlvbih0aGlzLmVmZmVjdGl2ZUZvbnRUeXBlKSkgKlxyXG4gICAgICAgICAgICAgICAgICAgIDEuMzM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRhcmdldEVsZW1lbnQuc3R5bGUubGluZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVkTGluZUhlaWdodCArIFwicHhcIjtcclxuICAgIH07XHJcbiAgICBUZXh0QmxvY2sucHJvdG90eXBlLmdldEpzb25UeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXCJUZXh0QmxvY2tcIjtcclxuICAgIH07XHJcbiAgICBUZXh0QmxvY2sucHJvdG90eXBlLmdldEVmZmVjdGl2ZVRleHRTdHlsZURlZmluaXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaG9zdENvbmZpZy50ZXh0U3R5bGVzLmdldFN0eWxlQnlOYW1lKHRoaXMuc3R5bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5nZXRFZmZlY3RpdmVUZXh0U3R5bGVEZWZpbml0aW9uLmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgVGV4dEJsb2NrLnByb3RvdHlwZS51cGRhdGVMYXlvdXQgPSBmdW5jdGlvbiAocHJvY2Vzc0NoaWxkcmVuKSB7XHJcbiAgICAgICAgaWYgKHByb2Nlc3NDaGlsZHJlbiA9PT0gdm9pZCAwKSB7IHByb2Nlc3NDaGlsZHJlbiA9IGZhbHNlOyB9XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVMYXlvdXQuY2FsbCh0aGlzLCBwcm9jZXNzQ2hpbGRyZW4pO1xyXG4gICAgICAgIGlmIChzaGFyZWRfMS5HbG9iYWxTZXR0aW5ncy51c2VBZHZhbmNlZFRleHRCbG9ja1RydW5jYXRpb24gJiYgdGhpcy5tYXhMaW5lcyAmJiB0aGlzLmlzRGlzcGxheWVkKCkpIHtcclxuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGVsZW1lbnQncyBpbm5lckhUTUwgaW4gY2FzZSB0aGUgYXZhaWxhYmxlIHJvb20gZm9yXHJcbiAgICAgICAgICAgIC8vIGNvbnRlbnQgaGFzIGluY3JlYXNlZFxyXG4gICAgICAgICAgICB0aGlzLnJlc3RvcmVPcmlnaW5hbENvbnRlbnQoKTtcclxuICAgICAgICAgICAgdGhpcy50cnVuY2F0ZUlmU3VwcG9ydGVkKHRoaXMuX2NvbXB1dGVkTGluZUhlaWdodCAqIHRoaXMubWF4TGluZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgVGV4dEJsb2NrLndyYXBQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuQm9vbFByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcIndyYXBcIiwgZmFsc2UpO1xyXG4gICAgVGV4dEJsb2NrLm1heExpbmVzUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLk51bVByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcIm1heExpbmVzXCIpO1xyXG4gICAgVGV4dEJsb2NrLnN0eWxlUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlZhbHVlU2V0UHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzUsIFwic3R5bGVcIiwgW1xyXG4gICAgICAgIHsgdmFsdWU6IFwiZGVmYXVsdFwiIH0sXHJcbiAgICAgICAgeyB2YWx1ZTogXCJjb2x1bW5IZWFkZXJcIiB9LFxyXG4gICAgICAgIHsgdmFsdWU6IFwiaGVhZGluZ1wiIH1cclxuICAgIF0pO1xyXG4gICAgLy8gTWFya2Rvd24gcHJvY2Vzc2luZyBpcyBoYW5kbGVkIG91dHNpZGUgb2YgQWRhcHRpdmUgQ2FyZHMuIEl0J3MgdXAgdG8gdGhlIGhvc3QgdG8gZW5zdXJlIHRoYXQgbWFya2Rvd24gaXMgc2FmZWx5XHJcbiAgICAvLyBwcm9jZXNzZWQuXHJcbiAgICBUZXh0QmxvY2suX3R0TWFya2Rvd25Qb2xpY3kgPSAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpID8gdW5kZWZpbmVkIDogKF9hID0gd2luZG93LnRydXN0ZWRUeXBlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNyZWF0ZVBvbGljeShcImFkYXB0aXZlY2FyZHMjbWFya2Rvd25QYXNzdGhyb3VnaFBvbGljeVwiLCB7IGNyZWF0ZUhUTUw6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH0gfSk7XHJcbiAgICAvLyBXaGVuIFwiYWR2YW5jZWRcIiB0cnVuY2F0aW9uIGlzIGVuYWJsZWQgKHNlZSBHbG9iYWxTZXR0aW5ncy51c2VBZHZhbmNlZENhcmRCb3R0b21UcnVuY2F0aW9uIGFuZFxyXG4gICAgLy8gR2xvYmFsU2V0dGluZ3MudXNlQWR2YW5jZWRUZXh0QmxvY2tUcnVuY2F0aW9uKSwgd2Ugc3RvcmUgdGhlIG9yaWdpbmFsIHByZS10cnVuY2F0aW9uIGNvbnRlbnQgaW5cclxuICAgIC8vIF9vcmlnaW5hbElubmVySHRtbCBzbyB0aGF0IHdlIGNhbiByZXN0b3JlL3JlY2FsY3VsYXRlIHRydW5jYXRpb24gbGF0ZXIgaWYgc3BhY2UgYXZhaWxhYmlsaXR5IGhhcyBjaGFuZ2VkIChzZWVcclxuICAgIC8vIFRleHRCbG9jay5yZXN0b3JlT3JpZ2luYWxDb250ZW50KCkpXHJcbiAgICBUZXh0QmxvY2suX3R0Um91bmR0cmlwUG9saWN5ID0gKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSA/IHVuZGVmaW5lZCA6IChfYiA9IHdpbmRvdy50cnVzdGVkVHlwZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jcmVhdGVQb2xpY3koXCJhZGFwdGl2ZWNhcmRzI3Jlc3RvcmVDb250ZW50c1BvbGljeVwiLCB7IGNyZWF0ZUhUTUw6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH0gfSk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShUZXh0QmxvY2sud3JhcFByb3BlcnR5KVxyXG4gICAgXSwgVGV4dEJsb2NrLnByb3RvdHlwZSwgXCJ3cmFwXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShUZXh0QmxvY2subWF4TGluZXNQcm9wZXJ0eSlcclxuICAgIF0sIFRleHRCbG9jay5wcm90b3R5cGUsIFwibWF4TGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKFRleHRCbG9jay5zdHlsZVByb3BlcnR5KVxyXG4gICAgXSwgVGV4dEJsb2NrLnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xyXG4gICAgcmV0dXJuIFRleHRCbG9jaztcclxufShCYXNlVGV4dEJsb2NrKSk7XHJcbmV4cG9ydHMuVGV4dEJsb2NrID0gVGV4dEJsb2NrO1xyXG52YXIgVGV4dFJ1biA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhUZXh0UnVuLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVGV4dFJ1bigpIHtcclxuICAgICAgICAvLyNyZWdpb24gU2NoZW1hXHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuaXRhbGljID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuc3RyaWtldGhyb3VnaCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmhpZ2hsaWdodCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLnVuZGVybGluZSA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFRleHRSdW4ucHJvdG90eXBlLnBvcHVsYXRlU2NoZW1hID0gZnVuY3Rpb24gKHNjaGVtYSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucG9wdWxhdGVTY2hlbWEuY2FsbCh0aGlzLCBzY2hlbWEpO1xyXG4gICAgICAgIHNjaGVtYS5hZGQoQmFzZVRleHRCbG9jay5zZWxlY3RBY3Rpb25Qcm9wZXJ0eSk7XHJcbiAgICB9O1xyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgICBUZXh0UnVuLnByb3RvdHlwZS5pbnRlcm5hbFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIHByZVByb2Nlc3NlZFRleHQgPSB0aGlzLnByZVByb2Nlc3NQcm9wZXJ0eVZhbHVlKEJhc2VUZXh0QmxvY2sudGV4dFByb3BlcnR5KTtcclxuICAgICAgICAgICAgdmFyIGhvc3RDb25maWcgPSB0aGlzLmhvc3RDb25maWc7XHJcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRUZXh0ID0gVGV4dEZvcm1hdHRlcnMuZm9ybWF0VGV4dCh0aGlzLmxhbmcsIHByZVByb2Nlc3NlZFRleHQpO1xyXG4gICAgICAgICAgICBpZiAoIWZvcm1hdHRlZFRleHQpIHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFRleHQgPSBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy10ZXh0UnVuXCIpKTtcclxuICAgICAgICAgICAgdGhpcy5hcHBseVN0eWxlc1RvKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RBY3Rpb24gJiYgaG9zdENvbmZpZy5zdXBwb3J0c0ludGVyYWN0aXZpdHkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcclxuICAgICAgICAgICAgICAgIGFuY2hvci5jbGFzc0xpc3QuYWRkKGhvc3RDb25maWcubWFrZUNzc0NsYXNzTmFtZShcImFjLWFuY2hvclwiKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaHJlZiA9IHRoaXMuc2VsZWN0QWN0aW9uLmdldEhyZWYoKTtcclxuICAgICAgICAgICAgICAgIGFuY2hvci5ocmVmID0gaHJlZiA/IGhyZWYgOiBcIlwiO1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yLnRhcmdldCA9IFwiX2JsYW5rXCI7XHJcbiAgICAgICAgICAgICAgICBhbmNob3Iub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnNlbGVjdEFjdGlvbiAmJiBfdGhpcy5zZWxlY3RBY3Rpb24uaXNFZmZlY3RpdmVseUVuYWJsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VsZWN0QWN0aW9uLmV4ZWN1dGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RBY3Rpb24uc2V0dXBFbGVtZW50Rm9yQWNjZXNzaWJpbGl0eShhbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yLmlubmVyVGV4dCA9IGZvcm1hdHRlZFRleHQ7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGFuY2hvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmlubmVyVGV4dCA9IGZvcm1hdHRlZFRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUZXh0UnVuLnByb3RvdHlwZS5hcHBseVN0eWxlc1RvID0gZnVuY3Rpb24gKHRhcmdldEVsZW1lbnQpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmFwcGx5U3R5bGVzVG8uY2FsbCh0aGlzLCB0YXJnZXRFbGVtZW50KTtcclxuICAgICAgICBpZiAodGhpcy5pdGFsaWMpIHtcclxuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5zdHlsZS5mb250U3R5bGUgPSBcIml0YWxpY1wiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zdHJpa2V0aHJvdWdoKSB7XHJcbiAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuc3R5bGUudGV4dERlY29yYXRpb24gPSBcImxpbmUtdGhyb3VnaFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHQpIHtcclxuICAgICAgICAgICAgdmFyIGNvbG9yRGVmaW5pdGlvbiA9IHRoaXMuZ2V0Q29sb3JEZWZpbml0aW9uKHRoaXMuZ2V0RWZmZWN0aXZlU3R5bGVEZWZpbml0aW9uKCkuZm9yZWdyb3VuZENvbG9ycywgdGhpcy5lZmZlY3RpdmVDb2xvcik7XHJcbiAgICAgICAgICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBVdGlscy5zdHJpbmdUb0Nzc0NvbG9yKHRoaXMuZWZmZWN0aXZlSXNTdWJ0bGVcclxuICAgICAgICAgICAgICAgID8gY29sb3JEZWZpbml0aW9uLmhpZ2hsaWdodENvbG9ycy5zdWJ0bGVcclxuICAgICAgICAgICAgICAgIDogY29sb3JEZWZpbml0aW9uLmhpZ2hsaWdodENvbG9ycy5kZWZhdWx0KTtcclxuICAgICAgICAgICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBiYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudW5kZXJsaW5lKSB7XHJcbiAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuc3R5bGUudGV4dERlY29yYXRpb24gPSBcInVuZGVybGluZVwiO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUZXh0UnVuLnByb3RvdHlwZS5nZXRKc29uVHlwZU5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiVGV4dFJ1blwiO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0UnVuLnByb3RvdHlwZSwgXCJpc1N0YW5kYWxvbmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHRSdW4ucHJvdG90eXBlLCBcImlzSW5saW5lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgVGV4dFJ1bi5pdGFsaWNQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuQm9vbFByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8yLCBcIml0YWxpY1wiLCBmYWxzZSk7XHJcbiAgICBUZXh0UnVuLnN0cmlrZXRocm91Z2hQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuQm9vbFByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8yLCBcInN0cmlrZXRocm91Z2hcIiwgZmFsc2UpO1xyXG4gICAgVGV4dFJ1bi5oaWdobGlnaHRQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuQm9vbFByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8yLCBcImhpZ2hsaWdodFwiLCBmYWxzZSk7XHJcbiAgICBUZXh0UnVuLnVuZGVybGluZVByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5Cb29sUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzMsIFwidW5kZXJsaW5lXCIsIGZhbHNlKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKFRleHRSdW4uaXRhbGljUHJvcGVydHkpXHJcbiAgICBdLCBUZXh0UnVuLnByb3RvdHlwZSwgXCJpdGFsaWNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKFRleHRSdW4uc3RyaWtldGhyb3VnaFByb3BlcnR5KVxyXG4gICAgXSwgVGV4dFJ1bi5wcm90b3R5cGUsIFwic3RyaWtldGhyb3VnaFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoVGV4dFJ1bi5oaWdobGlnaHRQcm9wZXJ0eSlcclxuICAgIF0sIFRleHRSdW4ucHJvdG90eXBlLCBcImhpZ2hsaWdodFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoVGV4dFJ1bi51bmRlcmxpbmVQcm9wZXJ0eSlcclxuICAgIF0sIFRleHRSdW4ucHJvdG90eXBlLCBcInVuZGVybGluZVwiLCB2b2lkIDApO1xyXG4gICAgcmV0dXJuIFRleHRSdW47XHJcbn0oQmFzZVRleHRCbG9jaykpO1xyXG5leHBvcnRzLlRleHRSdW4gPSBUZXh0UnVuO1xyXG52YXIgUmljaFRleHRCbG9jayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSaWNoVGV4dEJsb2NrLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUmljaFRleHRCbG9jaygpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5faW5saW5lcyA9IFtdO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFJpY2hUZXh0QmxvY2sucHJvdG90eXBlLmludGVybmFsQWRkSW5saW5lID0gZnVuY3Rpb24gKGlubGluZSwgZm9yY2VBZGQpIHtcclxuICAgICAgICBpZiAoZm9yY2VBZGQgPT09IHZvaWQgMCkgeyBmb3JjZUFkZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKCFpbmxpbmUuaXNJbmxpbmUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy5lbGVtZW50Q2Fubm90QmVVc2VkQXNJbmxpbmUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkb0FkZCA9IGlubGluZS5wYXJlbnQgPT09IHVuZGVmaW5lZCB8fCBmb3JjZUFkZDtcclxuICAgICAgICBpZiAoIWRvQWRkICYmIGlubGluZS5wYXJlbnQgIT09IHRoaXMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy5pbmxpbmVBbHJlYWR5UGFyZW50ZWQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpbmxpbmUuc2V0UGFyZW50KHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9pbmxpbmVzLnB1c2goaW5saW5lKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmljaFRleHRCbG9jay5wcm90b3R5cGUuaW50ZXJuYWxQYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNvbnRleHQpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmludGVybmFsUGFyc2UuY2FsbCh0aGlzLCBzb3VyY2UsIGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMuX2lubGluZXMgPSBbXTtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2VbXCJpbmxpbmVzXCJdKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gc291cmNlW1wiaW5saW5lc1wiXTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBqc29uSW5saW5lID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlubGluZSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YganNvbklubGluZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0UnVuID0gbmV3IFRleHRSdW4oKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0UnVuLnRleHQgPSBqc29uSW5saW5lO1xyXG4gICAgICAgICAgICAgICAgICAgIGlubGluZSA9IHRleHRSdW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBObyBmYWxsYmFjayBmb3IgaW5saW5lcyBpbiAxLjJcclxuICAgICAgICAgICAgICAgICAgICBpbmxpbmUgPSBjb250ZXh0LnBhcnNlRWxlbWVudCh0aGlzLCBqc29uSW5saW5lLCBbXSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlubGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxBZGRJbmxpbmUoaW5saW5lLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSaWNoVGV4dEJsb2NrLnByb3RvdHlwZS5pbnRlcm5hbFRvSlNPTiA9IGZ1bmN0aW9uICh0YXJnZXQsIGNvbnRleHQpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmludGVybmFsVG9KU09OLmNhbGwodGhpcywgdGFyZ2V0LCBjb250ZXh0KTtcclxuICAgICAgICBpZiAodGhpcy5faW5saW5lcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBqc29uSW5saW5lcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5faW5saW5lczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmxpbmUgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBqc29uSW5saW5lcy5wdXNoKGlubGluZS50b0pTT04oY29udGV4dCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2VyaWFsaXplVmFsdWUodGFyZ2V0LCBcImlubGluZXNcIiwganNvbklubGluZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSaWNoVGV4dEJsb2NrLnByb3RvdHlwZS5pbnRlcm5hbFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5faW5saW5lcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdm9pZCAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mb3JFbGVtZW50SWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsYWJlbEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XHJcbiAgICAgICAgICAgICAgICBsYWJlbEVsZW1lbnQuaHRtbEZvciA9IHRoaXMuZm9yRWxlbWVudElkO1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGxhYmVsRWxlbWVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5ob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1yaWNoVGV4dEJsb2NrXCIpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZ2V0RWZmZWN0aXZlSG9yaXpvbnRhbEFsaWdubWVudCgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVudW1zLkhvcml6b250YWxBbGlnbm1lbnQuQ2VudGVyOlxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRW51bXMuSG9yaXpvbnRhbEFsaWdubWVudC5SaWdodDpcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnRleHRBbGlnbiA9IFwiZW5kXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUudGV4dEFsaWduID0gXCJzdGFydFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZW5kZXJlZElubGluZXMgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5faW5saW5lczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmxpbmUgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVuZGVyZWRJbmxpbmUgPSBpbmxpbmUucmVuZGVyKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZWRJbmxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHJlbmRlcmVkSW5saW5lKTtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZElubGluZXMrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVuZGVyZWRJbmxpbmVzID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBSaWNoVGV4dEJsb2NrLnByb3RvdHlwZS5hc1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5faW5saW5lczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGlubGluZSA9IF9hW19pXTtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IGlubGluZS5hc1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIFJpY2hUZXh0QmxvY2sucHJvdG90eXBlLmdldEpzb25UeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXCJSaWNoVGV4dEJsb2NrXCI7XHJcbiAgICB9O1xyXG4gICAgUmljaFRleHRCbG9jay5wcm90b3R5cGUuZ2V0SW5saW5lQ291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubGluZXMubGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIFJpY2hUZXh0QmxvY2sucHJvdG90eXBlLmdldElubGluZUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9pbmxpbmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5saW5lc1tpbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyaW5nc18xLlN0cmluZ3MuZXJyb3JzLmluZGV4T3V0T2ZSYW5nZShpbmRleCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSaWNoVGV4dEJsb2NrLnByb3RvdHlwZS5hZGRJbmxpbmUgPSBmdW5jdGlvbiAoaW5saW5lKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBpbmxpbmUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEFkZElubGluZShuZXcgVGV4dFJ1bihpbmxpbmUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxBZGRJbmxpbmUoaW5saW5lKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmljaFRleHRCbG9jay5wcm90b3R5cGUucmVtb3ZlSW5saW5lID0gZnVuY3Rpb24gKGlubGluZSkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2lubGluZXMuaW5kZXhPZihpbmxpbmUpO1xyXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lubGluZXNbaW5kZXhdLnNldFBhcmVudCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB0aGlzLl9pbmxpbmVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJpY2hUZXh0QmxvY2s7XHJcbn0oQ2FyZEVsZW1lbnQpKTtcclxuZXhwb3J0cy5SaWNoVGV4dEJsb2NrID0gUmljaFRleHRCbG9jaztcclxudmFyIEZhY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRmFjdCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZhY3QobmFtZSwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgICBGYWN0LnByb3RvdHlwZS5nZXRTY2hlbWFLZXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiRmFjdFwiO1xyXG4gICAgfTtcclxuICAgIC8vI3JlZ2lvbiBTY2hlbWFcclxuICAgIEZhY3QudGl0bGVQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuU3RyaW5nUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwidGl0bGVcIik7XHJcbiAgICBGYWN0LnZhbHVlUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcInZhbHVlXCIpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoRmFjdC50aXRsZVByb3BlcnR5KVxyXG4gICAgXSwgRmFjdC5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoRmFjdC52YWx1ZVByb3BlcnR5KVxyXG4gICAgXSwgRmFjdC5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIHJldHVybiBGYWN0O1xyXG59KHNlcmlhbGl6YXRpb25fMS5TZXJpYWxpemFibGVPYmplY3QpKTtcclxuZXhwb3J0cy5GYWN0ID0gRmFjdDtcclxudmFyIEZhY3RTZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRmFjdFNldCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZhY3RTZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZhY3RTZXQucHJvdG90eXBlLCBcInVzZURlZmF1bHRTaXppbmdcIiwge1xyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgRmFjdFNldC5wcm90b3R5cGUuaW50ZXJuYWxSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIGhvc3RDb25maWcgPSB0aGlzLmhvc3RDb25maWc7XHJcbiAgICAgICAgaWYgKHRoaXMuZmFjdHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRhYmxlXCIpO1xyXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmJvcmRlcldpZHRoID0gXCIwcHhcIjtcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5ib3JkZXJTcGFjaW5nID0gXCIwcHhcIjtcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5ib3JkZXJTdHlsZSA9IFwibm9uZVwiO1xyXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmJvcmRlckNvbGxhcHNlID0gXCJjb2xsYXBzZVwiO1xyXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xyXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoaG9zdENvbmZpZy5tYWtlQ3NzQ2xhc3NOYW1lKFwiYWMtZmFjdHNldFwiKSk7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZhY3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRyXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJFbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9IGhvc3RDb25maWcuZmFjdFNldC5zcGFjaW5nICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVGl0bGUgY29sdW1uXHJcbiAgICAgICAgICAgICAgICB2YXIgdGRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xyXG4gICAgICAgICAgICAgICAgdGRFbGVtZW50LnN0eWxlLnBhZGRpbmcgPSBcIjBcIjtcclxuICAgICAgICAgICAgICAgIHRkRWxlbWVudC5jbGFzc0xpc3QuYWRkKGhvc3RDb25maWcubWFrZUNzc0NsYXNzTmFtZShcImFjLWZhY3QtdGl0bGVcIikpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhvc3RDb25maWcuZmFjdFNldC50aXRsZS5tYXhXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRkRWxlbWVudC5zdHlsZS5tYXhXaWR0aCA9IGhvc3RDb25maWcuZmFjdFNldC50aXRsZS5tYXhXaWR0aCArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRkRWxlbWVudC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gXCJ0b3BcIjtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXh0QmxvY2sgPSBuZXcgVGV4dEJsb2NrKCk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0QmxvY2suc2V0UGFyZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGV4dEJsb2NrLnRleHQgPVxyXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmZhY3RzW2ldLm5hbWUgJiYgdGhpcy5pc0Rlc2lnbk1vZGUoKSA/IFwiVGl0bGVcIiA6IHRoaXMuZmFjdHNbaV0ubmFtZTtcclxuICAgICAgICAgICAgICAgIHRleHRCbG9jay5zaXplID0gaG9zdENvbmZpZy5mYWN0U2V0LnRpdGxlLnNpemU7XHJcbiAgICAgICAgICAgICAgICB0ZXh0QmxvY2suY29sb3IgPSBob3N0Q29uZmlnLmZhY3RTZXQudGl0bGUuY29sb3I7XHJcbiAgICAgICAgICAgICAgICB0ZXh0QmxvY2suaXNTdWJ0bGUgPSBob3N0Q29uZmlnLmZhY3RTZXQudGl0bGUuaXNTdWJ0bGU7XHJcbiAgICAgICAgICAgICAgICB0ZXh0QmxvY2sud2VpZ2h0ID0gaG9zdENvbmZpZy5mYWN0U2V0LnRpdGxlLndlaWdodDtcclxuICAgICAgICAgICAgICAgIHRleHRCbG9jay53cmFwID0gaG9zdENvbmZpZy5mYWN0U2V0LnRpdGxlLndyYXA7XHJcbiAgICAgICAgICAgICAgICB0ZXh0QmxvY2suc3BhY2luZyA9IEVudW1zLlNwYWNpbmcuTm9uZTtcclxuICAgICAgICAgICAgICAgIFV0aWxzLmFwcGVuZENoaWxkKHRkRWxlbWVudCwgdGV4dEJsb2NrLnJlbmRlcigpKTtcclxuICAgICAgICAgICAgICAgIFV0aWxzLmFwcGVuZENoaWxkKHRyRWxlbWVudCwgdGRFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIC8vIFNwYWNlciBjb2x1bW5cclxuICAgICAgICAgICAgICAgIHRkRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiKTtcclxuICAgICAgICAgICAgICAgIHRkRWxlbWVudC5zdHlsZS53aWR0aCA9IFwiMTBweFwiO1xyXG4gICAgICAgICAgICAgICAgVXRpbHMuYXBwZW5kQ2hpbGQodHJFbGVtZW50LCB0ZEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgLy8gVmFsdWUgY29sdW1uXHJcbiAgICAgICAgICAgICAgICB0ZEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XHJcbiAgICAgICAgICAgICAgICB0ZEVsZW1lbnQuc3R5bGUucGFkZGluZyA9IFwiMFwiO1xyXG4gICAgICAgICAgICAgICAgdGRFbGVtZW50LnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcInRvcFwiO1xyXG4gICAgICAgICAgICAgICAgdGRFbGVtZW50LmNsYXNzTGlzdC5hZGQoaG9zdENvbmZpZy5tYWtlQ3NzQ2xhc3NOYW1lKFwiYWMtZmFjdC12YWx1ZVwiKSk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0QmxvY2sgPSBuZXcgVGV4dEJsb2NrKCk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0QmxvY2suc2V0UGFyZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGV4dEJsb2NrLnRleHQgPSB0aGlzLmZhY3RzW2ldLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGV4dEJsb2NrLnNpemUgPSBob3N0Q29uZmlnLmZhY3RTZXQudmFsdWUuc2l6ZTtcclxuICAgICAgICAgICAgICAgIHRleHRCbG9jay5jb2xvciA9IGhvc3RDb25maWcuZmFjdFNldC52YWx1ZS5jb2xvcjtcclxuICAgICAgICAgICAgICAgIHRleHRCbG9jay5pc1N1YnRsZSA9IGhvc3RDb25maWcuZmFjdFNldC52YWx1ZS5pc1N1YnRsZTtcclxuICAgICAgICAgICAgICAgIHRleHRCbG9jay53ZWlnaHQgPSBob3N0Q29uZmlnLmZhY3RTZXQudmFsdWUud2VpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdGV4dEJsb2NrLndyYXAgPSBob3N0Q29uZmlnLmZhY3RTZXQudmFsdWUud3JhcDtcclxuICAgICAgICAgICAgICAgIHRleHRCbG9jay5zcGFjaW5nID0gRW51bXMuU3BhY2luZy5Ob25lO1xyXG4gICAgICAgICAgICAgICAgVXRpbHMuYXBwZW5kQ2hpbGQodGRFbGVtZW50LCB0ZXh0QmxvY2sucmVuZGVyKCkpO1xyXG4gICAgICAgICAgICAgICAgVXRpbHMuYXBwZW5kQ2hpbGQodHJFbGVtZW50LCB0ZEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgVXRpbHMuYXBwZW5kQ2hpbGQoZWxlbWVudCwgdHJFbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH07XHJcbiAgICBGYWN0U2V0LnByb3RvdHlwZS5nZXRKc29uVHlwZU5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiRmFjdFNldFwiO1xyXG4gICAgfTtcclxuICAgIC8vI3JlZ2lvbiBTY2hlbWFcclxuICAgIEZhY3RTZXQuZmFjdHNQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuU2VyaWFsaXphYmxlT2JqZWN0Q29sbGVjdGlvblByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcImZhY3RzXCIsIEZhY3QpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoRmFjdFNldC5mYWN0c1Byb3BlcnR5KVxyXG4gICAgXSwgRmFjdFNldC5wcm90b3R5cGUsIFwiZmFjdHNcIiwgdm9pZCAwKTtcclxuICAgIHJldHVybiBGYWN0U2V0O1xyXG59KENhcmRFbGVtZW50KSk7XHJcbmV4cG9ydHMuRmFjdFNldCA9IEZhY3RTZXQ7XHJcbnZhciBJbWFnZURpbWVuc2lvblByb3BlcnR5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEltYWdlRGltZW5zaW9uUHJvcGVydHksIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBJbWFnZURpbWVuc2lvblByb3BlcnR5KHRhcmdldFZlcnNpb24sIG5hbWUsIGludGVybmFsTmFtZSwgZmFsbGJhY2tQcm9wZXJ0eSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRhcmdldFZlcnNpb24sIG5hbWUpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudGFyZ2V0VmVyc2lvbiA9IHRhcmdldFZlcnNpb247XHJcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgX3RoaXMuaW50ZXJuYWxOYW1lID0gaW50ZXJuYWxOYW1lO1xyXG4gICAgICAgIF90aGlzLmZhbGxiYWNrUHJvcGVydHkgPSBmYWxsYmFja1Byb3BlcnR5O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEltYWdlRGltZW5zaW9uUHJvcGVydHkucHJvdG90eXBlLmdldEludGVybmFsTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE5hbWU7XHJcbiAgICB9O1xyXG4gICAgSW1hZ2VEaW1lbnNpb25Qcm9wZXJ0eS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc2VuZGVyLCBzb3VyY2UsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHZhciBzb3VyY2VWYWx1ZSA9IHNvdXJjZVt0aGlzLm5hbWVdO1xyXG4gICAgICAgIGlmIChzb3VyY2VWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVZhbHVlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IHNoYXJlZF8xLlNpemVBbmRVbml0LnBhcnNlKHNvdXJjZVZhbHVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChzaXplLnVuaXQgPT09IEVudW1zLlNpemVVbml0LlBpeGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2l6ZS5waHlzaWNhbFNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTd2FsbG93IHRoZSBleGNlcHRpb25cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgc291cmNlIHZhbHVlIGlzbid0IHZhbGlkIHBlciB0aGlzIHByb3BlcnR5IGRlZmluaXRpb24sXHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGl0cyB2YWxpZGl0eSBwZXIgdGhlIGZhbGxiYWNrIHByb3BlcnR5LCBpZiBzcGVjaWZpZWRcclxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkICYmIHRoaXMuZmFsbGJhY2tQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRoaXMuZmFsbGJhY2tQcm9wZXJ0eS5pc1ZhbGlkVmFsdWUoc291cmNlVmFsdWUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNWYWxpZCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmxvZ1BhcnNlRXZlbnQoc2VuZGVyLCBFbnVtcy5WYWxpZGF0aW9uRXZlbnQuSW52YWxpZFByb3BlcnR5VmFsdWUsIHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy5pbnZhbGlkUHJvcGVydHlWYWx1ZShzb3VyY2VWYWx1ZSwgdGhpcy5uYW1lKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgSW1hZ2VEaW1lbnNpb25Qcm9wZXJ0eS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKHNlbmRlciwgdGFyZ2V0LCB2YWx1ZSwgY29udGV4dCkge1xyXG4gICAgICAgIGNvbnRleHQuc2VyaWFsaXplVmFsdWUodGFyZ2V0LCB0aGlzLm5hbWUsIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4odmFsdWUpID8gdmFsdWUgKyBcInB4XCIgOiB1bmRlZmluZWQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBJbWFnZURpbWVuc2lvblByb3BlcnR5O1xyXG59KHNlcmlhbGl6YXRpb25fMS5Qcm9wZXJ0eURlZmluaXRpb24pKTtcclxudmFyIEltYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEltYWdlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSW1hZ2UoKSB7XHJcbiAgICAgICAgLy8jcmVnaW9uIFNjaGVtYVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnNpemUgPSBFbnVtcy5TaXplLkF1dG87XHJcbiAgICAgICAgX3RoaXMuc3R5bGUgPSBFbnVtcy5JbWFnZVN0eWxlLkRlZmF1bHQ7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgSW1hZ2UucHJvdG90eXBlLnBvcHVsYXRlU2NoZW1hID0gZnVuY3Rpb24gKHNjaGVtYSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucG9wdWxhdGVTY2hlbWEuY2FsbCh0aGlzLCBzY2hlbWEpO1xyXG4gICAgICAgIHNjaGVtYS5yZW1vdmUoQ2FyZEVsZW1lbnQuaGVpZ2h0UHJvcGVydHkpO1xyXG4gICAgfTtcclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgSW1hZ2UucHJvdG90eXBlLmFwcGx5U2l6ZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGl4ZWxXaWR0aCB8fCB0aGlzLnBpeGVsSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBpeGVsV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSB0aGlzLnBpeGVsV2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMucGl4ZWxIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5waXhlbEhlaWdodCArIFwicHhcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWF4SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaW1hZ2UgaXMgY29uc3RyYWluZWQgaW4gaGVpZ2h0LCB3ZSBzZXQgaXRzIGhlaWdodCBwcm9wZXJ0eSBhbmRcclxuICAgICAgICAgICAgICAgIC8vIGF1dG8gYW5kIHN0cmV0Y2ggYXJlIGlnbm9yZWQgKGRlZmF1bHQgdG8gbWVkaXVtKS4gVEhpcyBpcyBuZWNlc3NhcnkgZm9yXHJcbiAgICAgICAgICAgICAgICAvLyBJbWFnZVNldCB3aGljaCB1c2VzIGEgbWF4aW11bSBpbWFnZSBoZWlnaHQgYXMgb3Bwb3NlZCB0byB0aGUgY2FyZHMgd2lkdGhcclxuICAgICAgICAgICAgICAgIC8vIGFzIGEgY29uc3RyYWluaW5nIGRpbWVuc2lvblxyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEVudW1zLlNpemUuU21hbGw6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5ob3N0Q29uZmlnLmltYWdlU2l6ZXMuc21hbGwgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRW51bXMuU2l6ZS5MYXJnZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhvc3RDb25maWcuaW1hZ2VTaXplcy5sYXJnZSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhvc3RDb25maWcuaW1hZ2VTaXplcy5tZWRpdW0gKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5tYXhIZWlnaHQgPSB0aGlzLm1heEhlaWdodCArIFwicHhcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBFbnVtcy5TaXplLlN0cmV0Y2g6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBFbnVtcy5TaXplLkF1dG86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUubWF4V2lkdGggPSBcIjEwMCVcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBFbnVtcy5TaXplLlNtYWxsOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gdGhpcy5ob3N0Q29uZmlnLmltYWdlU2l6ZXMuc21hbGwgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRW51bXMuU2l6ZS5MYXJnZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IHRoaXMuaG9zdENvbmZpZy5pbWFnZVNpemVzLmxhcmdlICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEVudW1zLlNpemUuTWVkaXVtOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gdGhpcy5ob3N0Q29uZmlnLmltYWdlU2l6ZXMubWVkaXVtICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUubWF4SGVpZ2h0ID0gXCIxMDAlXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEltYWdlLnByb3RvdHlwZSwgXCJ1c2VEZWZhdWx0U2l6aW5nXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEltYWdlLnByb3RvdHlwZS5pbnRlcm5hbFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmICh0aGlzLnVybCkge1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuYWxpZ25JdGVtcyA9IFwiZmxleC1zdGFydFwiO1xyXG4gICAgICAgICAgICAvLyBDYWNoZSBob3N0Q29uZmlnIHRvIGF2b2lkIHdhbGtpbmcgdGhlIHBhcmVudCBoaWVyYXJjaHkgbXVsdGlwbGUgdGltZXNcclxuICAgICAgICAgICAgdmFyIGhvc3RDb25maWcgPSB0aGlzLmhvc3RDb25maWc7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5nZXRFZmZlY3RpdmVIb3Jpem9udGFsQWxpZ25tZW50KCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgRW51bXMuSG9yaXpvbnRhbEFsaWdubWVudC5DZW50ZXI6XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVudW1zLkhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiZmxleC1lbmRcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiZmxleC1zdGFydFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpbWFnZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xyXG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQub25sb2FkID0gZnVuY3Rpb24gKF9lKSB7XHJcbiAgICAgICAgICAgICAgICByYWlzZUltYWdlTG9hZGVkRXZlbnQoX3RoaXMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQub25lcnJvciA9IGZ1bmN0aW9uIChfZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlbmRlcmVkRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYXJkID0gX3RoaXMuZ2V0Um9vdEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJlZEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcmQgJiYgY2FyZC5kZXNpZ25Nb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckVsZW1lbnQuc3R5bGUuYWxpZ25JdGVtcyA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yRWxlbWVudC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIiNFRUVFRUVcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JFbGVtZW50LnN0eWxlLmNvbG9yID0gXCJibGFja1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckVsZW1lbnQuaW5uZXJUZXh0ID0gXCI6LShcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JFbGVtZW50LnN0eWxlLnBhZGRpbmcgPSBcIjEwcHhcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXBwbHlTaXplKGVycm9yRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlcmVkRWxlbWVudC5hcHBlbmRDaGlsZChlcnJvckVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJhaXNlSW1hZ2VMb2FkZWRFdmVudChfdGhpcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGltYWdlRWxlbWVudC5zdHlsZS5taW5XaWR0aCA9IFwiMFwiO1xyXG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1pbWFnZVwiKSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdEFjdGlvbiAmJiBob3N0Q29uZmlnLnN1cHBvcnRzSW50ZXJhY3Rpdml0eSkge1xyXG4gICAgICAgICAgICAgICAgaW1hZ2VFbGVtZW50Lm9ua2V5cHJlc3MgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zZWxlY3RBY3Rpb24gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VsZWN0QWN0aW9uLmlzRWZmZWN0aXZlbHlFbmFibGVkKCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGUuY29kZSA9PT0gXCJFbnRlclwiIHx8IGUuY29kZSA9PT0gXCJTcGFjZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbnRlciBvciBzcGFjZSBwcmVzc2VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZWxlY3RBY3Rpb24uZXhlY3V0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpbWFnZUVsZW1lbnQub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnNlbGVjdEFjdGlvbiAmJiBfdGhpcy5zZWxlY3RBY3Rpb24uaXNFZmZlY3RpdmVseUVuYWJsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VsZWN0QWN0aW9uLmV4ZWN1dGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RBY3Rpb24uc2V0dXBFbGVtZW50Rm9yQWNjZXNzaWJpbGl0eShpbWFnZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0QWN0aW9uLmlzRWZmZWN0aXZlbHlFbmFibGVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1zZWxlY3RhYmxlXCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFwcGx5U2l6ZShpbWFnZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdHlsZSA9PT0gRW51bXMuSW1hZ2VTdHlsZS5QZXJzb24pIHtcclxuICAgICAgICAgICAgICAgIGltYWdlRWxlbWVudC5zdHlsZS5ib3JkZXJSYWRpdXMgPSBcIjUwJVwiO1xyXG4gICAgICAgICAgICAgICAgaW1hZ2VFbGVtZW50LnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9IFwiNTAlIDUwJVwiO1xyXG4gICAgICAgICAgICAgICAgaW1hZ2VFbGVtZW50LnN0eWxlLmJhY2tncm91bmRSZXBlYXQgPSBcIm5vLXJlcGVhdFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBVdGlscy5zdHJpbmdUb0Nzc0NvbG9yKHRoaXMuYmFja2dyb3VuZENvbG9yKTtcclxuICAgICAgICAgICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgaW1hZ2VFbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQuc3JjID0gdGhpcy5wcmVQcm9jZXNzUHJvcGVydHlWYWx1ZShJbWFnZS51cmxQcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgIHZhciBhbHRUZXh0UHJvcGVydHkgPSB0aGlzLnByZVByb2Nlc3NQcm9wZXJ0eVZhbHVlKEltYWdlLmFsdFRleHRQcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgIGlmIChhbHRUZXh0UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgIGltYWdlRWxlbWVudC5hbHQgPSBhbHRUZXh0UHJvcGVydHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChpbWFnZUVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH07XHJcbiAgICBJbWFnZS5wcm90b3R5cGUuZ2V0SnNvblR5cGVOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcIkltYWdlXCI7XHJcbiAgICB9O1xyXG4gICAgSW1hZ2UucHJvdG90eXBlLmdldEFsbEFjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IF9zdXBlci5wcm90b3R5cGUuZ2V0QWxsQWN0aW9ucy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdEFjdGlvbikge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnNlbGVjdEFjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgSW1hZ2UucHJvdG90eXBlLmdldEFjdGlvbkJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS5nZXRBY3Rpb25CeUlkLmNhbGwodGhpcywgaWQpO1xyXG4gICAgICAgIGlmICghcmVzdWx0ICYmIHRoaXMuc2VsZWN0QWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuc2VsZWN0QWN0aW9uLmdldEFjdGlvbkJ5SWQoaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIEltYWdlLnByb3RvdHlwZS5nZXRSZXNvdXJjZUluZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVybCA/IFt7IHVybDogdGhpcy51cmwsIG1pbWVUeXBlOiBcImltYWdlXCIgfV0gOiBbXTtcclxuICAgIH07XHJcbiAgICBJbWFnZS51cmxQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuU3RyaW5nUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwidXJsXCIpO1xyXG4gICAgSW1hZ2UuYWx0VGV4dFByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCwgXCJhbHRUZXh0XCIpO1xyXG4gICAgSW1hZ2UuYmFja2dyb3VuZENvbG9yUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8xLCBcImJhY2tncm91bmRDb2xvclwiKTtcclxuICAgIEltYWdlLnN0eWxlUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLkVudW1Qcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCwgXCJzdHlsZVwiLCBFbnVtcy5JbWFnZVN0eWxlLCBFbnVtcy5JbWFnZVN0eWxlLkRlZmF1bHQpO1xyXG4gICAgSW1hZ2Uuc2l6ZVByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5FbnVtUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwic2l6ZVwiLCBFbnVtcy5TaXplLCBFbnVtcy5TaXplLkF1dG8pO1xyXG4gICAgSW1hZ2UucGl4ZWxXaWR0aFByb3BlcnR5ID0gbmV3IEltYWdlRGltZW5zaW9uUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzEsIFwid2lkdGhcIiwgXCJwaXhlbFdpZHRoXCIpO1xyXG4gICAgSW1hZ2UucGl4ZWxIZWlnaHRQcm9wZXJ0eSA9IG5ldyBJbWFnZURpbWVuc2lvblByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8xLCBcImhlaWdodFwiLCBcInBpeGVsSGVpZ2h0XCIsIENhcmRFbGVtZW50LmhlaWdodFByb3BlcnR5KTtcclxuICAgIEltYWdlLnNlbGVjdEFjdGlvblByb3BlcnR5ID0gbmV3IEFjdGlvblByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8xLCBcInNlbGVjdEFjdGlvblwiLCBbXHJcbiAgICAgICAgXCJBY3Rpb24uU2hvd0NhcmRcIlxyXG4gICAgXSk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShJbWFnZS51cmxQcm9wZXJ0eSlcclxuICAgIF0sIEltYWdlLnByb3RvdHlwZSwgXCJ1cmxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEltYWdlLmFsdFRleHRQcm9wZXJ0eSlcclxuICAgIF0sIEltYWdlLnByb3RvdHlwZSwgXCJhbHRUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShJbWFnZS5iYWNrZ3JvdW5kQ29sb3JQcm9wZXJ0eSlcclxuICAgIF0sIEltYWdlLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEltYWdlLnNpemVQcm9wZXJ0eSlcclxuICAgIF0sIEltYWdlLnByb3RvdHlwZSwgXCJzaXplXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShJbWFnZS5zdHlsZVByb3BlcnR5KVxyXG4gICAgXSwgSW1hZ2UucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShJbWFnZS5waXhlbFdpZHRoUHJvcGVydHkpXHJcbiAgICBdLCBJbWFnZS5wcm90b3R5cGUsIFwicGl4ZWxXaWR0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoSW1hZ2UucGl4ZWxIZWlnaHRQcm9wZXJ0eSlcclxuICAgIF0sIEltYWdlLnByb3RvdHlwZSwgXCJwaXhlbEhlaWdodFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoSW1hZ2Uuc2VsZWN0QWN0aW9uUHJvcGVydHkpXHJcbiAgICBdLCBJbWFnZS5wcm90b3R5cGUsIFwic2VsZWN0QWN0aW9uXCIsIHZvaWQgMCk7XHJcbiAgICByZXR1cm4gSW1hZ2U7XHJcbn0oQ2FyZEVsZW1lbnQpKTtcclxuZXhwb3J0cy5JbWFnZSA9IEltYWdlO1xyXG52YXIgQ2FyZEVsZW1lbnRDb250YWluZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ2FyZEVsZW1lbnRDb250YWluZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDYXJkRWxlbWVudENvbnRhaW5lcigpIHtcclxuICAgICAgICAvLyNyZWdpb24gU2NoZW1hXHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuYWxsb3dWZXJ0aWNhbE92ZXJmbG93ID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQ2FyZEVsZW1lbnRDb250YWluZXIucHJvdG90eXBlLnBvcHVsYXRlU2NoZW1hID0gZnVuY3Rpb24gKHNjaGVtYSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucG9wdWxhdGVTY2hlbWEuY2FsbCh0aGlzLCBzY2hlbWEpO1xyXG4gICAgICAgIGlmICghdGhpcy5pc1NlbGVjdGFibGUpIHtcclxuICAgICAgICAgICAgc2NoZW1hLnJlbW92ZShDYXJkRWxlbWVudENvbnRhaW5lci5zZWxlY3RBY3Rpb25Qcm9wZXJ0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgQ2FyZEVsZW1lbnRDb250YWluZXIucHJvdG90eXBlLmlzRWxlbWVudEFsbG93ZWQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhvc3RDb25maWcuc3VwcG9ydHNJbnRlcmFjdGl2aXR5IHx8ICFlbGVtZW50LmlzSW50ZXJhY3RpdmU7XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnRDb250YWluZXIucHJvdG90eXBlLmFwcGx5UGFkZGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmFwcGx5UGFkZGluZy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGh5c2ljYWxQYWRkaW5nID0gbmV3IHNoYXJlZF8xLlNwYWNpbmdEZWZpbml0aW9uKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0RWZmZWN0aXZlUGFkZGluZygpKSB7XHJcbiAgICAgICAgICAgIHBoeXNpY2FsUGFkZGluZyA9IHRoaXMuaG9zdENvbmZpZy5wYWRkaW5nRGVmaW5pdGlvblRvU3BhY2luZ0RlZmluaXRpb24odGhpcy5nZXRFZmZlY3RpdmVQYWRkaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudC5zdHlsZS5wYWRkaW5nVG9wID0gcGh5c2ljYWxQYWRkaW5nLnRvcCArIFwicHhcIjtcclxuICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBwaHlzaWNhbFBhZGRpbmcucmlnaHQgKyBcInB4XCI7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQuc3R5bGUucGFkZGluZ0JvdHRvbSA9IHBoeXNpY2FsUGFkZGluZy5ib3R0b20gKyBcInB4XCI7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSBwaHlzaWNhbFBhZGRpbmcubGVmdCArIFwicHhcIjtcclxuICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudC5zdHlsZS5tYXJnaW5SaWdodCA9IFwiMFwiO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50LnN0eWxlLm1hcmdpbkxlZnQgPSBcIjBcIjtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FyZEVsZW1lbnRDb250YWluZXIucHJvdG90eXBlLCBcImlzU2VsZWN0YWJsZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGtlcHQgYnV0IHJldHVybiBbXSB3aGVuIHJlbW92aW5nIENhcm91c2VsIGZyb20gY29kZVxyXG4gICAgQ2FyZEVsZW1lbnRDb250YWluZXIucHJvdG90eXBlLmZvcmJpZGRlbkNoaWxkRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50Q29udGFpbmVyLnByb3RvdHlwZS5yZWxlYXNlRE9NUmVzb3VyY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVsZWFzZURPTVJlc291cmNlcy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nZXRJdGVtQ291bnQoKTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0SXRlbUF0KGkpLnJlbGVhc2VET01SZXNvdXJjZXMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnRDb250YWluZXIucHJvdG90eXBlLmludGVybmFsVmFsaWRhdGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmludGVybmFsVmFsaWRhdGVQcm9wZXJ0aWVzLmNhbGwodGhpcywgY29udGV4dCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdldEl0ZW1Db3VudCgpOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW1BdChpKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmhvc3RDb25maWcuc3VwcG9ydHNJbnRlcmFjdGl2aXR5ICYmIGl0ZW0uaXNJbnRlcmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5hZGRGYWlsdXJlKHRoaXMsIEVudW1zLlZhbGlkYXRpb25FdmVudC5JbnRlcmFjdGl2aXR5Tm90QWxsb3dlZCwgc3RyaW5nc18xLlN0cmluZ3MuZXJyb3JzLmludGVyYWN0aXZpdHlOb3RBbGxvd2VkKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0VsZW1lbnRBbGxvd2VkKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFkZEZhaWx1cmUodGhpcywgRW51bXMuVmFsaWRhdGlvbkV2ZW50LkludGVyYWN0aXZpdHlOb3RBbGxvd2VkLCBzdHJpbmdzXzEuU3RyaW5ncy5lcnJvcnMuZWxlbWVudFR5cGVOb3RBbGxvd2VkKGl0ZW0uZ2V0SnNvblR5cGVOYW1lKCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpdGVtLmludGVybmFsVmFsaWRhdGVQcm9wZXJ0aWVzKGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fc2VsZWN0QWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdEFjdGlvbi5pbnRlcm5hbFZhbGlkYXRlUHJvcGVydGllcyhjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnRDb250YWluZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gX3N1cGVyLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICB2YXIgaG9zdENvbmZpZyA9IHRoaXMuaG9zdENvbmZpZztcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dWZXJ0aWNhbE92ZXJmbG93KSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLm92ZXJmbG93WCA9IFwiaGlkZGVuXCI7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9IFwiYXV0b1wiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2VsZWN0YWJsZSAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0QWN0aW9uICYmXHJcbiAgICAgICAgICAgICAgICBob3N0Q29uZmlnLnN1cHBvcnRzSW50ZXJhY3Rpdml0eSkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3NlbGVjdEFjdGlvbiAmJiBfdGhpcy5fc2VsZWN0QWN0aW9uLmlzRWZmZWN0aXZlbHlFbmFibGVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZWxlY3RBY3Rpb24uZXhlY3V0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9ua2V5cHJlc3MgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc2VsZWN0QWN0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZWxlY3RBY3Rpb24uaXNFZmZlY3RpdmVseUVuYWJsZWQoKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoZS5jb2RlID09PSBcIkVudGVyXCIgfHwgZS5jb2RlID09PSBcIlNwYWNlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVudGVyIG9yIHNwYWNlIHByZXNzZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZWxlY3RBY3Rpb24uZXhlY3V0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RBY3Rpb24uc2V0dXBFbGVtZW50Rm9yQWNjZXNzaWJpbGl0eShlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3RBY3Rpb24uaXNFZmZlY3RpdmVseUVuYWJsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1zZWxlY3RhYmxlXCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH07XHJcbiAgICBDYXJkRWxlbWVudENvbnRhaW5lci5wcm90b3R5cGUudXBkYXRlTGF5b3V0ID0gZnVuY3Rpb24gKHByb2Nlc3NDaGlsZHJlbikge1xyXG4gICAgICAgIGlmIChwcm9jZXNzQ2hpbGRyZW4gPT09IHZvaWQgMCkgeyBwcm9jZXNzQ2hpbGRyZW4gPSB0cnVlOyB9XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVMYXlvdXQuY2FsbCh0aGlzLCBwcm9jZXNzQ2hpbGRyZW4pO1xyXG4gICAgICAgIGlmIChwcm9jZXNzQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdldEl0ZW1Db3VudCgpOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0SXRlbUF0KGkpLnVwZGF0ZUxheW91dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhcmRFbGVtZW50Q29udGFpbmVyLnByb3RvdHlwZS5nZXRBbGxJbnB1dHMgPSBmdW5jdGlvbiAocHJvY2Vzc0FjdGlvbnMpIHtcclxuICAgICAgICBpZiAocHJvY2Vzc0FjdGlvbnMgPT09IHZvaWQgMCkgeyBwcm9jZXNzQWN0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdldEl0ZW1Db3VudCgpOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCB0aGlzLmdldEl0ZW1BdChpKS5nZXRBbGxJbnB1dHMocHJvY2Vzc0FjdGlvbnMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBDYXJkRWxlbWVudENvbnRhaW5lci5wcm90b3R5cGUuZ2V0QWxsQWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS5nZXRBbGxBY3Rpb25zLmNhbGwodGhpcyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdldEl0ZW1Db3VudCgpOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCB0aGlzLmdldEl0ZW1BdChpKS5nZXRBbGxBY3Rpb25zKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fc2VsZWN0QWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuX3NlbGVjdEFjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnRDb250YWluZXIucHJvdG90eXBlLmdldFJlc291cmNlSW5mb3JtYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nZXRJdGVtQ291bnQoKTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgdGhpcy5nZXRJdGVtQXQoaSkuZ2V0UmVzb3VyY2VJbmZvcm1hdGlvbigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBDYXJkRWxlbWVudENvbnRhaW5lci5wcm90b3R5cGUuZ2V0RWxlbWVudEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS5nZXRFbGVtZW50QnlJZC5jYWxsKHRoaXMsIGlkKTtcclxuICAgICAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ2V0SXRlbUNvdW50KCk7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5nZXRJdGVtQXQoaSkuZ2V0RWxlbWVudEJ5SWQoaWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5oZXJpdGRvY1xyXG4gICAgICovXHJcbiAgICBDYXJkRWxlbWVudENvbnRhaW5lci5wcm90b3R5cGUuZmluZERPTU5vZGVPd25lciA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdldEl0ZW1Db3VudCgpOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gcmVjdXIgdGhyb3VnaCBjaGlsZCBlbGVtZW50c1xyXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLmdldEl0ZW1BdChpKS5maW5kRE9NTm9kZU93bmVyKG5vZGUpO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIG5vdCBmb3VuZCBpbiBjaGlsZHJlbiwgY2hlY2sgdGhlIGFjdGlvbnNcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ2V0QWN0aW9uQ291bnQoKTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IChfYSA9IHRoaXMuZ2V0QWN0aW9uQXQoaSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maW5kRE9NTm9kZU93bmVyKG5vZGUpO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIG5vdCBmb3VuZCBpbiBjaGlsZHJlbiBvciBhY3Rpb25zLCBkZWZlciB0byBwYXJlbnQgaW1wbGVtZW50YXRpb25cclxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5maW5kRE9NTm9kZU93bmVyLmNhbGwodGhpcywgbm9kZSk7XHJcbiAgICB9O1xyXG4gICAgQ2FyZEVsZW1lbnRDb250YWluZXIuc2VsZWN0QWN0aW9uUHJvcGVydHkgPSBuZXcgQWN0aW9uUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzEsIFwic2VsZWN0QWN0aW9uXCIsIFtcclxuICAgICAgICBcIkFjdGlvbi5TaG93Q2FyZFwiXHJcbiAgICBdKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKENhcmRFbGVtZW50Q29udGFpbmVyLnNlbGVjdEFjdGlvblByb3BlcnR5KVxyXG4gICAgXSwgQ2FyZEVsZW1lbnRDb250YWluZXIucHJvdG90eXBlLCBcIl9zZWxlY3RBY3Rpb25cIiwgdm9pZCAwKTtcclxuICAgIHJldHVybiBDYXJkRWxlbWVudENvbnRhaW5lcjtcclxufShDYXJkRWxlbWVudCkpO1xyXG5leHBvcnRzLkNhcmRFbGVtZW50Q29udGFpbmVyID0gQ2FyZEVsZW1lbnRDb250YWluZXI7XHJcbnZhciBJbWFnZVNldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhJbWFnZVNldCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEltYWdlU2V0KCkge1xyXG4gICAgICAgIC8vI3JlZ2lvbiBTY2hlbWFcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5faW1hZ2VzID0gW107XHJcbiAgICAgICAgX3RoaXMuaW1hZ2VTaXplID0gRW51bXMuSW1hZ2VTaXplLk1lZGl1bTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICAgIEltYWdlU2V0LnByb3RvdHlwZS5pbnRlcm5hbFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAodGhpcy5faW1hZ2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xyXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmZsZXhXcmFwID0gXCJ3cmFwXCI7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9pbWFnZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuaW1hZ2VTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBFbnVtcy5JbWFnZVNpemUuU21hbGw6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLnNpemUgPSBFbnVtcy5TaXplLlNtYWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEVudW1zLkltYWdlU2l6ZS5MYXJnZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uuc2l6ZSA9IEVudW1zLlNpemUuTGFyZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLnNpemUgPSBFbnVtcy5TaXplLk1lZGl1bTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbWFnZS5tYXhIZWlnaHQgPSB0aGlzLmhvc3RDb25maWcuaW1hZ2VTZXQubWF4SW1hZ2VIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVuZGVyZWRJbWFnZSA9IGltYWdlLnJlbmRlcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlbmRlcmVkSW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZEltYWdlLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1mbGV4XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRJbWFnZS5zdHlsZS5tYXJnaW4gPSBcIjBweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkSW1hZ2Uuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjEwcHhcIjtcclxuICAgICAgICAgICAgICAgICAgICBVdGlscy5hcHBlbmRDaGlsZChlbGVtZW50LCByZW5kZXJlZEltYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH07XHJcbiAgICBJbWFnZVNldC5wcm90b3R5cGUuZ2V0SXRlbUNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZXMubGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIEltYWdlU2V0LnByb3RvdHlwZS5nZXRJdGVtQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2VzW2luZGV4XTtcclxuICAgIH07XHJcbiAgICBJbWFnZVNldC5wcm90b3R5cGUuZ2V0Rmlyc3RWaXNpYmxlUmVuZGVyZWRJdGVtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZXMgJiYgdGhpcy5faW1hZ2VzLmxlbmd0aCA+IDAgPyB0aGlzLl9pbWFnZXNbMF0gOiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgSW1hZ2VTZXQucHJvdG90eXBlLmdldExhc3RWaXNpYmxlUmVuZGVyZWRJdGVtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZXMgJiYgdGhpcy5faW1hZ2VzLmxlbmd0aCA+IDBcclxuICAgICAgICAgICAgPyB0aGlzLl9pbWFnZXNbdGhpcy5faW1hZ2VzLmxlbmd0aCAtIDFdXHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIEltYWdlU2V0LnByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEltYWdlKSB7XHJcbiAgICAgICAgICAgIHZhciBpdGVtSW5kZXggPSB0aGlzLl9pbWFnZXMuaW5kZXhPZihpdGVtKTtcclxuICAgICAgICAgICAgaWYgKGl0ZW1JbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZXMuc3BsaWNlKGl0ZW1JbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICBpdGVtLnNldFBhcmVudCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYXlvdXQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBJbWFnZVNldC5wcm90b3R5cGUuZ2V0SnNvblR5cGVOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcIkltYWdlU2V0XCI7XHJcbiAgICB9O1xyXG4gICAgSW1hZ2VTZXQucHJvdG90eXBlLmFkZEltYWdlID0gZnVuY3Rpb24gKGltYWdlKSB7XHJcbiAgICAgICAgaWYgKCFpbWFnZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5faW1hZ2VzLnB1c2goaW1hZ2UpO1xyXG4gICAgICAgICAgICBpbWFnZS5zZXRQYXJlbnQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGltYWdlIGFscmVhZHkgYmVsb25ncyB0byBhbm90aGVyIEltYWdlU2V0XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbWFnZVNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChjYXJkRWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiBjYXJkRWxlbWVudCBpbnN0YW5jZW9mIEltYWdlID8gdGhpcy5faW1hZ2VzLmluZGV4T2YoY2FyZEVsZW1lbnQpIDogLTE7XHJcbiAgICB9O1xyXG4gICAgSW1hZ2VTZXQuaW1hZ2VzUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlNlcmlhbGl6YWJsZU9iamVjdENvbGxlY3Rpb25Qcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCwgXCJpbWFnZXNcIiwgSW1hZ2UsIGZ1bmN0aW9uIChzZW5kZXIsIGl0ZW0pIHtcclxuICAgICAgICBpdGVtLnNldFBhcmVudChzZW5kZXIpO1xyXG4gICAgfSk7XHJcbiAgICBJbWFnZVNldC5pbWFnZVNpemVQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuRW51bVByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcImltYWdlU2l6ZVwiLCBFbnVtcy5JbWFnZVNpemUsIEVudW1zLkltYWdlU2l6ZS5NZWRpdW0pO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoSW1hZ2VTZXQuaW1hZ2VzUHJvcGVydHkpXHJcbiAgICBdLCBJbWFnZVNldC5wcm90b3R5cGUsIFwiX2ltYWdlc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoSW1hZ2VTZXQuaW1hZ2VTaXplUHJvcGVydHkpXHJcbiAgICBdLCBJbWFnZVNldC5wcm90b3R5cGUsIFwiaW1hZ2VTaXplXCIsIHZvaWQgMCk7XHJcbiAgICByZXR1cm4gSW1hZ2VTZXQ7XHJcbn0oQ2FyZEVsZW1lbnRDb250YWluZXIpKTtcclxuZXhwb3J0cy5JbWFnZVNldCA9IEltYWdlU2V0O1xyXG52YXIgQ29udGVudFNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb250ZW50U291cmNlLCBfc3VwZXIpO1xyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgICBmdW5jdGlvbiBDb250ZW50U291cmNlKHVybCwgbWltZVR5cGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnVybCA9IHVybDtcclxuICAgICAgICBfdGhpcy5taW1lVHlwZSA9IG1pbWVUeXBlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIENvbnRlbnRTb3VyY2UucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWltZVR5cGUgJiYgdGhpcy51cmwgPyB0cnVlIDogZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLy8jcmVnaW9uIFNjaGVtYVxyXG4gICAgQ29udGVudFNvdXJjZS5taW1lVHlwZVByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMSwgXCJtaW1lVHlwZVwiKTtcclxuICAgIENvbnRlbnRTb3VyY2UudXJsUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8xLCBcInVybFwiKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKENvbnRlbnRTb3VyY2UubWltZVR5cGVQcm9wZXJ0eSlcclxuICAgIF0sIENvbnRlbnRTb3VyY2UucHJvdG90eXBlLCBcIm1pbWVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShDb250ZW50U291cmNlLnVybFByb3BlcnR5KVxyXG4gICAgXSwgQ29udGVudFNvdXJjZS5wcm90b3R5cGUsIFwidXJsXCIsIHZvaWQgMCk7XHJcbiAgICByZXR1cm4gQ29udGVudFNvdXJjZTtcclxufShzZXJpYWxpemF0aW9uXzEuU2VyaWFsaXphYmxlT2JqZWN0KSk7XHJcbmV4cG9ydHMuQ29udGVudFNvdXJjZSA9IENvbnRlbnRTb3VyY2U7XHJcbnZhciBDYXB0aW9uU291cmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENhcHRpb25Tb3VyY2UsIF9zdXBlcik7XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICAgIGZ1bmN0aW9uIENhcHRpb25Tb3VyY2UodXJsLCBtaW1lVHlwZSwgbGFiZWwpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB1cmwsIG1pbWVUeXBlKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmxhYmVsID0gbGFiZWw7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQ2FwdGlvblNvdXJjZS5wcm90b3R5cGUuZ2V0U2NoZW1hS2V5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcIkNhcHRpb25Tb3VyY2VcIjtcclxuICAgIH07XHJcbiAgICBDYXB0aW9uU291cmNlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRyYWNrXCIpO1xyXG4gICAgICAgICAgICByZXN1bHQuc3JjID0gdGhpcy51cmw7XHJcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0gXCJjYXB0aW9uc1wiO1xyXG4gICAgICAgICAgICByZXN1bHQubGFiZWwgPSB0aGlzLmxhYmVsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIC8vI3JlZ2lvbiBTY2hlbWFcclxuICAgIENhcHRpb25Tb3VyY2UubGFiZWxQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuU3RyaW5nUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzYsIFwibGFiZWxcIik7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShDYXB0aW9uU291cmNlLmxhYmVsUHJvcGVydHkpXHJcbiAgICBdLCBDYXB0aW9uU291cmNlLnByb3RvdHlwZSwgXCJsYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgcmV0dXJuIENhcHRpb25Tb3VyY2U7XHJcbn0oQ29udGVudFNvdXJjZSkpO1xyXG5leHBvcnRzLkNhcHRpb25Tb3VyY2UgPSBDYXB0aW9uU291cmNlO1xyXG52YXIgTWVkaWFTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWVkaWFTb3VyY2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNZWRpYVNvdXJjZSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBNZWRpYVNvdXJjZS5wcm90b3R5cGUuZ2V0U2NoZW1hS2V5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcIk1lZGlhU291cmNlXCI7XHJcbiAgICB9O1xyXG4gICAgTWVkaWFTb3VyY2UucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic291cmNlXCIpO1xyXG4gICAgICAgICAgICByZXN1bHQuc3JjID0gdGhpcy51cmw7XHJcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gdGhpcy5taW1lVHlwZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTWVkaWFTb3VyY2U7XHJcbn0oQ29udGVudFNvdXJjZSkpO1xyXG5leHBvcnRzLk1lZGlhU291cmNlID0gTWVkaWFTb3VyY2U7XHJcbnZhciBNZWRpYVBsYXllciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1lZGlhUGxheWVyKCkge1xyXG4gICAgfVxyXG4gICAgTWVkaWFQbGF5ZXIucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpbiBiYXNlIGltcGxlbWVudGF0aW9uXHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lZGlhUGxheWVyLnByb3RvdHlwZSwgXCJwb3N0ZXJVcmxcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9zdGVyVXJsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fcG9zdGVyVXJsID0gdmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lZGlhUGxheWVyLnByb3RvdHlwZSwgXCJzZWxlY3RlZE1lZGlhVHlwZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIE1lZGlhUGxheWVyO1xyXG59KCkpO1xyXG5leHBvcnRzLk1lZGlhUGxheWVyID0gTWVkaWFQbGF5ZXI7XHJcbnZhciBIVE1MNU1lZGlhUGxheWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEhUTUw1TWVkaWFQbGF5ZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBIVE1MNU1lZGlhUGxheWVyKG93bmVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5vd25lciA9IG93bmVyO1xyXG4gICAgICAgIF90aGlzLl9zZWxlY3RlZFNvdXJjZXMgPSBbXTtcclxuICAgICAgICBfdGhpcy5fY2FwdGlvblNvdXJjZXMgPSBbXTtcclxuICAgICAgICBfdGhpcy5wcm9jZXNzU291cmNlcygpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEhUTUw1TWVkaWFQbGF5ZXIucHJvdG90eXBlLnByb2Nlc3NTb3VyY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLl9zZWxlY3RlZFNvdXJjZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9jYXB0aW9uU291cmNlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3NlbGVjdGVkTWVkaWFUeXBlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2IgPSB0aGlzLm93bmVyLnNvdXJjZXM7IF9pIDwgX2IubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBfYltfaV07XHJcbiAgICAgICAgICAgIHZhciBtaW1lQ29tcG9uZW50cyA9IHNvdXJjZS5taW1lVHlwZSA/IHNvdXJjZS5taW1lVHlwZS5zcGxpdChcIi9cIikgOiBbXTtcclxuICAgICAgICAgICAgaWYgKG1pbWVDb21wb25lbnRzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zZWxlY3RlZE1lZGlhVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IEhUTUw1TWVkaWFQbGF5ZXIuc3VwcG9ydGVkTWVkaWFUeXBlcy5pbmRleE9mKG1pbWVDb21wb25lbnRzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZE1lZGlhVHlwZSA9IEhUTUw1TWVkaWFQbGF5ZXIuc3VwcG9ydGVkTWVkaWFUeXBlc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1pbWVDb21wb25lbnRzWzBdID09PSB0aGlzLl9zZWxlY3RlZE1lZGlhVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkU291cmNlcy5wdXNoKHNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgKF9hID0gdGhpcy5fY2FwdGlvblNvdXJjZXMpLnB1c2guYXBwbHkoX2EsIHRoaXMub3duZXIuY2FwdGlvblNvdXJjZXMpO1xyXG4gICAgfTtcclxuICAgIEhUTUw1TWVkaWFQbGF5ZXIucHJvdG90eXBlLmNhblBsYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkU291cmNlcy5sZW5ndGggPiAwO1xyXG4gICAgfTtcclxuICAgIEhUTUw1TWVkaWFQbGF5ZXIucHJvdG90eXBlLmZldGNoVmlkZW9EZXRhaWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIVE1MNU1lZGlhUGxheWVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkTWVkaWFUeXBlID09PSBcInZpZGVvXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWVkaWFFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbWVkaWFFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImF1ZGlvXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9tZWRpYUVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0aGlzLm93bmVyLmFsdFRleHQgPyB0aGlzLm93bmVyLmFsdFRleHQgOiBzdHJpbmdzXzEuU3RyaW5ncy5kZWZhdWx0cy5tZWRpYVBsYXllckFyaWFMYWJlbCgpKTtcclxuICAgICAgICB0aGlzLl9tZWRpYUVsZW1lbnQuc2V0QXR0cmlidXRlKFwid2Via2l0LXBsYXlzaW5saW5lXCIsIFwiXCIpO1xyXG4gICAgICAgIHRoaXMuX21lZGlhRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJwbGF5c2lubGluZVwiLCBcIlwiKTtcclxuICAgICAgICAvLyBXZSBlbmFibGUgY3Jvc3NvcmlnaW4gZm9yIGNhc2VzIHdoZXJlIHRoZSBjYXB0aW9uIGZpbGUgaGFzIGEgZGlmZmVyZW50IGRvbWFpbiB0aGFuXHJcbiAgICAgICAgLy8gdGhlIHZpZGVvIGZpbGUuIElmIHRoZSBjYXB0aW9uIGZpbGUgbGl2ZXMgaW4gYSBkaWZmZXJlbnQgZG9tYWluIHRoYW4gdGhlIHZpZGVvIGZpbGVcclxuICAgICAgICAvLyBhbmQgY3Jvc3NvcmlnaW4gaXMgbm90IHNldCwgdGhlbiB0aGUgY2FwdGlvbiBmaWxlIHdpbGwgZmFpbCB0byBsb2FkLlxyXG4gICAgICAgIHRoaXMuX21lZGlhRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjcm9zc29yaWdpblwiLCBcIlwiKTtcclxuICAgICAgICB0aGlzLl9tZWRpYUVsZW1lbnQuYXV0b3BsYXkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX21lZGlhRWxlbWVudC5jb250cm9scyA9IHRydWU7XHJcbiAgICAgICAgaWYgKFV0aWxzLmlzTW9iaWxlT1MoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tZWRpYUVsZW1lbnQubXV0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9tZWRpYUVsZW1lbnQucHJlbG9hZCA9IFwibm9uZVwiO1xyXG4gICAgICAgIHRoaXMuX21lZGlhRWxlbWVudC5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLm93bmVyLnNvdXJjZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIHZhciByZW5kZXJlZFNvdXJjZSA9IHNvdXJjZS5yZW5kZXIoKTtcclxuICAgICAgICAgICAgVXRpbHMuYXBwZW5kQ2hpbGQodGhpcy5fbWVkaWFFbGVtZW50LCByZW5kZXJlZFNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSB0aGlzLm93bmVyLmNhcHRpb25Tb3VyY2VzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICB2YXIgY2FwdGlvblNvdXJjZSA9IF9jW19iXTtcclxuICAgICAgICAgICAgaWYgKGNhcHRpb25Tb3VyY2UubWltZVR5cGUgPT0gXCJ2dHRcIikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbmRlcmVkQ2FwdGlvblNvdXJjZSA9IGNhcHRpb25Tb3VyY2UucmVuZGVyKCk7XHJcbiAgICAgICAgICAgICAgICBVdGlscy5hcHBlbmRDaGlsZCh0aGlzLl9tZWRpYUVsZW1lbnQsIHJlbmRlcmVkQ2FwdGlvblNvdXJjZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhRWxlbWVudDtcclxuICAgIH07XHJcbiAgICBIVE1MNU1lZGlhUGxheWVyLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9tZWRpYUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWVkaWFFbGVtZW50LnBsYXkoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUw1TWVkaWFQbGF5ZXIucHJvdG90eXBlLCBcInNlbGVjdGVkTWVkaWFUeXBlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkTWVkaWFUeXBlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEhUTUw1TWVkaWFQbGF5ZXIuc3VwcG9ydGVkTWVkaWFUeXBlcyA9IFtcImF1ZGlvXCIsIFwidmlkZW9cIl07XHJcbiAgICByZXR1cm4gSFRNTDVNZWRpYVBsYXllcjtcclxufShNZWRpYVBsYXllcikpO1xyXG5leHBvcnRzLkhUTUw1TWVkaWFQbGF5ZXIgPSBIVE1MNU1lZGlhUGxheWVyO1xyXG52YXIgQ3VzdG9tTWVkaWFQbGF5ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ3VzdG9tTWVkaWFQbGF5ZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDdXN0b21NZWRpYVBsYXllcihtYXRjaGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQ3VzdG9tTWVkaWFQbGF5ZXI7XHJcbn0oTWVkaWFQbGF5ZXIpKTtcclxuZXhwb3J0cy5DdXN0b21NZWRpYVBsYXllciA9IEN1c3RvbU1lZGlhUGxheWVyO1xyXG52YXIgSUZyYW1lTWVkaWFNZWRpYVBsYXllciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhJRnJhbWVNZWRpYU1lZGlhUGxheWVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSUZyYW1lTWVkaWFNZWRpYVBsYXllcihtYXRjaGVzLCBpRnJhbWVUaXRsZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1hdGNoZXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuaUZyYW1lVGl0bGUgPSBpRnJhbWVUaXRsZTtcclxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPj0gMikge1xyXG4gICAgICAgICAgICBfdGhpcy5fdmlkZW9JZCA9IG1hdGNoZXNbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIElGcmFtZU1lZGlhTWVkaWFQbGF5ZXIucHJvdG90eXBlLmNhblBsYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZGVvSWQgIT09IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBJRnJhbWVNZWRpYU1lZGlhUGxheWVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xyXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xyXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBcIjBcIjtcclxuICAgICAgICBjb250YWluZXIuc3R5bGUucGFkZGluZ0JvdHRvbSA9IFwiNTYuMjUlXCI7XHJcbiAgICAgICAgdmFyIGlGcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XHJcbiAgICAgICAgaUZyYW1lLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG4gICAgICAgIGlGcmFtZS5zdHlsZS50b3AgPSBcIjBcIjtcclxuICAgICAgICBpRnJhbWUuc3R5bGUubGVmdCA9IFwiMFwiO1xyXG4gICAgICAgIGlGcmFtZS5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xyXG4gICAgICAgIGlGcmFtZS5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcclxuICAgICAgICBpRnJhbWUuc3JjID0gdGhpcy5nZXRFbWJlZFZpZGVvVXJsKCk7XHJcbiAgICAgICAgaUZyYW1lLmZyYW1lQm9yZGVyID0gXCIwXCI7XHJcbiAgICAgICAgaWYgKHRoaXMuaUZyYW1lVGl0bGUpIHtcclxuICAgICAgICAgICAgaUZyYW1lLnRpdGxlID0gdGhpcy5pRnJhbWVUaXRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaUZyYW1lLmFsbG93ID1cclxuICAgICAgICAgICAgXCJhY2NlbGVyb21ldGVyOyBhdXRvcGxheTsgY2xpcGJvYXJkLXdyaXRlOyBlbmNyeXB0ZWQtbWVkaWE7IGd5cm9zY29wZTsgcGljdHVyZS1pbi1waWN0dXJlXCI7XHJcbiAgICAgICAgaUZyYW1lLmFsbG93RnVsbHNjcmVlbiA9IHRydWU7XHJcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGlGcmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSUZyYW1lTWVkaWFNZWRpYVBsYXllci5wcm90b3R5cGUsIFwidmlkZW9JZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWRlb0lkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBJRnJhbWVNZWRpYU1lZGlhUGxheWVyO1xyXG59KEN1c3RvbU1lZGlhUGxheWVyKSk7XHJcbmV4cG9ydHMuSUZyYW1lTWVkaWFNZWRpYVBsYXllciA9IElGcmFtZU1lZGlhTWVkaWFQbGF5ZXI7XHJcbnZhciBWaW1lb1BsYXllciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhWaW1lb1BsYXllciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFZpbWVvUGxheWVyKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFZpbWVvUGxheWVyLnByb3RvdHlwZS5mZXRjaFZpZGVvRGV0YWlscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBvRW1iZWRVcmwsIHJlc3BvbnNlLCBqc29uO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvRW1iZWRVcmwgPSBcImh0dHBzOi8vdmltZW8uY29tL2FwaS9vZW1iZWQuanNvbj91cmw9XCIuY29uY2F0KHRoaXMuZ2V0RW1iZWRWaWRlb1VybCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2gob0VtYmVkVXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc3BvbnNlLmpzb24oKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc3RlclVybCA9IGpzb25bXCJ0aHVtYm5haWxfdXJsXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFZpbWVvUGxheWVyLnByb3RvdHlwZS5nZXRFbWJlZFZpZGVvVXJsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcImh0dHBzOi8vcGxheWVyLnZpbWVvLmNvbS92aWRlby9cIi5jb25jYXQodGhpcy52aWRlb0lkLCBcIj9hdXRvcGxheT0xXCIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBWaW1lb1BsYXllcjtcclxufShJRnJhbWVNZWRpYU1lZGlhUGxheWVyKSk7XHJcbmV4cG9ydHMuVmltZW9QbGF5ZXIgPSBWaW1lb1BsYXllcjtcclxudmFyIERhaWx5bW90aW9uUGxheWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKERhaWx5bW90aW9uUGxheWVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGFpbHltb3Rpb25QbGF5ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgRGFpbHltb3Rpb25QbGF5ZXIucHJvdG90eXBlLmZldGNoVmlkZW9EZXRhaWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFwaVVybCwgcmVzcG9uc2UsIGpzb247XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaVVybCA9IFwiaHR0cHM6Ly9hcGkuZGFpbHltb3Rpb24uY29tL3ZpZGVvL1wiLmNvbmNhdCh0aGlzLnZpZGVvSWQsIFwiP2ZpZWxkcz10aHVtYm5haWxfNzIwX3VybFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2goYXBpVXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc3BvbnNlLmpzb24oKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc3RlclVybCA9IGpzb25bXCJ0aHVtYm5haWxfNzIwX3VybFwiXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEYWlseW1vdGlvblBsYXllci5wcm90b3R5cGUuZ2V0RW1iZWRWaWRlb1VybCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXCJodHRwczovL3d3dy5kYWlseW1vdGlvbi5jb20vZW1iZWQvdmlkZW8vXCIuY29uY2F0KHRoaXMudmlkZW9JZCwgXCI/YXV0b3BsYXk9MVwiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGFpbHltb3Rpb25QbGF5ZXI7XHJcbn0oSUZyYW1lTWVkaWFNZWRpYVBsYXllcikpO1xyXG5leHBvcnRzLkRhaWx5bW90aW9uUGxheWVyID0gRGFpbHltb3Rpb25QbGF5ZXI7XHJcbnZhciBZb3VUdWJlUGxheWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFlvdVR1YmVQbGF5ZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBZb3VUdWJlUGxheWVyKG1hdGNoZXMsIGlGcmFtZVRpdGxlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWF0Y2hlcywgaUZyYW1lVGl0bGUpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuaUZyYW1lVGl0bGUgPSBpRnJhbWVUaXRsZTtcclxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPj0gMyAmJiBtYXRjaGVzWzJdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3N0YXJ0VGltZUluZGV4ID0gcGFyc2VJbnQobWF0Y2hlc1syXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFlvdVR1YmVQbGF5ZXIucHJvdG90eXBlLmZldGNoVmlkZW9EZXRhaWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3N0ZXJVcmwgPSB0aGlzLnZpZGVvSWRcclxuICAgICAgICAgICAgICAgICAgICA/IFwiaHR0cHM6Ly9pbWcueW91dHViZS5jb20vdmkvXCIuY29uY2F0KHRoaXMudmlkZW9JZCwgXCIvbWF4cmVzZGVmYXVsdC5qcGdcIilcclxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgWW91VHViZVBsYXllci5wcm90b3R5cGUuZ2V0RW1iZWRWaWRlb1VybCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdXJsID0gXCJodHRwczovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC9cIi5jb25jYXQodGhpcy52aWRlb0lkLCBcIj9hdXRvcGxheT0xXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLl9zdGFydFRpbWVJbmRleCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHVybCArPSBcIiZzdGFydD1cIi5jb25jYXQodGhpcy5fc3RhcnRUaW1lSW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBZb3VUdWJlUGxheWVyO1xyXG59KElGcmFtZU1lZGlhTWVkaWFQbGF5ZXIpKTtcclxuZXhwb3J0cy5Zb3VUdWJlUGxheWVyID0gWW91VHViZVBsYXllcjtcclxudmFyIE1lZGlhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1lZGlhLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWVkaWEoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuc291cmNlcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLmNhcHRpb25Tb3VyY2VzID0gW107XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTWVkaWEucHJvdG90eXBlLmNyZWF0ZU1lZGlhUGxheWVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBNZWRpYS5jdXN0b21NZWRpYVBsYXllcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm92aWRlciA9IF9hW19pXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMuc291cmNlczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBfY1tfYl07XHJcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gMCwgX2YgPSBwcm92aWRlci51cmxQYXR0ZXJuczsgX2QgPCBfZi5sZW5ndGg7IF9kKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBfZltfZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gcGF0dGVybi5leGVjKHNvdXJjZS51cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmNyZWF0ZU1lZGlhUGxheWVyKG1hdGNoZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgSFRNTDVNZWRpYVBsYXllcih0aGlzKTtcclxuICAgIH07XHJcbiAgICBNZWRpYS5wcm90b3R5cGUuaGFuZGxlUGxheUJ1dHRvbkludm9rZSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhvc3RDb25maWcubWVkaWEuYWxsb3dJbmxpbmVQbGF5YmFjaykge1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtZWRpYVBsYXllckVsZW1lbnQgPSB0aGlzLl9tZWRpYVBsYXllci5yZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgIGNsZWFyRWxlbWVudCh0aGlzLnJlbmRlcmVkRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudC5hcHBlbmRDaGlsZChtZWRpYVBsYXllckVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIucGxheSgpO1xyXG4gICAgICAgICAgICAgICAgbWVkaWFQbGF5ZXJFbGVtZW50LmZvY3VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChNZWRpYS5vblBsYXkpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgTWVkaWEub25QbGF5KHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1lZGlhLnByb3RvdHlwZS5kaXNwbGF5UG9zdGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHBsYXlCdXR0b25BcnJvd1dpZHRoLCBwbGF5QnV0dG9uQXJyb3dIZWlnaHQsIHBvc3RlclJvb3RFbGVtZW50XzEsIHBvc3RlclVybCwgcG9zdGVySW1hZ2VFbGVtZW50XzEsIHBsYXlCdXR0b25PdXRlckVsZW1lbnQsIHBsYXlCdXR0b25Jbm5lckVsZW1lbnQsIHBsYXlCdXR0b25Db250YWluZXI7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVkRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBsYXlCdXR0b25BcnJvd1dpZHRoID0gMTI7XHJcbiAgICAgICAgICAgICAgICAgICAgcGxheUJ1dHRvbkFycm93SGVpZ2h0ID0gMTU7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zdGVyUm9vdEVsZW1lbnRfMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zdGVyUm9vdEVsZW1lbnRfMS5jbGFzc05hbWUgPSB0aGlzLmhvc3RDb25maWcubWFrZUNzc0NsYXNzTmFtZShcImFjLW1lZGlhLXBvc3RlclwiKTtcclxuICAgICAgICAgICAgICAgICAgICBwb3N0ZXJSb290RWxlbWVudF8xLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJjb250ZW50aW5mb1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBwb3N0ZXJSb290RWxlbWVudF8xLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy5hbHRUZXh0ID8gdGhpcy5hbHRUZXh0IDogc3RyaW5nc18xLlN0cmluZ3MuZGVmYXVsdHMubWVkaWFQbGF5ZXJBcmlhTGFiZWwoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zdGVyUm9vdEVsZW1lbnRfMS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcclxuICAgICAgICAgICAgICAgICAgICBwb3N0ZXJSb290RWxlbWVudF8xLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcclxuICAgICAgICAgICAgICAgICAgICBwb3N0ZXJVcmwgPSB0aGlzLnBvc3RlciA/IHRoaXMucG9zdGVyIDogdGhpcy5fbWVkaWFQbGF5ZXIucG9zdGVyVXJsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcG9zdGVyVXJsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RlclVybCA9IHRoaXMuaG9zdENvbmZpZy5tZWRpYS5kZWZhdWx0UG9zdGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zdGVyVXJsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RlckltYWdlRWxlbWVudF8xID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdGVySW1hZ2VFbGVtZW50XzEuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdGVySW1hZ2VFbGVtZW50XzEuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RlckltYWdlRWxlbWVudF8xLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RlckltYWdlRWxlbWVudF8xLm9uZXJyb3IgPSBmdW5jdGlvbiAoX2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3N0ZXJJbWFnZUVsZW1lbnRfMS5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdGVySW1hZ2VFbGVtZW50XzEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwb3N0ZXJJbWFnZUVsZW1lbnRfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0ZXJSb290RWxlbWVudF8xLmNsYXNzTGlzdC5hZGQoXCJlbXB0eVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RlclJvb3RFbGVtZW50XzEuc3R5bGUubWluSGVpZ2h0ID0gXCIxNTBweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0ZXJJbWFnZUVsZW1lbnRfMS5zcmMgPSBwb3N0ZXJVcmw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RlclJvb3RFbGVtZW50XzEuYXBwZW5kQ2hpbGQocG9zdGVySW1hZ2VFbGVtZW50XzEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdGVyUm9vdEVsZW1lbnRfMS5jbGFzc0xpc3QuYWRkKFwiZW1wdHlcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RlclJvb3RFbGVtZW50XzEuc3R5bGUubWluSGVpZ2h0ID0gXCIxNTBweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ob3N0Q29uZmlnLnN1cHBvcnRzSW50ZXJhY3Rpdml0eSAmJiB0aGlzLl9tZWRpYVBsYXllci5jYW5QbGF5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheUJ1dHRvbk91dGVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXlCdXR0b25PdXRlckVsZW1lbnQudGFiSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5QnV0dG9uT3V0ZXJFbGVtZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJidXR0b25cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXlCdXR0b25PdXRlckVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBzdHJpbmdzXzEuU3RyaW5ncy5kZWZhdWx0cy5tZWRpYVBsYXllclBsYXlNZWRpYSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheUJ1dHRvbk91dGVyRWxlbWVudC5jbGFzc05hbWUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1tZWRpYS1wbGF5QnV0dG9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5QnV0dG9uT3V0ZXJFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheUJ1dHRvbk91dGVyRWxlbWVudC5zdHlsZS5hbGlnbkl0ZW1zID0gXCJjZW50ZXJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheUJ1dHRvbk91dGVyRWxlbWVudC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXlCdXR0b25PdXRlckVsZW1lbnQub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVQbGF5QnV0dG9uSW52b2tlKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5QnV0dG9uT3V0ZXJFbGVtZW50Lm9ua2V5cHJlc3MgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gXCJFbnRlclwiIHx8IGUuY29kZSA9PT0gXCJTcGFjZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BhY2Ugb3IgZW50ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVQbGF5QnV0dG9uSW52b2tlKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5QnV0dG9uSW5uZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheUJ1dHRvbklubmVyRWxlbWVudC5jbGFzc05hbWUgPSB0aGlzLmhvc3RDb25maWcubWFrZUNzc0NsYXNzTmFtZShcImFjLW1lZGlhLXBsYXlCdXR0b24tYXJyb3dcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXlCdXR0b25Jbm5lckVsZW1lbnQuc3R5bGUud2lkdGggPSBwbGF5QnV0dG9uQXJyb3dXaWR0aCArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheUJ1dHRvbklubmVyRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBwbGF5QnV0dG9uQXJyb3dIZWlnaHQgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXlCdXR0b25Jbm5lckVsZW1lbnQuc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBwbGF5QnV0dG9uQXJyb3dIZWlnaHQgLyAyICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5QnV0dG9uSW5uZXJFbGVtZW50LnN0eWxlLmJvcmRlckJvdHRvbVdpZHRoID0gcGxheUJ1dHRvbkFycm93SGVpZ2h0IC8gMiArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheUJ1dHRvbklubmVyRWxlbWVudC5zdHlsZS5ib3JkZXJMZWZ0V2lkdGggPSBwbGF5QnV0dG9uQXJyb3dXaWR0aCArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheUJ1dHRvbklubmVyRWxlbWVudC5zdHlsZS5ib3JkZXJSaWdodFdpZHRoID0gXCIwXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXlCdXR0b25Jbm5lckVsZW1lbnQuc3R5bGUuYm9yZGVyU3R5bGUgPSBcInNvbGlkXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXlCdXR0b25Jbm5lckVsZW1lbnQuc3R5bGUuYm9yZGVyVG9wQ29sb3IgPSBcInRyYW5zcGFyZW50XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXlCdXR0b25Jbm5lckVsZW1lbnQuc3R5bGUuYm9yZGVyUmlnaHRDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheUJ1dHRvbklubmVyRWxlbWVudC5zdHlsZS5ib3JkZXJCb3R0b21Db2xvciA9IFwidHJhbnNwYXJlbnRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheUJ1dHRvbklubmVyRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0cmFuc2xhdGUoXCIgKyBwbGF5QnV0dG9uQXJyb3dXaWR0aCAvIDEwICsgXCJweCwwcHgpXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXlCdXR0b25PdXRlckVsZW1lbnQuYXBwZW5kQ2hpbGQocGxheUJ1dHRvbklubmVyRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXlCdXR0b25Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5QnV0dG9uQ29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5QnV0dG9uQ29udGFpbmVyLnN0eWxlLmxlZnQgPSBcIjBcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheUJ1dHRvbkNvbnRhaW5lci5zdHlsZS50b3AgPSBcIjBcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheUJ1dHRvbkNvbnRhaW5lci5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5QnV0dG9uQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5QnV0dG9uQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheUJ1dHRvbkNvbnRhaW5lci5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXlCdXR0b25Db250YWluZXIuc3R5bGUuYWxpZ25JdGVtcyA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXlCdXR0b25Db250YWluZXIuYXBwZW5kQ2hpbGQocGxheUJ1dHRvbk91dGVyRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RlclJvb3RFbGVtZW50XzEuYXBwZW5kQ2hpbGQocGxheUJ1dHRvbkNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyRWxlbWVudCh0aGlzLnJlbmRlcmVkRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQuYXBwZW5kQ2hpbGQocG9zdGVyUm9vdEVsZW1lbnRfMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE1lZGlhLnByb3RvdHlwZS5pbnRlcm5hbFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSB0aGlzLmhvc3RDb25maWcubWFrZUNzc0NsYXNzTmFtZShcImFjLW1lZGlhXCIpO1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgfTtcclxuICAgIE1lZGlhLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21lZGlhUGxheWVyID0gdGhpcy5jcmVhdGVNZWRpYVBsYXllcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5mZXRjaFZpZGVvRGV0YWlscygpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZGlzcGxheVBvc3RlcigpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBNZWRpYS5wcm90b3R5cGUucmVsZWFzZURPTVJlc291cmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJlbGVhc2VET01SZXNvdXJjZXMuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmRpc3BsYXlQb3N0ZXIoKTtcclxuICAgIH07XHJcbiAgICBNZWRpYS5wcm90b3R5cGUuZ2V0SnNvblR5cGVOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcIk1lZGlhXCI7XHJcbiAgICB9O1xyXG4gICAgTWVkaWEucHJvdG90eXBlLmdldFJlc291cmNlSW5mb3JtYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLl9tZWRpYVBsYXllcikge1xyXG4gICAgICAgICAgICB2YXIgcG9zdGVyVXJsID0gdGhpcy5wb3N0ZXIgPyB0aGlzLnBvc3RlciA6IHRoaXMuaG9zdENvbmZpZy5tZWRpYS5kZWZhdWx0UG9zdGVyO1xyXG4gICAgICAgICAgICBpZiAocG9zdGVyVXJsKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IHVybDogcG9zdGVyVXJsLCBtaW1lVHlwZTogXCJpbWFnZVwiIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnNvdXJjZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBtZWRpYVNvdXJjZSA9IF9hW19pXTtcclxuICAgICAgICAgICAgaWYgKG1lZGlhU291cmNlLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS10eXBlLWFzc2VydGlvbiAtLSBgbWVkaWFTb3VyY2UudXJsYCBpcyBvZiB0eXBlIGBzdHJpbmcgfCB1bmRlZmluZWRgLCBidXQgaXMgdmFsaWRhdGVkIGJ5IGBpc1ZhbGlkKClgIGNhbGwgKi9cclxuICAgICAgICAgICAgICAgICAgICB1cmw6IG1lZGlhU291cmNlLnVybCxcclxuICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogbWVkaWFTb3VyY2UubWltZVR5cGVcclxuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS10eXBlLWFzc2VydGlvbiAqL1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMuY2FwdGlvblNvdXJjZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgIHZhciBjYXB0aW9uU291cmNlID0gX2NbX2JdO1xyXG4gICAgICAgICAgICBpZiAoY2FwdGlvblNvdXJjZS5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb24gLS0gYGNhcHRpb25Tb3VyY2UudXJsYCBpcyBvZiB0eXBlIGBzdHJpbmcgfCB1bmRlZmluZWRgLCBidXQgaXMgdmFsaWRhdGVkIGJ5IGBpc1ZhbGlkKClgIGNhbGwgKi9cclxuICAgICAgICAgICAgICAgICAgICB1cmw6IGNhcHRpb25Tb3VyY2UudXJsLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBjYXB0aW9uU291cmNlLm1pbWVUeXBlXHJcbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb24gKi9cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lZGlhLnByb3RvdHlwZSwgXCJzZWxlY3RlZE1lZGlhVHlwZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllci5zZWxlY3RlZE1lZGlhVHlwZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNZWRpYS5jdXN0b21NZWRpYVBsYXllcnMgPSBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB1cmxQYXR0ZXJuczogW1xyXG4gICAgICAgICAgICAgICAgL14oPzpodHRwcz86XFwvXFwvKT8oPzp3d3cuKT95b3V0dWJlLmNvbVxcL3dhdGNoXFw/KD89Lip2PShbXFx3XFxkLV9dKykpKD89KD86Lip0PShcXGQrKSk/KS4qL2dpLFxyXG4gICAgICAgICAgICAgICAgL14oPzpodHRwcz86XFwvXFwvKT95b3V0dS5iZVxcLyhbXFx3XFxkLV9dKykoPzpcXD90PShcXGQrKSk/L2dpXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGNyZWF0ZU1lZGlhUGxheWVyOiBmdW5jdGlvbiAobWF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBZb3VUdWJlUGxheWVyKG1hdGNoZXMsIHN0cmluZ3NfMS5TdHJpbmdzLmRlZmF1bHRzLnlvdVR1YmVWaWRlb1BsYXllcigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB1cmxQYXR0ZXJuczogWy9eKD86aHR0cHM/OlxcL1xcLyk/dmltZW8uY29tXFwvKFtcXHdcXGQtX10rKS4qL2dpXSxcclxuICAgICAgICAgICAgY3JlYXRlTWVkaWFQbGF5ZXI6IGZ1bmN0aW9uIChtYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZpbWVvUGxheWVyKG1hdGNoZXMsIHN0cmluZ3NfMS5TdHJpbmdzLmRlZmF1bHRzLnZpbWVvVmlkZW9QbGF5ZXIoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdXJsUGF0dGVybnM6IFsvXig/Omh0dHBzPzpcXC9cXC8pPyg/Ond3dy4pP2RhaWx5bW90aW9uLmNvbVxcL3ZpZGVvXFwvKFtcXHdcXGQtX10rKS4qL2dpXSxcclxuICAgICAgICAgICAgY3JlYXRlTWVkaWFQbGF5ZXI6IGZ1bmN0aW9uIChtYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhaWx5bW90aW9uUGxheWVyKG1hdGNoZXMsIHN0cmluZ3NfMS5TdHJpbmdzLmRlZmF1bHRzLmRhaWx5bW90aW9uVmlkZW9QbGF5ZXIoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICBdO1xyXG4gICAgLy8jcmVnaW9uIFNjaGVtYVxyXG4gICAgTWVkaWEuc291cmNlc1Byb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TZXJpYWxpemFibGVPYmplY3RDb2xsZWN0aW9uUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzEsIFwic291cmNlc1wiLCBNZWRpYVNvdXJjZSk7XHJcbiAgICBNZWRpYS5jYXB0aW9uU291cmNlc1Byb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TZXJpYWxpemFibGVPYmplY3RDb2xsZWN0aW9uUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzYsIFwiY2FwdGlvblNvdXJjZXNcIiwgQ2FwdGlvblNvdXJjZSk7XHJcbiAgICBNZWRpYS5wb3N0ZXJQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuU3RyaW5nUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzEsIFwicG9zdGVyXCIpO1xyXG4gICAgTWVkaWEuYWx0VGV4dFByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMSwgXCJhbHRUZXh0XCIpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoTWVkaWEuc291cmNlc1Byb3BlcnR5KVxyXG4gICAgXSwgTWVkaWEucHJvdG90eXBlLCBcInNvdXJjZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKE1lZGlhLmNhcHRpb25Tb3VyY2VzUHJvcGVydHkpXHJcbiAgICBdLCBNZWRpYS5wcm90b3R5cGUsIFwiY2FwdGlvblNvdXJjZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKE1lZGlhLnBvc3RlclByb3BlcnR5KVxyXG4gICAgXSwgTWVkaWEucHJvdG90eXBlLCBcInBvc3RlclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoTWVkaWEuYWx0VGV4dFByb3BlcnR5KVxyXG4gICAgXSwgTWVkaWEucHJvdG90eXBlLCBcImFsdFRleHRcIiwgdm9pZCAwKTtcclxuICAgIHJldHVybiBNZWRpYTtcclxufShDYXJkRWxlbWVudCkpO1xyXG5leHBvcnRzLk1lZGlhID0gTWVkaWE7XHJcbnZhciBJbnB1dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhJbnB1dCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIElucHV0KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIElucHV0LnByb3RvdHlwZS5nZXRBbGxMYWJlbElkcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbGFiZWxJZHMgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5sYWJlbGxlZEJ5KSB7XHJcbiAgICAgICAgICAgIGxhYmVsSWRzLnB1c2godGhpcy5sYWJlbGxlZEJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlcmVkTGFiZWxFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGxhYmVsSWRzLnB1c2godGhpcy5fcmVuZGVyZWRMYWJlbEVsZW1lbnQuaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyZWRFcnJvck1lc3NhZ2VFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGxhYmVsSWRzLnB1c2godGhpcy5fcmVuZGVyZWRFcnJvck1lc3NhZ2VFbGVtZW50LmlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxhYmVsSWRzO1xyXG4gICAgfTtcclxuICAgIElucHV0LnByb3RvdHlwZS51cGRhdGVJbnB1dENvbnRyb2xBcmlhTGFiZWxsZWRCeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyZWRJbnB1dENvbnRyb2xFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbElkcyA9IHRoaXMuZ2V0QWxsTGFiZWxJZHMoKTtcclxuICAgICAgICAgICAgaWYgKGxhYmVsSWRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkSW5wdXRDb250cm9sRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsbGVkYnlcIiwgbGFiZWxJZHMuam9pbihcIiBcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZWRJbnB1dENvbnRyb2xFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5wdXQucHJvdG90eXBlLCBcImlzTnVsbGFibGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5wdXQucHJvdG90eXBlLCBcInJlbmRlcmVkSW5wdXRDb250cm9sRWxlbWVudFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlZElucHV0Q29udHJvbEVsZW1lbnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElucHV0LnByb3RvdHlwZSwgXCJpbnB1dENvbnRyb2xDb250YWluZXJFbGVtZW50XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0Q29udHJvbENvbnRhaW5lckVsZW1lbnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgSW5wdXQucHJvdG90eXBlLm92ZXJyaWRlSW50ZXJuYWxSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGhvc3RDb25maWcgPSB0aGlzLmhvc3RDb25maWc7XHJcbiAgICAgICAgdGhpcy5fb3V0ZXJDb250YWluZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICB0aGlzLl9vdXRlckNvbnRhaW5lckVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xyXG4gICAgICAgIHRoaXMuX291dGVyQ29udGFpbmVyRWxlbWVudC5zdHlsZS5mbGV4RGlyZWN0aW9uID0gXCJjb2x1bW5cIjtcclxuICAgICAgICB2YXIgcmVuZGVyZWRJbnB1dENvbnRyb2xJZCA9IFV0aWxzLmdlbmVyYXRlVW5pcXVlSWQoKTtcclxuICAgICAgICBpZiAodGhpcy5sYWJlbCkge1xyXG4gICAgICAgICAgICB2YXIgbGFiZWxSaWNoVGV4dEJsb2NrID0gbmV3IFJpY2hUZXh0QmxvY2soKTtcclxuICAgICAgICAgICAgbGFiZWxSaWNoVGV4dEJsb2NrLnNldFBhcmVudCh0aGlzKTtcclxuICAgICAgICAgICAgbGFiZWxSaWNoVGV4dEJsb2NrLmZvckVsZW1lbnRJZCA9IHJlbmRlcmVkSW5wdXRDb250cm9sSWQ7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbElubGluZSA9IG5ldyBUZXh0UnVuKHRoaXMubGFiZWwpO1xyXG4gICAgICAgICAgICBsYWJlbFJpY2hUZXh0QmxvY2suYWRkSW5saW5lKGxhYmVsSW5saW5lKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXF1aXJlZCkge1xyXG4gICAgICAgICAgICAgICAgbGFiZWxJbmxpbmUuaW5pdChob3N0Q29uZmlnLmlucHV0cy5sYWJlbC5yZXF1aXJlZElucHV0cyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNSZXF1aXJlZEN1ZUlubGluZSA9IG5ldyBUZXh0UnVuKGhvc3RDb25maWcuaW5wdXRzLmxhYmVsLnJlcXVpcmVkSW5wdXRzLnN1ZmZpeCk7XHJcbiAgICAgICAgICAgICAgICBpc1JlcXVpcmVkQ3VlSW5saW5lLmNvbG9yID0gaG9zdENvbmZpZy5pbnB1dHMubGFiZWwucmVxdWlyZWRJbnB1dHMuc3VmZml4Q29sb3I7XHJcbiAgICAgICAgICAgICAgICBpc1JlcXVpcmVkQ3VlSW5saW5lLmFyaWFIaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgbGFiZWxSaWNoVGV4dEJsb2NrLmFkZElubGluZShpc1JlcXVpcmVkQ3VlSW5saW5lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxhYmVsSW5saW5lLmluaXQoaG9zdENvbmZpZy5pbnB1dHMubGFiZWwub3B0aW9uYWxJbnB1dHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkTGFiZWxFbGVtZW50ID0gbGFiZWxSaWNoVGV4dEJsb2NrLnJlbmRlcigpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcmVuZGVyZWRMYWJlbEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkTGFiZWxFbGVtZW50LmlkID0gVXRpbHMuZ2VuZXJhdGVVbmlxdWVJZCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZWRMYWJlbEVsZW1lbnQuc3R5bGUubWFyZ2luQm90dG9tID1cclxuICAgICAgICAgICAgICAgICAgICBob3N0Q29uZmlnLmdldEVmZmVjdGl2ZVNwYWNpbmcoaG9zdENvbmZpZy5pbnB1dHMubGFiZWwuaW5wdXRTcGFjaW5nKSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX291dGVyQ29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9yZW5kZXJlZExhYmVsRWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faW5wdXRDb250cm9sQ29udGFpbmVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgdGhpcy5faW5wdXRDb250cm9sQ29udGFpbmVyRWxlbWVudC5jbGFzc05hbWUgPVxyXG4gICAgICAgICAgICBob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1pbnB1dC1jb250YWluZXJcIik7XHJcbiAgICAgICAgdGhpcy5faW5wdXRDb250cm9sQ29udGFpbmVyRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XHJcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSBcInN0cmV0Y2hcIikge1xyXG4gICAgICAgICAgICB0aGlzLl9pbnB1dENvbnRyb2xDb250YWluZXJFbGVtZW50LnN0eWxlLmFsaWduSXRlbXMgPSBcInN0cmV0Y2hcIjtcclxuICAgICAgICAgICAgdGhpcy5faW5wdXRDb250cm9sQ29udGFpbmVyRWxlbWVudC5zdHlsZS5mbGV4ID0gXCIxIDEgYXV0b1wiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZW5kZXJlZElucHV0Q29udHJvbEVsZW1lbnQgPSB0aGlzLmludGVybmFsUmVuZGVyKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlcmVkSW5wdXRDb250cm9sRWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlZElucHV0Q29udHJvbEVsZW1lbnQuaWQgPSByZW5kZXJlZElucHV0Q29udHJvbElkO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlZElucHV0Q29udHJvbEVsZW1lbnQuc3R5bGUubWluV2lkdGggPSBcIjBweFwiO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc051bGxhYmxlICYmIHRoaXMuaXNSZXF1aXJlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZWRJbnB1dENvbnRyb2xFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtcmVxdWlyZWRcIiwgXCJ0cnVlXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZWRJbnB1dENvbnRyb2xFbGVtZW50LmNsYXNzTGlzdC5hZGQoaG9zdENvbmZpZy5tYWtlQ3NzQ2xhc3NOYW1lKFwiYWMtaW5wdXQtcmVxdWlyZWRcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2lucHV0Q29udHJvbENvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fcmVuZGVyZWRJbnB1dENvbnRyb2xFbGVtZW50KTtcclxuICAgICAgICAgICAgdGhpcy5fb3V0ZXJDb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2lucHV0Q29udHJvbENvbnRhaW5lckVsZW1lbnQpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUlucHV0Q29udHJvbEFyaWFMYWJlbGxlZEJ5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vdXRlckNvbnRhaW5lckVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVzZXREaXJ0eVN0YXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBJbnB1dC5wcm90b3R5cGUudmFsdWVDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZ2V0Um9vdEVsZW1lbnQoKS51cGRhdGVBY3Rpb25zRW5hYmxlZFN0YXRlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXRWYWxpZGF0aW9uRmFpbHVyZUN1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vblZhbHVlQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICB0aGlzLm9uVmFsdWVDaGFuZ2VkKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByYWlzZUlucHV0VmFsdWVDaGFuZ2VkRXZlbnQodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgSW5wdXQucHJvdG90eXBlLnJlc2V0VmFsaWRhdGlvbkZhaWx1cmVDdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRJbnB1dENvbnRyb2xFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWRJbnB1dENvbnRyb2xFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5ob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1pbnB1dC12YWxpZGF0aW9uLWZhaWxlZFwiKSk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5wdXRDb250cm9sQXJpYUxhYmVsbGVkQnkoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbmRlcmVkRXJyb3JNZXNzYWdlRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0ZXJDb250YWluZXJFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX3JlbmRlcmVkRXJyb3JNZXNzYWdlRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlZEVycm9yTWVzc2FnZUVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW5wdXQucHJvdG90eXBlLnNob3dWYWxpZGF0aW9uRXJyb3JNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVkRWxlbWVudCAmJlxyXG4gICAgICAgICAgICB0aGlzLmVycm9yTWVzc2FnZSAmJlxyXG4gICAgICAgICAgICBzaGFyZWRfMS5HbG9iYWxTZXR0aW5ncy5kaXNwbGF5SW5wdXRWYWxpZGF0aW9uRXJyb3JzKSB7XHJcbiAgICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2VUZXh0QmxvY2sgPSBuZXcgVGV4dEJsb2NrKCk7XHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZVRleHRCbG9jay5zZXRQYXJlbnQodGhpcyk7XHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZVRleHRCbG9jay50ZXh0ID0gdGhpcy5lcnJvck1lc3NhZ2U7XHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZVRleHRCbG9jay53cmFwID0gdHJ1ZTtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlVGV4dEJsb2NrLmluaXQodGhpcy5ob3N0Q29uZmlnLmlucHV0cy5lcnJvck1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlZEVycm9yTWVzc2FnZUVsZW1lbnQgPSBlcnJvck1lc3NhZ2VUZXh0QmxvY2sucmVuZGVyKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZW5kZXJlZEVycm9yTWVzc2FnZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkRXJyb3JNZXNzYWdlRWxlbWVudC5pZCA9IFV0aWxzLmdlbmVyYXRlVW5pcXVlSWQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX291dGVyQ29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9yZW5kZXJlZEVycm9yTWVzc2FnZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbnB1dENvbnRyb2xBcmlhTGFiZWxsZWRCeSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIElucHV0LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyZWRJbnB1dENvbnRyb2xFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkSW5wdXRDb250cm9sRWxlbWVudC5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbnB1dC5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBJbnB1dC5wcm90b3R5cGUuaXNEaXJ0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSAhPT0gdGhpcy5fb2xkVmFsdWU7XHJcbiAgICB9O1xyXG4gICAgSW5wdXQucHJvdG90eXBlLnJlc2V0RGlydHlTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9vbGRWYWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICB9O1xyXG4gICAgSW5wdXQucHJvdG90eXBlLmludGVybmFsVmFsaWRhdGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmludGVybmFsVmFsaWRhdGVQcm9wZXJ0aWVzLmNhbGwodGhpcywgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlkKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYWRkRmFpbHVyZSh0aGlzLCBFbnVtcy5WYWxpZGF0aW9uRXZlbnQuUHJvcGVydHlDYW50QmVOdWxsLCBzdHJpbmdzXzEuU3RyaW5ncy5lcnJvcnMuaW5wdXRzTXVzdEhhdmVVbmlxdWVJZCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNSZXF1aXJlZCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuYWRkRmFpbHVyZSh0aGlzLCBFbnVtcy5WYWxpZGF0aW9uRXZlbnQuUmVxdWlyZWRJbnB1dHNTaG91bGRIYXZlTGFiZWwsIFwiUmVxdWlyZWQgaW5wdXRzIHNob3VsZCBoYXZlIGEgbGFiZWxcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmVycm9yTWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5hZGRGYWlsdXJlKHRoaXMsIEVudW1zLlZhbGlkYXRpb25FdmVudC5SZXF1aXJlZElucHV0c1Nob3VsZEhhdmVFcnJvck1lc3NhZ2UsIFwiUmVxdWlyZWQgaW5wdXRzIHNob3VsZCBoYXZlIGFuIGVycm9yIG1lc3NhZ2VcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW5wdXQucHJvdG90eXBlLnZhbGlkYXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yZXNldFZhbGlkYXRpb25GYWlsdXJlQ3VlKCk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaXNSZXF1aXJlZCA/IHRoaXMuaXNTZXQoKSAmJiB0aGlzLmlzVmFsaWQoKSA6IHRoaXMuaXNWYWxpZCgpO1xyXG4gICAgICAgIGlmICghcmVzdWx0ICYmIHRoaXMucmVuZGVyZWRJbnB1dENvbnRyb2xFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWRJbnB1dENvbnRyb2xFbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5ob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1pbnB1dC12YWxpZGF0aW9uLWZhaWxlZFwiKSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd1ZhbGlkYXRpb25FcnJvck1lc3NhZ2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBJbnB1dC5wcm90b3R5cGUuZ2V0QWxsSW5wdXRzID0gZnVuY3Rpb24gKHByb2Nlc3NBY3Rpb25zKSB7XHJcbiAgICAgICAgaWYgKHByb2Nlc3NBY3Rpb25zID09PSB2b2lkIDApIHsgcHJvY2Vzc0FjdGlvbnMgPSB0cnVlOyB9XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzXTtcclxuICAgIH07XHJcbiAgICBJbnB1dC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucmVzZXREaXJ0eVN0YXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5wdXQucHJvdG90eXBlLCBcImlzSW50ZXJhY3RpdmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvLyNyZWdpb24gU2NoZW1hXHJcbiAgICBJbnB1dC5sYWJlbFByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMywgXCJsYWJlbFwiLCB0cnVlKTtcclxuICAgIElucHV0LmlzUmVxdWlyZWRQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuQm9vbFByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8zLCBcImlzUmVxdWlyZWRcIiwgZmFsc2UpO1xyXG4gICAgSW5wdXQuZXJyb3JNZXNzYWdlUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8zLCBcImVycm9yTWVzc2FnZVwiLCB0cnVlKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKElucHV0LmxhYmVsUHJvcGVydHkpXHJcbiAgICBdLCBJbnB1dC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKElucHV0LmlzUmVxdWlyZWRQcm9wZXJ0eSlcclxuICAgIF0sIElucHV0LnByb3RvdHlwZSwgXCJpc1JlcXVpcmVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShJbnB1dC5lcnJvck1lc3NhZ2VQcm9wZXJ0eSlcclxuICAgIF0sIElucHV0LnByb3RvdHlwZSwgXCJlcnJvck1lc3NhZ2VcIiwgdm9pZCAwKTtcclxuICAgIHJldHVybiBJbnB1dDtcclxufShDYXJkRWxlbWVudCkpO1xyXG5leHBvcnRzLklucHV0ID0gSW5wdXQ7XHJcbnZhciBUZXh0SW5wdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVGV4dElucHV0LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVGV4dElucHV0KCkge1xyXG4gICAgICAgIC8vI3JlZ2lvbiBTY2hlbWFcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5pc011bHRpbGluZSA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLnN0eWxlID0gRW51bXMuSW5wdXRUZXh0U3R5bGUuVGV4dDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICAgIFRleHRJbnB1dC5wcm90b3R5cGUuc2V0dXBJbnB1dCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaW5wdXQuc3R5bGUuZmxleCA9IFwiMSAxIGF1dG9cIjtcclxuICAgICAgICBpbnB1dC50YWJJbmRleCA9IHRoaXMuaXNEZXNpZ25Nb2RlKCkgPyAtMSA6IDA7XHJcbiAgICAgICAgaWYgKHRoaXMucGxhY2Vob2xkZXIpIHtcclxuICAgICAgICAgICAgaW5wdXQucGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyO1xyXG4gICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRoaXMucGxhY2Vob2xkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICAgICAgaW5wdXQudmFsdWUgPSB0aGlzLmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubWF4TGVuZ3RoICYmIHRoaXMubWF4TGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBpbnB1dC5tYXhMZW5ndGggPSB0aGlzLm1heExlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5wdXQub25pbnB1dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMudmFsdWVDaGFuZ2VkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpbnB1dC5vbmtleXByZXNzID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgLy8gQ3RybCtFbnRlciBwcmVzc2VkXHJcbiAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgJiZcclxuICAgICAgICAgICAgICAgIGUuY29kZSA9PT0gXCJFbnRlclwiICYmXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pbmxpbmVBY3Rpb24gJiZcclxuICAgICAgICAgICAgICAgIF90aGlzLmlubGluZUFjdGlvbi5pc0VmZmVjdGl2ZWx5RW5hYmxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pbmxpbmVBY3Rpb24uZXhlY3V0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBUZXh0SW5wdXQucHJvdG90eXBlLmludGVybmFsUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNNdWx0aWxpbmUgJiYgdGhpcy5zdHlsZSAhPT0gRW51bXMuSW5wdXRUZXh0U3R5bGUuUGFzc3dvcmQpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xyXG4gICAgICAgICAgICByZXN1bHQuY2xhc3NOYW1lID0gdGhpcy5ob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1pbnB1dFwiLCBcImFjLXRleHRJbnB1dFwiLCBcImFjLW11bHRpbGluZVwiKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSBcInN0cmV0Y2hcIikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0eWxlLmhlaWdodCA9IFwiaW5pdGlhbFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XHJcbiAgICAgICAgICAgIHJlc3VsdC5jbGFzc05hbWUgPSB0aGlzLmhvc3RDb25maWcubWFrZUNzc0NsYXNzTmFtZShcImFjLWlucHV0XCIsIFwiYWMtdGV4dElucHV0XCIpO1xyXG4gICAgICAgICAgICByZXN1bHQudHlwZSA9IEVudW1zLklucHV0VGV4dFN0eWxlW3RoaXMuc3R5bGVdLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0dXBJbnB1dChyZXN1bHQpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgVGV4dElucHV0LnByb3RvdHlwZS5vdmVycmlkZUludGVybmFsUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVkSW5wdXRDb250cm9sID0gX3N1cGVyLnByb3RvdHlwZS5vdmVycmlkZUludGVybmFsUmVuZGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5saW5lQWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBidXR0b25fMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XHJcbiAgICAgICAgICAgIGJ1dHRvbl8xLmNsYXNzTmFtZSA9IHRoaXMuaG9zdENvbmZpZy5tYWtlQ3NzQ2xhc3NOYW1lKHRoaXMuaW5saW5lQWN0aW9uLmlzRWZmZWN0aXZlbHlFbmFibGVkKClcclxuICAgICAgICAgICAgICAgID8gXCJhYy1pbmxpbmVBY3Rpb25CdXR0b25cIlxyXG4gICAgICAgICAgICAgICAgOiBcImFjLWlubGluZUFjdGlvbkJ1dHRvbi1kaXNhYmxlZFwiKTtcclxuICAgICAgICAgICAgYnV0dG9uXzEub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaW5saW5lQWN0aW9uICYmIF90aGlzLmlubGluZUFjdGlvbi5pc0VmZmVjdGl2ZWx5RW5hYmxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbmxpbmVBY3Rpb24uZXhlY3V0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbmxpbmVBY3Rpb24uaWNvblVybCkge1xyXG4gICAgICAgICAgICAgICAgYnV0dG9uXzEuY2xhc3NMaXN0LmFkZChcImljb25Pbmx5XCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGljb25fMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XHJcbiAgICAgICAgICAgICAgICBpY29uXzEuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XHJcbiAgICAgICAgICAgICAgICBpY29uXzEuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBiZWxvdyB0cmljayBpcyBuZWNlc3NhcnkgYXMgYSB3b3JrYXJvdW5kIGluIENocm9tZSB3aGVyZSB0aGUgaWNvbiBpcyBpbml0aWFsbHkgZGlzcGxheWVkXHJcbiAgICAgICAgICAgICAgICAvLyBhdCBpdHMgbmF0aXZlIHNpemUgdGhlbiByZXNpemVkIHRvIDEwMCUgb2YgdGhlIGJ1dHRvbidzIGhlaWdodC4gVGhpcyBjZnJlYXRlcyBhbiB1bnBsZWFzYW50XHJcbiAgICAgICAgICAgICAgICAvLyBmbGlja2VyLiBPbiB0b3Agb2YgdGhhdCwgQ2hyb21lJ3MgZmxleCBpbXBsZW1lbnRhdGlvbiBmYWlscyB0byBwcnBlcmx5IHJlLWxheW91dCB0aGUgYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAvLyBhZnRlciB0aGUgaW1hZ2UgaGFzIGxvYWRlZCBhbmQgYmVlbiBnaWN2ZW4gaXRzIGZpbmFsIHNpemUuIFRoZSBiZWxvdyB0cmljayBhbHNvIGZpeGVzIHRoYXQuXHJcbiAgICAgICAgICAgICAgICBpY29uXzEuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgICAgICAgICAgaWNvbl8xLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpY29uXzEuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJkaXNwbGF5XCIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGljb25fMS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbl8xLnJlbW92ZUNoaWxkKGljb25fMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uXzEuY2xhc3NMaXN0LnJlbW92ZShcImljb25Pbmx5XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbl8xLmNsYXNzTGlzdC5hZGQoXCJ0ZXh0T25seVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBidXR0b25fMS50ZXh0Q29udGVudCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmlubGluZUFjdGlvbiAmJiBfdGhpcy5pbmxpbmVBY3Rpb24udGl0bGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gX3RoaXMuaW5saW5lQWN0aW9uLnRpdGxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHN0cmluZ3NfMS5TdHJpbmdzLmRlZmF1bHRzLmlubGluZUFjdGlvblRpdGxlKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWNvbl8xLnNyYyA9IHRoaXMuaW5saW5lQWN0aW9uLmljb25Vcmw7XHJcbiAgICAgICAgICAgICAgICBidXR0b25fMS5hcHBlbmRDaGlsZChpY29uXzEpO1xyXG4gICAgICAgICAgICAgICAgYnV0dG9uXzEudGl0bGUgPSB0aGlzLmlubGluZUFjdGlvbi50aXRsZVxyXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5pbmxpbmVBY3Rpb24udGl0bGVcclxuICAgICAgICAgICAgICAgICAgICA6IHN0cmluZ3NfMS5TdHJpbmdzLmRlZmF1bHRzLmlubGluZUFjdGlvblRpdGxlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBidXR0b25fMS5jbGFzc0xpc3QuYWRkKFwidGV4dE9ubHlcIik7XHJcbiAgICAgICAgICAgICAgICBidXR0b25fMS50ZXh0Q29udGVudCA9IHRoaXMuaW5saW5lQWN0aW9uLnRpdGxlXHJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmlubGluZUFjdGlvbi50aXRsZVxyXG4gICAgICAgICAgICAgICAgICAgIDogc3RyaW5nc18xLlN0cmluZ3MuZGVmYXVsdHMuaW5saW5lQWN0aW9uVGl0bGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlubGluZUFjdGlvbi5zZXR1cEVsZW1lbnRGb3JBY2Nlc3NpYmlsaXR5KGJ1dHRvbl8xLCB0cnVlKTtcclxuICAgICAgICAgICAgYnV0dG9uXzEuc3R5bGUubWFyZ2luTGVmdCA9IFwiOHB4XCI7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRDb250cm9sQ29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChidXR0b25fMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW5kZXJlZElucHV0Q29udHJvbDtcclxuICAgIH07XHJcbiAgICBUZXh0SW5wdXQucHJvdG90eXBlLmdldEpzb25UeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXCJJbnB1dC5UZXh0XCI7XHJcbiAgICB9O1xyXG4gICAgVGV4dElucHV0LnByb3RvdHlwZS5nZXRBbGxBY3Rpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLmdldEFsbEFjdGlvbnMuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAodGhpcy5pbmxpbmVBY3Rpb24pIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5pbmxpbmVBY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIFRleHRJbnB1dC5wcm90b3R5cGUuZ2V0QWN0aW9uQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLmdldEFjdGlvbkJ5SWQuY2FsbCh0aGlzLCBpZCk7XHJcbiAgICAgICAgaWYgKCFyZXN1bHQgJiYgdGhpcy5pbmxpbmVBY3Rpb24pIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5pbmxpbmVBY3Rpb24uZ2V0QWN0aW9uQnlJZChpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgVGV4dElucHV0LnByb3RvdHlwZS5pc1NldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA/IHRydWUgOiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBUZXh0SW5wdXQucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5yZWdleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh0aGlzLnJlZ2V4LCBcImdcIikudGVzdCh0aGlzLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHRJbnB1dC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJlZElucHV0Q29udHJvbEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTXVsdGlsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZWRJbnB1dENvbnRyb2xFbGVtZW50LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZWRJbnB1dENvbnRyb2xFbGVtZW50LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFRleHRJbnB1dC52YWx1ZVByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCwgXCJ2YWx1ZVwiKTtcclxuICAgIFRleHRJbnB1dC5tYXhMZW5ndGhQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuTnVtUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwibWF4TGVuZ3RoXCIpO1xyXG4gICAgVGV4dElucHV0LmlzTXVsdGlsaW5lUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLkJvb2xQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCwgXCJpc011bHRpbGluZVwiLCBmYWxzZSk7XHJcbiAgICBUZXh0SW5wdXQucGxhY2Vob2xkZXJQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuU3RyaW5nUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwicGxhY2Vob2xkZXJcIik7XHJcbiAgICBUZXh0SW5wdXQuc3R5bGVQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuRW51bVByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcInN0eWxlXCIsIEVudW1zLklucHV0VGV4dFN0eWxlLCBFbnVtcy5JbnB1dFRleHRTdHlsZS5UZXh0LCBbXHJcbiAgICAgICAgeyB2YWx1ZTogRW51bXMuSW5wdXRUZXh0U3R5bGUuVGV4dCB9LFxyXG4gICAgICAgIHsgdmFsdWU6IEVudW1zLklucHV0VGV4dFN0eWxlLlRlbCB9LFxyXG4gICAgICAgIHsgdmFsdWU6IEVudW1zLklucHV0VGV4dFN0eWxlLlVybCB9LFxyXG4gICAgICAgIHsgdmFsdWU6IEVudW1zLklucHV0VGV4dFN0eWxlLkVtYWlsIH0sXHJcbiAgICAgICAgeyB2YWx1ZTogRW51bXMuSW5wdXRUZXh0U3R5bGUuUGFzc3dvcmQsIHRhcmdldFZlcnNpb246IHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV81IH1cclxuICAgIF0pO1xyXG4gICAgVGV4dElucHV0LmlubGluZUFjdGlvblByb3BlcnR5ID0gbmV3IEFjdGlvblByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcImlubGluZUFjdGlvblwiLCBbXHJcbiAgICAgICAgXCJBY3Rpb24uU2hvd0NhcmRcIlxyXG4gICAgXSk7XHJcbiAgICBUZXh0SW5wdXQucmVnZXhQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuU3RyaW5nUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzMsIFwicmVnZXhcIiwgdHJ1ZSk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShUZXh0SW5wdXQudmFsdWVQcm9wZXJ0eSlcclxuICAgIF0sIFRleHRJbnB1dC5wcm90b3R5cGUsIFwiZGVmYXVsdFZhbHVlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShUZXh0SW5wdXQubWF4TGVuZ3RoUHJvcGVydHkpXHJcbiAgICBdLCBUZXh0SW5wdXQucHJvdG90eXBlLCBcIm1heExlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoVGV4dElucHV0LmlzTXVsdGlsaW5lUHJvcGVydHkpXHJcbiAgICBdLCBUZXh0SW5wdXQucHJvdG90eXBlLCBcImlzTXVsdGlsaW5lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShUZXh0SW5wdXQucGxhY2Vob2xkZXJQcm9wZXJ0eSlcclxuICAgIF0sIFRleHRJbnB1dC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKFRleHRJbnB1dC5zdHlsZVByb3BlcnR5KVxyXG4gICAgXSwgVGV4dElucHV0LnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoVGV4dElucHV0LmlubGluZUFjdGlvblByb3BlcnR5KVxyXG4gICAgXSwgVGV4dElucHV0LnByb3RvdHlwZSwgXCJpbmxpbmVBY3Rpb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKFRleHRJbnB1dC5yZWdleFByb3BlcnR5KVxyXG4gICAgXSwgVGV4dElucHV0LnByb3RvdHlwZSwgXCJyZWdleFwiLCB2b2lkIDApO1xyXG4gICAgcmV0dXJuIFRleHRJbnB1dDtcclxufShJbnB1dCkpO1xyXG5leHBvcnRzLlRleHRJbnB1dCA9IFRleHRJbnB1dDtcclxudmFyIFRvZ2dsZUlucHV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFRvZ2dsZUlucHV0LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVG9nZ2xlSW5wdXQoKSB7XHJcbiAgICAgICAgLy8jcmVnaW9uIFNjaGVtYVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnZhbHVlT24gPSBcInRydWVcIjtcclxuICAgICAgICBfdGhpcy52YWx1ZU9mZiA9IFwiZmFsc2VcIjtcclxuICAgICAgICBfdGhpcy53cmFwID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgVG9nZ2xlSW5wdXQucHJvdG90eXBlLnVwZGF0ZUlucHV0Q29udHJvbEFyaWFMYWJlbGxlZEJ5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jaGVja2JveElucHV0RWxlbWVudCkge1xyXG4gICAgICAgICAgICB2YXIgam9pbmVkTGFiZWxJZHMgPSB0aGlzLmdldEFsbExhYmVsSWRzKCkuam9pbihcIiBcIik7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGVja2JveElucHV0TGFiZWxFbGVtZW50ICYmIHRoaXMuX2NoZWNrYm94SW5wdXRMYWJlbEVsZW1lbnQuaWQpIHtcclxuICAgICAgICAgICAgICAgIGpvaW5lZExhYmVsSWRzICs9IFwiIFwiICsgdGhpcy5fY2hlY2tib3hJbnB1dExhYmVsRWxlbWVudC5pZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoam9pbmVkTGFiZWxJZHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrYm94SW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiLCBqb2luZWRMYWJlbElkcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja2JveElucHV0RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsbGVkYnlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9nZ2xlSW5wdXQucHJvdG90eXBlLmludGVybmFsUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5ob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1pbnB1dFwiLCBcImFjLXRvZ2dsZUlucHV0XCIpO1xyXG4gICAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcclxuICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcclxuICAgICAgICBlbGVtZW50LnN0eWxlLmFsaWduSXRlbXMgPSBcImNlbnRlclwiO1xyXG4gICAgICAgIHRoaXMuX2NoZWNrYm94SW5wdXRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xyXG4gICAgICAgIHRoaXMuX2NoZWNrYm94SW5wdXRFbGVtZW50LmlkID0gVXRpbHMuZ2VuZXJhdGVVbmlxdWVJZCgpO1xyXG4gICAgICAgIHRoaXMuX2NoZWNrYm94SW5wdXRFbGVtZW50LnR5cGUgPSBcImNoZWNrYm94XCI7XHJcbiAgICAgICAgdGhpcy5fY2hlY2tib3hJbnB1dEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XHJcbiAgICAgICAgdGhpcy5fY2hlY2tib3hJbnB1dEVsZW1lbnQuc3R5bGUudmVydGljYWxBbGlnbiA9IFwibWlkZGxlXCI7XHJcbiAgICAgICAgdGhpcy5fY2hlY2tib3hJbnB1dEVsZW1lbnQuc3R5bGUubWFyZ2luID0gXCIwXCI7XHJcbiAgICAgICAgdGhpcy5fY2hlY2tib3hJbnB1dEVsZW1lbnQuc3R5bGUuZmxleCA9IFwiMCAwIGF1dG9cIjtcclxuICAgICAgICBpZiAodGhpcy50aXRsZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jaGVja2JveElucHV0RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRoaXMudGl0bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc1JlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrYm94SW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtcmVxdWlyZWRcIiwgXCJ0cnVlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jaGVja2JveElucHV0RWxlbWVudC50YWJJbmRleCA9IHRoaXMuaXNEZXNpZ25Nb2RlKCkgPyAtMSA6IDA7XHJcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdFZhbHVlID09PSB0aGlzLnZhbHVlT24pIHtcclxuICAgICAgICAgICAgdGhpcy5fY2hlY2tib3hJbnB1dEVsZW1lbnQuY2hlY2tlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX29sZENoZWNrYm94VmFsdWUgPSB0aGlzLl9jaGVja2JveElucHV0RWxlbWVudC5jaGVja2VkO1xyXG4gICAgICAgIHRoaXMuX2NoZWNrYm94SW5wdXRFbGVtZW50Lm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy52YWx1ZUNoYW5nZWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFV0aWxzLmFwcGVuZENoaWxkKGVsZW1lbnQsIHRoaXMuX2NoZWNrYm94SW5wdXRFbGVtZW50KTtcclxuICAgICAgICBpZiAodGhpcy50aXRsZSB8fCB0aGlzLmlzRGVzaWduTW9kZSgpKSB7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IG5ldyBUZXh0QmxvY2soKTtcclxuICAgICAgICAgICAgbGFiZWwuc2V0UGFyZW50KHRoaXMpO1xyXG4gICAgICAgICAgICBsYWJlbC5mb3JFbGVtZW50SWQgPSB0aGlzLl9jaGVja2JveElucHV0RWxlbWVudC5pZDtcclxuICAgICAgICAgICAgbGFiZWwuaG9zdENvbmZpZyA9IHRoaXMuaG9zdENvbmZpZztcclxuICAgICAgICAgICAgbGFiZWwudGV4dCA9ICF0aGlzLnRpdGxlID8gdGhpcy5nZXRKc29uVHlwZU5hbWUoKSA6IHRoaXMudGl0bGU7XHJcbiAgICAgICAgICAgIGxhYmVsLnVzZU1hcmtkb3duID0gc2hhcmVkXzEuR2xvYmFsU2V0dGluZ3MudXNlTWFya2Rvd25JblJhZGlvQnV0dG9uQW5kQ2hlY2tib3g7XHJcbiAgICAgICAgICAgIGxhYmVsLndyYXAgPSB0aGlzLndyYXA7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrYm94SW5wdXRMYWJlbEVsZW1lbnQgPSBsYWJlbC5yZW5kZXIoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2NoZWNrYm94SW5wdXRMYWJlbEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrYm94SW5wdXRMYWJlbEVsZW1lbnQuaWQgPSBVdGlscy5nZW5lcmF0ZVVuaXF1ZUlkKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja2JveElucHV0TGFiZWxFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tib3hJbnB1dExhYmVsRWxlbWVudC5zdHlsZS5mbGV4ID0gXCIxIDEgYXV0b1wiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tib3hJbnB1dExhYmVsRWxlbWVudC5zdHlsZS5tYXJnaW5MZWZ0ID0gXCI2cHhcIjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrYm94SW5wdXRMYWJlbEVsZW1lbnQuc3R5bGUudmVydGljYWxBbGlnbiA9IFwibWlkZGxlXCI7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2VyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgICAgICBzcGFjZXJFbGVtZW50LnN0eWxlLndpZHRoID0gXCI2cHhcIjtcclxuICAgICAgICAgICAgICAgIFV0aWxzLmFwcGVuZENoaWxkKGVsZW1lbnQsIHNwYWNlckVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgVXRpbHMuYXBwZW5kQ2hpbGQoZWxlbWVudCwgdGhpcy5fY2hlY2tib3hJbnB1dExhYmVsRWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvZ2dsZUlucHV0LnByb3RvdHlwZSwgXCJpc051bGxhYmxlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFRvZ2dsZUlucHV0LnByb3RvdHlwZS5nZXRKc29uVHlwZU5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiSW5wdXQuVG9nZ2xlXCI7XHJcbiAgICB9O1xyXG4gICAgVG9nZ2xlSW5wdXQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jaGVja2JveElucHV0RWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jaGVja2JveElucHV0RWxlbWVudC5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb2dnbGVJbnB1dC5wcm90b3R5cGUuaXNTZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNSZXF1aXJlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gdGhpcy52YWx1ZU9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA/IHRydWUgOiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBUb2dnbGVJbnB1dC5wcm90b3R5cGUuaXNEaXJ0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tib3hJbnB1dEVsZW1lbnRcclxuICAgICAgICAgICAgPyB0aGlzLl9jaGVja2JveElucHV0RWxlbWVudC5jaGVja2VkICE9PSB0aGlzLl9vbGRDaGVja2JveFZhbHVlXHJcbiAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvZ2dsZUlucHV0LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGVja2JveElucHV0RWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrYm94SW5wdXRFbGVtZW50LmNoZWNrZWQgPyB0aGlzLnZhbHVlT24gOiB0aGlzLnZhbHVlT2ZmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFRvZ2dsZUlucHV0LnZhbHVlUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcInZhbHVlXCIpO1xyXG4gICAgVG9nZ2xlSW5wdXQudGl0bGVQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuU3RyaW5nUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwidGl0bGVcIik7XHJcbiAgICBUb2dnbGVJbnB1dC52YWx1ZU9uUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcInZhbHVlT25cIiwgdHJ1ZSwgdW5kZWZpbmVkLCBcInRydWVcIiwgZnVuY3Rpb24gKHNlbmRlcikge1xyXG4gICAgICAgIHJldHVybiBcInRydWVcIjtcclxuICAgIH0pO1xyXG4gICAgVG9nZ2xlSW5wdXQudmFsdWVPZmZQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuU3RyaW5nUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwidmFsdWVPZmZcIiwgdHJ1ZSwgdW5kZWZpbmVkLCBcImZhbHNlXCIsIGZ1bmN0aW9uIChzZW5kZXIpIHtcclxuICAgICAgICByZXR1cm4gXCJmYWxzZVwiO1xyXG4gICAgfSk7XHJcbiAgICBUb2dnbGVJbnB1dC53cmFwUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLkJvb2xQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMiwgXCJ3cmFwXCIsIGZhbHNlKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKFRvZ2dsZUlucHV0LnZhbHVlUHJvcGVydHkpXHJcbiAgICBdLCBUb2dnbGVJbnB1dC5wcm90b3R5cGUsIFwiZGVmYXVsdFZhbHVlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShUb2dnbGVJbnB1dC50aXRsZVByb3BlcnR5KVxyXG4gICAgXSwgVG9nZ2xlSW5wdXQucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShUb2dnbGVJbnB1dC52YWx1ZU9uUHJvcGVydHkpXHJcbiAgICBdLCBUb2dnbGVJbnB1dC5wcm90b3R5cGUsIFwidmFsdWVPblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoVG9nZ2xlSW5wdXQudmFsdWVPZmZQcm9wZXJ0eSlcclxuICAgIF0sIFRvZ2dsZUlucHV0LnByb3RvdHlwZSwgXCJ2YWx1ZU9mZlwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoVG9nZ2xlSW5wdXQud3JhcFByb3BlcnR5KVxyXG4gICAgXSwgVG9nZ2xlSW5wdXQucHJvdG90eXBlLCBcIndyYXBcIiwgdm9pZCAwKTtcclxuICAgIHJldHVybiBUb2dnbGVJbnB1dDtcclxufShJbnB1dCkpO1xyXG5leHBvcnRzLlRvZ2dsZUlucHV0ID0gVG9nZ2xlSW5wdXQ7XHJcbnZhciBDaG9pY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ2hvaWNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ2hvaWNlKHRpdGxlLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudGl0bGUgPSB0aXRsZTtcclxuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgQ2hvaWNlLnByb3RvdHlwZS5nZXRTY2hlbWFLZXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiQ2hvaWNlXCI7XHJcbiAgICB9O1xyXG4gICAgLy8jcmVnaW9uIFNjaGVtYVxyXG4gICAgQ2hvaWNlLnRpdGxlUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcInRpdGxlXCIpO1xyXG4gICAgQ2hvaWNlLnZhbHVlUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcInZhbHVlXCIpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoQ2hvaWNlLnRpdGxlUHJvcGVydHkpXHJcbiAgICBdLCBDaG9pY2UucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShDaG9pY2UudmFsdWVQcm9wZXJ0eSlcclxuICAgIF0sIENob2ljZS5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIHJldHVybiBDaG9pY2U7XHJcbn0oc2VyaWFsaXphdGlvbl8xLlNlcmlhbGl6YWJsZU9iamVjdCkpO1xyXG5leHBvcnRzLkNob2ljZSA9IENob2ljZTtcclxudmFyIENob2ljZVNldElucHV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENob2ljZVNldElucHV0LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ2hvaWNlU2V0SW5wdXQoKSB7XHJcbiAgICAgICAgLy8jcmVnaW9uIFNjaGVtYVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmlzTXVsdGlTZWxlY3QgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy53cmFwID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuY2hvaWNlcyA9IFtdO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaG9pY2VTZXRJbnB1dC5wcm90b3R5cGUsIFwiaXNDb21wYWN0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLnN0eWxlIHx8IHRoaXMuc3R5bGUgPT09IFwiY29tcGFjdFwiO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZSA9IHZhbHVlID8gdW5kZWZpbmVkIDogXCJleHBhbmRlZFwiO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIENob2ljZVNldElucHV0LmdldFVuaXF1ZUNhdGVnb3J5TmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdW5pcXVlQ2F0ZWdvcnlOYW1lID0gXCJfX2FjLWNhdGVnb3J5XCIgKyBDaG9pY2VTZXRJbnB1dC5fdW5pcXVlQ2F0ZWdvcnlDb3VudGVyO1xyXG4gICAgICAgIENob2ljZVNldElucHV0Ll91bmlxdWVDYXRlZ29yeUNvdW50ZXIrKztcclxuICAgICAgICByZXR1cm4gdW5pcXVlQ2F0ZWdvcnlOYW1lO1xyXG4gICAgfTtcclxuICAgIC8vIE1ha2Ugc3VyZSBgYXJpYS1jdXJyZW50YCBpcyBhcHBsaWVkIHRvIHRoZSBjdXJyZW50bHktc2VsZWN0ZWQgaXRlbVxyXG4gICAgQ2hvaWNlU2V0SW5wdXQucHJvdG90eXBlLmludGVybmFsQXBwbHlBcmlhQ3VycmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fc2VsZWN0RWxlbWVudCkge1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX3NlbGVjdEVsZW1lbnQub3B0aW9ucztcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBBcnJheS5mcm9tKG9wdGlvbnMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24uc2V0QXR0cmlidXRlKFwiYXJpYS1jdXJyZW50XCIsIFwidHJ1ZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWN1cnJlbnRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENob2ljZVNldElucHV0LnByb3RvdHlwZS5yZW5kZXJDb21wb3VuZElucHV0ID0gZnVuY3Rpb24gKGNzc0NsYXNzTmFtZSwgdHlwZSwgZGVmYXVsdFZhbHVlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5ob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1pbnB1dFwiLCBjc3NDbGFzc05hbWUpO1xyXG4gICAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcclxuICAgICAgICBlbGVtZW50LnRhYkluZGV4ID0gdGhpcy5pc0Rlc2lnbk1vZGUoKSA/IC0xIDogMDtcclxuICAgICAgICB0aGlzLl90b2dnbGVJbnB1dHMgPSBbXTtcclxuICAgICAgICB0aGlzLl9sYWJlbHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jaG9pY2VzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgY2hvaWNlID0gX2FbX2ldO1xyXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XHJcbiAgICAgICAgICAgIGlucHV0LmlkID0gVXRpbHMuZ2VuZXJhdGVVbmlxdWVJZCgpO1xyXG4gICAgICAgICAgICBpbnB1dC50eXBlID0gdHlwZTtcclxuICAgICAgICAgICAgaW5wdXQuc3R5bGUubWFyZ2luID0gXCIwXCI7XHJcbiAgICAgICAgICAgIGlucHV0LnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xyXG4gICAgICAgICAgICBpbnB1dC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gXCJtaWRkbGVcIjtcclxuICAgICAgICAgICAgaW5wdXQuc3R5bGUuZmxleCA9IFwiMCAwIGF1dG9cIjtcclxuICAgICAgICAgICAgaW5wdXQubmFtZSA9IHRoaXMuaWQgPyB0aGlzLmlkIDogdGhpcy5fdW5pcXVlQ2F0ZWdvcnlOYW1lO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1JlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXJlcXVpcmVkXCIsIFwidHJ1ZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpbnB1dC50YWJJbmRleCA9IHRoaXMuaXNEZXNpZ25Nb2RlKCkgPyAtMSA6IDA7XHJcbiAgICAgICAgICAgIGlmIChjaG9pY2UudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0LnZhbHVlID0gY2hvaWNlLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaG9pY2UudGl0bGUpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgY2hvaWNlLnRpdGxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGVmYXVsdFZhbHVlcyAmJiBjaG9pY2UudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0VmFsdWVzLmluZGV4T2YoY2hvaWNlLnZhbHVlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW5wdXQub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZUNoYW5nZWQoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlSW5wdXRzLnB1c2goaW5wdXQpO1xyXG4gICAgICAgICAgICB2YXIgY29tcG91bmRJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIGNvbXBvdW5kSW5wdXQuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xyXG4gICAgICAgICAgICBjb21wb3VuZElucHV0LnN0eWxlLmFsaWduSXRlbXMgPSBcImNlbnRlclwiO1xyXG4gICAgICAgICAgICBVdGlscy5hcHBlbmRDaGlsZChjb21wb3VuZElucHV0LCBpbnB1dCk7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IG5ldyBUZXh0QmxvY2soKTtcclxuICAgICAgICAgICAgbGFiZWwuc2V0UGFyZW50KHRoaXMpO1xyXG4gICAgICAgICAgICBsYWJlbC5mb3JFbGVtZW50SWQgPSBpbnB1dC5pZDtcclxuICAgICAgICAgICAgbGFiZWwuaG9zdENvbmZpZyA9IHRoaXMuaG9zdENvbmZpZztcclxuICAgICAgICAgICAgbGFiZWwudGV4dCA9IGNob2ljZS50aXRsZSA/IGNob2ljZS50aXRsZSA6IFwiQ2hvaWNlIFwiICsgdGhpcy5fdG9nZ2xlSW5wdXRzLmxlbmd0aDtcclxuICAgICAgICAgICAgbGFiZWwudXNlTWFya2Rvd24gPSBzaGFyZWRfMS5HbG9iYWxTZXR0aW5ncy51c2VNYXJrZG93bkluUmFkaW9CdXR0b25BbmRDaGVja2JveDtcclxuICAgICAgICAgICAgbGFiZWwud3JhcCA9IHRoaXMud3JhcDtcclxuICAgICAgICAgICAgdmFyIGxhYmVsRWxlbWVudCA9IGxhYmVsLnJlbmRlcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9sYWJlbHMucHVzaChsYWJlbEVsZW1lbnQpO1xyXG4gICAgICAgICAgICBpZiAobGFiZWxFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbEVsZW1lbnQuaWQgPSBVdGlscy5nZW5lcmF0ZVVuaXF1ZUlkKCk7XHJcbiAgICAgICAgICAgICAgICBsYWJlbEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XHJcbiAgICAgICAgICAgICAgICBsYWJlbEVsZW1lbnQuc3R5bGUuZmxleCA9IFwiMSAxIGF1dG9cIjtcclxuICAgICAgICAgICAgICAgIGxhYmVsRWxlbWVudC5zdHlsZS5tYXJnaW5MZWZ0ID0gXCI2cHhcIjtcclxuICAgICAgICAgICAgICAgIGxhYmVsRWxlbWVudC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gXCJtaWRkbGVcIjtcclxuICAgICAgICAgICAgICAgIHZhciBzcGFjZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgICAgIHNwYWNlckVsZW1lbnQuc3R5bGUud2lkdGggPSBcIjZweFwiO1xyXG4gICAgICAgICAgICAgICAgVXRpbHMuYXBwZW5kQ2hpbGQoY29tcG91bmRJbnB1dCwgc3BhY2VyRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBVdGlscy5hcHBlbmRDaGlsZChjb21wb3VuZElucHV0LCBsYWJlbEVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFV0aWxzLmFwcGVuZENoaWxkKGVsZW1lbnQsIGNvbXBvdW5kSW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH07XHJcbiAgICBDaG9pY2VTZXRJbnB1dC5wcm90b3R5cGUudXBkYXRlSW5wdXRDb250cm9sQXJpYUxhYmVsbGVkQnkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCh0aGlzLmlzTXVsdGlTZWxlY3QgfHwgdGhpcy5zdHlsZSA9PT0gXCJleHBhbmRlZFwiKSAmJlxyXG4gICAgICAgICAgICB0aGlzLl90b2dnbGVJbnB1dHMgJiZcclxuICAgICAgICAgICAgdGhpcy5fbGFiZWxzKSB7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbElkcyA9IHRoaXMuZ2V0QWxsTGFiZWxJZHMoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90b2dnbGVJbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBqb2luZWRMYWJlbElkcyA9IGxhYmVsSWRzLmpvaW4oXCIgXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbGFiZWxzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsICYmIGxhYmVsLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgam9pbmVkTGFiZWxJZHMgKz0gXCIgXCIgKyBsYWJlbC5pZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChqb2luZWRMYWJlbElkcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUlucHV0c1tpXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsbGVkYnlcIiwgam9pbmVkTGFiZWxJZHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlSW5wdXRzW2ldLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVJbnB1dENvbnRyb2xBcmlhTGFiZWxsZWRCeS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDaG9pY2VTZXRJbnB1dC5wcm90b3R5cGUuaW50ZXJuYWxSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl91bmlxdWVDYXRlZ29yeU5hbWUgPSBDaG9pY2VTZXRJbnB1dC5nZXRVbmlxdWVDYXRlZ29yeU5hbWUoKTtcclxuICAgICAgICBpZiAodGhpcy5pc011bHRpU2VsZWN0KSB7XHJcbiAgICAgICAgICAgIC8vIFJlbmRlciBhcyBhIGxpc3Qgb2YgdG9nZ2xlIGlucHV0c1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJDb21wb3VuZElucHV0KFwiYWMtY2hvaWNlU2V0SW5wdXQtbXVsdGlTZWxlY3RcIiwgXCJjaGVja2JveFwiLCB0aGlzLmRlZmF1bHRWYWx1ZVxyXG4gICAgICAgICAgICAgICAgPyB0aGlzLmRlZmF1bHRWYWx1ZS5zcGxpdCh0aGlzLmhvc3RDb25maWcuY2hvaWNlU2V0SW5wdXRWYWx1ZVNlcGFyYXRvcilcclxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlID09PSBcImV4cGFuZGVkXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlbmRlciBhcyBhIHNlcmllcyBvZiByYWRpbyBidXR0b25zXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJDb21wb3VuZElucHV0KFwiYWMtY2hvaWNlU2V0SW5wdXQtZXhwYW5kZWRcIiwgXCJyYWRpb1wiLCB0aGlzLmRlZmF1bHRWYWx1ZSA/IFt0aGlzLmRlZmF1bHRWYWx1ZV0gOiB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3R5bGUgPT09IFwiZmlsdGVyZWRcIikge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVuZGVyIGFzIGEgdGV4dCBpbnB1dCBjb3VwbGVkIHdpdGggYSBkYXRhbGlzdFxyXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgICAgIGlucHV0Q29udGFpbmVyLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0SW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0SW5wdXQuY2xhc3NOYW1lID0gdGhpcy5ob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1pbnB1dFwiLCBcImFjLW11bHRpY2hvaWNlSW5wdXRcIiwgXCJhYy1jaG9pY2VTZXRJbnB1dC1maWx0ZXJlZFwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRJbnB1dC50eXBlID0gXCJ0ZXh0XCI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0SW5wdXQuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRJbnB1dC5vbmlucHV0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlQ2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fdGV4dElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhcmlhLWxhYmVsIHdoZW4gdmFsdWUgaXMgbm90IGVtcHR5IHNvIG5hcnJhdGlvbiBzb2Z0d2FyZSBkb2Vzbid0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlYWQgdGhlIHBsYWNlaG9sZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RleHRJbnB1dC5yZW1vdmVBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl90ZXh0SW5wdXQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5wbGFjZWhvbGRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RleHRJbnB1dC5wbGFjZWhvbGRlciA9IF90aGlzLnBsYWNlaG9sZGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RleHRJbnB1dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIF90aGlzLnBsYWNlaG9sZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0SW5wdXQudmFsdWUgPSB0aGlzLmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBsYWNlaG9sZGVyICYmICF0aGlzLl90ZXh0SW5wdXQudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0SW5wdXQucGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRJbnB1dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRoaXMucGxhY2Vob2xkZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dElucHV0LnRhYkluZGV4ID0gdGhpcy5pc0Rlc2lnbk1vZGUoKSA/IC0xIDogMDtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhTGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkYXRhbGlzdFwiKTtcclxuICAgICAgICAgICAgICAgIGRhdGFMaXN0LmlkID0gVXRpbHMuZ2VuZXJhdGVVbmlxdWVJZCgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2hvaWNlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hvaWNlID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIGZpeCBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yOTg4MjM2MS9zaG93LWRhdGFsaXN0LWxhYmVscy1idXQtc3VibWl0LXRoZS1hY3R1YWwtdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZSBpcyBtYXBwZWQgdG8gY2hvaWNlLnRpdGxlIG90aGVyIHRoYW4gY2hvaWNlLnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNob2ljZS50aXRsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24udmFsdWUgPSBjaG9pY2UudGl0bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGNob2ljZS50aXRsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbi50YWJJbmRleCA9IHRoaXMuaXNEZXNpZ25Nb2RlKCkgPyAtMSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YUxpc3QuYXBwZW5kQ2hpbGQob3B0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRJbnB1dC5zZXRBdHRyaWJ1dGUoXCJsaXN0XCIsIGRhdGFMaXN0LmlkKTtcclxuICAgICAgICAgICAgICAgIGlucHV0Q29udGFpbmVyLmFwcGVuZCh0aGlzLl90ZXh0SW5wdXQsIGRhdGFMaXN0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dENvbnRhaW5lcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlbmRlciBhcyBhIGNvbWJvIGJveFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RFbGVtZW50LmNsYXNzTmFtZSA9IHRoaXMuaG9zdENvbmZpZy5tYWtlQ3NzQ2xhc3NOYW1lKFwiYWMtaW5wdXRcIiwgXCJhYy1tdWx0aWNob2ljZUlucHV0XCIsIFwiYWMtY2hvaWNlU2V0SW5wdXQtY29tcGFjdFwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdEVsZW1lbnQuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdEVsZW1lbnQudGFiSW5kZXggPSB0aGlzLmlzRGVzaWduTW9kZSgpID8gLTEgOiAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyT3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcclxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyT3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyT3B0aW9uLmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyT3B0aW9uLmhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlck9wdGlvbi52YWx1ZSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wbGFjZWhvbGRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyT3B0aW9uLnRleHQgPSB0aGlzLnBsYWNlaG9sZGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgVXRpbHMuYXBwZW5kQ2hpbGQodGhpcy5fc2VsZWN0RWxlbWVudCwgcGxhY2Vob2xkZXJPcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMuY2hvaWNlczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hvaWNlID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbi52YWx1ZSA9IGNob2ljZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hvaWNlLnRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi50ZXh0ID0gY2hvaWNlLnRpdGxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBjaG9pY2UudGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBvcHRpb24udGFiSW5kZXggPSB0aGlzLmlzRGVzaWduTW9kZSgpID8gLTEgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaG9pY2UudmFsdWUgPT09IHRoaXMuZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFV0aWxzLmFwcGVuZENoaWxkKHRoaXMuX3NlbGVjdEVsZW1lbnQsIG9wdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RFbGVtZW50Lm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmludGVybmFsQXBwbHlBcmlhQ3VycmVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlQ2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxBcHBseUFyaWFDdXJyZW50KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0RWxlbWVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDaG9pY2VTZXRJbnB1dC5wcm90b3R5cGUuZ2V0SnNvblR5cGVOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcIklucHV0LkNob2ljZVNldFwiO1xyXG4gICAgfTtcclxuICAgIENob2ljZVNldElucHV0LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fdG9nZ2xlSW5wdXRzICYmICh0aGlzLmlzTXVsdGlTZWxlY3QgfHwgdGhpcy5zdHlsZSA9PT0gXCJleHBhbmRlZFwiKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdG9nZ2xlSW5wdXRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUlucHV0c1swXS5mb2N1cygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3RleHRJbnB1dCkge1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0SW5wdXQuZm9jdXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZm9jdXMuY2FsbCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2hvaWNlU2V0SW5wdXQucHJvdG90eXBlLmludGVybmFsVmFsaWRhdGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmludGVybmFsVmFsaWRhdGVQcm9wZXJ0aWVzLmNhbGwodGhpcywgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hvaWNlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY29udGV4dC5hZGRGYWlsdXJlKHRoaXMsIEVudW1zLlZhbGlkYXRpb25FdmVudC5Db2xsZWN0aW9uQ2FudEJlRW1wdHksIHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy5jaG9pY2VTZXRNdXN0SGF2ZUF0TGVhc3RPbmVDaG9pY2UoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNob2ljZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjaG9pY2UgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGlmICghY2hvaWNlLnRpdGxlIHx8ICFjaG9pY2UudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuYWRkRmFpbHVyZSh0aGlzLCBFbnVtcy5WYWxpZGF0aW9uRXZlbnQuUHJvcGVydHlDYW50QmVOdWxsLCBzdHJpbmdzXzEuU3RyaW5ncy5lcnJvcnMuY2hvaWNlU2V0Q2hvaWNlc011c3RIYXZlVGl0bGVBbmRWYWx1ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDaG9pY2VTZXRJbnB1dC5wcm90b3R5cGUuaXNTZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPyB0cnVlIDogZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQ2hvaWNlU2V0SW5wdXQucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RleHRJbnB1dCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gXCJcIiB8fCB0aGlzLnZhbHVlID09PSB0aGlzLnBsYWNlaG9sZGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jaG9pY2VzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNob2ljZSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBjaG9pY2UudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmlzVmFsaWQuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hvaWNlU2V0SW5wdXQucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzTXVsdGlTZWxlY3QpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3RFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdEVsZW1lbnQuc2VsZWN0ZWRJbmRleCA+IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9zZWxlY3RFbGVtZW50LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fdGV4dElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2hvaWNlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNob2ljZSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNob2ljZS50aXRsZSAmJiB0aGlzLl90ZXh0SW5wdXQudmFsdWUgPT09IGNob2ljZS50aXRsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNob2ljZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dElucHV0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fdG9nZ2xlSW5wdXRzICYmIHRoaXMuX3RvZ2dsZUlucHV0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMuX3RvZ2dsZUlucHV0czsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvZ2dsZUlucHV0ID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9nZ2xlSW5wdXQuY2hlY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvZ2dsZUlucHV0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdG9nZ2xlSW5wdXRzIHx8IHRoaXMuX3RvZ2dsZUlucHV0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IDAsIF9mID0gdGhpcy5fdG9nZ2xlSW5wdXRzOyBfZCA8IF9mLmxlbmd0aDsgX2QrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2dnbGVJbnB1dCA9IF9mW19kXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9nZ2xlSW5wdXQuY2hlY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5ob3N0Q29uZmlnLmNob2ljZVNldElucHV0VmFsdWVTZXBhcmF0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRvZ2dsZUlucHV0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBDaG9pY2VTZXRJbnB1dC52YWx1ZVByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCwgXCJ2YWx1ZVwiKTtcclxuICAgIENob2ljZVNldElucHV0LmNob2ljZXNQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuU2VyaWFsaXphYmxlT2JqZWN0Q29sbGVjdGlvblByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcImNob2ljZXNcIiwgQ2hvaWNlKTtcclxuICAgIENob2ljZVNldElucHV0LnN0eWxlUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlZhbHVlU2V0UHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwic3R5bGVcIiwgW1xyXG4gICAgICAgIHsgdmFsdWU6IFwiY29tcGFjdFwiIH0sXHJcbiAgICAgICAgeyB2YWx1ZTogXCJleHBhbmRlZFwiIH0sXHJcbiAgICAgICAgeyB2YWx1ZTogXCJmaWx0ZXJlZFwiLCB0YXJnZXRWZXJzaW9uOiBzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfNSB9XHJcbiAgICBdLCBcImNvbXBhY3RcIik7XHJcbiAgICBDaG9pY2VTZXRJbnB1dC5pc011bHRpU2VsZWN0UHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLkJvb2xQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCwgXCJpc011bHRpU2VsZWN0XCIsIGZhbHNlKTtcclxuICAgIENob2ljZVNldElucHV0LnBsYWNlaG9sZGVyUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcInBsYWNlaG9sZGVyXCIpO1xyXG4gICAgQ2hvaWNlU2V0SW5wdXQud3JhcFByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5Cb29sUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzIsIFwid3JhcFwiLCBmYWxzZSk7XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICAgIENob2ljZVNldElucHV0Ll91bmlxdWVDYXRlZ29yeUNvdW50ZXIgPSAwO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoQ2hvaWNlU2V0SW5wdXQudmFsdWVQcm9wZXJ0eSlcclxuICAgIF0sIENob2ljZVNldElucHV0LnByb3RvdHlwZSwgXCJkZWZhdWx0VmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKENob2ljZVNldElucHV0LnN0eWxlUHJvcGVydHkpXHJcbiAgICBdLCBDaG9pY2VTZXRJbnB1dC5wcm90b3R5cGUsIFwic3R5bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKENob2ljZVNldElucHV0LmlzTXVsdGlTZWxlY3RQcm9wZXJ0eSlcclxuICAgIF0sIENob2ljZVNldElucHV0LnByb3RvdHlwZSwgXCJpc011bHRpU2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShDaG9pY2VTZXRJbnB1dC5wbGFjZWhvbGRlclByb3BlcnR5KVxyXG4gICAgXSwgQ2hvaWNlU2V0SW5wdXQucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShDaG9pY2VTZXRJbnB1dC53cmFwUHJvcGVydHkpXHJcbiAgICBdLCBDaG9pY2VTZXRJbnB1dC5wcm90b3R5cGUsIFwid3JhcFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoQ2hvaWNlU2V0SW5wdXQuY2hvaWNlc1Byb3BlcnR5KVxyXG4gICAgXSwgQ2hvaWNlU2V0SW5wdXQucHJvdG90eXBlLCBcImNob2ljZXNcIiwgdm9pZCAwKTtcclxuICAgIHJldHVybiBDaG9pY2VTZXRJbnB1dDtcclxufShJbnB1dCkpO1xyXG5leHBvcnRzLkNob2ljZVNldElucHV0ID0gQ2hvaWNlU2V0SW5wdXQ7XHJcbnZhciBOdW1iZXJJbnB1dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhOdW1iZXJJbnB1dCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE51bWJlcklucHV0KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIE51bWJlcklucHV0LnByb3RvdHlwZS5pbnRlcm5hbFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX251bWJlcklucHV0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcclxuICAgICAgICB0aGlzLl9udW1iZXJJbnB1dEVsZW1lbnQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICBpZiAodGhpcy5taW4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9udW1iZXJJbnB1dEVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWluXCIsIHRoaXMubWluLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tYXggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9udW1iZXJJbnB1dEVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWF4XCIsIHRoaXMubWF4LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9udW1iZXJJbnB1dEVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5ob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1pbnB1dFwiLCBcImFjLW51bWJlcklucHV0XCIpO1xyXG4gICAgICAgIHRoaXMuX251bWJlcklucHV0RWxlbWVudC5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xyXG4gICAgICAgIHRoaXMuX251bWJlcklucHV0RWxlbWVudC50YWJJbmRleCA9IHRoaXMuaXNEZXNpZ25Nb2RlKCkgPyAtMSA6IDA7XHJcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fbnVtYmVySW5wdXRFbGVtZW50LnZhbHVlQXNOdW1iZXIgPSB0aGlzLmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGxhY2Vob2xkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbnVtYmVySW5wdXRFbGVtZW50LnBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlcjtcclxuICAgICAgICAgICAgdGhpcy5fbnVtYmVySW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy5wbGFjZWhvbGRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX251bWJlcklucHV0RWxlbWVudC5vbmlucHV0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy52YWx1ZUNoYW5nZWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9udW1iZXJJbnB1dEVsZW1lbnQ7XHJcbiAgICB9O1xyXG4gICAgTnVtYmVySW5wdXQucHJvdG90eXBlLmdldEpzb25UeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXCJJbnB1dC5OdW1iZXJcIjtcclxuICAgIH07XHJcbiAgICBOdW1iZXJJbnB1dC5wcm90b3R5cGUuaXNTZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhaXNOYU4odGhpcy52YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgTnVtYmVySW5wdXQucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuaXNSZXF1aXJlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMubWluICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmIHRoaXMudmFsdWUgPj0gdGhpcy5taW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1heCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCAmJiB0aGlzLnZhbHVlIDw9IHRoaXMubWF4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOdW1iZXJJbnB1dC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbnVtYmVySW5wdXRFbGVtZW50ID8gdGhpcy5fbnVtYmVySW5wdXRFbGVtZW50LnZhbHVlQXNOdW1iZXIgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdGhpcy5fbnVtYmVySW5wdXRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9udW1iZXJJbnB1dEVsZW1lbnQudmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLy8jcmVnaW9uIFNjaGVtYVxyXG4gICAgTnVtYmVySW5wdXQudmFsdWVQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuTnVtUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwidmFsdWVcIik7XHJcbiAgICBOdW1iZXJJbnB1dC5wbGFjZWhvbGRlclByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCwgXCJwbGFjZWhvbGRlclwiKTtcclxuICAgIE51bWJlcklucHV0Lm1pblByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5OdW1Qcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCwgXCJtaW5cIik7XHJcbiAgICBOdW1iZXJJbnB1dC5tYXhQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuTnVtUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwibWF4XCIpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoTnVtYmVySW5wdXQudmFsdWVQcm9wZXJ0eSlcclxuICAgIF0sIE51bWJlcklucHV0LnByb3RvdHlwZSwgXCJkZWZhdWx0VmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKE51bWJlcklucHV0Lm1pblByb3BlcnR5KVxyXG4gICAgXSwgTnVtYmVySW5wdXQucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoTnVtYmVySW5wdXQubWF4UHJvcGVydHkpXHJcbiAgICBdLCBOdW1iZXJJbnB1dC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShOdW1iZXJJbnB1dC5wbGFjZWhvbGRlclByb3BlcnR5KVxyXG4gICAgXSwgTnVtYmVySW5wdXQucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XHJcbiAgICByZXR1cm4gTnVtYmVySW5wdXQ7XHJcbn0oSW5wdXQpKTtcclxuZXhwb3J0cy5OdW1iZXJJbnB1dCA9IE51bWJlcklucHV0O1xyXG52YXIgRGF0ZUlucHV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKERhdGVJbnB1dCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERhdGVJbnB1dCgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBEYXRlSW5wdXQucHJvdG90eXBlLmludGVybmFsUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fZGF0ZUlucHV0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcclxuICAgICAgICB0aGlzLl9kYXRlSW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJkYXRlXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLm1pbikge1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRlSW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1pblwiLCB0aGlzLm1pbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1heCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRlSW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1heFwiLCB0aGlzLm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBsYWNlaG9sZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGVJbnB1dEVsZW1lbnQucGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyO1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRlSW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy5wbGFjZWhvbGRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2RhdGVJbnB1dEVsZW1lbnQudGFiSW5kZXggPSB0aGlzLmlzRGVzaWduTW9kZSgpID8gLTEgOiAwO1xyXG4gICAgICAgIHRoaXMuX2RhdGVJbnB1dEVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5ob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1pbnB1dFwiLCBcImFjLWRhdGVJbnB1dFwiKTtcclxuICAgICAgICB0aGlzLl9kYXRlSW5wdXRFbGVtZW50LnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XHJcbiAgICAgICAgdGhpcy5fZGF0ZUlucHV0RWxlbWVudC5vbmlucHV0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy52YWx1ZUNoYW5nZWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRlSW5wdXRFbGVtZW50LnZhbHVlID0gdGhpcy5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRlSW5wdXRFbGVtZW50O1xyXG4gICAgfTtcclxuICAgIERhdGVJbnB1dC5wcm90b3R5cGUuZ2V0SnNvblR5cGVOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcIklucHV0LkRhdGVcIjtcclxuICAgIH07XHJcbiAgICBEYXRlSW5wdXQucHJvdG90eXBlLmlzU2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID8gdHJ1ZSA6IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIERhdGVJbnB1dC5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMudmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmlzUmVxdWlyZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZUFzRGF0ZSA9IG5ldyBEYXRlKHRoaXMudmFsdWUpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLm1pbikge1xyXG4gICAgICAgICAgICB2YXIgbWluRGF0ZSA9IG5ldyBEYXRlKHRoaXMubWluKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmIHZhbHVlQXNEYXRlID49IG1pbkRhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1heCkge1xyXG4gICAgICAgICAgICB2YXIgbWF4RGF0ZSA9IG5ldyBEYXRlKHRoaXMubWF4KTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmIHZhbHVlQXNEYXRlIDw9IG1heERhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGVJbnB1dC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZUlucHV0RWxlbWVudCA/IHRoaXMuX2RhdGVJbnB1dEVsZW1lbnQudmFsdWUgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLy8jcmVnaW9uIFNjaGVtYVxyXG4gICAgRGF0ZUlucHV0LnZhbHVlUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcInZhbHVlXCIpO1xyXG4gICAgRGF0ZUlucHV0LnBsYWNlaG9sZGVyUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcInBsYWNlaG9sZGVyXCIpO1xyXG4gICAgRGF0ZUlucHV0Lm1pblByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCwgXCJtaW5cIik7XHJcbiAgICBEYXRlSW5wdXQubWF4UHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcIm1heFwiKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKERhdGVJbnB1dC52YWx1ZVByb3BlcnR5KVxyXG4gICAgXSwgRGF0ZUlucHV0LnByb3RvdHlwZSwgXCJkZWZhdWx0VmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKERhdGVJbnB1dC5taW5Qcm9wZXJ0eSlcclxuICAgIF0sIERhdGVJbnB1dC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShEYXRlSW5wdXQubWF4UHJvcGVydHkpXHJcbiAgICBdLCBEYXRlSW5wdXQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoRGF0ZUlucHV0LnBsYWNlaG9sZGVyUHJvcGVydHkpXHJcbiAgICBdLCBEYXRlSW5wdXQucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XHJcbiAgICByZXR1cm4gRGF0ZUlucHV0O1xyXG59KElucHV0KSk7XHJcbmV4cG9ydHMuRGF0ZUlucHV0ID0gRGF0ZUlucHV0O1xyXG52YXIgVGltZVByb3BlcnR5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFRpbWVQcm9wZXJ0eSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRpbWVQcm9wZXJ0eSh0YXJnZXRWZXJzaW9uLCBuYW1lKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdGFyZ2V0VmVyc2lvbiwgbmFtZSwgZnVuY3Rpb24gKHNlbmRlciwgcHJvcCwgc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wLm5hbWVdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICYmIC9eWzAtOV17Mn06WzAtOV17Mn0kLy50ZXN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKHNlbmRlciwgcHJvcCwgdGFyZ2V0LCB2YWx1ZSwgY29udGV4dCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LnNlcmlhbGl6ZVZhbHVlKHRhcmdldCwgcHJvcC5uYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgfSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy50YXJnZXRWZXJzaW9uID0gdGFyZ2V0VmVyc2lvbjtcclxuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVGltZVByb3BlcnR5O1xyXG59KHNlcmlhbGl6YXRpb25fMS5DdXN0b21Qcm9wZXJ0eSkpO1xyXG5leHBvcnRzLlRpbWVQcm9wZXJ0eSA9IFRpbWVQcm9wZXJ0eTtcclxudmFyIFRpbWVJbnB1dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhUaW1lSW5wdXQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW1lSW5wdXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgVGltZUlucHV0LmNvbnZlcnRUaW1lU3RyaW5nVG9EYXRlID0gZnVuY3Rpb24gKHRpbWVTdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGUoXCIxOTczLTA5LTA0VFwiICsgdGltZVN0cmluZyArIFwiOjAwWlwiKTtcclxuICAgIH07XHJcbiAgICBUaW1lSW5wdXQucHJvdG90eXBlLmludGVybmFsUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fdGltZUlucHV0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcclxuICAgICAgICB0aGlzLl90aW1lSW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJ0aW1lXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLm1pbikge1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lSW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1pblwiLCB0aGlzLm1pbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1heCkge1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lSW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1heFwiLCB0aGlzLm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3RpbWVJbnB1dEVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5ob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1pbnB1dFwiLCBcImFjLXRpbWVJbnB1dFwiKTtcclxuICAgICAgICB0aGlzLl90aW1lSW5wdXRFbGVtZW50LnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XHJcbiAgICAgICAgdGhpcy5fdGltZUlucHV0RWxlbWVudC5vbmlucHV0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy52YWx1ZUNoYW5nZWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzLnBsYWNlaG9sZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVJbnB1dEVsZW1lbnQucGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyO1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lSW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy5wbGFjZWhvbGRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3RpbWVJbnB1dEVsZW1lbnQudGFiSW5kZXggPSB0aGlzLmlzRGVzaWduTW9kZSgpID8gLTEgOiAwO1xyXG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lSW5wdXRFbGVtZW50LnZhbHVlID0gdGhpcy5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl90aW1lSW5wdXRFbGVtZW50O1xyXG4gICAgfTtcclxuICAgIFRpbWVJbnB1dC5wcm90b3R5cGUuZ2V0SnNvblR5cGVOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcIklucHV0LlRpbWVcIjtcclxuICAgIH07XHJcbiAgICBUaW1lSW5wdXQucHJvdG90eXBlLmlzU2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID8gdHJ1ZSA6IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIFRpbWVJbnB1dC5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMudmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmlzUmVxdWlyZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZUFzRGF0ZSA9IFRpbWVJbnB1dC5jb252ZXJ0VGltZVN0cmluZ1RvRGF0ZSh0aGlzLnZhbHVlKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5taW4pIHtcclxuICAgICAgICAgICAgdmFyIG1pbkRhdGUgPSBUaW1lSW5wdXQuY29udmVydFRpbWVTdHJpbmdUb0RhdGUodGhpcy5taW4pO1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgJiYgdmFsdWVBc0RhdGUgPj0gbWluRGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubWF4KSB7XHJcbiAgICAgICAgICAgIHZhciBtYXhEYXRlID0gVGltZUlucHV0LmNvbnZlcnRUaW1lU3RyaW5nVG9EYXRlKHRoaXMubWF4KTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmIHZhbHVlQXNEYXRlIDw9IG1heERhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWVJbnB1dC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZUlucHV0RWxlbWVudCA/IHRoaXMuX3RpbWVJbnB1dEVsZW1lbnQudmFsdWUgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLy8jcmVnaW9uIFNjaGVtYVxyXG4gICAgVGltZUlucHV0LnZhbHVlUHJvcGVydHkgPSBuZXcgVGltZVByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcInZhbHVlXCIpO1xyXG4gICAgVGltZUlucHV0LnBsYWNlaG9sZGVyUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcInBsYWNlaG9sZGVyXCIpO1xyXG4gICAgVGltZUlucHV0Lm1pblByb3BlcnR5ID0gbmV3IFRpbWVQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCwgXCJtaW5cIik7XHJcbiAgICBUaW1lSW5wdXQubWF4UHJvcGVydHkgPSBuZXcgVGltZVByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcIm1heFwiKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKFRpbWVJbnB1dC52YWx1ZVByb3BlcnR5KVxyXG4gICAgXSwgVGltZUlucHV0LnByb3RvdHlwZSwgXCJkZWZhdWx0VmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKFRpbWVJbnB1dC5taW5Qcm9wZXJ0eSlcclxuICAgIF0sIFRpbWVJbnB1dC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShUaW1lSW5wdXQubWF4UHJvcGVydHkpXHJcbiAgICBdLCBUaW1lSW5wdXQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoVGltZUlucHV0LnBsYWNlaG9sZGVyUHJvcGVydHkpXHJcbiAgICBdLCBUaW1lSW5wdXQucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XHJcbiAgICByZXR1cm4gVGltZUlucHV0O1xyXG59KElucHV0KSk7XHJcbmV4cG9ydHMuVGltZUlucHV0ID0gVGltZUlucHV0O1xyXG52YXIgQWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFjdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFjdGlvbigpIHtcclxuICAgICAgICAvLyNyZWdpb24gU2NoZW1hXHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuc3R5bGUgPSBFbnVtcy5BY3Rpb25TdHlsZS5EZWZhdWx0O1xyXG4gICAgICAgIF90aGlzLm1vZGUgPSBFbnVtcy5BY3Rpb25Nb2RlLlByaW1hcnk7XHJcbiAgICAgICAgX3RoaXMuX3N0YXRlID0gMCAvKiBOb3JtYWwgKi87XHJcbiAgICAgICAgX3RoaXMuX2lzRm9jdXNhYmxlID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICAgIEFjdGlvbi5wcm90b3R5cGUucmVuZGVyQnV0dG9uQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5yZW5kZXJlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgLy8gQ2FjaGUgaG9zdENvbmZpZyBmb3IgcGVyZlxyXG4gICAgICAgICAgICB2YXIgaG9zdENvbmZpZyA9IHRoaXMuaG9zdENvbmZpZztcclxuICAgICAgICAgICAgdmFyIHRpdGxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIHRpdGxlRWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XHJcbiAgICAgICAgICAgIHRpdGxlRWxlbWVudC5zdHlsZS50ZXh0T3ZlcmZsb3cgPSBcImVsbGlwc2lzXCI7XHJcbiAgICAgICAgICAgIGlmICghKGhvc3RDb25maWcuYWN0aW9ucy5pY29uUGxhY2VtZW50ID09PSBFbnVtcy5BY3Rpb25JY29uUGxhY2VtZW50LkFib3ZlVGl0bGUgfHxcclxuICAgICAgICAgICAgICAgIGhvc3RDb25maWcuYWN0aW9ucy5hbGxvd1RpdGxlVG9XcmFwKSkge1xyXG4gICAgICAgICAgICAgICAgdGl0bGVFbGVtZW50LnN0eWxlLndoaXRlU3BhY2UgPSBcIm5vd3JhcFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZUVsZW1lbnQuaW5uZXJUZXh0ID0gdGhpcy50aXRsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaWNvblVybCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm5vSWNvblwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50LmFwcGVuZENoaWxkKHRpdGxlRWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWNvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xyXG4gICAgICAgICAgICAgICAgaWNvbkVsZW1lbnQuc3JjID0gdGhpcy5pY29uVXJsO1xyXG4gICAgICAgICAgICAgICAgaWNvbkVsZW1lbnQuc3R5bGUud2lkdGggPSBob3N0Q29uZmlnLmFjdGlvbnMuaWNvblNpemUgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICBpY29uRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBob3N0Q29uZmlnLmFjdGlvbnMuaWNvblNpemUgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICBpY29uRWxlbWVudC5zdHlsZS5mbGV4ID0gXCIwIDAgYXV0b1wiO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhvc3RDb25maWcuYWN0aW9ucy5pY29uUGxhY2VtZW50ID09PSBFbnVtcy5BY3Rpb25JY29uUGxhY2VtZW50LkFib3ZlVGl0bGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiaWNvbkFib3ZlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50LnN0eWxlLmZsZXhEaXJlY3Rpb24gPSBcImNvbHVtblwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25FbGVtZW50LnN0eWxlLm1hcmdpbkJvdHRvbSA9IFwiNnB4XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImljb25MZWZ0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGljb25FbGVtZW50LnN0eWxlLm1heEhlaWdodCA9IFwiMTAwJVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25FbGVtZW50LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI2cHhcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudC5hcHBlbmRDaGlsZChpY29uRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudC5hcHBlbmRDaGlsZCh0aXRsZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFjdGlvbi5wcm90b3R5cGUuZ2V0UGFyZW50Q29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmdldFBhcmVudENvbnRhaW5lcigpIDogdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIEFjdGlvbi5wcm90b3R5cGUuaXNEZXNpZ25Nb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuZ2V0Um9vdE9iamVjdCgpO1xyXG4gICAgICAgIHJldHVybiByb290RWxlbWVudCBpbnN0YW5jZW9mIENhcmRFbGVtZW50ICYmIHJvb3RFbGVtZW50LmlzRGVzaWduTW9kZSgpO1xyXG4gICAgfTtcclxuICAgIEFjdGlvbi5wcm90b3R5cGUudXBkYXRlQ3NzQ2xhc3NlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnJlbmRlcmVkRWxlbWVudCkge1xyXG4gICAgICAgICAgICB2YXIgaG9zdENvbmZpZyA9IHRoaXMucGFyZW50Lmhvc3RDb25maWc7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50LmNsYXNzTmFtZSA9IGhvc3RDb25maWcubWFrZUNzc0NsYXNzTmFtZSh0aGlzLmlzRWZmZWN0aXZlbHlFbmFibGVkKCkgPyBcImFjLXB1c2hCdXR0b25cIiA6IFwiYWMtcHVzaEJ1dHRvbi1kaXNhYmxlZFwiKTtcclxuICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHRoaXMuZ2V0UGFyZW50Q29udGFpbmVyKCk7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXJTdHlsZSA9IHBhcmVudENvbnRhaW5lci5nZXRFZmZlY3RpdmVTdHlsZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudENvbnRhaW5lclN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInN0eWxlLVwiICsgcGFyZW50Q29udGFpbmVyU3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50LnRhYkluZGV4ID0gIXRoaXMuaXNEZXNpZ25Nb2RlKCkgJiYgdGhpcy5pc0ZvY3VzYWJsZSA/IDAgOiAtMTtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9zdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIE5vcm1hbCAqLzpcclxuICAgICAgICAgICAgICAgICAgICAvLyBObyBhZGRpdGlvbmFsIGNsYXNzZXMgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogRXhwYW5kZWQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQuY2xhc3NMaXN0LmFkZChob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJleHBhbmRlZFwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogU3ViZHVlZCAqLzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudC5jbGFzc0xpc3QuYWRkKGhvc3RDb25maWcubWFrZUNzc0NsYXNzTmFtZShcInN1YmR1ZWRcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlICYmIHRoaXMuaXNFZmZlY3RpdmVseUVuYWJsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUgPT09IEVudW1zLkFjdGlvblN0eWxlLlBvc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5yZW5kZXJlZEVsZW1lbnQuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2EsIGhvc3RDb25maWcubWFrZUNzc0NsYXNzTmFtZXMoXCJwcmltYXJ5XCIsIFwic3R5bGUtcG9zaXRpdmVcIikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKF9iID0gdGhpcy5yZW5kZXJlZEVsZW1lbnQuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2IsIGhvc3RDb25maWcubWFrZUNzc0NsYXNzTmFtZXMoXCJzdHlsZS1cIiArIHRoaXMuc3R5bGUudG9Mb3dlckNhc2UoKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFjdGlvbi5wcm90b3R5cGUuZ2V0RGVmYXVsdFNlcmlhbGl6YXRpb25Db250ZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU2VyaWFsaXphdGlvbkNvbnRleHQoKTtcclxuICAgIH07XHJcbiAgICBBY3Rpb24ucHJvdG90eXBlLmludGVybmFsR2V0UmVmZXJlbmNlZElucHV0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9O1xyXG4gICAgQWN0aW9uLnByb3RvdHlwZS5pbnRlcm5hbFByZXBhcmVGb3JFeGVjdXRpb24gPSBmdW5jdGlvbiAoX2lucHV0cykge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaW4gYmFzZSBpbXBsZW1lbnRhdGlvblxyXG4gICAgfTtcclxuICAgIEFjdGlvbi5wcm90b3R5cGUuaW50ZXJuYWxWYWxpZGF0ZUlucHV0cyA9IGZ1bmN0aW9uIChyZWZlcmVuY2VkSW5wdXRzKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGlmIChyZWZlcmVuY2VkSW5wdXRzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhyZWZlcmVuY2VkSW5wdXRzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSByZWZlcmVuY2VkSW5wdXRzW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LnZhbGlkYXRlVmFsdWUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGlucHV0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIEFjdGlvbi5wcm90b3R5cGUuc2hvdWxkU2VyaWFsaXplID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gY29udGV4dC5hY3Rpb25SZWdpc3RyeS5maW5kQnlOYW1lKHRoaXMuZ2V0SnNvblR5cGVOYW1lKCkpICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgQWN0aW9uLnByb3RvdHlwZS5yYWlzZUV4ZWN1dGVBY3Rpb25FdmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5vbkV4ZWN1dGUpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkV4ZWN1dGUodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJhaXNlRXhlY3V0ZUFjdGlvbkV2ZW50KHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEFjdGlvbi5wcm90b3R5cGUuaW50ZXJuYWxBZnRlckV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJvb3RPYmplY3QgPSB0aGlzLmdldFJvb3RPYmplY3QoKTtcclxuICAgICAgICBpZiAocm9vdE9iamVjdCBpbnN0YW5jZW9mIENhcmRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJvb3RPYmplY3QudXBkYXRlQWN0aW9uc0VuYWJsZWRTdGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBY3Rpb24ucHJvdG90eXBlLmdldEhyZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9O1xyXG4gICAgQWN0aW9uLnByb3RvdHlwZS5nZXRBcmlhUm9sZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXCJidXR0b25cIjtcclxuICAgIH07XHJcbiAgICBBY3Rpb24ucHJvdG90eXBlLnNldHVwRWxlbWVudEZvckFjY2Vzc2liaWxpdHkgPSBmdW5jdGlvbiAoZWxlbWVudCwgcHJvbW90ZVRvb2x0aXBUb0xhYmVsKSB7XHJcbiAgICAgICAgaWYgKHByb21vdGVUb29sdGlwVG9MYWJlbCA9PT0gdm9pZCAwKSB7IHByb21vdGVUb29sdGlwVG9MYWJlbCA9IGZhbHNlOyB9XHJcbiAgICAgICAgZWxlbWVudC50YWJJbmRleCA9IHRoaXMuaXNFZmZlY3RpdmVseUVuYWJsZWQoKSAmJiAhdGhpcy5pc0Rlc2lnbk1vZGUoKSA/IDAgOiAtMTtcclxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgdGhpcy5nZXRBcmlhUm9sZSgpKTtcclxuICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuZGlzYWJsZWQgPSAhdGhpcy5pc0VmZmVjdGl2ZWx5RW5hYmxlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuaXNFZmZlY3RpdmVseUVuYWJsZWQoKSkge1xyXG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIiwgXCJ0cnVlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWRpc2FibGVkXCIpO1xyXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5ob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1zZWxlY3RhYmxlXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudGl0bGUpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRoaXMudGl0bGUpO1xyXG4gICAgICAgICAgICBlbGVtZW50LnRpdGxlID0gdGhpcy50aXRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiKTtcclxuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJ0aXRsZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudG9vbHRpcCkge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0QXJpYUF0dHJpYnV0ZSA9IHByb21vdGVUb29sdGlwVG9MYWJlbFxyXG4gICAgICAgICAgICAgICAgPyB0aGlzLnRpdGxlXHJcbiAgICAgICAgICAgICAgICAgICAgPyBcImFyaWEtZGVzY3JpcHRpb25cIlxyXG4gICAgICAgICAgICAgICAgICAgIDogXCJhcmlhLWxhYmVsXCJcclxuICAgICAgICAgICAgICAgIDogXCJhcmlhLWRlc2NyaXB0aW9uXCI7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHRhcmdldEFyaWFBdHRyaWJ1dGUsIHRoaXMudG9vbHRpcCk7XHJcbiAgICAgICAgICAgIGVsZW1lbnQudGl0bGUgPSB0aGlzLnRvb2x0aXA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFjdGlvbi5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucGFyc2UuY2FsbCh0aGlzLCBzb3VyY2UsIGNvbnRleHQgPyBjb250ZXh0IDogbmV3IFNlcmlhbGl6YXRpb25Db250ZXh0KCkpO1xyXG4gICAgfTtcclxuICAgIEFjdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGJ1dHRvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xyXG4gICAgICAgIGJ1dHRvbkVsZW1lbnQudHlwZSA9IFwiYnV0dG9uXCI7XHJcbiAgICAgICAgYnV0dG9uRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XHJcbiAgICAgICAgYnV0dG9uRWxlbWVudC5zdHlsZS5hbGlnbkl0ZW1zID0gXCJjZW50ZXJcIjtcclxuICAgICAgICBidXR0b25FbGVtZW50LnN0eWxlLmp1c3RpZnlDb250ZW50ID0gXCJjZW50ZXJcIjtcclxuICAgICAgICBidXR0b25FbGVtZW50Lm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNFZmZlY3RpdmVseUVuYWJsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZXhlY3V0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlZEVsZW1lbnQgPSBidXR0b25FbGVtZW50O1xyXG4gICAgICAgIHRoaXMucmVuZGVyQnV0dG9uQ29udGVudCgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQ3NzQ2xhc3NlcygpO1xyXG4gICAgICAgIHRoaXMuc2V0dXBFbGVtZW50Rm9yQWNjZXNzaWJpbGl0eShidXR0b25FbGVtZW50KTtcclxuICAgIH07XHJcbiAgICBBY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2FjdGlvbkNvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uQ29sbGVjdGlvbi5hY3Rpb25FeGVjdXRlZCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yYWlzZUV4ZWN1dGVBY3Rpb25FdmVudCgpO1xyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxBZnRlckV4ZWN1dGUoKTtcclxuICAgIH07XHJcbiAgICBBY3Rpb24ucHJvdG90eXBlLnByZXBhcmVGb3JFeGVjdXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlZmVyZW5jZWRJbnB1dHMgPSB0aGlzLmdldFJlZmVyZW5jZWRJbnB1dHMoKTtcclxuICAgICAgICB2YXIgaW52YWxpZElucHV0cyA9IHRoaXMuaW50ZXJuYWxWYWxpZGF0ZUlucHV0cyhyZWZlcmVuY2VkSW5wdXRzKTtcclxuICAgICAgICBpZiAoaW52YWxpZElucHV0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGludmFsaWRJbnB1dHNbMF0uZm9jdXMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmludGVybmFsUHJlcGFyZUZvckV4ZWN1dGlvbihyZWZlcmVuY2VkSW5wdXRzKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBBY3Rpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fYWN0aW9uQ29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aW9uQ29sbGVjdGlvbi5yZW1vdmVBY3Rpb24odGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBBY3Rpb24ucHJvdG90eXBlLmdldEFsbElucHV0cyA9IGZ1bmN0aW9uIChwcm9jZXNzQWN0aW9ucykge1xyXG4gICAgICAgIGlmIChwcm9jZXNzQWN0aW9ucyA9PT0gdm9pZCAwKSB7IHByb2Nlc3NBY3Rpb25zID0gdHJ1ZTsgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH07XHJcbiAgICBBY3Rpb24ucHJvdG90eXBlLmdldEFsbEFjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzXTtcclxuICAgIH07XHJcbiAgICBBY3Rpb24ucHJvdG90eXBlLmdldFJlc291cmNlSW5mb3JtYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWNvblVybCA/IFt7IHVybDogdGhpcy5pY29uVXJsLCBtaW1lVHlwZTogXCJpbWFnZVwiIH1dIDogW107XHJcbiAgICB9O1xyXG4gICAgQWN0aW9uLnByb3RvdHlwZS5nZXRBY3Rpb25CeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgPT09IGlkID8gdGhpcyA6IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBBY3Rpb24ucHJvdG90eXBlLmdldFJlZmVyZW5jZWRJbnB1dHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxHZXRSZWZlcmVuY2VkSW5wdXRzKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIGlucHV0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQSBsaXN0IG9mIGlucHV0cyB0aGF0IGZhaWxlZCB2YWxpZGF0aW9uLCBvciBhbiBlbXB0eSBhcnJheSBpZiBubyBpbnB1dCBmYWlsZWQgdmFsaWRhdGlvbi5cclxuICAgICAqL1xyXG4gICAgQWN0aW9uLnByb3RvdHlwZS52YWxpZGF0ZUlucHV0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFZhbGlkYXRlSW5wdXRzKHRoaXMuZ2V0UmVmZXJlbmNlZElucHV0cygpKTtcclxuICAgIH07XHJcbiAgICBBY3Rpb24ucHJvdG90eXBlLnVwZGF0ZUVuYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGluIGJhc2UgaW1wbGVtZW50YXRpb25cclxuICAgIH07XHJcbiAgICBBY3Rpb24ucHJvdG90eXBlLmlzRWZmZWN0aXZlbHlFbmFibGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzRW5hYmxlZDtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aW9uLnByb3RvdHlwZSwgXCJpc1ByaW1hcnlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSA9PT0gRW51bXMuQWN0aW9uU3R5bGUuUG9zaXRpdmU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUgPSBFbnVtcy5BY3Rpb25TdHlsZS5Qb3NpdGl2ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlID09PSBFbnVtcy5BY3Rpb25TdHlsZS5Qb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUgPSBFbnVtcy5BY3Rpb25TdHlsZS5EZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGlvbi5wcm90b3R5cGUsIFwiaG9zdENvbmZpZ1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50Lmhvc3RDb25maWcgOiBob3N0X2NvbmZpZ18xLmRlZmF1bHRIb3N0Q29uZmlnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpb24ucHJvdG90eXBlLCBcInBhcmVudFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGlvbi5wcm90b3R5cGUsIFwic3RhdGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDc3NDbGFzc2VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aW9uLnByb3RvdHlwZSwgXCJpc0ZvY3VzYWJsZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0ZvY3VzYWJsZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0ZvY3VzYWJsZSAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzRm9jdXNhYmxlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNzc0NsYXNzZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEFjdGlvbi50aXRsZVByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCwgXCJ0aXRsZVwiKTtcclxuICAgIEFjdGlvbi5pY29uVXJsUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8xLCBcImljb25VcmxcIik7XHJcbiAgICBBY3Rpb24uc3R5bGVQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuVmFsdWVTZXRQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMiwgXCJzdHlsZVwiLCBbXHJcbiAgICAgICAgeyB2YWx1ZTogRW51bXMuQWN0aW9uU3R5bGUuRGVmYXVsdCB9LFxyXG4gICAgICAgIHsgdmFsdWU6IEVudW1zLkFjdGlvblN0eWxlLlBvc2l0aXZlIH0sXHJcbiAgICAgICAgeyB2YWx1ZTogRW51bXMuQWN0aW9uU3R5bGUuRGVzdHJ1Y3RpdmUgfVxyXG4gICAgXSwgRW51bXMuQWN0aW9uU3R5bGUuRGVmYXVsdCk7XHJcbiAgICBBY3Rpb24ubW9kZVByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5WYWx1ZVNldFByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV81LCBcIm1vZGVcIiwgW3sgdmFsdWU6IEVudW1zLkFjdGlvbk1vZGUuUHJpbWFyeSB9LCB7IHZhbHVlOiBFbnVtcy5BY3Rpb25Nb2RlLlNlY29uZGFyeSB9XSwgRW51bXMuQWN0aW9uTW9kZS5QcmltYXJ5KTtcclxuICAgIEFjdGlvbi50b29sdGlwUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV81LCBcInRvb2x0aXBcIik7XHJcbiAgICBBY3Rpb24uaXNFbmFibGVkUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLkJvb2xQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfNSwgXCJpc0VuYWJsZWRcIiwgdHJ1ZSk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShBY3Rpb24udGl0bGVQcm9wZXJ0eSlcclxuICAgIF0sIEFjdGlvbi5wcm90b3R5cGUsIFwidGl0bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEFjdGlvbi5pY29uVXJsUHJvcGVydHkpXHJcbiAgICBdLCBBY3Rpb24ucHJvdG90eXBlLCBcImljb25VcmxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEFjdGlvbi5zdHlsZVByb3BlcnR5KVxyXG4gICAgXSwgQWN0aW9uLnByb3RvdHlwZSwgXCJzdHlsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoQWN0aW9uLm1vZGVQcm9wZXJ0eSlcclxuICAgIF0sIEFjdGlvbi5wcm90b3R5cGUsIFwibW9kZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoQWN0aW9uLnRvb2x0aXBQcm9wZXJ0eSlcclxuICAgIF0sIEFjdGlvbi5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoQWN0aW9uLmlzRW5hYmxlZFByb3BlcnR5KVxyXG4gICAgXSwgQWN0aW9uLnByb3RvdHlwZSwgXCJpc0VuYWJsZWRcIiwgdm9pZCAwKTtcclxuICAgIHJldHVybiBBY3Rpb247XHJcbn0oY2FyZF9vYmplY3RfMS5DYXJkT2JqZWN0KSk7XHJcbmV4cG9ydHMuQWN0aW9uID0gQWN0aW9uO1xyXG52YXIgU3VibWl0QWN0aW9uQmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTdWJtaXRBY3Rpb25CYXNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU3VibWl0QWN0aW9uQmFzZSgpIHtcclxuICAgICAgICAvLyNyZWdpb24gU2NoZW1hXHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZGlzYWJsZWRVbmxlc3NBc3NvY2lhdGVkSW5wdXRzQ2hhbmdlID0gZmFsc2U7XHJcbiAgICAgICAgLy8jZW5kcmVnaW9uXHJcbiAgICAgICAgX3RoaXMuX2lzUHJlcGFyZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5fYXJlUmVmZXJlbmNlZElucHV0c0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgU3VibWl0QWN0aW9uQmFzZS5wcm90b3R5cGUuaW50ZXJuYWxHZXRSZWZlcmVuY2VkSW5wdXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICAgICBpZiAodGhpcy5hc3NvY2lhdGVkSW5wdXRzICE9PSBcIm5vbmVcIikge1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICB2YXIgaW5wdXRzID0gW107XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dHMucHVzaC5hcHBseShpbnB1dHMsIGN1cnJlbnQuZ2V0QWxsSW5wdXRzKGZhbHNlKSk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBpbnB1dHNfMSA9IGlucHV0czsgX2kgPCBpbnB1dHNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IGlucHV0c18xW19pXTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbnB1dC5pZF0gPSBpbnB1dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIFN1Ym1pdEFjdGlvbkJhc2UucHJvdG90eXBlLmludGVybmFsUHJlcGFyZUZvckV4ZWN1dGlvbiA9IGZ1bmN0aW9uIChpbnB1dHMpIHtcclxuICAgICAgICBpZiAodGhpcy5fb3JpZ2luYWxEYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NlZERhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuX29yaWdpbmFsRGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc2VkRGF0YSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcHJvY2Vzc2VkRGF0YSAmJiBpbnB1dHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKGlucHV0cyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gaW5wdXRzW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuaWQgJiYgaW5wdXQuaXNTZXQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NlZERhdGFbaW5wdXQuaWRdID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGlucHV0LnZhbHVlID09PSBcInN0cmluZ1wiID8gaW5wdXQudmFsdWUgOiBpbnB1dC52YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2lzUHJlcGFyZWQgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIFN1Ym1pdEFjdGlvbkJhc2UucHJvdG90eXBlLmludGVybmFsQWZ0ZXJFeGVjdXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChzaGFyZWRfMS5HbG9iYWxTZXR0aW5ncy5yZXNldElucHV0c0RpcnR5U3RhdGVBZnRlckFjdGlvbkV4ZWN1dGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0UmVmZXJlbmNlZElucHV0c0RpcnR5U3RhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgU3VibWl0QWN0aW9uQmFzZS5wcm90b3R5cGUucmVzZXRSZWZlcmVuY2VkSW5wdXRzRGlydHlTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVmZXJlbmNlZElucHV0cyA9IHRoaXMuZ2V0UmVmZXJlbmNlZElucHV0cygpO1xyXG4gICAgICAgIHRoaXMuX2FyZVJlZmVyZW5jZWRJbnB1dHNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChyZWZlcmVuY2VkSW5wdXRzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhyZWZlcmVuY2VkSW5wdXRzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSByZWZlcmVuY2VkSW5wdXRzW2tleV07XHJcbiAgICAgICAgICAgICAgICBpbnB1dC5yZXNldERpcnR5U3RhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTdWJtaXRBY3Rpb25CYXNlLnByb3RvdHlwZS51cGRhdGVFbmFibGVkU3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fYXJlUmVmZXJlbmNlZElucHV0c0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHJlZmVyZW5jZWRJbnB1dHMgPSB0aGlzLmdldFJlZmVyZW5jZWRJbnB1dHMoKTtcclxuICAgICAgICBpZiAocmVmZXJlbmNlZElucHV0cykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMocmVmZXJlbmNlZElucHV0cyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gcmVmZXJlbmNlZElucHV0c1trZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmlzRGlydHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FyZVJlZmVyZW5jZWRJbnB1dHNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVDc3NDbGFzc2VzKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlcmVkRWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldHVwRWxlbWVudEZvckFjY2Vzc2liaWxpdHkodGhpcy5fcmVuZGVyZWRFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgU3VibWl0QWN0aW9uQmFzZS5wcm90b3R5cGUuaXNFZmZlY3RpdmVseUVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IF9zdXBlci5wcm90b3R5cGUuaXNFZmZlY3RpdmVseUVuYWJsZWQuY2FsbCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZFVubGVzc0Fzc29jaWF0ZWRJbnB1dHNDaGFuZ2VcclxuICAgICAgICAgICAgPyByZXN1bHQgJiYgdGhpcy5fYXJlUmVmZXJlbmNlZElucHV0c0RpcnR5XHJcbiAgICAgICAgICAgIDogcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdWJtaXRBY3Rpb25CYXNlLnByb3RvdHlwZSwgXCJkYXRhXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzUHJlcGFyZWQgPyB0aGlzLl9wcm9jZXNzZWREYXRhIDogdGhpcy5fb3JpZ2luYWxEYXRhO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxEYXRhID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUHJlcGFyZWQgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBTdWJtaXRBY3Rpb25CYXNlLmRhdGFQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuUHJvcGVydHlEZWZpbml0aW9uKHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcImRhdGFcIik7XHJcbiAgICBTdWJtaXRBY3Rpb25CYXNlLmFzc29jaWF0ZWRJbnB1dHNQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuQ3VzdG9tUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzMsIFwiYXNzb2NpYXRlZElucHV0c1wiLCBmdW5jdGlvbiAoc2VuZGVyLCBwcm9wLCBzb3VyY2UsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcC5uYW1lXTtcclxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwibm9uZVwiID8gXCJub25lXCIgOiBcImF1dG9cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH0sIGZ1bmN0aW9uIChzZW5kZXIsIHByb3AsIHRhcmdldCwgdmFsdWUsIGNvbnRleHQpIHtcclxuICAgICAgICBjb250ZXh0LnNlcmlhbGl6ZVZhbHVlKHRhcmdldCwgcHJvcC5uYW1lLCB2YWx1ZSk7XHJcbiAgICB9KTtcclxuICAgIFN1Ym1pdEFjdGlvbkJhc2UuZGlzYWJsZWRVbmxlc3NBc3NvY2lhdGVkSW5wdXRzQ2hhbmdlUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLkJvb2xQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfNiwgXCJkaXNhYmxlZFVubGVzc0Fzc29jaWF0ZWRJbnB1dHNDaGFuZ2VcIiwgZmFsc2UpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoU3VibWl0QWN0aW9uQmFzZS5kYXRhUHJvcGVydHkpXHJcbiAgICBdLCBTdWJtaXRBY3Rpb25CYXNlLnByb3RvdHlwZSwgXCJfb3JpZ2luYWxEYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShTdWJtaXRBY3Rpb25CYXNlLmFzc29jaWF0ZWRJbnB1dHNQcm9wZXJ0eSlcclxuICAgIF0sIFN1Ym1pdEFjdGlvbkJhc2UucHJvdG90eXBlLCBcImFzc29jaWF0ZWRJbnB1dHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKFN1Ym1pdEFjdGlvbkJhc2UuZGlzYWJsZWRVbmxlc3NBc3NvY2lhdGVkSW5wdXRzQ2hhbmdlUHJvcGVydHkpXHJcbiAgICBdLCBTdWJtaXRBY3Rpb25CYXNlLnByb3RvdHlwZSwgXCJkaXNhYmxlZFVubGVzc0Fzc29jaWF0ZWRJbnB1dHNDaGFuZ2VcIiwgdm9pZCAwKTtcclxuICAgIHJldHVybiBTdWJtaXRBY3Rpb25CYXNlO1xyXG59KEFjdGlvbikpO1xyXG5leHBvcnRzLlN1Ym1pdEFjdGlvbkJhc2UgPSBTdWJtaXRBY3Rpb25CYXNlO1xyXG52YXIgU3VibWl0QWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFN1Ym1pdEFjdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFN1Ym1pdEFjdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBTdWJtaXRBY3Rpb24ucHJvdG90eXBlLmdldEpzb25UeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gU3VibWl0QWN0aW9uLkpzb25UeXBlTmFtZTtcclxuICAgIH07XHJcbiAgICAvLyBOb3RlIHRoZSBcIndlaXJkXCIgd2F5IHRoaXMgZmllbGQgaXMgZGVjbGFyZWQgaXMgdG8gd29yayBhcm91bmQgYSBicmVha2luZ1xyXG4gICAgLy8gY2hhbmdlIGludHJvZHVjZWQgaW4gVFMgMy4xIHdydCBkLnRzIGdlbmVyYXRpb24uIERPIE5PVCBDSEFOR0VcclxuICAgIFN1Ym1pdEFjdGlvbi5Kc29uVHlwZU5hbWUgPSBcIkFjdGlvbi5TdWJtaXRcIjtcclxuICAgIHJldHVybiBTdWJtaXRBY3Rpb247XHJcbn0oU3VibWl0QWN0aW9uQmFzZSkpO1xyXG5leHBvcnRzLlN1Ym1pdEFjdGlvbiA9IFN1Ym1pdEFjdGlvbjtcclxudmFyIEV4ZWN1dGVBY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRXhlY3V0ZUFjdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEV4ZWN1dGVBY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgICBFeGVjdXRlQWN0aW9uLnByb3RvdHlwZS5nZXRKc29uVHlwZU5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIEV4ZWN1dGVBY3Rpb24uSnNvblR5cGVOYW1lO1xyXG4gICAgfTtcclxuICAgIC8vIE5vdGUgdGhlIFwid2VpcmRcIiB3YXkgdGhpcyBmaWVsZCBpcyBkZWNsYXJlZCBpcyB0byB3b3JrIGFyb3VuZCBhIGJyZWFraW5nXHJcbiAgICAvLyBjaGFuZ2UgaW50cm9kdWNlZCBpbiBUUyAzLjEgd3J0IGQudHMgZ2VuZXJhdGlvbi4gRE8gTk9UIENIQU5HRVxyXG4gICAgRXhlY3V0ZUFjdGlvbi5Kc29uVHlwZU5hbWUgPSBcIkFjdGlvbi5FeGVjdXRlXCI7XHJcbiAgICAvLyNyZWdpb24gU2NoZW1hXHJcbiAgICBFeGVjdXRlQWN0aW9uLnZlcmJQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuU3RyaW5nUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzQsIFwidmVyYlwiKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEV4ZWN1dGVBY3Rpb24udmVyYlByb3BlcnR5KVxyXG4gICAgXSwgRXhlY3V0ZUFjdGlvbi5wcm90b3R5cGUsIFwidmVyYlwiLCB2b2lkIDApO1xyXG4gICAgcmV0dXJuIEV4ZWN1dGVBY3Rpb247XHJcbn0oU3VibWl0QWN0aW9uQmFzZSkpO1xyXG5leHBvcnRzLkV4ZWN1dGVBY3Rpb24gPSBFeGVjdXRlQWN0aW9uO1xyXG52YXIgT3BlblVybEFjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhPcGVuVXJsQWN0aW9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gT3BlblVybEFjdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBPcGVuVXJsQWN0aW9uLnByb3RvdHlwZS5nZXRKc29uVHlwZU5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIE9wZW5VcmxBY3Rpb24uSnNvblR5cGVOYW1lO1xyXG4gICAgfTtcclxuICAgIE9wZW5VcmxBY3Rpb24ucHJvdG90eXBlLmdldEFyaWFSb2xlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcImxpbmtcIjtcclxuICAgIH07XHJcbiAgICBPcGVuVXJsQWN0aW9uLnByb3RvdHlwZS5pbnRlcm5hbFZhbGlkYXRlUHJvcGVydGllcyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbnRlcm5hbFZhbGlkYXRlUHJvcGVydGllcy5jYWxsKHRoaXMsIGNvbnRleHQpO1xyXG4gICAgICAgIGlmICghdGhpcy51cmwpIHtcclxuICAgICAgICAgICAgY29udGV4dC5hZGRGYWlsdXJlKHRoaXMsIEVudW1zLlZhbGlkYXRpb25FdmVudC5Qcm9wZXJ0eUNhbnRCZU51bGwsIHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy5wcm9wZXJ0eU11c3RCZVNldChcInVybFwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9wZW5VcmxBY3Rpb24ucHJvdG90eXBlLmdldEhyZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsO1xyXG4gICAgfTtcclxuICAgIC8vI3JlZ2lvbiBTY2hlbWFcclxuICAgIE9wZW5VcmxBY3Rpb24udXJsUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcInVybFwiKTtcclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgLy8gTm90ZSB0aGUgXCJ3ZWlyZFwiIHdheSB0aGlzIGZpZWxkIGlzIGRlY2xhcmVkIGlzIHRvIHdvcmsgYXJvdW5kIGEgYnJlYWtpbmdcclxuICAgIC8vIGNoYW5nZSBpbnRyb2R1Y2VkIGluIFRTIDMuMSB3cnQgZC50cyBnZW5lcmF0aW9uLiBETyBOT1QgQ0hBTkdFXHJcbiAgICBPcGVuVXJsQWN0aW9uLkpzb25UeXBlTmFtZSA9IFwiQWN0aW9uLk9wZW5VcmxcIjtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKE9wZW5VcmxBY3Rpb24udXJsUHJvcGVydHkpXHJcbiAgICBdLCBPcGVuVXJsQWN0aW9uLnByb3RvdHlwZSwgXCJ1cmxcIiwgdm9pZCAwKTtcclxuICAgIHJldHVybiBPcGVuVXJsQWN0aW9uO1xyXG59KEFjdGlvbikpO1xyXG5leHBvcnRzLk9wZW5VcmxBY3Rpb24gPSBPcGVuVXJsQWN0aW9uO1xyXG52YXIgVG9nZ2xlVmlzaWJpbGl0eUFjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhUb2dnbGVWaXNpYmlsaXR5QWN0aW9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVG9nZ2xlVmlzaWJpbGl0eUFjdGlvbigpIHtcclxuICAgICAgICAvLyNyZWdpb24gU2NoZW1hXHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudGFyZ2V0RWxlbWVudHMgPSB7fTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBUb2dnbGVWaXNpYmlsaXR5QWN0aW9uLnByb3RvdHlwZS51cGRhdGVBcmlhQ29udHJvbHNBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gYXBwbHkgYXJpYSBsYWJlbHMgdG8gbWFrZSBpdCBjbGVhciB3aGljaCBlbGVtZW50cyB0aGlzIGFjdGlvbiB3aWxsIHRvZ2dsZVxyXG4gICAgICAgIGlmICh0aGlzLnRhcmdldEVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50SWRzID0gT2JqZWN0LmtleXModGhpcy50YXJnZXRFbGVtZW50cyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZW5kZXJlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50SWRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlZEVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1jb250cm9sc1wiLCBlbGVtZW50SWRzLmpvaW4oXCIgXCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWNvbnRyb2xzXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvZ2dsZVZpc2liaWxpdHlBY3Rpb24ucHJvdG90eXBlLmludGVybmFsVmFsaWRhdGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmludGVybmFsVmFsaWRhdGVQcm9wZXJ0aWVzLmNhbGwodGhpcywgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLnRhcmdldEVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYWRkRmFpbHVyZSh0aGlzLCBFbnVtcy5WYWxpZGF0aW9uRXZlbnQuUHJvcGVydHlDYW50QmVOdWxsLCBzdHJpbmdzXzEuU3RyaW5ncy5lcnJvcnMucHJvcGVydHlNdXN0QmVTZXQoXCJ0YXJnZXRFbGVtZW50c1wiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvZ2dsZVZpc2liaWxpdHlBY3Rpb24ucHJvdG90eXBlLmdldEpzb25UeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gVG9nZ2xlVmlzaWJpbGl0eUFjdGlvbi5Kc29uVHlwZU5hbWU7XHJcbiAgICB9O1xyXG4gICAgVG9nZ2xlVmlzaWJpbGl0eUFjdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVBcmlhQ29udHJvbHNBdHRyaWJ1dGUoKTtcclxuICAgIH07XHJcbiAgICBUb2dnbGVWaXNpYmlsaXR5QWN0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXhlY3V0ZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXModGhpcy50YXJnZXRFbGVtZW50cyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudElkID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEVsZW1lbnQgPSB0aGlzLnBhcmVudC5nZXRSb290RWxlbWVudCgpLmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy50YXJnZXRFbGVtZW50c1tlbGVtZW50SWRdID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50LmlzVmlzaWJsZSA9IHRoaXMudGFyZ2V0RWxlbWVudHNbZWxlbWVudElkXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuaXNWaXNpYmxlID0gIXRhcmdldEVsZW1lbnQuaXNWaXNpYmxlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb2dnbGVWaXNpYmlsaXR5QWN0aW9uLnByb3RvdHlwZS5hZGRUYXJnZXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnRJZCwgaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgaWYgKGlzVmlzaWJsZSA9PT0gdm9pZCAwKSB7IGlzVmlzaWJsZSA9IHVuZGVmaW5lZDsgfVxyXG4gICAgICAgIHRoaXMudGFyZ2V0RWxlbWVudHNbZWxlbWVudElkXSA9IGlzVmlzaWJsZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUFyaWFDb250cm9sc0F0dHJpYnV0ZSgpO1xyXG4gICAgfTtcclxuICAgIFRvZ2dsZVZpc2liaWxpdHlBY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRhcmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudElkKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMudGFyZ2V0RWxlbWVudHNbZWxlbWVudElkXTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUFyaWFDb250cm9sc0F0dHJpYnV0ZSgpO1xyXG4gICAgfTtcclxuICAgIFRvZ2dsZVZpc2liaWxpdHlBY3Rpb24udGFyZ2V0RWxlbWVudHNQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuQ3VzdG9tUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzIsIFwidGFyZ2V0RWxlbWVudHNcIiwgZnVuY3Rpb24gKHNlbmRlciwgcHJvcCwgc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZVtwcm9wLm5hbWVdKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gc291cmNlW3Byb3AubmFtZV07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpdGVtXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRJZCA9IGl0ZW1bXCJlbGVtZW50SWRcIl07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50SWQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2VsZW1lbnRJZF0gPSBVdGlscy5wYXJzZUJvb2woaXRlbVtcImlzVmlzaWJsZVwiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LCBmdW5jdGlvbiAoc2VuZGVyLCBwcm9wLCB0YXJnZXQsIHZhbHVlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHRhcmdldEVsZW1lbnRzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKHZhbHVlKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGlkID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlW2lkXSA9PT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRJZDogaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNWaXNpYmxlOiB2YWx1ZVtpZF1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudHMucHVzaChpZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGV4dC5zZXJpYWxpemVBcnJheSh0YXJnZXQsIHByb3AubmFtZSwgdGFyZ2V0RWxlbWVudHMpO1xyXG4gICAgfSwge30sIGZ1bmN0aW9uIChzZW5kZXIpIHtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9KTtcclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgLy8gTm90ZSB0aGUgXCJ3ZWlyZFwiIHdheSB0aGlzIGZpZWxkIGlzIGRlY2xhcmVkIGlzIHRvIHdvcmsgYXJvdW5kIGEgYnJlYWtpbmdcclxuICAgIC8vIGNoYW5nZSBpbnRyb2R1Y2VkIGluIFRTIDMuMSB3cnQgZC50cyBnZW5lcmF0aW9uLiBETyBOT1QgQ0hBTkdFXHJcbiAgICBUb2dnbGVWaXNpYmlsaXR5QWN0aW9uLkpzb25UeXBlTmFtZSA9IFwiQWN0aW9uLlRvZ2dsZVZpc2liaWxpdHlcIjtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKFRvZ2dsZVZpc2liaWxpdHlBY3Rpb24udGFyZ2V0RWxlbWVudHNQcm9wZXJ0eSlcclxuICAgIF0sIFRvZ2dsZVZpc2liaWxpdHlBY3Rpb24ucHJvdG90eXBlLCBcInRhcmdldEVsZW1lbnRzXCIsIHZvaWQgMCk7XHJcbiAgICByZXR1cm4gVG9nZ2xlVmlzaWJpbGl0eUFjdGlvbjtcclxufShBY3Rpb24pKTtcclxuZXhwb3J0cy5Ub2dnbGVWaXNpYmlsaXR5QWN0aW9uID0gVG9nZ2xlVmlzaWJpbGl0eUFjdGlvbjtcclxudmFyIFN0cmluZ1dpdGhTdWJzdGl0dXRpb25Qcm9wZXJ0eSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTdHJpbmdXaXRoU3Vic3RpdHV0aW9uUHJvcGVydHksIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTdHJpbmdXaXRoU3Vic3RpdHV0aW9uUHJvcGVydHkodGFyZ2V0VmVyc2lvbiwgbmFtZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRhcmdldFZlcnNpb24sIG5hbWUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHNoYXJlZF8xLlN0cmluZ1dpdGhTdWJzdGl0dXRpb25zKCk7XHJcbiAgICAgICAgfSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy50YXJnZXRWZXJzaW9uID0gdGFyZ2V0VmVyc2lvbjtcclxuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBTdHJpbmdXaXRoU3Vic3RpdHV0aW9uUHJvcGVydHkucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNlbmRlciwgc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBzaGFyZWRfMS5TdHJpbmdXaXRoU3Vic3RpdHV0aW9ucygpO1xyXG4gICAgICAgIHJlc3VsdC5zZXQoVXRpbHMucGFyc2VTdHJpbmcoc291cmNlW3RoaXMubmFtZV0pKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIFN0cmluZ1dpdGhTdWJzdGl0dXRpb25Qcm9wZXJ0eS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKHNlbmRlciwgdGFyZ2V0LCB2YWx1ZSwgY29udGV4dCkge1xyXG4gICAgICAgIGNvbnRleHQuc2VyaWFsaXplVmFsdWUodGFyZ2V0LCB0aGlzLm5hbWUsIHZhbHVlLmdldE9yaWdpbmFsKCkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTdHJpbmdXaXRoU3Vic3RpdHV0aW9uUHJvcGVydHk7XHJcbn0oc2VyaWFsaXphdGlvbl8xLlByb3BlcnR5RGVmaW5pdGlvbikpO1xyXG52YXIgSHR0cEhlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhIdHRwSGVhZGVyLCBfc3VwZXIpO1xyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgICBmdW5jdGlvbiBIdHRwSGVhZGVyKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gXCJcIjsgfVxyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gXCJcIjsgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBIdHRwSGVhZGVyLnByb3RvdHlwZS5nZXRTY2hlbWFLZXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiSHR0cEhlYWRlclwiO1xyXG4gICAgfTtcclxuICAgIEh0dHBIZWFkZXIucHJvdG90eXBlLmdldFJlZmVyZW5jZWRJbnB1dHMgPSBmdW5jdGlvbiAoaW5wdXRzLCByZWZlcmVuY2VkSW5wdXRzKSB7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUuZ2V0UmVmZXJlbmNlZElucHV0cyhpbnB1dHMsIHJlZmVyZW5jZWRJbnB1dHMpO1xyXG4gICAgfTtcclxuICAgIEh0dHBIZWFkZXIucHJvdG90eXBlLnByZXBhcmVGb3JFeGVjdXRpb24gPSBmdW5jdGlvbiAoaW5wdXRzKSB7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUuc3Vic3RpdHV0ZUlucHV0VmFsdWVzKGlucHV0cywgc2hhcmVkXzEuQ29udGVudFR5cGVzLmFwcGxpY2F0aW9uWFd3d0Zvcm1VcmxlbmNvZGVkKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSHR0cEhlYWRlci5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWUuZ2V0KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZS5zZXQobmV3VmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8vI3JlZ2lvbiBTY2hlbWFcclxuICAgIEh0dHBIZWFkZXIubmFtZVByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCwgXCJuYW1lXCIpO1xyXG4gICAgSHR0cEhlYWRlci52YWx1ZVByb3BlcnR5ID0gbmV3IFN0cmluZ1dpdGhTdWJzdGl0dXRpb25Qcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCwgXCJ2YWx1ZVwiKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEh0dHBIZWFkZXIubmFtZVByb3BlcnR5KVxyXG4gICAgXSwgSHR0cEhlYWRlci5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoSHR0cEhlYWRlci52YWx1ZVByb3BlcnR5KVxyXG4gICAgXSwgSHR0cEhlYWRlci5wcm90b3R5cGUsIFwiX3ZhbHVlXCIsIHZvaWQgMCk7XHJcbiAgICByZXR1cm4gSHR0cEhlYWRlcjtcclxufShzZXJpYWxpemF0aW9uXzEuU2VyaWFsaXphYmxlT2JqZWN0KSk7XHJcbmV4cG9ydHMuSHR0cEhlYWRlciA9IEh0dHBIZWFkZXI7XHJcbnZhciBIdHRwQWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEh0dHBBY3Rpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBIdHRwQWN0aW9uKCkge1xyXG4gICAgICAgIC8vI3JlZ2lvbiBTY2hlbWFcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5faWdub3JlSW5wdXRWYWxpZGF0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgSHR0cEFjdGlvbi5wcm90b3R5cGUuaW50ZXJuYWxHZXRSZWZlcmVuY2VkSW5wdXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhbGxJbnB1dHMgPSB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmdldFJvb3RFbGVtZW50KCkuZ2V0QWxsSW5wdXRzKCkgOiBbXTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgICAgdGhpcy5fdXJsLmdldFJlZmVyZW5jZWRJbnB1dHMoYWxsSW5wdXRzLCByZXN1bHQpO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmhlYWRlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGhlYWRlci5nZXRSZWZlcmVuY2VkSW5wdXRzKGFsbElucHV0cywgcmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYm9keS5nZXRSZWZlcmVuY2VkSW5wdXRzKGFsbElucHV0cywgcmVzdWx0KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIEh0dHBBY3Rpb24ucHJvdG90eXBlLmludGVybmFsUHJlcGFyZUZvckV4ZWN1dGlvbiA9IGZ1bmN0aW9uIChpbnB1dHMpIHtcclxuICAgICAgICBpZiAoaW5wdXRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VybC5zdWJzdGl0dXRlSW5wdXRWYWx1ZXMoaW5wdXRzLCBzaGFyZWRfMS5Db250ZW50VHlwZXMuYXBwbGljYXRpb25YV3d3Rm9ybVVybGVuY29kZWQpO1xyXG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSBzaGFyZWRfMS5Db250ZW50VHlwZXMuYXBwbGljYXRpb25Kc29uO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5oZWFkZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGhlYWRlci5wcmVwYXJlRm9yRXhlY3V0aW9uKGlucHV0cyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyLm5hbWUgJiYgaGVhZGVyLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gaGVhZGVyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2JvZHkuc3Vic3RpdHV0ZUlucHV0VmFsdWVzKGlucHV0cywgY29udGVudFR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBIdHRwQWN0aW9uLnByb3RvdHlwZS5nZXRKc29uVHlwZU5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIEh0dHBBY3Rpb24uSnNvblR5cGVOYW1lO1xyXG4gICAgfTtcclxuICAgIEh0dHBBY3Rpb24ucHJvdG90eXBlLmludGVybmFsVmFsaWRhdGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmludGVybmFsVmFsaWRhdGVQcm9wZXJ0aWVzLmNhbGwodGhpcywgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLnVybCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmFkZEZhaWx1cmUodGhpcywgRW51bXMuVmFsaWRhdGlvbkV2ZW50LlByb3BlcnR5Q2FudEJlTnVsbCwgc3RyaW5nc18xLlN0cmluZ3MuZXJyb3JzLnByb3BlcnR5TXVzdEJlU2V0KFwidXJsXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmhlYWRlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoZWFkZXIubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYWRkRmFpbHVyZSh0aGlzLCBFbnVtcy5WYWxpZGF0aW9uRXZlbnQuUHJvcGVydHlDYW50QmVOdWxsLCBzdHJpbmdzXzEuU3RyaW5ncy5lcnJvcnMuYWN0aW9uSHR0cEhlYWRlcnNNdXN0SGF2ZU5hbWVBbmRWYWx1ZSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSHR0cEFjdGlvbi5wcm90b3R5cGUsIFwiaWdub3JlSW5wdXRWYWxpZGF0aW9uXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lnbm9yZUlucHV0VmFsaWRhdGlvbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lnbm9yZUlucHV0VmFsaWRhdGlvbiA9IHZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIdHRwQWN0aW9uLnByb3RvdHlwZSwgXCJ1cmxcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXJsLmdldCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fdXJsLnNldCh2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEh0dHBBY3Rpb24ucHJvdG90eXBlLCBcImJvZHlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYm9keS5nZXQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvZHkuc2V0KHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBIdHRwQWN0aW9uLnVybFByb3BlcnR5ID0gbmV3IFN0cmluZ1dpdGhTdWJzdGl0dXRpb25Qcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCwgXCJ1cmxcIik7XHJcbiAgICBIdHRwQWN0aW9uLmJvZHlQcm9wZXJ0eSA9IG5ldyBTdHJpbmdXaXRoU3Vic3RpdHV0aW9uUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwiYm9keVwiKTtcclxuICAgIEh0dHBBY3Rpb24ubWV0aG9kUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcIm1ldGhvZFwiKTtcclxuICAgIEh0dHBBY3Rpb24uaGVhZGVyc1Byb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TZXJpYWxpemFibGVPYmplY3RDb2xsZWN0aW9uUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwiaGVhZGVyc1wiLCBIdHRwSGVhZGVyKTtcclxuICAgIEh0dHBBY3Rpb24uaWdub3JlSW5wdXRWYWxpZGF0aW9uUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLkJvb2xQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMywgXCJpZ25vcmVJbnB1dFZhbGlkYXRpb25cIiwgZmFsc2UpO1xyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgICAvLyBOb3RlIHRoZSBcIndlaXJkXCIgd2F5IHRoaXMgZmllbGQgaXMgZGVjbGFyZWQgaXMgdG8gd29yayBhcm91bmQgYSBicmVha2luZ1xyXG4gICAgLy8gY2hhbmdlIGludHJvZHVjZWQgaW4gVFMgMy4xIHdydCBkLnRzIGdlbmVyYXRpb24uIERPIE5PVCBDSEFOR0VcclxuICAgIEh0dHBBY3Rpb24uSnNvblR5cGVOYW1lID0gXCJBY3Rpb24uSHR0cFwiO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoSHR0cEFjdGlvbi51cmxQcm9wZXJ0eSlcclxuICAgIF0sIEh0dHBBY3Rpb24ucHJvdG90eXBlLCBcIl91cmxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEh0dHBBY3Rpb24uYm9keVByb3BlcnR5KVxyXG4gICAgXSwgSHR0cEFjdGlvbi5wcm90b3R5cGUsIFwiX2JvZHlcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEh0dHBBY3Rpb24ubWV0aG9kUHJvcGVydHkpXHJcbiAgICBdLCBIdHRwQWN0aW9uLnByb3RvdHlwZSwgXCJtZXRob2RcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEh0dHBBY3Rpb24uaGVhZGVyc1Byb3BlcnR5KVxyXG4gICAgXSwgSHR0cEFjdGlvbi5wcm90b3R5cGUsIFwiaGVhZGVyc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoSHR0cEFjdGlvbi5pZ25vcmVJbnB1dFZhbGlkYXRpb25Qcm9wZXJ0eSlcclxuICAgIF0sIEh0dHBBY3Rpb24ucHJvdG90eXBlLCBcIl9pZ25vcmVJbnB1dFZhbGlkYXRpb25cIiwgdm9pZCAwKTtcclxuICAgIHJldHVybiBIdHRwQWN0aW9uO1xyXG59KEFjdGlvbikpO1xyXG5leHBvcnRzLkh0dHBBY3Rpb24gPSBIdHRwQWN0aW9uO1xyXG52YXIgU2hvd0NhcmRBY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU2hvd0NhcmRBY3Rpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTaG93Q2FyZEFjdGlvbigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5jYXJkID0gbmV3IElubGluZUFkYXB0aXZlQ2FyZCgpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFNob3dDYXJkQWN0aW9uLnByb3RvdHlwZS51cGRhdGVDc3NDbGFzc2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlQ3NzQ2xhc3Nlcy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVkRWxlbWVudCkge1xyXG4gICAgICAgICAgICB2YXIgZWZmZWN0aXZlSG9zdENvbmZpZyA9IHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuaG9zdENvbmZpZyA6IGhvc3RfY29uZmlnXzEuZGVmYXVsdEhvc3RDb25maWc7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50LmNsYXNzTGlzdC5hZGQoZWZmZWN0aXZlSG9zdENvbmZpZy5tYWtlQ3NzQ2xhc3NOYW1lKFwiZXhwYW5kYWJsZVwiKSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgKHRoaXMuc3RhdGUgPT09IDEgLyogRXhwYW5kZWQgKi8pLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTaG93Q2FyZEFjdGlvbi5wcm90b3R5cGUuaW50ZXJuYWxQYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNvbnRleHQpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmludGVybmFsUGFyc2UuY2FsbCh0aGlzLCBzb3VyY2UsIGNvbnRleHQpO1xyXG4gICAgICAgIHZhciBqc29uQ2FyZCA9IHNvdXJjZVtcImNhcmRcIl07XHJcbiAgICAgICAgaWYgKGpzb25DYXJkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FyZC5wYXJzZShqc29uQ2FyZCwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb250ZXh0LmxvZ1BhcnNlRXZlbnQodGhpcywgRW51bXMuVmFsaWRhdGlvbkV2ZW50LlByb3BlcnR5Q2FudEJlTnVsbCwgc3RyaW5nc18xLlN0cmluZ3MuZXJyb3JzLnNob3dDYXJkTXVzdEhhdmVDYXJkKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTaG93Q2FyZEFjdGlvbi5wcm90b3R5cGUuaW50ZXJuYWxUb0pTT04gPSBmdW5jdGlvbiAodGFyZ2V0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbnRlcm5hbFRvSlNPTi5jYWxsKHRoaXMsIHRhcmdldCwgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FyZCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LnNlcmlhbGl6ZVZhbHVlKHRhcmdldCwgXCJjYXJkXCIsIHRoaXMuY2FyZC50b0pTT04oY29udGV4dCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTaG93Q2FyZEFjdGlvbi5wcm90b3R5cGUucmFpc2VFeGVjdXRlQWN0aW9uRXZlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaG9zdENvbmZpZy5hY3Rpb25zLnNob3dDYXJkLmFjdGlvbk1vZGUgPT09IEVudW1zLlNob3dDYXJkQWN0aW9uTW9kZS5Qb3B1cCkge1xyXG4gICAgICAgICAgICAvLyBPbmx5IHJhaXNlIHRoZSBldmVudCBpbiBQb3B1cCBtb2RlLlxyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJhaXNlRXhlY3V0ZUFjdGlvbkV2ZW50LmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNob3dDYXJkQWN0aW9uLnByb3RvdHlwZS5yZWxlYXNlRE9NUmVzb3VyY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVsZWFzZURPTVJlc291cmNlcy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuY2FyZC5yZWxlYXNlRE9NUmVzb3VyY2VzKCk7XHJcbiAgICB9O1xyXG4gICAgU2hvd0NhcmRBY3Rpb24ucHJvdG90eXBlLmdldEpzb25UeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gU2hvd0NhcmRBY3Rpb24uSnNvblR5cGVOYW1lO1xyXG4gICAgfTtcclxuICAgIFNob3dDYXJkQWN0aW9uLnByb3RvdHlwZS5pbnRlcm5hbFZhbGlkYXRlUHJvcGVydGllcyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbnRlcm5hbFZhbGlkYXRlUHJvcGVydGllcy5jYWxsKHRoaXMsIGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMuY2FyZC5pbnRlcm5hbFZhbGlkYXRlUHJvcGVydGllcyhjb250ZXh0KTtcclxuICAgIH07XHJcbiAgICBTaG93Q2FyZEFjdGlvbi5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5zZXRQYXJlbnQuY2FsbCh0aGlzLCB2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5jYXJkLnNldFBhcmVudCh2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgU2hvd0NhcmRBY3Rpb24ucHJvdG90eXBlLmdldEFsbElucHV0cyA9IGZ1bmN0aW9uIChwcm9jZXNzQWN0aW9ucykge1xyXG4gICAgICAgIGlmIChwcm9jZXNzQWN0aW9ucyA9PT0gdm9pZCAwKSB7IHByb2Nlc3NBY3Rpb25zID0gdHJ1ZTsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNhcmQuZ2V0QWxsSW5wdXRzKHByb2Nlc3NBY3Rpb25zKTtcclxuICAgIH07XHJcbiAgICBTaG93Q2FyZEFjdGlvbi5wcm90b3R5cGUuZ2V0QWxsQWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS5nZXRBbGxBY3Rpb25zLmNhbGwodGhpcyk7XHJcbiAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCB0aGlzLmNhcmQuZ2V0QWxsQWN0aW9ucygpKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIFNob3dDYXJkQWN0aW9uLnByb3RvdHlwZS5nZXRSZXNvdXJjZUluZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLmdldFJlc291cmNlSW5mb3JtYXRpb24uY2FsbCh0aGlzKTtcclxuICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIHRoaXMuY2FyZC5nZXRSZXNvdXJjZUluZm9ybWF0aW9uKCkpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgU2hvd0NhcmRBY3Rpb24ucHJvdG90eXBlLmdldEFjdGlvbkJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS5nZXRBY3Rpb25CeUlkLmNhbGwodGhpcywgaWQpO1xyXG4gICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2FyZC5nZXRBY3Rpb25CeUlkKGlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvLyBOb3RlIHRoZSBcIndlaXJkXCIgd2F5IHRoaXMgZmllbGQgaXMgZGVjbGFyZWQgaXMgdG8gd29yayBhcm91bmQgYSBicmVha2luZ1xyXG4gICAgLy8gY2hhbmdlIGludHJvZHVjZWQgaW4gVFMgMy4xIHdydCBkLnRzIGdlbmVyYXRpb24uIERPIE5PVCBDSEFOR0VcclxuICAgIFNob3dDYXJkQWN0aW9uLkpzb25UeXBlTmFtZSA9IFwiQWN0aW9uLlNob3dDYXJkXCI7XHJcbiAgICByZXR1cm4gU2hvd0NhcmRBY3Rpb247XHJcbn0oQWN0aW9uKSk7XHJcbmV4cG9ydHMuU2hvd0NhcmRBY3Rpb24gPSBTaG93Q2FyZEFjdGlvbjtcclxudmFyIE92ZXJmbG93QWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE92ZXJmbG93QWN0aW9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gT3ZlcmZsb3dBY3Rpb24oYWN0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX2FjdGlvbnMgPSBhY3Rpb25zO1xyXG4gICAgICAgIF90aGlzLnRpdGxlID0gc3RyaW5nc18xLlN0cmluZ3MuZGVmYXVsdHMub3ZlcmZsb3dCdXR0b25UZXh0KCk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT3ZlcmZsb3dBY3Rpb24ucHJvdG90eXBlLmdldEFjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbnM7XHJcbiAgICB9O1xyXG4gICAgT3ZlcmZsb3dBY3Rpb24ucHJvdG90eXBlLmdldEFsbEFjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IF9zdXBlci5wcm90b3R5cGUuZ2V0QWxsQWN0aW9ucy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgdGhpcy5fYWN0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBPdmVyZmxvd0FjdGlvbi5wcm90b3R5cGUuZ2V0SnNvblR5cGVOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBTaG93Q2FyZEFjdGlvbi5Kc29uVHlwZU5hbWU7XHJcbiAgICB9O1xyXG4gICAgT3ZlcmZsb3dBY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIHNob3VsZERpc3BsYXlQb3B1cE1lbnUgPSAhcmFpc2VEaXNwbGF5T3ZlcmZsb3dBY3Rpb25NZW51RXZlbnQodGhpcywgdGhpcy5yZW5kZXJlZEVsZW1lbnQpO1xyXG4gICAgICAgIGlmIChzaG91bGREaXNwbGF5UG9wdXBNZW51ICYmIHRoaXMucmVuZGVyZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBjb250ZXh0TWVudV8xID0gbmV3IGNvbnRyb2xzXzEuUG9wdXBNZW51KCk7XHJcbiAgICAgICAgICAgIGNvbnRleHRNZW51XzEuaG9zdENvbmZpZyA9IHRoaXMuaG9zdENvbmZpZztcclxuICAgICAgICAgICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lbnVJdGVtID0gbmV3IGNvbnRyb2xzXzEuTWVudUl0ZW0oaS50b1N0cmluZygpLCAoX2EgPSB0aGlzXzEuX2FjdGlvbnNbaV0udGl0bGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgbWVudUl0ZW0uaXNFbmFibGVkID0gdGhpc18xLl9hY3Rpb25zW2ldLmlzRW5hYmxlZDtcclxuICAgICAgICAgICAgICAgIG1lbnVJdGVtLm9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGlvblRvRXhlY3V0ZSA9IF90aGlzLl9hY3Rpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRNZW51XzEuY2xvc2VQb3B1cChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvblRvRXhlY3V0ZS5pc0VuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uVG9FeGVjdXRlLmV4ZWN1dGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY29udGV4dE1lbnVfMS5pdGVtcy5hZGQobWVudUl0ZW0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9hY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBfbG9vcF8yKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHRNZW51XzEucG9wdXAodGhpcy5yZW5kZXJlZEVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPdmVyZmxvd0FjdGlvbi5Kc29uVHlwZU5hbWUgPSBcIkFjdGlvbi5PdmVyZmxvd1wiO1xyXG4gICAgcmV0dXJuIE92ZXJmbG93QWN0aW9uO1xyXG59KEFjdGlvbikpO1xyXG52YXIgQWN0aW9uQ29sbGVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFjdGlvbkNvbGxlY3Rpb24ob3duZXIpIHtcclxuICAgICAgICB0aGlzLl9pdGVtcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVkQWN0aW9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX293bmVyID0gb3duZXI7XHJcbiAgICB9XHJcbiAgICBBY3Rpb25Db2xsZWN0aW9uLnByb3RvdHlwZS5pc0FjdGlvbkFsbG93ZWQgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIGZvcmJpZGRlblR5cGVzID0gdGhpcy5fb3duZXIuZ2V0Rm9yYmlkZGVuQWN0aW9uVHlwZXMoKTtcclxuICAgICAgICBpZiAoZm9yYmlkZGVuVHlwZXMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBmb3JiaWRkZW5UeXBlc18xID0gZm9yYmlkZGVuVHlwZXM7IF9pIDwgZm9yYmlkZGVuVHlwZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBmb3JiaWRkZW5UeXBlID0gZm9yYmlkZGVuVHlwZXNfMVtfaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLmNvbnN0cnVjdG9yID09PSBmb3JiaWRkZW5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIEFjdGlvbkNvbGxlY3Rpb24ucHJvdG90eXBlLnJlZnJlc2hDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY2xlYXJFbGVtZW50KHRoaXMuX2FjdGlvbkNhcmRDb250YWluZXIpO1xyXG4gICAgICAgIGlmICghdGhpcy5fYWN0aW9uQ2FyZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25DYXJkQ29udGFpbmVyLnN0eWxlLm1hcmdpblRvcCA9IFwiMHB4XCI7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYWN0aW9uQ2FyZENvbnRhaW5lci5zdHlsZS5tYXJnaW5Ub3AgPVxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVkQWN0aW9uQ291bnQgPiAwXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMuX293bmVyLmhvc3RDb25maWcuYWN0aW9ucy5zaG93Q2FyZC5pbmxpbmVUb3BNYXJnaW4gKyBcInB4XCJcclxuICAgICAgICAgICAgICAgIDogXCIwcHhcIjtcclxuICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuX293bmVyLmdldEVmZmVjdGl2ZVBhZGRpbmcoKTtcclxuICAgICAgICB0aGlzLl9vd25lci5nZXRJbW1lZGlhdGVTdXJyb3VuZGluZ1BhZGRpbmcocGFkZGluZyk7XHJcbiAgICAgICAgdmFyIHBoeXNpY2FsUGFkZGluZyA9IHRoaXMuX293bmVyLmhvc3RDb25maWcucGFkZGluZ0RlZmluaXRpb25Ub1NwYWNpbmdEZWZpbml0aW9uKHBhZGRpbmcpO1xyXG4gICAgICAgIGlmICh0aGlzLl9hY3Rpb25DYXJkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbkNhcmQuc3R5bGUucGFkZGluZ0xlZnQgPSBwaHlzaWNhbFBhZGRpbmcubGVmdCArIFwicHhcIjtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uQ2FyZC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBwaHlzaWNhbFBhZGRpbmcucmlnaHQgKyBcInB4XCI7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbkNhcmQuc3R5bGUubWFyZ2luTGVmdCA9IFwiLVwiICsgcGh5c2ljYWxQYWRkaW5nLmxlZnQgKyBcInB4XCI7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbkNhcmQuc3R5bGUubWFyZ2luUmlnaHQgPSBcIi1cIiArIHBoeXNpY2FsUGFkZGluZy5yaWdodCArIFwicHhcIjtcclxuICAgICAgICAgICAgaWYgKHBoeXNpY2FsUGFkZGluZy5ib3R0b20gIT09IDAgJiYgIXRoaXMuX293bmVyLmlzRGVzaWduTW9kZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25DYXJkLnN0eWxlLnBhZGRpbmdCb3R0b20gPSBwaHlzaWNhbFBhZGRpbmcuYm90dG9tICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9uQ2FyZC5zdHlsZS5tYXJnaW5Cb3R0b20gPSBcIi1cIiArIHBoeXNpY2FsUGFkZGluZy5ib3R0b20gKyBcInB4XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVXRpbHMuYXBwZW5kQ2hpbGQodGhpcy5fYWN0aW9uQ2FyZENvbnRhaW5lciwgdGhpcy5fYWN0aW9uQ2FyZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFjdGlvbkNvbGxlY3Rpb24ucHJvdG90eXBlLmxheW91dENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fb3duZXIuZ2V0Um9vdEVsZW1lbnQoKS51cGRhdGVMYXlvdXQoKTtcclxuICAgIH07XHJcbiAgICBBY3Rpb25Db2xsZWN0aW9uLnByb3RvdHlwZS5zaG93QWN0aW9uQ2FyZCA9IGZ1bmN0aW9uIChhY3Rpb24sIHN1cHByZXNzU3R5bGUsIHJhaXNlRXZlbnQpIHtcclxuICAgICAgICBpZiAoc3VwcHJlc3NTdHlsZSA9PT0gdm9pZCAwKSB7IHN1cHByZXNzU3R5bGUgPSBmYWxzZTsgfVxyXG4gICAgICAgIGlmIChyYWlzZUV2ZW50ID09PSB2b2lkIDApIHsgcmFpc2VFdmVudCA9IHRydWU7IH1cclxuICAgICAgICBhY3Rpb24uY2FyZC5zdXBwcmVzc1N0eWxlID0gc3VwcHJlc3NTdHlsZTtcclxuICAgICAgICAvLyBBbHdheXMgcmUtcmVuZGVyIGEgU2hvd0NhcmQgYWN0aW9uIGluIGRlc2lnbiBtb2RlOyByZXVzZSBhbHJlYWR5IHJlbmRlcmVkIFNob3dDYXJkIChpZiBhdmFpbGFibGUpIG90aGVyd2lzZVxyXG4gICAgICAgIHZhciByZW5kZXJlZENhcmQgPSBhY3Rpb24uY2FyZC5yZW5kZXJlZEVsZW1lbnQgJiYgIXRoaXMuX293bmVyLmlzRGVzaWduTW9kZSgpXHJcbiAgICAgICAgICAgID8gYWN0aW9uLmNhcmQucmVuZGVyZWRFbGVtZW50XHJcbiAgICAgICAgICAgIDogYWN0aW9uLmNhcmQucmVuZGVyKCk7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9uQ2FyZCA9IHJlbmRlcmVkQ2FyZDtcclxuICAgICAgICB0aGlzLl9leHBhbmRlZEFjdGlvbiA9IGFjdGlvbjtcclxuICAgICAgICB0aGlzLnJlZnJlc2hDb250YWluZXIoKTtcclxuICAgICAgICBpZiAocmFpc2VFdmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmxheW91dENoYW5nZWQoKTtcclxuICAgICAgICAgICAgcmFpc2VJbmxpbmVDYXJkRXhwYW5kZWRFdmVudChhY3Rpb24sIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBY3Rpb25Db2xsZWN0aW9uLnByb3RvdHlwZS5jb2xsYXBzZUV4cGFuZGVkQWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9yZW5kZXJlZEFjdGlvbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGFjdGlvbi5zdGF0ZSA9IDAgLyogTm9ybWFsICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJldmlvdXNseUV4cGFuZGVkQWN0aW9uID0gdGhpcy5fZXhwYW5kZWRBY3Rpb247XHJcbiAgICAgICAgdGhpcy5fZXhwYW5kZWRBY3Rpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9uQ2FyZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnJlZnJlc2hDb250YWluZXIoKTtcclxuICAgICAgICBpZiAocHJldmlvdXNseUV4cGFuZGVkQWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Q2hhbmdlZCgpO1xyXG4gICAgICAgICAgICByYWlzZUlubGluZUNhcmRFeHBhbmRlZEV2ZW50KHByZXZpb3VzbHlFeHBhbmRlZEFjdGlvbiwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBY3Rpb25Db2xsZWN0aW9uLnByb3RvdHlwZS5leHBhbmRTaG93Q2FyZEFjdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24sIHJhaXNlRXZlbnQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBhZnRlclNlbGVjdGVkQWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX3JlbmRlcmVkQWN0aW9uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHJlbmRlcmVkQWN0aW9uID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgYWN0aW9ucyBhZnRlciBzZWxlY3RlZCBhY3Rpb24gZnJvbSB0YWJPcmRlciBpZiB0aGUgYWN0aW9ucyBhcmUgb3JpZW50ZWQgaG9yaXpvbnRhbGx5LCB0byBza2lwIGZvY3VzIGRpcmVjdGx5IHRvIGV4cGFuZGVkIGNhcmRcclxuICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyLmhvc3RDb25maWcuYWN0aW9ucy5hY3Rpb25zT3JpZW50YXRpb24gPT0gRW51bXMuT3JpZW50YXRpb24uSG9yaXpvbnRhbCAmJlxyXG4gICAgICAgICAgICAgICAgYWZ0ZXJTZWxlY3RlZEFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRBY3Rpb24uaXNGb2N1c2FibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVuZGVyZWRBY3Rpb24gIT09IGFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRBY3Rpb24uc3RhdGUgPSAyIC8qIFN1YmR1ZWQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlZEFjdGlvbi5zdGF0ZSA9IDEgLyogRXhwYW5kZWQgKi87XHJcbiAgICAgICAgICAgICAgICBhZnRlclNlbGVjdGVkQWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJlZEFjdGlvbi5yZW5kZXJlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZEFjdGlvbi5yZW5kZXJlZEVsZW1lbnQub25ibHVyID0gZnVuY3Rpb24gKF9lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBfdGhpcy5fcmVuZGVyZWRBY3Rpb25zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmEuaXNGb2N1c2FibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNob3dBY3Rpb25DYXJkKGFjdGlvbiwgISh0aGlzLl9vd25lci5pc0F0VGhlVmVyeUxlZnQoKSAmJiB0aGlzLl9vd25lci5pc0F0VGhlVmVyeVJpZ2h0KCkpLCByYWlzZUV2ZW50KTtcclxuICAgIH07XHJcbiAgICBBY3Rpb25Db2xsZWN0aW9uLnByb3RvdHlwZS5yZWxlYXNlRE9NUmVzb3VyY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9yZW5kZXJlZEFjdGlvbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGFjdGlvbi5yZWxlYXNlRE9NUmVzb3VyY2VzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFjdGlvbkNvbGxlY3Rpb24ucHJvdG90eXBlLmFjdGlvbkV4ZWN1dGVkID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIGlmICghKGFjdGlvbiBpbnN0YW5jZW9mIFNob3dDYXJkQWN0aW9uKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxhcHNlRXhwYW5kZWRBY3Rpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT09IHRoaXMuX2V4cGFuZGVkQWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxhcHNlRXhwYW5kZWRBY3Rpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9vd25lci5ob3N0Q29uZmlnLmFjdGlvbnMuc2hvd0NhcmQuYWN0aW9uTW9kZSA9PT1cclxuICAgICAgICAgICAgICAgIEVudW1zLlNob3dDYXJkQWN0aW9uTW9kZS5JbmxpbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kU2hvd0NhcmRBY3Rpb24oYWN0aW9uLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBY3Rpb25Db2xsZWN0aW9uLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNvdXJjZV8xID0gc291cmNlOyBfaSA8IHNvdXJjZV8xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGpzb25BY3Rpb24gPSBzb3VyY2VfMVtfaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9yYmlkZGVuQWN0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFjdGlvbiBvd25lciBpcyBhIENvbnRhaW5lcldpdGhBY3Rpb25zLCB3ZSBzaG91bGQgY2hlY2sgZm9yIGZvcmJpZGRlbiBhY3Rpb25zXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3duZXIgaW5zdGFuY2VvZiBDb250YWluZXJXaXRoQWN0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcmJpZGRlbkFjdGlvbnMgPSB0aGlzLl9vd25lci5nZXRGb3JiaWRkZW5BY3Rpb25OYW1lcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGNvbnRleHQucGFyc2VBY3Rpb24odGhpcy5fb3duZXIsIGpzb25BY3Rpb24sIGZvcmJpZGRlbkFjdGlvbnMsICF0aGlzLl9vd25lci5pc0Rlc2lnbk1vZGUoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRBY3Rpb24oYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBY3Rpb25Db2xsZWN0aW9uLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIGNvbnRleHQpIHtcclxuICAgICAgICBjb250ZXh0LnNlcmlhbGl6ZUFycmF5KHRhcmdldCwgcHJvcGVydHlOYW1lLCB0aGlzLl9pdGVtcyk7XHJcbiAgICB9O1xyXG4gICAgQWN0aW9uQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0QWN0aW9uQXQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbaWRdO1xyXG4gICAgfTtcclxuICAgIEFjdGlvbkNvbGxlY3Rpb24ucHJvdG90eXBlLmdldEFjdGlvbkNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgQWN0aW9uQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0QWN0aW9uQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX2l0ZW1zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgaXRlbSA9IF9hW19pXTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gaXRlbS5nZXRBY3Rpb25CeUlkKGlkKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBBY3Rpb25Db2xsZWN0aW9uLnByb3RvdHlwZS52YWxpZGF0ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9vd25lci5ob3N0Q29uZmlnLmFjdGlvbnMubWF4QWN0aW9ucyAmJlxyXG4gICAgICAgICAgICB0aGlzLl9pdGVtcy5sZW5ndGggPiB0aGlzLl9vd25lci5ob3N0Q29uZmlnLmFjdGlvbnMubWF4QWN0aW9ucykge1xyXG4gICAgICAgICAgICBjb250ZXh0LmFkZEZhaWx1cmUodGhpcy5fb3duZXIsIEVudW1zLlZhbGlkYXRpb25FdmVudC5Ub29NYW55QWN0aW9ucywgc3RyaW5nc18xLlN0cmluZ3MuZXJyb3JzLnRvb01hbnlBY3Rpb25zKHRoaXMuX293bmVyLmhvc3RDb25maWcuYWN0aW9ucy5tYXhBY3Rpb25zKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9pdGVtcy5sZW5ndGggPiAwICYmICF0aGlzLl9vd25lci5ob3N0Q29uZmlnLnN1cHBvcnRzSW50ZXJhY3Rpdml0eSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmFkZEZhaWx1cmUodGhpcy5fb3duZXIsIEVudW1zLlZhbGlkYXRpb25FdmVudC5JbnRlcmFjdGl2aXR5Tm90QWxsb3dlZCwgc3RyaW5nc18xLlN0cmluZ3MuZXJyb3JzLmludGVyYWN0aXZpdHlOb3RBbGxvd2VkKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5faXRlbXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBpdGVtID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNBY3Rpb25BbGxvd2VkKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFkZEZhaWx1cmUodGhpcy5fb3duZXIsIEVudW1zLlZhbGlkYXRpb25FdmVudC5BY3Rpb25UeXBlTm90QWxsb3dlZCwgc3RyaW5nc18xLlN0cmluZ3MuZXJyb3JzLmFjdGlvblR5cGVOb3RBbGxvd2VkKGl0ZW0uZ2V0SnNvblR5cGVOYW1lKCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpdGVtLmludGVybmFsVmFsaWRhdGVQcm9wZXJ0aWVzKGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBY3Rpb25Db2xsZWN0aW9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAob3JpZW50YXRpb24pIHtcclxuICAgICAgICAvLyBDYWNoZSBob3N0Q29uZmlnIGZvciBiZXR0ZXIgcGVyZlxyXG4gICAgICAgIHZhciBob3N0Q29uZmlnID0gdGhpcy5fb3duZXIuaG9zdENvbmZpZztcclxuICAgICAgICBpZiAoIWhvc3RDb25maWcuc3VwcG9ydHNJbnRlcmFjdGl2aXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICB2YXIgbWF4QWN0aW9ucyA9IGhvc3RDb25maWcuYWN0aW9ucy5tYXhBY3Rpb25zXHJcbiAgICAgICAgICAgID8gTWF0aC5taW4oaG9zdENvbmZpZy5hY3Rpb25zLm1heEFjdGlvbnMsIHRoaXMuX2l0ZW1zLmxlbmd0aClcclxuICAgICAgICAgICAgOiB0aGlzLl9pdGVtcy5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9uQ2FyZENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZWRBY3Rpb25zID0gW107XHJcbiAgICAgICAgaWYgKGhvc3RDb25maWcuYWN0aW9ucy5wcmVFeHBhbmRTaW5nbGVTaG93Q2FyZEFjdGlvbiAmJlxyXG4gICAgICAgICAgICBtYXhBY3Rpb25zID09PSAxICYmXHJcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zWzBdIGluc3RhbmNlb2YgU2hvd0NhcmRBY3Rpb24gJiZcclxuICAgICAgICAgICAgdGhpcy5pc0FjdGlvbkFsbG93ZWQodGhpcy5faXRlbXNbMF0pKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd0FjdGlvbkNhcmQodGhpcy5faXRlbXNbMF0sIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlZEFjdGlvbnMucHVzaCh0aGlzLl9pdGVtc1swXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgYnV0dG9uU3RyaXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICBidXR0b25TdHJpcC5jbGFzc05hbWUgPSBob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1hY3Rpb25TZXRcIik7XHJcbiAgICAgICAgICAgIGJ1dHRvblN0cmlwLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcclxuICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBFbnVtcy5PcmllbnRhdGlvbi5Ib3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICBidXR0b25TdHJpcC5zdHlsZS5mbGV4RGlyZWN0aW9uID0gXCJyb3dcIjtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vd25lci5ob3Jpem9udGFsQWxpZ25tZW50ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdENvbmZpZy5hY3Rpb25zLmFjdGlvbkFsaWdubWVudCAhPT0gRW51bXMuQWN0aW9uQWxpZ25tZW50LlN0cmV0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX293bmVyLmhvcml6b250YWxBbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbnVtcy5Ib3Jpem9udGFsQWxpZ25tZW50LkNlbnRlcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvblN0cmlwLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gXCJjZW50ZXJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVudW1zLkhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25TdHJpcC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiZmxleC1lbmRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uU3RyaXAuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSBcImZsZXgtc3RhcnRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoaG9zdENvbmZpZy5hY3Rpb25zLmFjdGlvbkFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVudW1zLkFjdGlvbkFsaWdubWVudC5DZW50ZXI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25TdHJpcC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbnVtcy5BY3Rpb25BbGlnbm1lbnQuUmlnaHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25TdHJpcC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiZmxleC1lbmRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uU3RyaXAuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSBcImZsZXgtc3RhcnRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJ1dHRvblN0cmlwLnN0eWxlLmZsZXhEaXJlY3Rpb24gPSBcImNvbHVtblwiO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyLmhvcml6b250YWxBbGlnbm1lbnQgJiZcclxuICAgICAgICAgICAgICAgICAgICBob3N0Q29uZmlnLmFjdGlvbnMuYWN0aW9uQWxpZ25tZW50ICE9PSBFbnVtcy5BY3Rpb25BbGlnbm1lbnQuU3RyZXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fb3duZXIuaG9yaXpvbnRhbEFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVudW1zLkhvcml6b250YWxBbGlnbm1lbnQuQ2VudGVyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uU3RyaXAuc3R5bGUuYWxpZ25JdGVtcyA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbnVtcy5Ib3Jpem9udGFsQWxpZ25tZW50LlJpZ2h0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uU3RyaXAuc3R5bGUuYWxpZ25JdGVtcyA9IFwiZmxleC1lbmRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uU3RyaXAuc3R5bGUuYWxpZ25JdGVtcyA9IFwiZmxleC1zdGFydFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChob3N0Q29uZmlnLmFjdGlvbnMuYWN0aW9uQWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW51bXMuQWN0aW9uQWxpZ25tZW50LkNlbnRlcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvblN0cmlwLnN0eWxlLmFsaWduSXRlbXMgPSBcImNlbnRlclwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRW51bXMuQWN0aW9uQWxpZ25tZW50LlJpZ2h0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uU3RyaXAuc3R5bGUuYWxpZ25JdGVtcyA9IFwiZmxleC1lbmRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVudW1zLkFjdGlvbkFsaWdubWVudC5TdHJldGNoOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uU3RyaXAuc3R5bGUuYWxpZ25JdGVtcyA9IFwic3RyZXRjaFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25TdHJpcC5zdHlsZS5hbGlnbkl0ZW1zID0gXCJmbGV4LXN0YXJ0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFsbG93ZWRBY3Rpb25zID0gdGhpcy5faXRlbXMuZmlsdGVyKHRoaXMuaXNBY3Rpb25BbGxvd2VkLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICB2YXIgcHJpbWFyeUFjdGlvbnNfMSA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgc2Vjb25kYXJ5QWN0aW9uc18xID0gW107XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fb3duZXIuaXNEZXNpZ25Nb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgIGFsbG93ZWRBY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb24ubW9kZSA9PT0gRW51bXMuQWN0aW9uTW9kZS5TZWNvbmRhcnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWNvbmRhcnlBY3Rpb25zXzEucHVzaChhY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcHJpbWFyeUFjdGlvbnNfMS5wdXNoKGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIElmIHByaW1hcnlBY3Rpb25zLmxlbmd0aCA+IG1heEFjdGlvbnMsIGV4dHJhIGFjdGlvbnMgYXJlIG1vdmVkIHRvIG92ZXJmbG93XHJcbiAgICAgICAgICAgICAgICB2YXIgb3ZlcmZsb3dQcmltYXJ5QWN0aW9ucyA9IHByaW1hcnlBY3Rpb25zXzEuc3BsaWNlKGhvc3RDb25maWcuYWN0aW9ucy5tYXhBY3Rpb25zKTtcclxuICAgICAgICAgICAgICAgIGlmIChzaGFyZWRfMS5HbG9iYWxTZXR0aW5ncy5hbGxvd01vcmVUaGFuTWF4QWN0aW9uc0luT3ZlcmZsb3dNZW51KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kYXJ5QWN0aW9uc18xLnB1c2guYXBwbHkoc2Vjb25kYXJ5QWN0aW9uc18xLCBvdmVyZmxvd1ByaW1hcnlBY3Rpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzaG91bGRSZW5kZXJPdmVyZmxvd0FjdGlvbkJ1dHRvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2Vjb25kYXJ5QWN0aW9uc18xLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX292ZXJmbG93QWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX292ZXJmbG93QWN0aW9uID0gbmV3IE92ZXJmbG93QWN0aW9uKHNlY29uZGFyeUFjdGlvbnNfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX292ZXJmbG93QWN0aW9uLnNldFBhcmVudCh0aGlzLl9vd25lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX292ZXJmbG93QWN0aW9uW1wiX2FjdGlvbkNvbGxlY3Rpb25cIl0gPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNSb290QWN0aW9uID0gdGhpcy5fb3duZXIgaW5zdGFuY2VvZiBBZGFwdGl2ZUNhcmQgJiYgIXRoaXMuX293bmVyLnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICBzaG91bGRSZW5kZXJPdmVyZmxvd0FjdGlvbkJ1dHRvbiA9ICFyYWlzZVJlbmRlck92ZXJmbG93QWN0aW9uc0V2ZW50KHRoaXMuX292ZXJmbG93QWN0aW9uLCBpc1Jvb3RBY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX292ZXJmbG93QWN0aW9uICYmIHNob3VsZFJlbmRlck92ZXJmbG93QWN0aW9uQnV0dG9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUFjdGlvbnNfMS5wdXNoKHRoaXMuX292ZXJmbG93QWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHByaW1hcnlBY3Rpb25zXzEgPSBhbGxvd2VkQWN0aW9ucztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW1hcnlBY3Rpb25zXzEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBwcmltYXJ5QWN0aW9uc18xW2ldO1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uLnJlbmRlcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbi5yZW5kZXJlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaG9zdENvbmZpZy5hY3Rpb25zLmFjdGlvbnNPcmllbnRhdGlvbiA9PT0gRW51bXMuT3JpZW50YXRpb24uSG9yaXpvbnRhbCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0Q29uZmlnLmFjdGlvbnMuYWN0aW9uQWxpZ25tZW50ID09PSBFbnVtcy5BY3Rpb25BbGlnbm1lbnQuU3RyZXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24ucmVuZGVyZWRFbGVtZW50LnN0eWxlLmZsZXggPSBcIjAgMSAxMDAlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24ucmVuZGVyZWRFbGVtZW50LnN0eWxlLmZsZXggPSBcIjAgMSBhdXRvXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvblN0cmlwLmFwcGVuZENoaWxkKGFjdGlvbi5yZW5kZXJlZEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkQWN0aW9ucy5wdXNoKGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBwcmltYXJ5QWN0aW9uc18xLmxlbmd0aCAtIDEgJiYgaG9zdENvbmZpZy5hY3Rpb25zLmJ1dHRvblNwYWNpbmcgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGFjZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT09IEVudW1zLk9yaWVudGF0aW9uLkhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlci5zdHlsZS5mbGV4ID0gXCIwIDAgYXV0b1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2VyLnN0eWxlLndpZHRoID0gaG9zdENvbmZpZy5hY3Rpb25zLmJ1dHRvblNwYWNpbmcgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFjZXIuc3R5bGUuaGVpZ2h0ID0gaG9zdENvbmZpZy5hY3Rpb25zLmJ1dHRvblNwYWNpbmcgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMuYXBwZW5kQ2hpbGQoYnV0dG9uU3RyaXAsIHNwYWNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBidXR0b25TdHJpcENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIGJ1dHRvblN0cmlwQ29udGFpbmVyLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcclxuICAgICAgICAgICAgYnV0dG9uU3RyaXBDb250YWluZXIuYXBwZW5kQ2hpbGQoYnV0dG9uU3RyaXApO1xyXG4gICAgICAgICAgICBVdGlscy5hcHBlbmRDaGlsZChlbGVtZW50LCBidXR0b25TdHJpcENvbnRhaW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFV0aWxzLmFwcGVuZENoaWxkKGVsZW1lbnQsIHRoaXMuX2FjdGlvbkNhcmRDb250YWluZXIpO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9yZW5kZXJlZEFjdGlvbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByZW5kZXJlZEFjdGlvbiA9IF9hW19pXTtcclxuICAgICAgICAgICAgaWYgKHJlbmRlcmVkQWN0aW9uLnN0YXRlID09PSAxIC8qIEV4cGFuZGVkICovKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZFNob3dDYXJkQWN0aW9uKHJlbmRlcmVkQWN0aW9uLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZWRBY3Rpb25zLmxlbmd0aCA+IDAgPyBlbGVtZW50IDogdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIEFjdGlvbkNvbGxlY3Rpb24ucHJvdG90eXBlLmFkZEFjdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICBpZiAoIWFjdGlvbikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYWN0aW9uIHBhcmFtZXRlciBjYW5ub3QgYmUgbnVsbC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoIWFjdGlvbi5wYXJlbnQgfHwgYWN0aW9uLnBhcmVudCA9PT0gdGhpcy5fb3duZXIpICYmIHRoaXMuX2l0ZW1zLmluZGV4T2YoYWN0aW9uKSA8IDApIHtcclxuICAgICAgICAgICAgdGhpcy5faXRlbXMucHVzaChhY3Rpb24pO1xyXG4gICAgICAgICAgICBpZiAoIWFjdGlvbi5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGFjdGlvbi5zZXRQYXJlbnQodGhpcy5fb3duZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGlvbltcIl9hY3Rpb25Db2xsZWN0aW9uXCJdID0gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHJpbmdzXzEuU3RyaW5ncy5lcnJvcnMuYWN0aW9uQWxyZWFkeVBhcmVudGVkKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBY3Rpb25Db2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVBY3Rpb24gPSBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWRBY3Rpb24gJiYgdGhpcy5fZXhwYW5kZWRBY3Rpb24gPT09IGFjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxhcHNlRXhwYW5kZWRBY3Rpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFjdGlvbkluZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihhY3Rpb24pO1xyXG4gICAgICAgIGlmIChhY3Rpb25JbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShhY3Rpb25JbmRleCwgMSk7XHJcbiAgICAgICAgICAgIGFjdGlvbi5zZXRQYXJlbnQodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgYWN0aW9uW1wiX2FjdGlvbkNvbGxlY3Rpb25cIl0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcmVuZGVyZWRBY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVuZGVyZWRBY3Rpb25zW2ldID09PSBhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlZEFjdGlvbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQWN0aW9uQ29sbGVjdGlvbi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlZEFjdGlvbnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9leHBhbmRlZEFjdGlvbiA9IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBBY3Rpb25Db2xsZWN0aW9uLnByb3RvdHlwZS5nZXRBbGxJbnB1dHMgPSBmdW5jdGlvbiAocHJvY2Vzc0FjdGlvbnMpIHtcclxuICAgICAgICBpZiAocHJvY2Vzc0FjdGlvbnMgPT09IHZvaWQgMCkgeyBwcm9jZXNzQWN0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgaWYgKHByb2Nlc3NBY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9pdGVtczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIGFjdGlvbi5nZXRBbGxJbnB1dHMoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBBY3Rpb25Db2xsZWN0aW9uLnByb3RvdHlwZS5nZXRSZXNvdXJjZUluZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5faXRlbXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBfYVtfaV07XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgYWN0aW9uLmdldFJlc291cmNlSW5mb3JtYXRpb24oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGlvbkNvbGxlY3Rpb24ucHJvdG90eXBlLCBcInJlbmRlcmVkQWN0aW9uQ291bnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZWRBY3Rpb25zLmxlbmd0aDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aW9uQ29sbGVjdGlvbi5wcm90b3R5cGUsIFwiZXhwYW5kZWRBY3Rpb25cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwYW5kZWRBY3Rpb247XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIEFjdGlvbkNvbGxlY3Rpb247XHJcbn0oKSk7XHJcbnZhciBBY3Rpb25TZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQWN0aW9uU2V0LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWN0aW9uU2V0KCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX2FjdGlvbkNvbGxlY3Rpb24gPSBuZXcgQWN0aW9uQ29sbGVjdGlvbihfdGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQWN0aW9uU2V0LnByb3RvdHlwZS5pbnRlcm5hbFBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY29udGV4dCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW50ZXJuYWxQYXJzZS5jYWxsKHRoaXMsIHNvdXJjZSwgY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9uQ29sbGVjdGlvbi5wYXJzZShzb3VyY2VbXCJhY3Rpb25zXCJdLCBjb250ZXh0KTtcclxuICAgIH07XHJcbiAgICBBY3Rpb25TZXQucHJvdG90eXBlLmludGVybmFsVG9KU09OID0gZnVuY3Rpb24gKHRhcmdldCwgY29udGV4dCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW50ZXJuYWxUb0pTT04uY2FsbCh0aGlzLCB0YXJnZXQsIGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMuX2FjdGlvbkNvbGxlY3Rpb24udG9KU09OKHRhcmdldCwgXCJhY3Rpb25zXCIsIGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIEFjdGlvblNldC5wcm90b3R5cGUuaW50ZXJuYWxSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbkNvbGxlY3Rpb24ucmVuZGVyKHRoaXMub3JpZW50YXRpb24gIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA/IHRoaXMub3JpZW50YXRpb25cclxuICAgICAgICAgICAgOiB0aGlzLmhvc3RDb25maWcuYWN0aW9ucy5hY3Rpb25zT3JpZW50YXRpb24pO1xyXG4gICAgfTtcclxuICAgIEFjdGlvblNldC5wcm90b3R5cGUucmVsZWFzZURPTVJlc291cmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJlbGVhc2VET01SZXNvdXJjZXMuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9hY3Rpb25Db2xsZWN0aW9uLnJlbGVhc2VET01SZXNvdXJjZXMoKTtcclxuICAgIH07XHJcbiAgICBBY3Rpb25TZXQucHJvdG90eXBlLmlzQmxlZWRpbmdBdEJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fYWN0aW9uQ29sbGVjdGlvbi5yZW5kZXJlZEFjdGlvbkNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmlzQmxlZWRpbmdBdEJvdHRvbS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGlvbkNvbGxlY3Rpb24uZ2V0QWN0aW9uQ291bnQoKSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9hY3Rpb25Db2xsZWN0aW9uLmV4cGFuZGVkQWN0aW9uICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5ob3N0Q29uZmlnLmFjdGlvbnMucHJlRXhwYW5kU2luZ2xlU2hvd0NhcmRBY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbkNvbGxlY3Rpb24uZXhwYW5kZWRBY3Rpb24gIT09IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBY3Rpb25TZXQucHJvdG90eXBlLmdldEpzb25UeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXCJBY3Rpb25TZXRcIjtcclxuICAgIH07XHJcbiAgICBBY3Rpb25TZXQucHJvdG90eXBlLmdldEFjdGlvbkNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb25Db2xsZWN0aW9uLmdldEFjdGlvbkNvdW50KCk7XHJcbiAgICB9O1xyXG4gICAgQWN0aW9uU2V0LnByb3RvdHlwZS5nZXRBY3Rpb25BdCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5nZXRBY3Rpb25Db3VudCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb25Db2xsZWN0aW9uLmdldEFjdGlvbkF0KGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmdldEFjdGlvbkF0LmNhbGwodGhpcywgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBY3Rpb25TZXQucHJvdG90eXBlLmdldEFjdGlvbkJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fYWN0aW9uQ29sbGVjdGlvbi5nZXRBY3Rpb25CeUlkKGlkKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0ID8gcmVzdWx0IDogX3N1cGVyLnByb3RvdHlwZS5nZXRBY3Rpb25CeUlkLmNhbGwodGhpcywgaWQpO1xyXG4gICAgfTtcclxuICAgIEFjdGlvblNldC5wcm90b3R5cGUuZ2V0QWxsQWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS5nZXRBbGxBY3Rpb25zLmNhbGwodGhpcyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdldEFjdGlvbkNvdW50KCk7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gdGhpcy5nZXRBY3Rpb25BdChpKTtcclxuICAgICAgICAgICAgaWYgKGFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYWN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIEFjdGlvblNldC5wcm90b3R5cGUuaW50ZXJuYWxWYWxpZGF0ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW50ZXJuYWxWYWxpZGF0ZVByb3BlcnRpZXMuY2FsbCh0aGlzLCBjb250ZXh0KTtcclxuICAgICAgICB0aGlzLl9hY3Rpb25Db2xsZWN0aW9uLnZhbGlkYXRlUHJvcGVydGllcyhjb250ZXh0KTtcclxuICAgIH07XHJcbiAgICBBY3Rpb25TZXQucHJvdG90eXBlLmFkZEFjdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB0aGlzLl9hY3Rpb25Db2xsZWN0aW9uLmFkZEFjdGlvbihhY3Rpb24pO1xyXG4gICAgfTtcclxuICAgIEFjdGlvblNldC5wcm90b3R5cGUuZ2V0QWxsSW5wdXRzID0gZnVuY3Rpb24gKHByb2Nlc3NBY3Rpb25zKSB7XHJcbiAgICAgICAgaWYgKHByb2Nlc3NBY3Rpb25zID09PSB2b2lkIDApIHsgcHJvY2Vzc0FjdGlvbnMgPSB0cnVlOyB9XHJcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NBY3Rpb25zID8gdGhpcy5fYWN0aW9uQ29sbGVjdGlvbi5nZXRBbGxJbnB1dHMoKSA6IFtdO1xyXG4gICAgfTtcclxuICAgIEFjdGlvblNldC5wcm90b3R5cGUuZ2V0UmVzb3VyY2VJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aW9uQ29sbGVjdGlvbi5nZXRSZXNvdXJjZUluZm9ybWF0aW9uKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5oZXJpdGRvY1xyXG4gICAgICovXHJcbiAgICBBY3Rpb25TZXQucHJvdG90eXBlLmZpbmRET01Ob2RlT3duZXIgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdldEFjdGlvbkNvdW50KCk7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gdGhpcy5nZXRBY3Rpb25BdChpKTtcclxuICAgICAgICAgICAgaWYgKGFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVjdXIgdGhyb3VnaCBlYWNoIEFjdGlvblxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gYWN0aW9uLmZpbmRET01Ob2RlT3duZXIobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiBub3QgZm91bmQgaW4gYW55IEFjdGlvbiwgZGVmZXIgdG8gcGFyZW50IGltcGxlbWVudGF0aW9uXHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZmluZERPTU5vZGVPd25lci5jYWxsKHRoaXMsIG5vZGUpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpb25TZXQucHJvdG90eXBlLCBcImlzSW50ZXJhY3RpdmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvLyNyZWdpb24gU2NoZW1hXHJcbiAgICBBY3Rpb25TZXQub3JpZW50YXRpb25Qcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuRW51bVByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8xLCBcIm9yaWVudGF0aW9uXCIsIEVudW1zLk9yaWVudGF0aW9uKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEFjdGlvblNldC5vcmllbnRhdGlvblByb3BlcnR5KVxyXG4gICAgXSwgQWN0aW9uU2V0LnByb3RvdHlwZSwgXCJvcmllbnRhdGlvblwiLCB2b2lkIDApO1xyXG4gICAgcmV0dXJuIEFjdGlvblNldDtcclxufShDYXJkRWxlbWVudCkpO1xyXG5leHBvcnRzLkFjdGlvblNldCA9IEFjdGlvblNldDtcclxudmFyIENvbnRhaW5lclN0eWxlUHJvcGVydHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ29udGFpbmVyU3R5bGVQcm9wZXJ0eSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENvbnRhaW5lclN0eWxlUHJvcGVydHkodGFyZ2V0VmVyc2lvbiwgbmFtZSwgZGVmYXVsdFZhbHVlLCBvbkdldEluaXRpYWxWYWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRhcmdldFZlcnNpb24sIG5hbWUsIFtcclxuICAgICAgICAgICAgeyB2YWx1ZTogRW51bXMuQ29udGFpbmVyU3R5bGUuRGVmYXVsdCB9LFxyXG4gICAgICAgICAgICB7IHZhbHVlOiBFbnVtcy5Db250YWluZXJTdHlsZS5FbXBoYXNpcyB9LFxyXG4gICAgICAgICAgICB7IHRhcmdldFZlcnNpb246IHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8yLCB2YWx1ZTogRW51bXMuQ29udGFpbmVyU3R5bGUuQWNjZW50IH0sXHJcbiAgICAgICAgICAgIHsgdGFyZ2V0VmVyc2lvbjogc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzIsIHZhbHVlOiBFbnVtcy5Db250YWluZXJTdHlsZS5Hb29kIH0sXHJcbiAgICAgICAgICAgIHsgdGFyZ2V0VmVyc2lvbjogc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzIsIHZhbHVlOiBFbnVtcy5Db250YWluZXJTdHlsZS5BdHRlbnRpb24gfSxcclxuICAgICAgICAgICAgeyB0YXJnZXRWZXJzaW9uOiBzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMiwgdmFsdWU6IEVudW1zLkNvbnRhaW5lclN0eWxlLldhcm5pbmcgfVxyXG4gICAgICAgIF0sIGRlZmF1bHRWYWx1ZSwgb25HZXRJbml0aWFsVmFsdWUpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudGFyZ2V0VmVyc2lvbiA9IHRhcmdldFZlcnNpb247XHJcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgX3RoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIF90aGlzLm9uR2V0SW5pdGlhbFZhbHVlID0gb25HZXRJbml0aWFsVmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIENvbnRhaW5lclN0eWxlUHJvcGVydHk7XHJcbn0oc2VyaWFsaXphdGlvbl8xLlZhbHVlU2V0UHJvcGVydHkpKTtcclxuZXhwb3J0cy5Db250YWluZXJTdHlsZVByb3BlcnR5ID0gQ29udGFpbmVyU3R5bGVQcm9wZXJ0eTtcclxudmFyIFN0eWxhYmxlQ2FyZEVsZW1lbnRDb250YWluZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU3R5bGFibGVDYXJkRWxlbWVudENvbnRhaW5lciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFN0eWxhYmxlQ2FyZEVsZW1lbnRDb250YWluZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0eWxhYmxlQ2FyZEVsZW1lbnRDb250YWluZXIucHJvdG90eXBlLCBcInN0eWxlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dDdXN0b21TdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5nZXRWYWx1ZShTdHlsYWJsZUNhcmRFbGVtZW50Q29udGFpbmVyLnN0eWxlUHJvcGVydHkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlICYmIHRoaXMuaG9zdENvbmZpZy5jb250YWluZXJTdHlsZXMuZ2V0U3R5bGVCeU5hbWUoc3R5bGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKFN0eWxhYmxlQ2FyZEVsZW1lbnRDb250YWluZXIuc3R5bGVQcm9wZXJ0eSwgdmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHlsYWJsZUNhcmRFbGVtZW50Q29udGFpbmVyLnByb3RvdHlwZSwgXCJhbGxvd0N1c3RvbVN0eWxlXCIsIHtcclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0eWxhYmxlQ2FyZEVsZW1lbnRDb250YWluZXIucHJvdG90eXBlLCBcImhhc0V4cGxpY2l0U3R5bGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZShTdHlsYWJsZUNhcmRFbGVtZW50Q29udGFpbmVyLnN0eWxlUHJvcGVydHkpICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgU3R5bGFibGVDYXJkRWxlbWVudENvbnRhaW5lci5wcm90b3R5cGUuYXBwbHlCb3JkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gTm8gYm9yZGVyIGluIGJhc2UgaW1wbGVtZW50YXRpb25cclxuICAgIH07XHJcbiAgICBTdHlsYWJsZUNhcmRFbGVtZW50Q29udGFpbmVyLnByb3RvdHlwZS5hcHBseUJhY2tncm91bmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZURlZmluaXRpb24gPSB0aGlzLmhvc3RDb25maWcuY29udGFpbmVyU3R5bGVzLmdldFN0eWxlQnlOYW1lKHRoaXMuc3R5bGUsIHRoaXMuaG9zdENvbmZpZy5jb250YWluZXJTdHlsZXMuZ2V0U3R5bGVCeU5hbWUodGhpcy5kZWZhdWx0U3R5bGUpKTtcclxuICAgICAgICAgICAgaWYgKHN0eWxlRGVmaW5pdGlvbi5iYWNrZ3JvdW5kQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiZ0NvbG9yID0gVXRpbHMuc3RyaW5nVG9Dc3NDb2xvcihzdHlsZURlZmluaXRpb24uYmFja2dyb3VuZENvbG9yKTtcclxuICAgICAgICAgICAgICAgIGlmIChiZ0NvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYmdDb2xvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTdHlsYWJsZUNhcmRFbGVtZW50Q29udGFpbmVyLnByb3RvdHlwZS5hcHBseVBhZGRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5hcHBseVBhZGRpbmcuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAoIXRoaXMucmVuZGVyZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBoeXNpY2FsUGFkZGluZyA9IG5ldyBzaGFyZWRfMS5TcGFjaW5nRGVmaW5pdGlvbigpO1xyXG4gICAgICAgIGlmICh0aGlzLmdldEVmZmVjdGl2ZVBhZGRpbmcoKSkge1xyXG4gICAgICAgICAgICBwaHlzaWNhbFBhZGRpbmcgPSB0aGlzLmhvc3RDb25maWcucGFkZGluZ0RlZmluaXRpb25Ub1NwYWNpbmdEZWZpbml0aW9uKHRoaXMuZ2V0RWZmZWN0aXZlUGFkZGluZygpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQuc3R5bGUucGFkZGluZ1RvcCA9IHBoeXNpY2FsUGFkZGluZy50b3AgKyBcInB4XCI7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gcGh5c2ljYWxQYWRkaW5nLnJpZ2h0ICsgXCJweFwiO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50LnN0eWxlLnBhZGRpbmdCb3R0b20gPSBwaHlzaWNhbFBhZGRpbmcuYm90dG9tICsgXCJweFwiO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gcGh5c2ljYWxQYWRkaW5nLmxlZnQgKyBcInB4XCI7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNCbGVlZGluZygpKSB7XHJcbiAgICAgICAgICAgIC8vIEJsZWVkIGludG8gdGhlIGZpcnN0IHBhcmVudCB0aGF0IGRvZXMgaGF2ZSBwYWRkaW5nXHJcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gbmV3IHNoYXJlZF8xLlBhZGRpbmdEZWZpbml0aW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0SW1tZWRpYXRlU3Vycm91bmRpbmdQYWRkaW5nKHBhZGRpbmcpO1xyXG4gICAgICAgICAgICB2YXIgc3Vycm91bmRpbmdQYWRkaW5nID0gdGhpcy5ob3N0Q29uZmlnLnBhZGRpbmdEZWZpbml0aW9uVG9TcGFjaW5nRGVmaW5pdGlvbihwYWRkaW5nKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQuc3R5bGUubWFyZ2luUmlnaHQgPSBcIi1cIiArIHN1cnJvdW5kaW5nUGFkZGluZy5yaWdodCArIFwicHhcIjtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQuc3R5bGUubWFyZ2luTGVmdCA9IFwiLVwiICsgc3Vycm91bmRpbmdQYWRkaW5nLmxlZnQgKyBcInB4XCI7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Rlc2lnbk1vZGUoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQuc3R5bGUubWFyZ2luVG9wID0gXCItXCIgKyBzdXJyb3VuZGluZ1BhZGRpbmcudG9wICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQuc3R5bGUubWFyZ2luQm90dG9tID0gXCItXCIgKyBzdXJyb3VuZGluZ1BhZGRpbmcuYm90dG9tICsgXCJweFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNlcGFyYXRvckVsZW1lbnQgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VwYXJhdG9yT3JpZW50YXRpb24gPT09IEVudW1zLk9yaWVudGF0aW9uLkhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VwYXJhdG9yRWxlbWVudC5zdHlsZS5tYXJnaW5MZWZ0ID0gXCItXCIgKyBzdXJyb3VuZGluZ1BhZGRpbmcubGVmdCArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VwYXJhdG9yRWxlbWVudC5zdHlsZS5tYXJnaW5SaWdodCA9IFwiLVwiICsgc3Vycm91bmRpbmdQYWRkaW5nLnJpZ2h0ICsgXCJweFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudC5zdHlsZS5tYXJnaW5SaWdodCA9IFwiMFwiO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudC5zdHlsZS5tYXJnaW5MZWZ0ID0gXCIwXCI7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9IFwiMFwiO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudC5zdHlsZS5tYXJnaW5Cb3R0b20gPSBcIjBcIjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2VwYXJhdG9yRWxlbWVudCAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXBhcmF0b3JPcmllbnRhdGlvbiA9PT0gRW51bXMuT3JpZW50YXRpb24uSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXBhcmF0b3JFbGVtZW50LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCIwXCI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlcGFyYXRvckVsZW1lbnQuc3R5bGUubWFyZ2luTGVmdCA9IFwiMFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFN0eWxhYmxlQ2FyZEVsZW1lbnRDb250YWluZXIucHJvdG90eXBlLmdldEhhc0JhY2tncm91bmQgPSBmdW5jdGlvbiAoaWdub3JlQmFja2dyb3VuZEltYWdlcykge1xyXG4gICAgICAgIGlmIChpZ25vcmVCYWNrZ3JvdW5kSW1hZ2VzID09PSB2b2lkIDApIHsgaWdub3JlQmFja2dyb3VuZEltYWdlcyA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGN1cnJlbnRFbGVtZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RWxlbWVudEhhc0JhY2tncm91bmRJbWFnZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoaWdub3JlQmFja2dyb3VuZEltYWdlcykge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEVsZW1lbnRIYXNCYWNrZ3JvdW5kSW1hZ2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50SGFzQmFja2dyb3VuZEltYWdlID1cclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudCBpbnN0YW5jZW9mIENvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnRFbGVtZW50LmJhY2tncm91bmRJbWFnZS5pc1ZhbGlkKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY3VycmVudEVsZW1lbnQgaW5zdGFuY2VvZiBTdHlsYWJsZUNhcmRFbGVtZW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNFeHBsaWNpdFN0eWxlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnRFbGVtZW50LmdldEVmZmVjdGl2ZVN0eWxlKCkgIT09IHRoaXMuZ2V0RWZmZWN0aXZlU3R5bGUoKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudEhhc0JhY2tncm91bmRJbWFnZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50RWxlbWVudCA9IGN1cnJlbnRFbGVtZW50LnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIFN0eWxhYmxlQ2FyZEVsZW1lbnRDb250YWluZXIucHJvdG90eXBlLmdldERlZmF1bHRQYWRkaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEhhc0JhY2tncm91bmQoKSB8fCB0aGlzLmdldEhhc0JvcmRlcigpXHJcbiAgICAgICAgICAgID8gbmV3IHNoYXJlZF8xLlBhZGRpbmdEZWZpbml0aW9uKEVudW1zLlNwYWNpbmcuUGFkZGluZywgRW51bXMuU3BhY2luZy5QYWRkaW5nLCBFbnVtcy5TcGFjaW5nLlBhZGRpbmcsIEVudW1zLlNwYWNpbmcuUGFkZGluZylcclxuICAgICAgICAgICAgOiBfc3VwZXIucHJvdG90eXBlLmdldERlZmF1bHRQYWRkaW5nLmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgU3R5bGFibGVDYXJkRWxlbWVudENvbnRhaW5lci5wcm90b3R5cGUuaW50ZXJuYWxWYWxpZGF0ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW50ZXJuYWxWYWxpZGF0ZVByb3BlcnRpZXMuY2FsbCh0aGlzLCBjb250ZXh0KTtcclxuICAgICAgICB2YXIgZXhwbGljaXRTdHlsZSA9IHRoaXMuZ2V0VmFsdWUoU3R5bGFibGVDYXJkRWxlbWVudENvbnRhaW5lci5zdHlsZVByb3BlcnR5KTtcclxuICAgICAgICBpZiAoZXhwbGljaXRTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZURlZmluaXRpb24gPSB0aGlzLmhvc3RDb25maWcuY29udGFpbmVyU3R5bGVzLmdldFN0eWxlQnlOYW1lKGV4cGxpY2l0U3R5bGUpO1xyXG4gICAgICAgICAgICBpZiAoIXN0eWxlRGVmaW5pdGlvbikge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5hZGRGYWlsdXJlKHRoaXMsIEVudW1zLlZhbGlkYXRpb25FdmVudC5JbnZhbGlkUHJvcGVydHlWYWx1ZSwgc3RyaW5nc18xLlN0cmluZ3MuZXJyb3JzLmludmFsaWRQcm9wZXJ0eVZhbHVlKGV4cGxpY2l0U3R5bGUsIFwic3R5bGVcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFN0eWxhYmxlQ2FyZEVsZW1lbnRDb250YWluZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVuZGVyZWRFbGVtZW50ID0gX3N1cGVyLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAocmVuZGVyZWRFbGVtZW50ICYmIHRoaXMuZ2V0SGFzQmFja2dyb3VuZCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlCYWNrZ3JvdW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXBwbHlCb3JkZXIoKTtcclxuICAgICAgICByZXR1cm4gcmVuZGVyZWRFbGVtZW50O1xyXG4gICAgfTtcclxuICAgIFN0eWxhYmxlQ2FyZEVsZW1lbnRDb250YWluZXIucHJvdG90eXBlLmdldEVmZmVjdGl2ZVN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlZmZlY3RpdmVTdHlsZSA9IHRoaXMuc3R5bGU7XHJcbiAgICAgICAgcmV0dXJuIGVmZmVjdGl2ZVN0eWxlID8gZWZmZWN0aXZlU3R5bGUgOiBfc3VwZXIucHJvdG90eXBlLmdldEVmZmVjdGl2ZVN0eWxlLmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgLy8jcmVnaW9uIFNjaGVtYVxyXG4gICAgU3R5bGFibGVDYXJkRWxlbWVudENvbnRhaW5lci5zdHlsZVByb3BlcnR5ID0gbmV3IENvbnRhaW5lclN0eWxlUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwic3R5bGVcIik7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShTdHlsYWJsZUNhcmRFbGVtZW50Q29udGFpbmVyLnN0eWxlUHJvcGVydHkpXHJcbiAgICBdLCBTdHlsYWJsZUNhcmRFbGVtZW50Q29udGFpbmVyLnByb3RvdHlwZSwgXCJzdHlsZVwiLCBudWxsKTtcclxuICAgIHJldHVybiBTdHlsYWJsZUNhcmRFbGVtZW50Q29udGFpbmVyO1xyXG59KENhcmRFbGVtZW50Q29udGFpbmVyKSk7XHJcbmV4cG9ydHMuU3R5bGFibGVDYXJkRWxlbWVudENvbnRhaW5lciA9IFN0eWxhYmxlQ2FyZEVsZW1lbnRDb250YWluZXI7XHJcbnZhciBDb250YWluZXJCYXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvbnRhaW5lckJhc2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDb250YWluZXJCYXNlKCkge1xyXG4gICAgICAgIC8vI3JlZ2lvbiBTY2hlbWFcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fYmxlZWQgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICAgIENvbnRhaW5lckJhc2UucHJvdG90eXBlLmFkanVzdFJlbmRlcmVkRWxlbWVudFNpemUgPSBmdW5jdGlvbiAocmVuZGVyZWRFbGVtZW50KSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5hZGp1c3RSZW5kZXJlZEVsZW1lbnRTaXplLmNhbGwodGhpcywgcmVuZGVyZWRFbGVtZW50KTtcclxuICAgICAgICBpZiAodGhpcy5taW5QaXhlbEhlaWdodCkge1xyXG4gICAgICAgICAgICByZW5kZXJlZEVsZW1lbnQuc3R5bGUubWluSGVpZ2h0ID0gdGhpcy5taW5QaXhlbEhlaWdodCArIFwicHhcIjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29udGFpbmVyQmFzZS5wcm90b3R5cGUuZ2V0SGFzRXhwYW5kZWRBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIENvbnRhaW5lckJhc2UucHJvdG90eXBlLmdldEJsZWVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ibGVlZDtcclxuICAgIH07XHJcbiAgICBDb250YWluZXJCYXNlLnByb3RvdHlwZS5zZXRCbGVlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2JsZWVkID0gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhaW5lckJhc2UucHJvdG90eXBlLCBcInJlbmRlcmVkQWN0aW9uQ291bnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBDb250YWluZXJCYXNlLnByb3RvdHlwZS5pc0JsZWVkaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5nZXRIYXNCYWNrZ3JvdW5kKCkgfHwgdGhpcy5ob3N0Q29uZmlnLmFsd2F5c0FsbG93QmxlZWQpICYmIHRoaXMuZ2V0QmxlZWQoKTtcclxuICAgIH07XHJcbiAgICBDb250YWluZXJCYXNlLmJsZWVkUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLkJvb2xQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMiwgXCJibGVlZFwiLCBmYWxzZSk7XHJcbiAgICBDb250YWluZXJCYXNlLm1pbkhlaWdodFByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5QaXhlbFNpemVQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMiwgXCJtaW5IZWlnaHRcIik7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShDb250YWluZXJCYXNlLmJsZWVkUHJvcGVydHkpXHJcbiAgICBdLCBDb250YWluZXJCYXNlLnByb3RvdHlwZSwgXCJfYmxlZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKENvbnRhaW5lckJhc2UubWluSGVpZ2h0UHJvcGVydHkpXHJcbiAgICBdLCBDb250YWluZXJCYXNlLnByb3RvdHlwZSwgXCJtaW5QaXhlbEhlaWdodFwiLCB2b2lkIDApO1xyXG4gICAgcmV0dXJuIENvbnRhaW5lckJhc2U7XHJcbn0oU3R5bGFibGVDYXJkRWxlbWVudENvbnRhaW5lcikpO1xyXG5leHBvcnRzLkNvbnRhaW5lckJhc2UgPSBDb250YWluZXJCYXNlO1xyXG52YXIgQmFja2dyb3VuZEltYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEJhY2tncm91bmRJbWFnZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJhY2tncm91bmRJbWFnZSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICAgIEJhY2tncm91bmRJbWFnZS5wcm90b3R5cGUuZ2V0U2NoZW1hS2V5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcIkJhY2tncm91bmRJbWFnZVwiO1xyXG4gICAgfTtcclxuICAgIEJhY2tncm91bmRJbWFnZS5wcm90b3R5cGUuaW50ZXJuYWxQYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0RGVmYXVsdFZhbHVlcygpO1xyXG4gICAgICAgICAgICB0aGlzLnVybCA9IHNvdXJjZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmludGVybmFsUGFyc2UuY2FsbCh0aGlzLCBzb3VyY2UsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCYWNrZ3JvdW5kSW1hZ2UucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICBpZiAodGhpcy51cmwgJiYgZWxlbWVudC5yZW5kZXJlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5yZW5kZXJlZEVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZEltYWdlID1cclxuICAgICAgICAgICAgICAgIFwidXJsKCdcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5wcmVQcm9jZXNzUHJvcGVydHlWYWx1ZShCYWNrZ3JvdW5kSW1hZ2UudXJsUHJvcGVydHksIHRoaXMudXJsKSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCInKVwiO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZmlsbE1vZGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgRW51bXMuRmlsbE1vZGUuUmVwZWF0OlxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVuZGVyZWRFbGVtZW50LnN0eWxlLmJhY2tncm91bmRSZXBlYXQgPSBcInJlcGVhdFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFbnVtcy5GaWxsTW9kZS5SZXBlYXRIb3Jpem9udGFsbHk6XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW5kZXJlZEVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZFJlcGVhdCA9IFwicmVwZWF0LXhcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRW51bXMuRmlsbE1vZGUuUmVwZWF0VmVydGljYWxseTpcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbmRlcmVkRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kUmVwZWF0ID0gXCJyZXBlYXQteVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFbnVtcy5GaWxsTW9kZS5Db3ZlcjpcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW5kZXJlZEVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZFJlcGVhdCA9IFwibm8tcmVwZWF0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW5kZXJlZEVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZFNpemUgPSBcImNvdmVyXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmhvcml6b250YWxBbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgRW51bXMuSG9yaXpvbnRhbEFsaWdubWVudC5MZWZ0OlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFbnVtcy5Ib3Jpem9udGFsQWxpZ25tZW50LkNlbnRlcjpcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbmRlcmVkRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb25YID0gXCJjZW50ZXJcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRW51bXMuSG9yaXpvbnRhbEFsaWdubWVudC5SaWdodDpcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbmRlcmVkRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb25YID0gXCJyaWdodFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy52ZXJ0aWNhbEFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFbnVtcy5WZXJ0aWNhbEFsaWdubWVudC5Ub3A6XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVudW1zLlZlcnRpY2FsQWxpZ25tZW50LkNlbnRlcjpcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbmRlcmVkRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb25ZID0gXCJjZW50ZXJcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRW51bXMuVmVydGljYWxBbGlnbm1lbnQuQm90dG9tOlxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVuZGVyZWRFbGVtZW50LnN0eWxlLmJhY2tncm91bmRQb3NpdGlvblkgPSBcImJvdHRvbVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJhY2tncm91bmRJbWFnZS5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51cmwgPyB0cnVlIDogZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLy8jcmVnaW9uIFNjaGVtYVxyXG4gICAgQmFja2dyb3VuZEltYWdlLnVybFByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCwgXCJ1cmxcIik7XHJcbiAgICBCYWNrZ3JvdW5kSW1hZ2UuZmlsbE1vZGVQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuRW51bVByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8yLCBcImZpbGxNb2RlXCIsIEVudW1zLkZpbGxNb2RlLCBFbnVtcy5GaWxsTW9kZS5Db3Zlcik7XHJcbiAgICBCYWNrZ3JvdW5kSW1hZ2UuaG9yaXpvbnRhbEFsaWdubWVudFByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5FbnVtUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzIsIFwiaG9yaXpvbnRhbEFsaWdubWVudFwiLCBFbnVtcy5Ib3Jpem9udGFsQWxpZ25tZW50LCBFbnVtcy5Ib3Jpem9udGFsQWxpZ25tZW50LkxlZnQpO1xyXG4gICAgQmFja2dyb3VuZEltYWdlLnZlcnRpY2FsQWxpZ25tZW50UHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLkVudW1Qcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMiwgXCJ2ZXJ0aWNhbEFsaWdubWVudFwiLCBFbnVtcy5WZXJ0aWNhbEFsaWdubWVudCwgRW51bXMuVmVydGljYWxBbGlnbm1lbnQuVG9wKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEJhY2tncm91bmRJbWFnZS51cmxQcm9wZXJ0eSlcclxuICAgIF0sIEJhY2tncm91bmRJbWFnZS5wcm90b3R5cGUsIFwidXJsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShCYWNrZ3JvdW5kSW1hZ2UuZmlsbE1vZGVQcm9wZXJ0eSlcclxuICAgIF0sIEJhY2tncm91bmRJbWFnZS5wcm90b3R5cGUsIFwiZmlsbE1vZGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEJhY2tncm91bmRJbWFnZS5ob3Jpem9udGFsQWxpZ25tZW50UHJvcGVydHkpXHJcbiAgICBdLCBCYWNrZ3JvdW5kSW1hZ2UucHJvdG90eXBlLCBcImhvcml6b250YWxBbGlnbm1lbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEJhY2tncm91bmRJbWFnZS52ZXJ0aWNhbEFsaWdubWVudFByb3BlcnR5KVxyXG4gICAgXSwgQmFja2dyb3VuZEltYWdlLnByb3RvdHlwZSwgXCJ2ZXJ0aWNhbEFsaWdubWVudFwiLCB2b2lkIDApO1xyXG4gICAgcmV0dXJuIEJhY2tncm91bmRJbWFnZTtcclxufShzZXJpYWxpemF0aW9uXzEuU2VyaWFsaXphYmxlT2JqZWN0KSk7XHJcbmV4cG9ydHMuQmFja2dyb3VuZEltYWdlID0gQmFja2dyb3VuZEltYWdlO1xyXG52YXIgQ29udGFpbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvbnRhaW5lciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENvbnRhaW5lcigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuICAgICAgICBfdGhpcy5faXRlbXMgPSBbXTtcclxuICAgICAgICBfdGhpcy5fcmVuZGVyZWRJdGVtcyA9IFtdO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250YWluZXIucHJvdG90eXBlLCBcImJhY2tncm91bmRJbWFnZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlKENvbnRhaW5lci5iYWNrZ3JvdW5kSW1hZ2VQcm9wZXJ0eSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5pbnNlcnRJdGVtQXQgPSBmdW5jdGlvbiAoaXRlbSwgaW5kZXgsIGZvcmNlSW5zZXJ0KSB7XHJcbiAgICAgICAgaWYgKCFpdGVtLnBhcmVudCB8fCBmb3JjZUluc2VydCkge1xyXG4gICAgICAgICAgICBpZiAoaXRlbS5pc1N0YW5kYWxvbmUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXRlbXMucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleCwgMCwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpdGVtLnNldFBhcmVudCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHJpbmdzXzEuU3RyaW5ncy5lcnJvcnMuZWxlbWVudFR5cGVOb3RTdGFuZGFsb25lKGl0ZW0uZ2V0SnNvblR5cGVOYW1lKCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy5lbGVtZW50QWxyZWFkeVBhcmVudGVkKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDb250YWluZXIucHJvdG90eXBlLmdldEl0ZW1zQ29sbGVjdGlvblByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXCJpdGVtc1wiO1xyXG4gICAgfTtcclxuICAgIENvbnRhaW5lci5wcm90b3R5cGUuYXBwbHlCYWNrZ3JvdW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmJhY2tncm91bmRJbWFnZS5pc1ZhbGlkKCkgJiYgdGhpcy5yZW5kZXJlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UuYXBwbHkodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYXBwbHlCYWNrZ3JvdW5kLmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5hcHBseVJUTCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMucnRsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5kaXIgPSB0aGlzLnJ0bCA/IFwicnRsXCIgOiBcImx0clwiO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDb250YWluZXIucHJvdG90eXBlLmludGVybmFsUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVkSXRlbXMgPSBbXTtcclxuICAgICAgICAvLyBDYWNoZSBob3N0Q29uZmlnIHRvIGF2b2lkIHdhbGtpbmcgdGhlIHBhcmVudCBoaWVyYXJjaHkgc2V2ZXJhbCB0aW1lc1xyXG4gICAgICAgIHZhciBob3N0Q29uZmlnID0gdGhpcy5ob3N0Q29uZmlnO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICB0aGlzLmFwcGx5UlRMKGVsZW1lbnQpO1xyXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1jb250YWluZXJcIikpO1xyXG4gICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xyXG4gICAgICAgIGVsZW1lbnQuc3R5bGUuZmxleERpcmVjdGlvbiA9IFwiY29sdW1uXCI7XHJcbiAgICAgICAgaWYgKHNoYXJlZF8xLkdsb2JhbFNldHRpbmdzLnVzZUFkdmFuY2VkQ2FyZEJvdHRvbVRydW5jYXRpb24pIHtcclxuICAgICAgICAgICAgLy8gRm9yY2VzIHRoZSBjb250YWluZXIgdG8gYmUgYXQgbGVhc3QgYXMgdGFsbCBhcyBpdHMgY29udGVudC5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gRml4ZXMgYSBxdWlyayBpbiBDaHJvbWUgd2hlcmUsIGZvciBuZXN0ZWQgZmxleCBlbGVtZW50cywgdGhlXHJcbiAgICAgICAgICAgIC8vIGlubmVyIGVsZW1lbnQncyBoZWlnaHQgd291bGQgbmV2ZXIgZXhjZWVkIHRoZSBvdXRlciBlbGVtZW50J3NcclxuICAgICAgICAgICAgLy8gaGVpZ2h0LiBUaGlzIGNhdXNlZCBvdmVyZmxvdyB0cnVuY2F0aW9uIHRvIGJyZWFrIC0tIGNvbnRhaW5lcnNcclxuICAgICAgICAgICAgLy8gd291bGQgYWx3YXlzIGJlIG1lYXN1cmVkIGFzIG5vdCBvdmVyZmxvd2luZywgc2luY2UgdGhlaXIgaGVpZ2h0c1xyXG4gICAgICAgICAgICAvLyB3ZXJlIGNvbnN0cmFpbmVkIGJ5IHRoZWlyIHBhcmVudHMgYXMgb3Bwb3NlZCB0byB0cnVseSByZWZsZWN0aW5nXHJcbiAgICAgICAgICAgIC8vIHRoZSBoZWlnaHQgb2YgdGhlaXIgY29udGVudC5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gU2VlIHRoZSBcIkJyb3dzZXIgUmVuZGVyaW5nIE5vdGVzXCIgc2VjdGlvbiBvZiB0aGlzIGFuc3dlcjpcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzYyNDcxNDAvd2h5LWRvZXNudC1mbGV4LWl0ZW0tc2hyaW5rLXBhc3QtY29udGVudC1zaXplXHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUubWluSGVpZ2h0ID0gXCItd2Via2l0LW1pbi1jb250ZW50XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAodGhpcy5nZXRFZmZlY3RpdmVWZXJ0aWNhbENvbnRlbnRBbGlnbm1lbnQoKSkge1xyXG4gICAgICAgICAgICBjYXNlIEVudW1zLlZlcnRpY2FsQWxpZ25tZW50LkNlbnRlcjpcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSBcImNlbnRlclwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRW51bXMuVmVydGljYWxBbGlnbm1lbnQuQm90dG9tOlxyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiZmxleC1lbmRcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiZmxleC1zdGFydFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9pdGVtcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9pdGVtczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbmRlcmVkSXRlbSA9IHRoaXMuaXNFbGVtZW50QWxsb3dlZChpdGVtKSA/IGl0ZW0ucmVuZGVyKCkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZWRJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlbmRlcmVkSXRlbXMubGVuZ3RoID4gMCAmJiBpdGVtLnNlcGFyYXRvckVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXBhcmF0b3JFbGVtZW50LnN0eWxlLmZsZXggPSBcIjAgMCBhdXRvXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFV0aWxzLmFwcGVuZENoaWxkKGVsZW1lbnQsIGl0ZW0uc2VwYXJhdG9yRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFV0aWxzLmFwcGVuZENoaWxkKGVsZW1lbnQsIHJlbmRlcmVkSXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZWRJdGVtcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0Rlc2lnbk1vZGUoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyRWxlbWVudCA9IHRoaXMuY3JlYXRlUGxhY2Vob2xkZXJFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckVsZW1lbnQuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcclxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQocGxhY2Vob2xkZXJFbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH07XHJcbiAgICBDb250YWluZXIucHJvdG90eXBlLnRydW5jYXRlT3ZlcmZsb3cgPSBmdW5jdGlvbiAobWF4SGVpZ2h0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIC8vIEFkZCAxIHRvIGFjY291bnQgZm9yIHJvdW5kaW5nIGRpZmZlcmVuY2VzIGJldHdlZW4gYnJvd3NlcnNcclxuICAgICAgICAgICAgdmFyIGJvdW5kYXJ5XzEgPSB0aGlzLnJlbmRlcmVkRWxlbWVudC5vZmZzZXRUb3AgKyBtYXhIZWlnaHQgKyAxO1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlRWxlbWVudF8xID0gZnVuY3Rpb24gKGNhcmRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWx0ID0gY2FyZEVsZW1lbnQucmVuZGVyZWRFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoVXRpbHMuZ2V0Rml0U3RhdHVzKGVsdCwgYm91bmRhcnlfMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbnVtcy5Db250YWluZXJGaXRTdGF0dXMuRnVsbHlJbkNvbnRhaW5lcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaXplQ2hhbmdlZCA9IGNhcmRFbGVtZW50W1wicmVzZXRPdmVyZmxvd1wiXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQncyBzaXplIGNoYW5nZWQgYWZ0ZXIgcmVzZXR0aW5nIGNvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIGNoZWNrIGlmIGl0IHN0aWxsIGZpdHMgZnVsbHkgaW4gdGhlIGNhcmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXplQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUVsZW1lbnRfMShjYXJkRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbnVtcy5Db250YWluZXJGaXRTdGF0dXMuT3ZlcmZsb3dpbmc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyTWF4SGVpZ2h0ID0gYm91bmRhcnlfMSAtIGVsdC5vZmZzZXRUb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJkRWxlbWVudFtcImhhbmRsZU92ZXJmbG93XCJdKGNvbnRhaW5lck1heEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFbnVtcy5Db250YWluZXJGaXRTdGF0dXMuRnVsbHlPdXRPZkNvbnRhaW5lcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmRFbGVtZW50W1wiaGFuZGxlT3ZlcmZsb3dcIl0oMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9pdGVtczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRWxlbWVudF8xKGl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS51bmRvT3ZlcmZsb3dUcnVuY2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9pdGVtczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGl0ZW1bXCJyZXNldE92ZXJmbG93XCJdKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENvbnRhaW5lci5wcm90b3R5cGUuZ2V0SGFzQmFja2dyb3VuZCA9IGZ1bmN0aW9uIChpZ25vcmVCYWNrZ3JvdW5kSW1hZ2VzKSB7XHJcbiAgICAgICAgaWYgKGlnbm9yZUJhY2tncm91bmRJbWFnZXMgPT09IHZvaWQgMCkgeyBpZ25vcmVCYWNrZ3JvdW5kSW1hZ2VzID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gaWdub3JlQmFja2dyb3VuZEltYWdlcyA/IGZhbHNlIDogdGhpcy5iYWNrZ3JvdW5kSW1hZ2UuaXNWYWxpZCgpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQgfHwgX3N1cGVyLnByb3RvdHlwZS5nZXRIYXNCYWNrZ3JvdW5kLmNhbGwodGhpcywgaWdub3JlQmFja2dyb3VuZEltYWdlcyk7XHJcbiAgICB9O1xyXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5jYW5Ib3N0U2luZ2xldG9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5pbnRlcm5hbFBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY29udGV4dCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW50ZXJuYWxQYXJzZS5jYWxsKHRoaXMsIHNvdXJjZSwgY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuc2V0U2hvdWxkRmFsbGJhY2soZmFsc2UpO1xyXG4gICAgICAgIHZhciBqc29uSXRlbXMgPSBzb3VyY2VbdGhpcy5nZXRJdGVtc0NvbGxlY3Rpb25Qcm9wZXJ0eU5hbWUoKV07XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb25JdGVtcykgJiZcclxuICAgICAgICAgICAgdHlwZW9mIGpzb25JdGVtcyA9PT0gXCJvYmplY3RcIiAmJlxyXG4gICAgICAgICAgICB0aGlzLmNhbkhvc3RTaW5nbGV0b25zKCkpIHtcclxuICAgICAgICAgICAgdmFyIHR5cGVOYW1lID0gVXRpbHMucGFyc2VTdHJpbmcoanNvbkl0ZW1zW1widHlwZVwiXSk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbiA9IGNvbnRleHQuZWxlbWVudFJlZ2lzdHJ5LmZpbmRCeU5hbWUodHlwZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChyZWdpc3RyYXRpb24gPT09IG51bGwgfHwgcmVnaXN0cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWdpc3RyYXRpb24uc2luZ2xldG9uQmVoYXZpb3IpICE9PSByZWdpc3RyeV8xLkVsZW1lbnRTaW5nbGV0b25CZWhhdmlvci5Ob3RBbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0LnBhcnNlRWxlbWVudCh0aGlzLCBqc29uSXRlbXMsIFtdLCAhdGhpcy5pc0Rlc2lnbk1vZGUoKSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRJdGVtQXQoZWxlbWVudCwgLTEsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGpzb25JdGVtcykpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBqc29uSXRlbXNfMSA9IGpzb25JdGVtczsgX2kgPCBqc29uSXRlbXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0ganNvbkl0ZW1zXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0LnBhcnNlRWxlbWVudCh0aGlzLCBpdGVtLCB0aGlzLmZvcmJpZGRlbkNoaWxkRWxlbWVudHMoKSwgIXRoaXMuaXNEZXNpZ25Nb2RlKCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydEl0ZW1BdChlbGVtZW50LCAtMSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5pbnRlcm5hbFRvSlNPTiA9IGZ1bmN0aW9uICh0YXJnZXQsIGNvbnRleHQpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmludGVybmFsVG9KU09OLmNhbGwodGhpcywgdGFyZ2V0LCBjb250ZXh0KTtcclxuICAgICAgICB2YXIgY29sbGVjdGlvblByb3BlcnR5TmFtZSA9IHRoaXMuZ2V0SXRlbXNDb2xsZWN0aW9uUHJvcGVydHlOYW1lKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2l0ZW1zLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgICAgICB0aGlzLl9pdGVtc1swXS5nZXRFbGVtZW50U2luZ2xldG9uQmVoYXZpb3IoKSA9PT0gcmVnaXN0cnlfMS5FbGVtZW50U2luZ2xldG9uQmVoYXZpb3IuT25seSkge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBvbmx5IGFsbG93ZWQgaW4gYSBzaW5nbGV0b24gY29udGV4dCwgcGFyc2UgaXQgdG8gYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXlcclxuICAgICAgICAgICAgY29udGV4dC5zZXJpYWxpemVWYWx1ZSh0YXJnZXQsIGNvbGxlY3Rpb25Qcm9wZXJ0eU5hbWUsIHRoaXMuX2l0ZW1zWzBdLnRvSlNPTihjb250ZXh0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb250ZXh0LnNlcmlhbGl6ZUFycmF5KHRhcmdldCwgY29sbGVjdGlvblByb3BlcnR5TmFtZSwgdGhpcy5faXRlbXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGFpbmVyLnByb3RvdHlwZSwgXCJpc1NlbGVjdGFibGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBDb250YWluZXIucHJvdG90eXBlLmdldEVmZmVjdGl2ZVBhZGRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHNoYXJlZF8xLkdsb2JhbFNldHRpbmdzLnJlbW92ZVBhZGRpbmdGcm9tQ29udGFpbmVyc1dpdGhCYWNrZ3JvdW5kSW1hZ2UgJiZcclxuICAgICAgICAgICAgIXRoaXMuZ2V0SGFzQmFja2dyb3VuZCh0cnVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHNoYXJlZF8xLlBhZGRpbmdEZWZpbml0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmdldEVmZmVjdGl2ZVBhZGRpbmcuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBDb250YWluZXIucHJvdG90eXBlLmdldEVmZmVjdGl2ZVZlcnRpY2FsQ29udGVudEFsaWdubWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy52ZXJ0aWNhbENvbnRlbnRBbGlnbm1lbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJ0aWNhbENvbnRlbnRBbGlnbm1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSB0aGlzLmdldFBhcmVudENvbnRhaW5lcigpO1xyXG4gICAgICAgIHJldHVybiBwYXJlbnRDb250YWluZXJcclxuICAgICAgICAgICAgPyBwYXJlbnRDb250YWluZXIuZ2V0RWZmZWN0aXZlVmVydGljYWxDb250ZW50QWxpZ25tZW50KClcclxuICAgICAgICAgICAgOiBFbnVtcy5WZXJ0aWNhbEFsaWdubWVudC5Ub3A7XHJcbiAgICB9O1xyXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5nZXRJdGVtQ291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmxlbmd0aDtcclxuICAgIH07XHJcbiAgICBDb250YWluZXIucHJvdG90eXBlLmdldEl0ZW1BdCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtc1tpbmRleF07XHJcbiAgICB9O1xyXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5nZXRGaXJzdFZpc2libGVSZW5kZXJlZEl0ZW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRFbGVtZW50ICYmIHRoaXMuX3JlbmRlcmVkSXRlbXMgJiYgdGhpcy5fcmVuZGVyZWRJdGVtcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9yZW5kZXJlZEl0ZW1zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIENvbnRhaW5lci5wcm90b3R5cGUuZ2V0TGFzdFZpc2libGVSZW5kZXJlZEl0ZW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRFbGVtZW50ICYmIHRoaXMuX3JlbmRlcmVkSXRlbXMgJiYgdGhpcy5fcmVuZGVyZWRJdGVtcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9yZW5kZXJlZEl0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVuZGVyZWRJdGVtc1tpXS5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZWRJdGVtc1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIENvbnRhaW5lci5wcm90b3R5cGUuZ2V0SnNvblR5cGVOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcIkNvbnRhaW5lclwiO1xyXG4gICAgfTtcclxuICAgIENvbnRhaW5lci5wcm90b3R5cGUuaXNGaXJzdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBkZXNpZ25Nb2RlID0gdGhpcy5pc0Rlc2lnbk1vZGUoKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5faXRlbXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBpdGVtID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBpZiAoaXRlbS5pc1Zpc2libGUgfHwgZGVzaWduTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0gPT09IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIENvbnRhaW5lci5wcm90b3R5cGUuaXNMYXN0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIGRlc2lnbk1vZGUgPSB0aGlzLmlzRGVzaWduTW9kZSgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9pdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXRlbXNbaV0uaXNWaXNpYmxlIHx8IGRlc2lnbk1vZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pdGVtc1tpXSA9PT0gZWxlbWVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5pc1J0bCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5ydGwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ydGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50Q29udGFpbmVyID0gdGhpcy5nZXRQYXJlbnRDb250YWluZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudENvbnRhaW5lciA/IHBhcmVudENvbnRhaW5lci5pc1J0bCgpIDogZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENvbnRhaW5lci5wcm90b3R5cGUuaXNCbGVlZGluZ0F0VG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBmaXJzdFJlbmRlcmVkSXRlbSA9IHRoaXMuZ2V0Rmlyc3RWaXNpYmxlUmVuZGVyZWRJdGVtKCk7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzQmxlZWRpbmcoKSB8fCAoZmlyc3RSZW5kZXJlZEl0ZW0gPyBmaXJzdFJlbmRlcmVkSXRlbS5pc0JsZWVkaW5nQXRUb3AoKSA6IGZhbHNlKSk7XHJcbiAgICB9O1xyXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5pc0JsZWVkaW5nQXRCb3R0b20gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxhc3RSZW5kZXJlZEl0ZW0gPSB0aGlzLmdldExhc3RWaXNpYmxlUmVuZGVyZWRJdGVtKCk7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzQmxlZWRpbmcoKSB8fFxyXG4gICAgICAgICAgICAobGFzdFJlbmRlcmVkSXRlbVxyXG4gICAgICAgICAgICAgICAgPyBsYXN0UmVuZGVyZWRJdGVtLmlzQmxlZWRpbmdBdEJvdHRvbSgpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFJlbmRlcmVkSXRlbS5nZXRFZmZlY3RpdmVTdHlsZSgpID09PSB0aGlzLmdldEVmZmVjdGl2ZVN0eWxlKClcclxuICAgICAgICAgICAgICAgIDogZmFsc2UpKTtcclxuICAgIH07XHJcbiAgICBDb250YWluZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoY2FyZEVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMuaW5kZXhPZihjYXJkRWxlbWVudCk7XHJcbiAgICB9O1xyXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5hZGRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB0aGlzLmluc2VydEl0ZW1BdChpdGVtLCAtMSwgZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIENvbnRhaW5lci5wcm90b3R5cGUuaW5zZXJ0SXRlbUJlZm9yZSA9IGZ1bmN0aW9uIChpdGVtLCBpbnNlcnRCZWZvcmUpIHtcclxuICAgICAgICB0aGlzLmluc2VydEl0ZW1BdChpdGVtLCB0aGlzLl9pdGVtcy5pbmRleE9mKGluc2VydEJlZm9yZSksIGZhbHNlKTtcclxuICAgIH07XHJcbiAgICBDb250YWluZXIucHJvdG90eXBlLmluc2VydEl0ZW1BZnRlciA9IGZ1bmN0aW9uIChpdGVtLCBpbnNlcnRBZnRlcikge1xyXG4gICAgICAgIHRoaXMuaW5zZXJ0SXRlbUF0KGl0ZW0sIHRoaXMuX2l0ZW1zLmluZGV4T2YoaW5zZXJ0QWZ0ZXIpICsgMSwgZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIENvbnRhaW5lci5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgdmFyIGl0ZW1JbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoaXRlbSk7XHJcbiAgICAgICAgaWYgKGl0ZW1JbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpdGVtSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICBpdGVtLnNldFBhcmVudCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxheW91dCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIENvbnRhaW5lci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlZEl0ZW1zID0gW107XHJcbiAgICB9O1xyXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5nZXRSZXNvdXJjZUluZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLmdldFJlc291cmNlSW5mb3JtYXRpb24uY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kSW1hZ2UuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb24gLS0gdmFsaWRhdGVkIGJ5IGBpc1ZhbGlkKClgXHJcbiAgICAgICAgICAgICAgICB1cmw6IHRoaXMuYmFja2dyb3VuZEltYWdlLnVybCxcclxuICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBcImltYWdlXCJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5nZXRBY3Rpb25CeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IF9zdXBlci5wcm90b3R5cGUuZ2V0QWN0aW9uQnlJZC5jYWxsKHRoaXMsIGlkKTtcclxuICAgICAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RBY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuc2VsZWN0QWN0aW9uLmdldEFjdGlvbkJ5SWQoaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5faXRlbXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gaXRlbS5nZXRBY3Rpb25CeUlkKGlkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250YWluZXIucHJvdG90eXBlLCBcInBhZGRpbmdcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWRkaW5nKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFBhZGRpbmcodmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250YWluZXIucHJvdG90eXBlLCBcInNlbGVjdEFjdGlvblwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RBY3Rpb247XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RBY3Rpb24gPSB2YWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGFpbmVyLnByb3RvdHlwZSwgXCJibGVlZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEJsZWVkKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldEJsZWVkKHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvLyNyZWdpb24gU2NoZW1hXHJcbiAgICBDb250YWluZXIuYmFja2dyb3VuZEltYWdlUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlNlcmlhbGl6YWJsZU9iamVjdFByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcImJhY2tncm91bmRJbWFnZVwiLCBCYWNrZ3JvdW5kSW1hZ2UpO1xyXG4gICAgQ29udGFpbmVyLnZlcnRpY2FsQ29udGVudEFsaWdubWVudFByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5FbnVtUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzEsIFwidmVydGljYWxDb250ZW50QWxpZ25tZW50XCIsIEVudW1zLlZlcnRpY2FsQWxpZ25tZW50KTtcclxuICAgIENvbnRhaW5lci5ydGxQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuQm9vbFByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcInJ0bFwiKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKENvbnRhaW5lci5iYWNrZ3JvdW5kSW1hZ2VQcm9wZXJ0eSlcclxuICAgIF0sIENvbnRhaW5lci5wcm90b3R5cGUsIFwiYmFja2dyb3VuZEltYWdlXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoQ29udGFpbmVyLnZlcnRpY2FsQ29udGVudEFsaWdubWVudFByb3BlcnR5KVxyXG4gICAgXSwgQ29udGFpbmVyLnByb3RvdHlwZSwgXCJ2ZXJ0aWNhbENvbnRlbnRBbGlnbm1lbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKENvbnRhaW5lci5ydGxQcm9wZXJ0eSlcclxuICAgIF0sIENvbnRhaW5lci5wcm90b3R5cGUsIFwicnRsXCIsIHZvaWQgMCk7XHJcbiAgICByZXR1cm4gQ29udGFpbmVyO1xyXG59KENvbnRhaW5lckJhc2UpKTtcclxuZXhwb3J0cy5Db250YWluZXIgPSBDb250YWluZXI7XHJcbnZhciBDb2x1bW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ29sdW1uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ29sdW1uKHdpZHRoKSB7XHJcbiAgICAgICAgaWYgKHdpZHRoID09PSB2b2lkIDApIHsgd2lkdGggPSBcInN0cmV0Y2hcIjsgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMud2lkdGggPSBcInN0cmV0Y2hcIjtcclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuICAgICAgICBfdGhpcy5fY29tcHV0ZWRXZWlnaHQgPSAwO1xyXG4gICAgICAgIF90aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQ29sdW1uLnByb3RvdHlwZS5hZGp1c3RSZW5kZXJlZEVsZW1lbnRTaXplID0gZnVuY3Rpb24gKHJlbmRlcmVkRWxlbWVudCkge1xyXG4gICAgICAgIHZhciBtaW5EZXNpZ25UaW1lQ29sdW1uSGVpZ2h0ID0gMjA7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEZXNpZ25Nb2RlKCkpIHtcclxuICAgICAgICAgICAgcmVuZGVyZWRFbGVtZW50LnN0eWxlLm1pbldpZHRoID0gXCIyMHB4XCI7XHJcbiAgICAgICAgICAgIHJlbmRlcmVkRWxlbWVudC5zdHlsZS5taW5IZWlnaHQgPVxyXG4gICAgICAgICAgICAgICAgKCF0aGlzLm1pblBpeGVsSGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgPyBtaW5EZXNpZ25UaW1lQ29sdW1uSGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1heCh0aGlzLm1pblBpeGVsSGVpZ2h0LCBtaW5EZXNpZ25UaW1lQ29sdW1uSGVpZ2h0KSkgKyBcInB4XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZW5kZXJlZEVsZW1lbnQuc3R5bGUubWluV2lkdGggPSBcIjBcIjtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWluUGl4ZWxIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVkRWxlbWVudC5zdHlsZS5taW5IZWlnaHQgPSB0aGlzLm1pblBpeGVsSGVpZ2h0ICsgXCJweFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLndpZHRoID09PSBcImF1dG9cIikge1xyXG4gICAgICAgICAgICByZW5kZXJlZEVsZW1lbnQuc3R5bGUuZmxleCA9IFwiMCAxIGF1dG9cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy53aWR0aCA9PT0gXCJzdHJldGNoXCIpIHtcclxuICAgICAgICAgICAgcmVuZGVyZWRFbGVtZW50LnN0eWxlLmZsZXggPSBcIjEgMSA1MHB4XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMud2lkdGggaW5zdGFuY2VvZiBzaGFyZWRfMS5TaXplQW5kVW5pdCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aC51bml0ID09PSBFbnVtcy5TaXplVW5pdC5QaXhlbCkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRFbGVtZW50LnN0eWxlLmZsZXggPSBcIjAgMCBhdXRvXCI7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlZEVsZW1lbnQuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoLnBoeXNpY2FsU2l6ZSArIFwicHhcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVkRWxlbWVudC5zdHlsZS5mbGV4ID1cclxuICAgICAgICAgICAgICAgICAgICBcIjEgMSBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLl9jb21wdXRlZFdlaWdodCA+IDAgPyB0aGlzLl9jb21wdXRlZFdlaWdodCA6IHRoaXMud2lkdGgucGh5c2ljYWxTaXplKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiJVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENvbHVtbi5wcm90b3R5cGUuc2hvdWxkU2VyaWFsaXplID0gZnVuY3Rpb24gKF9jb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbHVtbi5wcm90b3R5cGUsIFwic2VwYXJhdG9yT3JpZW50YXRpb25cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gRW51bXMuT3JpZW50YXRpb24uVmVydGljYWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQ29sdW1uLnByb3RvdHlwZS5nZXRKc29uVHlwZU5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiQ29sdW1uXCI7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbHVtbi5wcm90b3R5cGUsIFwiaGFzVmlzaWJsZVNlcGFyYXRvclwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudCBpbnN0YW5jZW9mIENvbHVtblNldCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VwYXJhdG9yRWxlbWVudCAhPT0gdW5kZWZpbmVkICYmICF0aGlzLnBhcmVudC5pc0xlZnRNb3N0RWxlbWVudCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2x1bW4ucHJvdG90eXBlLCBcImlzU3RhbmRhbG9uZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvLyNyZWdpb24gU2NoZW1hXHJcbiAgICBDb2x1bW4ud2lkdGhQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuQ3VzdG9tUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwid2lkdGhcIiwgZnVuY3Rpb24gKHNlbmRlciwgcHJvcCwgc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHByb3AuZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wLm5hbWVdO1xyXG4gICAgICAgIHZhciBpbnZhbGlkV2lkdGggPSBmYWxzZTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmICFpc05hTih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IHNoYXJlZF8xLlNpemVBbmRVbml0KHZhbHVlLCBFbnVtcy5TaXplVW5pdC5XZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCJhdXRvXCIgfHwgdmFsdWUgPT09IFwic3RyZXRjaFwiKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNoYXJlZF8xLlNpemVBbmRVbml0LnBhcnNlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudW5pdCA9PT0gRW51bXMuU2l6ZVVuaXQuUGl4ZWwgJiZcclxuICAgICAgICAgICAgICAgICAgICBwcm9wLnRhcmdldFZlcnNpb24uY29tcGFyZVRvKGNvbnRleHQudGFyZ2V0VmVyc2lvbikgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZFdpZHRoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgaW52YWxpZFdpZHRoID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaW52YWxpZFdpZHRoID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGludmFsaWRXaWR0aCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmxvZ1BhcnNlRXZlbnQoc2VuZGVyLCBFbnVtcy5WYWxpZGF0aW9uRXZlbnQuSW52YWxpZFByb3BlcnR5VmFsdWUsIHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy5pbnZhbGlkQ29sdW1uV2lkdGgodmFsdWUpKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gXCJhdXRvXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LCBmdW5jdGlvbiAoc2VuZGVyLCBwcm9wZXJ0eSwgdGFyZ2V0LCB2YWx1ZSwgY29udGV4dCkge1xyXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIHNoYXJlZF8xLlNpemVBbmRVbml0KSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS51bml0ID09PSBFbnVtcy5TaXplVW5pdC5QaXhlbCkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zZXJpYWxpemVWYWx1ZSh0YXJnZXQsIFwid2lkdGhcIiwgdmFsdWUucGh5c2ljYWxTaXplICsgXCJweFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2VyaWFsaXplTnVtYmVyKHRhcmdldCwgXCJ3aWR0aFwiLCB2YWx1ZS5waHlzaWNhbFNpemUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb250ZXh0LnNlcmlhbGl6ZVZhbHVlKHRhcmdldCwgXCJ3aWR0aFwiLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgXCJzdHJldGNoXCIpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoQ29sdW1uLndpZHRoUHJvcGVydHkpXHJcbiAgICBdLCBDb2x1bW4ucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XHJcbiAgICByZXR1cm4gQ29sdW1uO1xyXG59KENvbnRhaW5lcikpO1xyXG5leHBvcnRzLkNvbHVtbiA9IENvbHVtbjtcclxudmFyIENvbHVtblNldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb2x1bW5TZXQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDb2x1bW5TZXQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX2NvbHVtbnMgPSBbXTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBDb2x1bW5TZXQucHJvdG90eXBlLmNyZWF0ZUNvbHVtbkluc3RhbmNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiBjb250ZXh0LnBhcnNlQ2FyZE9iamVjdCh0aGlzLCBzb3VyY2UsIFtdLCAhdGhpcy5pc0Rlc2lnbk1vZGUoKSwgZnVuY3Rpb24gKHR5cGVOYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhdHlwZU5hbWUgfHwgdHlwZU5hbWUgPT09IFwiQ29sdW1uXCIgPyBuZXcgQ29sdW1uKCkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKHR5cGVOYW1lLCBfZXJyb3JUeXBlKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQubG9nUGFyc2VFdmVudCh1bmRlZmluZWQsIEVudW1zLlZhbGlkYXRpb25FdmVudC5FbGVtZW50VHlwZU5vdEFsbG93ZWQsIHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy5lbGVtZW50VHlwZU5vdEFsbG93ZWQodHlwZU5hbWUpKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBDb2x1bW5TZXQucHJvdG90eXBlLmludGVybmFsUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVkQ29sdW1ucyA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLl9jb2x1bW5zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy8gQ2FjaGUgaG9zdENvbmZpZyB0byBhdm9pZCB3YWxraW5nIHRoZSBwYXJlbnQgaGllcmFyY2h5IHNldmVyYWwgdGltZXNcclxuICAgICAgICAgICAgdmFyIGhvc3RDb25maWcgPSB0aGlzLmhvc3RDb25maWc7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1jb2x1bW5TZXRcIik7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xyXG4gICAgICAgICAgICBpZiAoc2hhcmVkXzEuR2xvYmFsU2V0dGluZ3MudXNlQWR2YW5jZWRDYXJkQm90dG9tVHJ1bmNhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgLy8gU2VlIGNvbW1lbnQgaW4gQ29udGFpbmVyLmludGVybmFsUmVuZGVyKClcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUubWluSGVpZ2h0ID0gXCItd2Via2l0LW1pbi1jb250ZW50XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmdldEVmZmVjdGl2ZUhvcml6b250YWxBbGlnbm1lbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFbnVtcy5Ib3Jpem9udGFsQWxpZ25tZW50LkNlbnRlcjpcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmp1c3RpZnlDb250ZW50ID0gXCJjZW50ZXJcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRW51bXMuSG9yaXpvbnRhbEFsaWdubWVudC5SaWdodDpcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmp1c3RpZnlDb250ZW50ID0gXCJmbGV4LWVuZFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmp1c3RpZnlDb250ZW50ID0gXCJmbGV4LXN0YXJ0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRvdGFsV2VpZ2h0ID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX2NvbHVtbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi53aWR0aCBpbnN0YW5jZW9mIHNoYXJlZF8xLlNpemVBbmRVbml0ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLndpZHRoLnVuaXQgPT09IEVudW1zLlNpemVVbml0LldlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsV2VpZ2h0ICs9IGNvbHVtbi53aWR0aC5waHlzaWNhbFNpemU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMuX2NvbHVtbnM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi53aWR0aCBpbnN0YW5jZW9mIHNoYXJlZF8xLlNpemVBbmRVbml0ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLndpZHRoLnVuaXQgPT09IEVudW1zLlNpemVVbml0LldlaWdodCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsV2VpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wdXRlZFdlaWdodCA9ICgxMDAgLyB0b3RhbFdlaWdodCkgKiBjb2x1bW4ud2lkdGgucGh5c2ljYWxTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlc3Qgd2F5IHRvIGVtdWxhdGUgXCJpbnRlcm5hbFwiIGFjY2VzcyBJIGtub3cgb2ZcclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5bXCJfY29tcHV0ZWRXZWlnaHRcIl0gPSBjb21wdXRlZFdlaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByZW5kZXJlZENvbHVtbiA9IGNvbHVtbi5yZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJlZENvbHVtbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZW5kZXJlZENvbHVtbnMubGVuZ3RoID4gMCAmJiBjb2x1bW4uc2VwYXJhdG9yRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc2VwYXJhdG9yRWxlbWVudC5zdHlsZS5mbGV4ID0gXCIwIDAgYXV0b1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBVdGlscy5hcHBlbmRDaGlsZChlbGVtZW50LCBjb2x1bW4uc2VwYXJhdG9yRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFV0aWxzLmFwcGVuZENoaWxkKGVsZW1lbnQsIHJlbmRlcmVkQ29sdW1uKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlZENvbHVtbnMucHVzaChjb2x1bW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlZENvbHVtbnMubGVuZ3RoID4gMCA/IGVsZW1lbnQgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDb2x1bW5TZXQucHJvdG90eXBlLnRydW5jYXRlT3ZlcmZsb3cgPSBmdW5jdGlvbiAobWF4SGVpZ2h0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX2NvbHVtbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGNvbHVtbltcImhhbmRsZU92ZXJmbG93XCJdKG1heEhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIENvbHVtblNldC5wcm90b3R5cGUudW5kb092ZXJmbG93VHJ1bmNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fY29sdW1uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IF9hW19pXTtcclxuICAgICAgICAgICAgY29sdW1uW1wicmVzZXRPdmVyZmxvd1wiXSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sdW1uU2V0LnByb3RvdHlwZSwgXCJpc1NlbGVjdGFibGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBDb2x1bW5TZXQucHJvdG90eXBlLmludGVybmFsUGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbnRlcm5hbFBhcnNlLmNhbGwodGhpcywgc291cmNlLCBjb250ZXh0KTtcclxuICAgICAgICB0aGlzLl9jb2x1bW5zID0gW107XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZWRDb2x1bW5zID0gW107XHJcbiAgICAgICAgdmFyIGpzb25Db2x1bW5zID0gc291cmNlW1wiY29sdW1uc1wiXTtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uQ29sdW1ucykpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBqc29uQ29sdW1uc18xID0ganNvbkNvbHVtbnM7IF9pIDwganNvbkNvbHVtbnNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0ganNvbkNvbHVtbnNfMVtfaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5jcmVhdGVDb2x1bW5JbnN0YW5jZShpdGVtLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb2x1bW5zLnB1c2goY29sdW1uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDb2x1bW5TZXQucHJvdG90eXBlLmludGVybmFsVG9KU09OID0gZnVuY3Rpb24gKHRhcmdldCwgY29udGV4dCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW50ZXJuYWxUb0pTT04uY2FsbCh0aGlzLCB0YXJnZXQsIGNvbnRleHQpO1xyXG4gICAgICAgIGNvbnRleHQuc2VyaWFsaXplQXJyYXkodGFyZ2V0LCBcImNvbHVtbnNcIiwgdGhpcy5fY29sdW1ucyk7XHJcbiAgICB9O1xyXG4gICAgQ29sdW1uU2V0LnByb3RvdHlwZS5pc0ZpcnN0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX2NvbHVtbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGlmIChjb2x1bW4uaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uID09PSBlbGVtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBDb2x1bW5TZXQucHJvdG90eXBlLmlzQmxlZWRpbmdBdFRvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0JsZWVkaW5nKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJlZENvbHVtbnMgJiYgdGhpcy5fcmVuZGVyZWRDb2x1bW5zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX2NvbHVtbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5pc0JsZWVkaW5nQXRUb3AoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBDb2x1bW5TZXQucHJvdG90eXBlLmlzQmxlZWRpbmdBdEJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0JsZWVkaW5nKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJlZENvbHVtbnMgJiYgdGhpcy5fcmVuZGVyZWRDb2x1bW5zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX2NvbHVtbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5pc0JsZWVkaW5nQXRCb3R0b20oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBDb2x1bW5TZXQucHJvdG90eXBlLmdldEl0ZW1Db3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29sdW1ucy5sZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgQ29sdW1uU2V0LnByb3RvdHlwZS5nZXRGaXJzdFZpc2libGVSZW5kZXJlZEl0ZW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRFbGVtZW50ICYmIHRoaXMuX3JlbmRlcmVkQ29sdW1ucyAmJiB0aGlzLl9yZW5kZXJlZENvbHVtbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZWRDb2x1bW5zWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29sdW1uU2V0LnByb3RvdHlwZS5nZXRMYXN0VmlzaWJsZVJlbmRlcmVkSXRlbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5yZW5kZXJlZEVsZW1lbnQgJiYgdGhpcy5fcmVuZGVyZWRDb2x1bW5zICYmIHRoaXMuX3JlbmRlcmVkQ29sdW1ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlZENvbHVtbnNbdGhpcy5fcmVuZGVyZWRDb2x1bW5zLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29sdW1uU2V0LnByb3RvdHlwZS5nZXRDb2x1bW5BdCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zW2luZGV4XTtcclxuICAgIH07XHJcbiAgICBDb2x1bW5TZXQucHJvdG90eXBlLmdldEl0ZW1BdCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtbkF0KGluZGV4KTtcclxuICAgIH07XHJcbiAgICBDb2x1bW5TZXQucHJvdG90eXBlLmdldEpzb25UeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXCJDb2x1bW5TZXRcIjtcclxuICAgIH07XHJcbiAgICBDb2x1bW5TZXQucHJvdG90eXBlLmludGVybmFsVmFsaWRhdGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmludGVybmFsVmFsaWRhdGVQcm9wZXJ0aWVzLmNhbGwodGhpcywgY29udGV4dCk7XHJcbiAgICAgICAgdmFyIHdlaWdodGVkQ29sdW1ucyA9IDA7XHJcbiAgICAgICAgdmFyIHN0cmV0Y2hlZENvbHVtbnMgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9jb2x1bW5zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgY29sdW1uID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbHVtbi53aWR0aCA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgd2VpZ2h0ZWRDb2x1bW5zKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29sdW1uLndpZHRoID09PSBcInN0cmV0Y2hcIikge1xyXG4gICAgICAgICAgICAgICAgc3RyZXRjaGVkQ29sdW1ucysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh3ZWlnaHRlZENvbHVtbnMgPiAwICYmIHN0cmV0Y2hlZENvbHVtbnMgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYWRkRmFpbHVyZSh0aGlzLCBFbnVtcy5WYWxpZGF0aW9uRXZlbnQuSGludCwgc3RyaW5nc18xLlN0cmluZ3MuaGludHMuZG9udFVzZVdlaWdodGVkQW5kU3RyZWN0aGVkQ29sdW1uc0luU2FtZVNldCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29sdW1uU2V0LnByb3RvdHlwZS5hZGRDb2x1bW4gPSBmdW5jdGlvbiAoY29sdW1uKSB7XHJcbiAgICAgICAgaWYgKCFjb2x1bW4ucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbHVtbnMucHVzaChjb2x1bW4pO1xyXG4gICAgICAgICAgICBjb2x1bW4uc2V0UGFyZW50KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy5jb2x1bW5BbHJlYWR5QmVsb25nc1RvQW5vdGhlclNldCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29sdW1uU2V0LnByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIENvbHVtbikge1xyXG4gICAgICAgICAgICB2YXIgaXRlbUluZGV4ID0gdGhpcy5fY29sdW1ucy5pbmRleE9mKGl0ZW0pO1xyXG4gICAgICAgICAgICBpZiAoaXRlbUluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbHVtbnMuc3BsaWNlKGl0ZW1JbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICBpdGVtLnNldFBhcmVudCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYXlvdXQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBDb2x1bW5TZXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoY2FyZEVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gY2FyZEVsZW1lbnQgaW5zdGFuY2VvZiBDb2x1bW4gPyB0aGlzLl9jb2x1bW5zLmluZGV4T2YoY2FyZEVsZW1lbnQpIDogLTE7XHJcbiAgICB9O1xyXG4gICAgQ29sdW1uU2V0LnByb3RvdHlwZS5pc0xlZnRNb3N0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbnMuaW5kZXhPZihlbGVtZW50KSA9PT0gMDtcclxuICAgIH07XHJcbiAgICBDb2x1bW5TZXQucHJvdG90eXBlLmlzUmlnaHRNb3N0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbnMuaW5kZXhPZihlbGVtZW50KSA9PT0gdGhpcy5fY29sdW1ucy5sZW5ndGggLSAxO1xyXG4gICAgfTtcclxuICAgIENvbHVtblNldC5wcm90b3R5cGUuaXNUb3BFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29sdW1ucy5pbmRleE9mKGVsZW1lbnQpID49IDA7XHJcbiAgICB9O1xyXG4gICAgQ29sdW1uU2V0LnByb3RvdHlwZS5pc0JvdHRvbUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zLmluZGV4T2YoZWxlbWVudCkgPj0gMDtcclxuICAgIH07XHJcbiAgICBDb2x1bW5TZXQucHJvdG90eXBlLmdldEFjdGlvbkJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9jb2x1bW5zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgY29sdW1uID0gX2FbX2ldO1xyXG4gICAgICAgICAgICByZXN1bHQgPSBjb2x1bW4uZ2V0QWN0aW9uQnlJZChpZCk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbHVtblNldC5wcm90b3R5cGUsIFwiYmxlZWRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCbGVlZCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRCbGVlZCh2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbHVtblNldC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFBhZGRpbmcoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UGFkZGluZyh2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbHVtblNldC5wcm90b3R5cGUsIFwic2VsZWN0QWN0aW9uXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdEFjdGlvbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdEFjdGlvbiA9IHZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBDb2x1bW5TZXQ7XHJcbn0oQ29udGFpbmVyQmFzZSkpO1xyXG5leHBvcnRzLkNvbHVtblNldCA9IENvbHVtblNldDtcclxuZnVuY3Rpb24gcmFpc2VJbWFnZUxvYWRlZEV2ZW50KGltYWdlKSB7XHJcbiAgICB2YXIgY2FyZCA9IGltYWdlLmdldFJvb3RFbGVtZW50KCk7XHJcbiAgICB2YXIgb25JbWFnZUxvYWRlZEhhbmRsZXIgPSBjYXJkICYmIGNhcmQub25JbWFnZUxvYWRlZCA/IGNhcmQub25JbWFnZUxvYWRlZCA6IEFkYXB0aXZlQ2FyZC5vbkltYWdlTG9hZGVkO1xyXG4gICAgaWYgKG9uSW1hZ2VMb2FkZWRIYW5kbGVyKSB7XHJcbiAgICAgICAgb25JbWFnZUxvYWRlZEhhbmRsZXIoaW1hZ2UpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJhaXNlQW5jaG9yQ2xpY2tlZEV2ZW50KGVsZW1lbnQsIGFuY2hvciwgZXYpIHtcclxuICAgIHZhciBjYXJkID0gZWxlbWVudC5nZXRSb290RWxlbWVudCgpO1xyXG4gICAgdmFyIG9uQW5jaG9yQ2xpY2tlZEhhbmRsZXIgPSBjYXJkICYmIGNhcmQub25BbmNob3JDbGlja2VkID8gY2FyZC5vbkFuY2hvckNsaWNrZWQgOiBBZGFwdGl2ZUNhcmQub25BbmNob3JDbGlja2VkO1xyXG4gICAgcmV0dXJuIG9uQW5jaG9yQ2xpY2tlZEhhbmRsZXIgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgID8gb25BbmNob3JDbGlja2VkSGFuZGxlcihlbGVtZW50LCBhbmNob3IsIGV2KVxyXG4gICAgICAgIDogZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gcmFpc2VFeGVjdXRlQWN0aW9uRXZlbnQoYWN0aW9uKSB7XHJcbiAgICB2YXIgY2FyZCA9IGFjdGlvbi5wYXJlbnQgPyBhY3Rpb24ucGFyZW50LmdldFJvb3RFbGVtZW50KCkgOiB1bmRlZmluZWQ7XHJcbiAgICB2YXIgb25FeGVjdXRlQWN0aW9uSGFuZGxlciA9IGNhcmQgJiYgY2FyZC5vbkV4ZWN1dGVBY3Rpb24gPyBjYXJkLm9uRXhlY3V0ZUFjdGlvbiA6IEFkYXB0aXZlQ2FyZC5vbkV4ZWN1dGVBY3Rpb247XHJcbiAgICBpZiAoYWN0aW9uLnByZXBhcmVGb3JFeGVjdXRpb24oKSAmJiBvbkV4ZWN1dGVBY3Rpb25IYW5kbGVyKSB7XHJcbiAgICAgICAgb25FeGVjdXRlQWN0aW9uSGFuZGxlcihhY3Rpb24pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJhaXNlSW5saW5lQ2FyZEV4cGFuZGVkRXZlbnQoYWN0aW9uLCBpc0V4cGFuZGVkKSB7XHJcbiAgICB2YXIgY2FyZCA9IGFjdGlvbi5wYXJlbnQgPyBhY3Rpb24ucGFyZW50LmdldFJvb3RFbGVtZW50KCkgOiB1bmRlZmluZWQ7XHJcbiAgICB2YXIgb25JbmxpbmVDYXJkRXhwYW5kZWRIYW5kbGVyID0gY2FyZCAmJiBjYXJkLm9uSW5saW5lQ2FyZEV4cGFuZGVkXHJcbiAgICAgICAgPyBjYXJkLm9uSW5saW5lQ2FyZEV4cGFuZGVkXHJcbiAgICAgICAgOiBBZGFwdGl2ZUNhcmQub25JbmxpbmVDYXJkRXhwYW5kZWQ7XHJcbiAgICBpZiAob25JbmxpbmVDYXJkRXhwYW5kZWRIYW5kbGVyKSB7XHJcbiAgICAgICAgb25JbmxpbmVDYXJkRXhwYW5kZWRIYW5kbGVyKGFjdGlvbiwgaXNFeHBhbmRlZCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmFpc2VJbnB1dFZhbHVlQ2hhbmdlZEV2ZW50KGlucHV0KSB7XHJcbiAgICB2YXIgY2FyZCA9IGlucHV0LmdldFJvb3RFbGVtZW50KCk7XHJcbiAgICB2YXIgb25JbnB1dFZhbHVlQ2hhbmdlZEhhbmRsZXIgPSBjYXJkICYmIGNhcmQub25JbnB1dFZhbHVlQ2hhbmdlZFxyXG4gICAgICAgID8gY2FyZC5vbklucHV0VmFsdWVDaGFuZ2VkXHJcbiAgICAgICAgOiBBZGFwdGl2ZUNhcmQub25JbnB1dFZhbHVlQ2hhbmdlZDtcclxuICAgIGlmIChvbklucHV0VmFsdWVDaGFuZ2VkSGFuZGxlcikge1xyXG4gICAgICAgIG9uSW5wdXRWYWx1ZUNoYW5nZWRIYW5kbGVyKGlucHV0KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByYWlzZUVsZW1lbnRWaXNpYmlsaXR5Q2hhbmdlZEV2ZW50KGVsZW1lbnQsIHNob3VsZFVwZGF0ZUxheW91dCkge1xyXG4gICAgaWYgKHNob3VsZFVwZGF0ZUxheW91dCA9PT0gdm9pZCAwKSB7IHNob3VsZFVwZGF0ZUxheW91dCA9IHRydWU7IH1cclxuICAgIHZhciByb290RWxlbWVudCA9IGVsZW1lbnQuZ2V0Um9vdEVsZW1lbnQoKTtcclxuICAgIGlmIChzaG91bGRVcGRhdGVMYXlvdXQpIHtcclxuICAgICAgICByb290RWxlbWVudC51cGRhdGVMYXlvdXQoKTtcclxuICAgIH1cclxuICAgIHZhciBjYXJkID0gcm9vdEVsZW1lbnQ7XHJcbiAgICB2YXIgb25FbGVtZW50VmlzaWJpbGl0eUNoYW5nZWRIYW5kbGVyID0gY2FyZCAmJiBjYXJkLm9uRWxlbWVudFZpc2liaWxpdHlDaGFuZ2VkXHJcbiAgICAgICAgPyBjYXJkLm9uRWxlbWVudFZpc2liaWxpdHlDaGFuZ2VkXHJcbiAgICAgICAgOiBBZGFwdGl2ZUNhcmQub25FbGVtZW50VmlzaWJpbGl0eUNoYW5nZWQ7XHJcbiAgICBpZiAob25FbGVtZW50VmlzaWJpbGl0eUNoYW5nZWRIYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBvbkVsZW1lbnRWaXNpYmlsaXR5Q2hhbmdlZEhhbmRsZXIoZWxlbWVudCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIHJldHVybiBmYWxzZSB0byBjb250aW51ZSB3aXRoIGRlZmF1bHQgY29udGV4dCBtZW51OyByZXR1cm4gdHJ1ZSB0byBza2lwIFNESyBkZWZhdWx0IGNvbnRleHQgbWVudVxyXG4gKi9cclxuZnVuY3Rpb24gcmFpc2VEaXNwbGF5T3ZlcmZsb3dBY3Rpb25NZW51RXZlbnQoYWN0aW9uLCB0YXJnZXQpIHtcclxuICAgIHZhciBjYXJkID0gYWN0aW9uLnBhcmVudCA/IGFjdGlvbi5wYXJlbnQuZ2V0Um9vdEVsZW1lbnQoKSA6IHVuZGVmaW5lZDtcclxuICAgIHZhciBvbkRpc3BsYXlPdmVyZmxvd0FjdGlvbk1lbnVIYW5kbGVyID0gY2FyZCAmJiBjYXJkLm9uRGlzcGxheU92ZXJmbG93QWN0aW9uTWVudVxyXG4gICAgICAgID8gY2FyZC5vbkRpc3BsYXlPdmVyZmxvd0FjdGlvbk1lbnVcclxuICAgICAgICA6IEFkYXB0aXZlQ2FyZC5vbkRpc3BsYXlPdmVyZmxvd0FjdGlvbk1lbnU7XHJcbiAgICByZXR1cm4gb25EaXNwbGF5T3ZlcmZsb3dBY3Rpb25NZW51SGFuZGxlciAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgPyBvbkRpc3BsYXlPdmVyZmxvd0FjdGlvbk1lbnVIYW5kbGVyKGFjdGlvbi5nZXRBY3Rpb25zKCksIHRhcmdldClcclxuICAgICAgICA6IGZhbHNlO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyByZXR1cm4gZmFsc2UgdG8gY29udGludWUgd2l0aCBkZWZhdWx0IGFjdGlvbiBidXR0b247IHJldHVybiB0cnVlIHRvIHNraXAgU0RLIGRlZmF1bHQgYWN0aW9uIGJ1dHRvblxyXG4gKi9cclxuZnVuY3Rpb24gcmFpc2VSZW5kZXJPdmVyZmxvd0FjdGlvbnNFdmVudChhY3Rpb24sIGlzQXRSb290TGV2ZWxBY3Rpb25zKSB7XHJcbiAgICB2YXIgY2FyZCA9IGFjdGlvbi5wYXJlbnQgPyBhY3Rpb24ucGFyZW50LmdldFJvb3RFbGVtZW50KCkgOiB1bmRlZmluZWQ7XHJcbiAgICB2YXIgb25SZW5kZXJPdmVyZmxvd0FjdGlvbnNIYW5kbGVyID0gY2FyZCAmJiBjYXJkLm9uUmVuZGVyT3ZlcmZsb3dBY3Rpb25zXHJcbiAgICAgICAgPyBjYXJkLm9uUmVuZGVyT3ZlcmZsb3dBY3Rpb25zXHJcbiAgICAgICAgOiBBZGFwdGl2ZUNhcmQub25SZW5kZXJPdmVyZmxvd0FjdGlvbnM7XHJcbiAgICByZXR1cm4gb25SZW5kZXJPdmVyZmxvd0FjdGlvbnNIYW5kbGVyICE9PSB1bmRlZmluZWRcclxuICAgICAgICA/IG9uUmVuZGVyT3ZlcmZsb3dBY3Rpb25zSGFuZGxlcihhY3Rpb24uZ2V0QWN0aW9ucygpLCBpc0F0Um9vdExldmVsQWN0aW9ucylcclxuICAgICAgICA6IGZhbHNlO1xyXG59XHJcbnZhciBDb250YWluZXJXaXRoQWN0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb250YWluZXJXaXRoQWN0aW9ucywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENvbnRhaW5lcldpdGhBY3Rpb25zKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX2FjdGlvbkNvbGxlY3Rpb24gPSBuZXcgQWN0aW9uQ29sbGVjdGlvbihfdGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQ29udGFpbmVyV2l0aEFjdGlvbnMucHJvdG90eXBlLmludGVybmFsUGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbnRlcm5hbFBhcnNlLmNhbGwodGhpcywgc291cmNlLCBjb250ZXh0KTtcclxuICAgICAgICB0aGlzLnBhcnNlQWN0aW9ucyhzb3VyY2UsIGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIENvbnRhaW5lcldpdGhBY3Rpb25zLnByb3RvdHlwZS5wYXJzZUFjdGlvbnMgPSBmdW5jdGlvbiAoc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9uQ29sbGVjdGlvbi5wYXJzZShzb3VyY2VbXCJhY3Rpb25zXCJdLCBjb250ZXh0KTtcclxuICAgIH07XHJcbiAgICBDb250YWluZXJXaXRoQWN0aW9ucy5wcm90b3R5cGUuaW50ZXJuYWxUb0pTT04gPSBmdW5jdGlvbiAodGFyZ2V0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbnRlcm5hbFRvSlNPTi5jYWxsKHRoaXMsIHRhcmdldCwgY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9uQ29sbGVjdGlvbi50b0pTT04odGFyZ2V0LCBcImFjdGlvbnNcIiwgY29udGV4dCk7XHJcbiAgICB9O1xyXG4gICAgQ29udGFpbmVyV2l0aEFjdGlvbnMucHJvdG90eXBlLmludGVybmFsUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gX3N1cGVyLnByb3RvdHlwZS5pbnRlcm5hbFJlbmRlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciByZW5kZXJlZEFjdGlvbnMgPSB0aGlzLl9hY3Rpb25Db2xsZWN0aW9uLnJlbmRlcih0aGlzLmhvc3RDb25maWcuYWN0aW9ucy5hY3Rpb25zT3JpZW50YXRpb24pO1xyXG4gICAgICAgICAgICBpZiAocmVuZGVyZWRBY3Rpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBVdGlscy5hcHBlbmRDaGlsZChlbGVtZW50LCByZW5kZXJTZXBhcmF0aW9uKHRoaXMuaG9zdENvbmZpZywge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwYWNpbmc6IHRoaXMuaG9zdENvbmZpZy5nZXRFZmZlY3RpdmVTcGFjaW5nKHRoaXMuaG9zdENvbmZpZy5hY3Rpb25zLnNwYWNpbmcpXHJcbiAgICAgICAgICAgICAgICB9LCBFbnVtcy5PcmllbnRhdGlvbi5Ib3Jpem9udGFsKSk7XHJcbiAgICAgICAgICAgICAgICBVdGlscy5hcHBlbmRDaGlsZChlbGVtZW50LCByZW5kZXJlZEFjdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcklmRW1wdHkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID4gMCA/IGVsZW1lbnQgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENvbnRhaW5lcldpdGhBY3Rpb25zLnByb3RvdHlwZS5nZXRIYXNFeHBhbmRlZEFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5yZW5kZXJlZEFjdGlvbkNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5yZW5kZXJlZEFjdGlvbkNvdW50ID09PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fYWN0aW9uQ29sbGVjdGlvbi5leHBhbmRlZEFjdGlvbiAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5ob3N0Q29uZmlnLmFjdGlvbnMucHJlRXhwYW5kU2luZ2xlU2hvd0NhcmRBY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbkNvbGxlY3Rpb24uZXhwYW5kZWRBY3Rpb24gIT09IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhaW5lcldpdGhBY3Rpb25zLnByb3RvdHlwZSwgXCJyZW5kZXJlZEFjdGlvbkNvdW50XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbkNvbGxlY3Rpb24ucmVuZGVyZWRBY3Rpb25Db3VudDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGFpbmVyV2l0aEFjdGlvbnMucHJvdG90eXBlLCBcInJlbmRlcklmRW1wdHlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQ29udGFpbmVyV2l0aEFjdGlvbnMucHJvdG90eXBlLnJlbGVhc2VET01SZXNvdXJjZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZWxlYXNlRE9NUmVzb3VyY2VzLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9uQ29sbGVjdGlvbi5yZWxlYXNlRE9NUmVzb3VyY2VzKCk7XHJcbiAgICB9O1xyXG4gICAgQ29udGFpbmVyV2l0aEFjdGlvbnMucHJvdG90eXBlLmdldEFjdGlvbkNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb25Db2xsZWN0aW9uLmdldEFjdGlvbkNvdW50KCk7XHJcbiAgICB9O1xyXG4gICAgQ29udGFpbmVyV2l0aEFjdGlvbnMucHJvdG90eXBlLmdldEFjdGlvbkF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLmdldEFjdGlvbkNvdW50KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbkNvbGxlY3Rpb24uZ2V0QWN0aW9uQXQoaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZ2V0QWN0aW9uQXQuY2FsbCh0aGlzLCBpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENvbnRhaW5lcldpdGhBY3Rpb25zLnByb3RvdHlwZS5nZXRBY3Rpb25CeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2FjdGlvbkNvbGxlY3Rpb24uZ2V0QWN0aW9uQnlJZChpZCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdCA6IF9zdXBlci5wcm90b3R5cGUuZ2V0QWN0aW9uQnlJZC5jYWxsKHRoaXMsIGlkKTtcclxuICAgIH07XHJcbiAgICBDb250YWluZXJXaXRoQWN0aW9ucy5wcm90b3R5cGUuaW50ZXJuYWxWYWxpZGF0ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW50ZXJuYWxWYWxpZGF0ZVByb3BlcnRpZXMuY2FsbCh0aGlzLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAodGhpcy5fYWN0aW9uQ29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25Db2xsZWN0aW9uLnZhbGlkYXRlUHJvcGVydGllcyhjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29udGFpbmVyV2l0aEFjdGlvbnMucHJvdG90eXBlLmlzTGFzdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmlzTGFzdEVsZW1lbnQuY2FsbCh0aGlzLCBlbGVtZW50KSAmJiB0aGlzLl9hY3Rpb25Db2xsZWN0aW9uLmdldEFjdGlvbkNvdW50KCkgPT09IDA7XHJcbiAgICB9O1xyXG4gICAgQ29udGFpbmVyV2l0aEFjdGlvbnMucHJvdG90eXBlLmFkZEFjdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB0aGlzLl9hY3Rpb25Db2xsZWN0aW9uLmFkZEFjdGlvbihhY3Rpb24pO1xyXG4gICAgfTtcclxuICAgIENvbnRhaW5lcldpdGhBY3Rpb25zLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmNsZWFyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9uQ29sbGVjdGlvbi5jbGVhcigpO1xyXG4gICAgfTtcclxuICAgIENvbnRhaW5lcldpdGhBY3Rpb25zLnByb3RvdHlwZS5nZXRBbGxJbnB1dHMgPSBmdW5jdGlvbiAocHJvY2Vzc0FjdGlvbnMpIHtcclxuICAgICAgICBpZiAocHJvY2Vzc0FjdGlvbnMgPT09IHZvaWQgMCkgeyBwcm9jZXNzQWN0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS5nZXRBbGxJbnB1dHMuY2FsbCh0aGlzLCBwcm9jZXNzQWN0aW9ucyk7XHJcbiAgICAgICAgaWYgKHByb2Nlc3NBY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgdGhpcy5fYWN0aW9uQ29sbGVjdGlvbi5nZXRBbGxJbnB1dHMocHJvY2Vzc0FjdGlvbnMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBDb250YWluZXJXaXRoQWN0aW9ucy5wcm90b3R5cGUuZ2V0UmVzb3VyY2VJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS5nZXRSZXNvdXJjZUluZm9ybWF0aW9uLmNhbGwodGhpcyk7XHJcbiAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCB0aGlzLl9hY3Rpb25Db2xsZWN0aW9uLmdldFJlc291cmNlSW5mb3JtYXRpb24oKSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBDb250YWluZXJXaXRoQWN0aW9ucy5wcm90b3R5cGUuaXNCbGVlZGluZ0F0Qm90dG9tID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9hY3Rpb25Db2xsZWN0aW9uLnJlbmRlcmVkQWN0aW9uQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuaXNCbGVlZGluZ0F0Qm90dG9tLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aW9uQ29sbGVjdGlvbi5nZXRBY3Rpb25Db3VudCgpID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuX2FjdGlvbkNvbGxlY3Rpb24uZXhwYW5kZWRBY3Rpb24gIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmhvc3RDb25maWcuYWN0aW9ucy5wcmVFeHBhbmRTaW5nbGVTaG93Q2FyZEFjdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aW9uQ29sbGVjdGlvbi5leHBhbmRlZEFjdGlvbiAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENvbnRhaW5lcldpdGhBY3Rpb25zLnByb3RvdHlwZS5nZXRGb3JiaWRkZW5BY3Rpb25OYW1lcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhaW5lcldpdGhBY3Rpb25zLnByb3RvdHlwZSwgXCJpc1N0YW5kYWxvbmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIENvbnRhaW5lcldpdGhBY3Rpb25zO1xyXG59KENvbnRhaW5lcikpO1xyXG5leHBvcnRzLkNvbnRhaW5lcldpdGhBY3Rpb25zID0gQ29udGFpbmVyV2l0aEFjdGlvbnM7XHJcbnZhciBSZWZyZXNoQWN0aW9uUHJvcGVydHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUmVmcmVzaEFjdGlvblByb3BlcnR5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUmVmcmVzaEFjdGlvblByb3BlcnR5KHRhcmdldFZlcnNpb24sIG5hbWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0YXJnZXRWZXJzaW9uLCBuYW1lLCB1bmRlZmluZWQpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudGFyZ2V0VmVyc2lvbiA9IHRhcmdldFZlcnNpb247XHJcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgUmVmcmVzaEFjdGlvblByb3BlcnR5LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzZW5kZXIsIHNvdXJjZSwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBhY3Rpb24gPSBjb250ZXh0LnBhcnNlQWN0aW9uKHNlbmRlci5wYXJlbnQsIHNvdXJjZVt0aGlzLm5hbWVdLCBbXSwgZmFsc2UpO1xyXG4gICAgICAgIGlmIChhY3Rpb24gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoYWN0aW9uIGluc3RhbmNlb2YgRXhlY3V0ZUFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250ZXh0LmxvZ1BhcnNlRXZlbnQoc2VuZGVyLCBFbnVtcy5WYWxpZGF0aW9uRXZlbnQuQWN0aW9uVHlwZU5vdEFsbG93ZWQsIHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy5hY3Rpb25UeXBlTm90QWxsb3dlZChhY3Rpb24uZ2V0SnNvblR5cGVOYW1lKCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGV4dC5sb2dQYXJzZUV2ZW50KHNlbmRlciwgRW51bXMuVmFsaWRhdGlvbkV2ZW50LlByb3BlcnR5Q2FudEJlTnVsbCwgc3RyaW5nc18xLlN0cmluZ3MuZXJyb3JzLnByb3BlcnR5TXVzdEJlU2V0KFwiYWN0aW9uXCIpKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIFJlZnJlc2hBY3Rpb25Qcm9wZXJ0eS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKHNlbmRlciwgdGFyZ2V0LCB2YWx1ZSwgY29udGV4dCkge1xyXG4gICAgICAgIGNvbnRleHQuc2VyaWFsaXplVmFsdWUodGFyZ2V0LCB0aGlzLm5hbWUsIHZhbHVlID8gdmFsdWUudG9KU09OKGNvbnRleHQpIDogdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZWZyZXNoQWN0aW9uUHJvcGVydHk7XHJcbn0oc2VyaWFsaXphdGlvbl8xLlByb3BlcnR5RGVmaW5pdGlvbikpO1xyXG5leHBvcnRzLlJlZnJlc2hBY3Rpb25Qcm9wZXJ0eSA9IFJlZnJlc2hBY3Rpb25Qcm9wZXJ0eTtcclxudmFyIFJlZnJlc2hEZWZpbml0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJlZnJlc2hEZWZpbml0aW9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUmVmcmVzaERlZmluaXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZnJlc2hEZWZpbml0aW9uLnByb3RvdHlwZSwgXCJhY3Rpb25cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZShSZWZyZXNoRGVmaW5pdGlvbi5hY3Rpb25Qcm9wZXJ0eSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKFJlZnJlc2hEZWZpbml0aW9uLmFjdGlvblByb3BlcnR5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUuc2V0UGFyZW50KHRoaXMucGFyZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFJlZnJlc2hEZWZpbml0aW9uLnByb3RvdHlwZS5nZXRTY2hlbWFLZXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiUmVmcmVzaERlZmluaXRpb25cIjtcclxuICAgIH07XHJcbiAgICAvLyNyZWdpb24gU2NoZW1hXHJcbiAgICBSZWZyZXNoRGVmaW5pdGlvbi5hY3Rpb25Qcm9wZXJ0eSA9IG5ldyBSZWZyZXNoQWN0aW9uUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzQsIFwiYWN0aW9uXCIpO1xyXG4gICAgUmVmcmVzaERlZmluaXRpb24udXNlcklkc1Byb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdBcnJheVByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV80LCBcInVzZXJJZHNcIik7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShSZWZyZXNoRGVmaW5pdGlvbi5hY3Rpb25Qcm9wZXJ0eSlcclxuICAgIF0sIFJlZnJlc2hEZWZpbml0aW9uLnByb3RvdHlwZSwgXCJhY3Rpb25cIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShSZWZyZXNoRGVmaW5pdGlvbi51c2VySWRzUHJvcGVydHkpXHJcbiAgICBdLCBSZWZyZXNoRGVmaW5pdGlvbi5wcm90b3R5cGUsIFwidXNlcklkc1wiLCB2b2lkIDApO1xyXG4gICAgcmV0dXJuIFJlZnJlc2hEZWZpbml0aW9uO1xyXG59KHNlcmlhbGl6YXRpb25fMS5TZXJpYWxpemFibGVPYmplY3QpKTtcclxuZXhwb3J0cy5SZWZyZXNoRGVmaW5pdGlvbiA9IFJlZnJlc2hEZWZpbml0aW9uO1xyXG52YXIgQXV0aENhcmRCdXR0b24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQXV0aENhcmRCdXR0b24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBdXRoQ2FyZEJ1dHRvbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBBdXRoQ2FyZEJ1dHRvbi5wcm90b3R5cGUuZ2V0U2NoZW1hS2V5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcIkF1dGhDYXJkQnV0dG9uXCI7XHJcbiAgICB9O1xyXG4gICAgLy8jcmVnaW9uIFNjaGVtYVxyXG4gICAgQXV0aENhcmRCdXR0b24udHlwZVByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfNCwgXCJ0eXBlXCIpO1xyXG4gICAgQXV0aENhcmRCdXR0b24udGl0bGVQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuU3RyaW5nUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzQsIFwidGl0bGVcIik7XHJcbiAgICBBdXRoQ2FyZEJ1dHRvbi5pbWFnZVByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfNCwgXCJpbWFnZVwiKTtcclxuICAgIEF1dGhDYXJkQnV0dG9uLnZhbHVlUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV80LCBcInZhbHVlXCIpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoQXV0aENhcmRCdXR0b24udHlwZVByb3BlcnR5KVxyXG4gICAgXSwgQXV0aENhcmRCdXR0b24ucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEF1dGhDYXJkQnV0dG9uLnRpdGxlUHJvcGVydHkpXHJcbiAgICBdLCBBdXRoQ2FyZEJ1dHRvbi5wcm90b3R5cGUsIFwidGl0bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEF1dGhDYXJkQnV0dG9uLmltYWdlUHJvcGVydHkpXHJcbiAgICBdLCBBdXRoQ2FyZEJ1dHRvbi5wcm90b3R5cGUsIFwiaW1hZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEF1dGhDYXJkQnV0dG9uLnZhbHVlUHJvcGVydHkpXHJcbiAgICBdLCBBdXRoQ2FyZEJ1dHRvbi5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIHJldHVybiBBdXRoQ2FyZEJ1dHRvbjtcclxufShzZXJpYWxpemF0aW9uXzEuU2VyaWFsaXphYmxlT2JqZWN0KSk7XHJcbmV4cG9ydHMuQXV0aENhcmRCdXR0b24gPSBBdXRoQ2FyZEJ1dHRvbjtcclxudmFyIFRva2VuRXhjaGFuZ2VSZXNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhUb2tlbkV4Y2hhbmdlUmVzb3VyY2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUb2tlbkV4Y2hhbmdlUmVzb3VyY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgVG9rZW5FeGNoYW5nZVJlc291cmNlLnByb3RvdHlwZS5nZXRTY2hlbWFLZXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiVG9rZW5FeGNoYW5nZVJlc291cmNlXCI7XHJcbiAgICB9O1xyXG4gICAgLy8jcmVnaW9uIFNjaGVtYVxyXG4gICAgVG9rZW5FeGNoYW5nZVJlc291cmNlLmlkUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV80LCBcImlkXCIpO1xyXG4gICAgVG9rZW5FeGNoYW5nZVJlc291cmNlLnVyaVByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfNCwgXCJ1cmlcIik7XHJcbiAgICBUb2tlbkV4Y2hhbmdlUmVzb3VyY2UucHJvdmlkZXJJZFByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfNCwgXCJwcm92aWRlcklkXCIpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoVG9rZW5FeGNoYW5nZVJlc291cmNlLmlkUHJvcGVydHkpXHJcbiAgICBdLCBUb2tlbkV4Y2hhbmdlUmVzb3VyY2UucHJvdG90eXBlLCBcImlkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShUb2tlbkV4Y2hhbmdlUmVzb3VyY2UudXJpUHJvcGVydHkpXHJcbiAgICBdLCBUb2tlbkV4Y2hhbmdlUmVzb3VyY2UucHJvdG90eXBlLCBcInVyaVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoVG9rZW5FeGNoYW5nZVJlc291cmNlLnByb3ZpZGVySWRQcm9wZXJ0eSlcclxuICAgIF0sIFRva2VuRXhjaGFuZ2VSZXNvdXJjZS5wcm90b3R5cGUsIFwicHJvdmlkZXJJZFwiLCB2b2lkIDApO1xyXG4gICAgcmV0dXJuIFRva2VuRXhjaGFuZ2VSZXNvdXJjZTtcclxufShzZXJpYWxpemF0aW9uXzEuU2VyaWFsaXphYmxlT2JqZWN0KSk7XHJcbmV4cG9ydHMuVG9rZW5FeGNoYW5nZVJlc291cmNlID0gVG9rZW5FeGNoYW5nZVJlc291cmNlO1xyXG52YXIgQXV0aGVudGljYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQXV0aGVudGljYXRpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBdXRoZW50aWNhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUuZ2V0U2NoZW1hS2V5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcIkF1dGhlbnRpY2F0aW9uXCI7XHJcbiAgICB9O1xyXG4gICAgLy8jcmVnaW9uIFNjaGVtYVxyXG4gICAgQXV0aGVudGljYXRpb24udGV4dFByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfNCwgXCJ0ZXh0XCIpO1xyXG4gICAgQXV0aGVudGljYXRpb24uY29ubmVjdGlvbk5hbWVQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuU3RyaW5nUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzQsIFwiY29ubmVjdGlvbk5hbWVcIik7XHJcbiAgICBBdXRoZW50aWNhdGlvbi5idXR0b25zUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlNlcmlhbGl6YWJsZU9iamVjdENvbGxlY3Rpb25Qcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfNCwgXCJidXR0b25zXCIsIEF1dGhDYXJkQnV0dG9uKTtcclxuICAgIEF1dGhlbnRpY2F0aW9uLnRva2VuRXhjaGFuZ2VSZXNvdXJjZVByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TZXJpYWxpemFibGVPYmplY3RQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfNCwgXCJ0b2tlbkV4Y2hhbmdlUmVzb3VyY2VcIiwgVG9rZW5FeGNoYW5nZVJlc291cmNlLCB0cnVlKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEF1dGhlbnRpY2F0aW9uLnRleHRQcm9wZXJ0eSlcclxuICAgIF0sIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShBdXRoZW50aWNhdGlvbi5jb25uZWN0aW9uTmFtZVByb3BlcnR5KVxyXG4gICAgXSwgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLCBcImNvbm5lY3Rpb25OYW1lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShBdXRoZW50aWNhdGlvbi5idXR0b25zUHJvcGVydHkpXHJcbiAgICBdLCBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUsIFwiYnV0dG9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoQXV0aGVudGljYXRpb24udG9rZW5FeGNoYW5nZVJlc291cmNlUHJvcGVydHkpXHJcbiAgICBdLCBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUsIFwidG9rZW5FeGNoYW5nZVJlc291cmNlXCIsIHZvaWQgMCk7XHJcbiAgICByZXR1cm4gQXV0aGVudGljYXRpb247XHJcbn0oc2VyaWFsaXphdGlvbl8xLlNlcmlhbGl6YWJsZU9iamVjdCkpO1xyXG5leHBvcnRzLkF1dGhlbnRpY2F0aW9uID0gQXV0aGVudGljYXRpb247XHJcbi8vIEBkeW5hbWljXHJcbnZhciBBZGFwdGl2ZUNhcmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQWRhcHRpdmVDYXJkLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWRhcHRpdmVDYXJkKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmRlc2lnbk1vZGUgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWRhcHRpdmVDYXJkLnByb3RvdHlwZSwgXCJyZWZyZXNoXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoQWRhcHRpdmVDYXJkLnJlZnJlc2hQcm9wZXJ0eSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKEFkYXB0aXZlQ2FyZC5yZWZyZXNoUHJvcGVydHksIHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFkYXB0aXZlQ2FyZCwgXCJwcm9jZXNzTWFya2Rvd25cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyaW5nc18xLlN0cmluZ3MuZXJyb3JzLnByb2Nlc3NNYXJrZG93bkV2ZW50UmVtb3ZlZCgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy5wcm9jZXNzTWFya2Rvd25FdmVudFJlbW92ZWQoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQWRhcHRpdmVDYXJkLmFwcGx5TWFya2Rvd24gPSBmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgIGRpZFByb2Nlc3M6IGZhbHNlXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoQWRhcHRpdmVDYXJkLm9uUHJvY2Vzc01hcmtkb3duKSB7XHJcbiAgICAgICAgICAgIEFkYXB0aXZlQ2FyZC5vblByb2Nlc3NNYXJrZG93bih0ZXh0LCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh3aW5kb3cubWFya2Rvd25pdCkge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgbWFya2Rvd25pdFxyXG4gICAgICAgICAgICB2YXIgbWFya2Rvd25JdCA9IHdpbmRvdy5tYXJrZG93bml0O1xyXG4gICAgICAgICAgICByZXN1bHQub3V0cHV0SHRtbCA9IG1hcmtkb3duSXQoKS5yZW5kZXIodGV4dCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5kaWRQcm9jZXNzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIUFkYXB0aXZlQ2FyZC5faGF2ZVdhcm5lZEFib3V0Tm9NYXJrZG93blByb2Nlc3NpbmcpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy5tYXJrZG93blByb2Nlc3NpbmdOb3RFbmFibGVkKTtcclxuICAgICAgICAgICAgQWRhcHRpdmVDYXJkLl9oYXZlV2FybmVkQWJvdXROb01hcmtkb3duUHJvY2Vzc2luZyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgQWRhcHRpdmVDYXJkLnByb3RvdHlwZS5pc1ZlcnNpb25TdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYnlwYXNzVmVyc2lvbkNoZWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHVuc3VwcG9ydGVkVmVyc2lvbiA9ICF0aGlzLnZlcnNpb24gfHxcclxuICAgICAgICAgICAgICAgICF0aGlzLnZlcnNpb24uaXNWYWxpZCB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXhWZXJzaW9uLm1ham9yIDwgdGhpcy52ZXJzaW9uLm1ham9yIHx8XHJcbiAgICAgICAgICAgICAgICAodGhpcy5tYXhWZXJzaW9uLm1ham9yID09PSB0aGlzLnZlcnNpb24ubWFqb3IgJiZcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heFZlcnNpb24ubWlub3IgPCB0aGlzLnZlcnNpb24ubWlub3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gIXVuc3VwcG9ydGVkVmVyc2lvbjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWRhcHRpdmVDYXJkLnByb3RvdHlwZS5nZXREZWZhdWx0U2VyaWFsaXphdGlvbkNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTZXJpYWxpemF0aW9uQ29udGV4dCh0aGlzLnZlcnNpb24pO1xyXG4gICAgfTtcclxuICAgIEFkYXB0aXZlQ2FyZC5wcm90b3R5cGUuZ2V0SXRlbXNDb2xsZWN0aW9uUHJvcGVydHlOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcImJvZHlcIjtcclxuICAgIH07XHJcbiAgICBBZGFwdGl2ZUNhcmQucHJvdG90eXBlLmNhbkhvc3RTaW5nbGV0b25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIEFkYXB0aXZlQ2FyZC5wcm90b3R5cGUuaW50ZXJuYWxQYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLl9mYWxsYmFja0NhcmQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIGZhbGxiYWNrRWxlbWVudCA9IGNvbnRleHQucGFyc2VFbGVtZW50KHVuZGVmaW5lZCwgc291cmNlW1wiZmFsbGJhY2tcIl0sIHRoaXMuZm9yYmlkZGVuQ2hpbGRFbGVtZW50cygpLCAhdGhpcy5pc0Rlc2lnbk1vZGUoKSk7XHJcbiAgICAgICAgaWYgKGZhbGxiYWNrRWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9mYWxsYmFja0NhcmQgPSBuZXcgQWRhcHRpdmVDYXJkKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZhbGxiYWNrQ2FyZC5hZGRJdGVtKGZhbGxiYWNrRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW50ZXJuYWxQYXJzZS5jYWxsKHRoaXMsIHNvdXJjZSwgY29udGV4dCk7XHJcbiAgICB9O1xyXG4gICAgQWRhcHRpdmVDYXJkLnByb3RvdHlwZS5pbnRlcm5hbFRvSlNPTiA9IGZ1bmN0aW9uICh0YXJnZXQsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLnNldFZhbHVlKEFkYXB0aXZlQ2FyZC52ZXJzaW9uUHJvcGVydHksIGNvbnRleHQudGFyZ2V0VmVyc2lvbik7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbnRlcm5hbFRvSlNPTi5jYWxsKHRoaXMsIHRhcmdldCwgY29udGV4dCk7XHJcbiAgICB9O1xyXG4gICAgQWRhcHRpdmVDYXJkLnByb3RvdHlwZS5pbnRlcm5hbFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVuZGVyZWRFbGVtZW50ID0gX3N1cGVyLnByb3RvdHlwZS5pbnRlcm5hbFJlbmRlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmIChzaGFyZWRfMS5HbG9iYWxTZXR0aW5ncy51c2VBZHZhbmNlZENhcmRCb3R0b21UcnVuY2F0aW9uICYmIHJlbmRlcmVkRWxlbWVudCkge1xyXG4gICAgICAgICAgICAvLyBVbmxpa2UgY29udGFpbmVycywgdGhlIHJvb3QgY2FyZCBlbGVtZW50IHNob3VsZCBiZSBhbGxvd2VkIHRvXHJcbiAgICAgICAgICAgIC8vIGJlIHNob3J0ZXIgdGhhbiBpdHMgY29udGVudCAob3RoZXJ3aXNlIHRoZSBvdmVyZmxvdyB0cnVuY2F0aW9uXHJcbiAgICAgICAgICAgIC8vIGxvZ2ljIHdvdWxkIG5ldmVyIGdldCB0cmlnZ2VyZWQpXHJcbiAgICAgICAgICAgIHJlbmRlcmVkRWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcIm1pbkhlaWdodFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkRWxlbWVudDtcclxuICAgIH07XHJcbiAgICBBZGFwdGl2ZUNhcmQucHJvdG90eXBlLmdldEhhc0JhY2tncm91bmQgPSBmdW5jdGlvbiAoaWdub3JlQmFja2dyb3VuZEltYWdlcykge1xyXG4gICAgICAgIGlmIChpZ25vcmVCYWNrZ3JvdW5kSW1hZ2VzID09PSB2b2lkIDApIHsgaWdub3JlQmFja2dyb3VuZEltYWdlcyA9IGZhbHNlOyB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgQWRhcHRpdmVDYXJkLnByb3RvdHlwZS5nZXREZWZhdWx0UGFkZGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IHNoYXJlZF8xLlBhZGRpbmdEZWZpbml0aW9uKEVudW1zLlNwYWNpbmcuUGFkZGluZywgRW51bXMuU3BhY2luZy5QYWRkaW5nLCBFbnVtcy5TcGFjaW5nLlBhZGRpbmcsIEVudW1zLlNwYWNpbmcuUGFkZGluZyk7XHJcbiAgICB9O1xyXG4gICAgQWRhcHRpdmVDYXJkLnByb3RvdHlwZS5zaG91bGRTZXJpYWxpemUgPSBmdW5jdGlvbiAoX2NvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWRhcHRpdmVDYXJkLnByb3RvdHlwZSwgXCJyZW5kZXJJZkVtcHR5XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFkYXB0aXZlQ2FyZC5wcm90b3R5cGUsIFwiYnlwYXNzVmVyc2lvbkNoZWNrXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBZGFwdGl2ZUNhcmQucHJvdG90eXBlLCBcImFsbG93Q3VzdG9tU3R5bGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ob3N0Q29uZmlnLmFkYXB0aXZlQ2FyZCAmJiB0aGlzLmhvc3RDb25maWcuYWRhcHRpdmVDYXJkLmFsbG93Q3VzdG9tU3R5bGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFkYXB0aXZlQ2FyZC5wcm90b3R5cGUsIFwiaGFzQmFja2dyb3VuZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEFkYXB0aXZlQ2FyZC5wcm90b3R5cGUuZ2V0SnNvblR5cGVOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcIkFkYXB0aXZlQ2FyZFwiO1xyXG4gICAgfTtcclxuICAgIEFkYXB0aXZlQ2FyZC5wcm90b3R5cGUuaW50ZXJuYWxWYWxpZGF0ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW50ZXJuYWxWYWxpZGF0ZVByb3BlcnRpZXMuY2FsbCh0aGlzLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAodGhpcy5nZXRWYWx1ZShDYXJkRWxlbWVudC50eXBlTmFtZVByb3BlcnR5KSAhPT0gXCJBZGFwdGl2ZUNhcmRcIikge1xyXG4gICAgICAgICAgICBjb250ZXh0LmFkZEZhaWx1cmUodGhpcywgRW51bXMuVmFsaWRhdGlvbkV2ZW50Lk1pc3NpbmdDYXJkVHlwZSwgc3RyaW5nc18xLlN0cmluZ3MuZXJyb3JzLmludmFsaWRDYXJkVHlwZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmJ5cGFzc1ZlcnNpb25DaGVjayAmJiAhdGhpcy52ZXJzaW9uKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYWRkRmFpbHVyZSh0aGlzLCBFbnVtcy5WYWxpZGF0aW9uRXZlbnQuUHJvcGVydHlDYW50QmVOdWxsLCBzdHJpbmdzXzEuU3RyaW5ncy5lcnJvcnMucHJvcGVydHlNdXN0QmVTZXQoXCJ2ZXJzaW9uXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuaXNWZXJzaW9uU3VwcG9ydGVkKCkpIHtcclxuICAgICAgICAgICAgY29udGV4dC5hZGRGYWlsdXJlKHRoaXMsIEVudW1zLlZhbGlkYXRpb25FdmVudC5VbnN1cHBvcnRlZENhcmRWZXJzaW9uLCBzdHJpbmdzXzEuU3RyaW5ncy5lcnJvcnMudW5zdXBwb3J0ZWRDYXJkVmVyc2lvbih0aGlzLnZlcnNpb24udG9TdHJpbmcoKSwgdGhpcy5tYXhWZXJzaW9uLnRvU3RyaW5nKCkpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWRhcHRpdmVDYXJkLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVkQ2FyZDtcclxuICAgICAgICBpZiAodGhpcy5zaG91bGRGYWxsYmFjaygpICYmIHRoaXMuX2ZhbGxiYWNrQ2FyZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9mYWxsYmFja0NhcmQuaG9zdENvbmZpZyA9IHRoaXMuaG9zdENvbmZpZztcclxuICAgICAgICAgICAgcmVuZGVyZWRDYXJkID0gdGhpcy5fZmFsbGJhY2tDYXJkLnJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVuZGVyZWRDYXJkID0gX3N1cGVyLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKHJlbmRlcmVkQ2FyZCkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRDYXJkLmNsYXNzTGlzdC5hZGQodGhpcy5ob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1hZGFwdGl2ZUNhcmRcIikpO1xyXG4gICAgICAgICAgICAgICAgLy8gSGF2aW5nIGEgdGFiSW5kZXggb24gdGhlIHJvb3QgY29udGFpbmVyIGZvciBhIGNhcmQgY2FuIG1lc3MgdXAgYWNjZXNzaWJpbGl0eSBpbiBzb21lIHNjZW5hcmlvcy5cclxuICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHdlJ3ZlIHNoaXBwZWQgdGhpcyBiZWhhdmlvciBiZWZvcmUsIGFuZCBzbyBjYW4ndCBqdXN0IHR1cm4gaXQgb2ZmIGluIGEgcG9pbnQgcmVsZWFzZS4gRm9yXHJcbiAgICAgICAgICAgICAgICAvLyBub3csIHRvIHVuYmxvY2sgYWNjZXNzaWJpbGl0eSBzY2VuYXJpb3MgZm9yIG91ciBjdXN0b21lcnMsIHdlJ3ZlIGdvdCBhbiBvcHRpb24gdG8gdHVybiBpdCBvZmYuIEluIGFcclxuICAgICAgICAgICAgICAgIC8vIGZ1dHVyZSByZWxlYXNlLCB3ZSBzaG91bGQgc3Ryb25nbHkgY29uc2lkZXIgZmxpcHBpbmcgdGhlIGRlZmF1bHQgc3VjaCB0aGF0IHdlICpkb24ndCogZW1pdCBhIHRhYkluZGV4XHJcbiAgICAgICAgICAgICAgICAvLyBieSBkZWZhdWx0LlxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXJlZF8xLkdsb2JhbFNldHRpbmdzLnNldFRhYkluZGV4QXRDYXJkUm9vdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkQ2FyZC50YWJJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zcGVhaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkQ2FyZC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRoaXMuc3BlYWspO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgVXRpbHMuYXBwZW5kQ2hpbGQodGFyZ2V0LCByZW5kZXJlZENhcmQpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxheW91dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVuZGVyZWRDYXJkO1xyXG4gICAgfTtcclxuICAgIEFkYXB0aXZlQ2FyZC5wcm90b3R5cGUudXBkYXRlTGF5b3V0ID0gZnVuY3Rpb24gKHByb2Nlc3NDaGlsZHJlbikge1xyXG4gICAgICAgIGlmIChwcm9jZXNzQ2hpbGRyZW4gPT09IHZvaWQgMCkgeyBwcm9jZXNzQ2hpbGRyZW4gPSB0cnVlOyB9XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVMYXlvdXQuY2FsbCh0aGlzLCBwcm9jZXNzQ2hpbGRyZW4pO1xyXG4gICAgICAgIGlmIChzaGFyZWRfMS5HbG9iYWxTZXR0aW5ncy51c2VBZHZhbmNlZENhcmRCb3R0b21UcnVuY2F0aW9uICYmIHRoaXMuaXNEaXNwbGF5ZWQoKSkge1xyXG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuaG9zdENvbmZpZy5nZXRFZmZlY3RpdmVTcGFjaW5nKEVudW1zLlNwYWNpbmcuRGVmYXVsdCk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb25cclxuICAgICAgICAgICAgdGhpc1tcImhhbmRsZU92ZXJmbG93XCJdKHRoaXMucmVuZGVyZWRFbGVtZW50Lm9mZnNldEhlaWdodCAtIHBhZGRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBZGFwdGl2ZUNhcmQucHJvdG90eXBlLnNob3VsZEZhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnNob3VsZEZhbGxiYWNrLmNhbGwodGhpcykgfHwgIXRoaXMuaXNWZXJzaW9uU3VwcG9ydGVkKCk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFkYXB0aXZlQ2FyZC5wcm90b3R5cGUsIFwiaGFzVmlzaWJsZVNlcGFyYXRvclwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBZGFwdGl2ZUNhcmQuc2NoZW1hVXJsID0gXCJodHRwOi8vYWRhcHRpdmVjYXJkcy5pby9zY2hlbWFzL2FkYXB0aXZlLWNhcmQuanNvblwiO1xyXG4gICAgLy8jcmVnaW9uIFNjaGVtYVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxyXG4gICAgQWRhcHRpdmVDYXJkLiRzY2hlbWFQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuQ3VzdG9tUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwiJHNjaGVtYVwiLCBmdW5jdGlvbiAoc2VuZGVyLCBwcm9wZXJ0eSwgc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIEFkYXB0aXZlQ2FyZC5zY2hlbWFVcmw7XHJcbiAgICB9LCBmdW5jdGlvbiAoc2VuZGVyLCBwcm9wLCB0YXJnZXQsIHZhbHVlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgY29udGV4dC5zZXJpYWxpemVWYWx1ZSh0YXJnZXQsIHByb3AubmFtZSwgQWRhcHRpdmVDYXJkLnNjaGVtYVVybCk7XHJcbiAgICB9KTtcclxuICAgIEFkYXB0aXZlQ2FyZC52ZXJzaW9uUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLkN1c3RvbVByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcInZlcnNpb25cIiwgZnVuY3Rpb24gKHNlbmRlciwgcHJvcCwgc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHZlcnNpb24gPSBzZXJpYWxpemF0aW9uXzEuVmVyc2lvbi5wYXJzZShzb3VyY2VbcHJvcC5uYW1lXSwgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2ZXJzaW9uID0gc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLmxhdGVzdDtcclxuICAgICAgICAgICAgY29udGV4dC5sb2dQYXJzZUV2ZW50KHNlbmRlciwgRW51bXMuVmFsaWRhdGlvbkV2ZW50LkludmFsaWRQcm9wZXJ0eVZhbHVlLCBzdHJpbmdzXzEuU3RyaW5ncy5lcnJvcnMuaW52YWxpZENhcmRWZXJzaW9uKHZlcnNpb24udG9TdHJpbmcoKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmVyc2lvbjtcclxuICAgIH0sIGZ1bmN0aW9uIChzZW5kZXIsIHByb3AsIHRhcmdldCwgdmFsdWUsIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LnNlcmlhbGl6ZVZhbHVlKHRhcmdldCwgcHJvcC5uYW1lLCB2YWx1ZS50b1N0cmluZygpKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCk7XHJcbiAgICBBZGFwdGl2ZUNhcmQuZmFsbGJhY2tUZXh0UHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlN0cmluZ1Byb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wLCBcImZhbGxiYWNrVGV4dFwiKTtcclxuICAgIEFkYXB0aXZlQ2FyZC5zcGVha1Byb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCwgXCJzcGVha1wiKTtcclxuICAgIEFkYXB0aXZlQ2FyZC5yZWZyZXNoUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlNlcmlhbGl6YWJsZU9iamVjdFByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV80LCBcInJlZnJlc2hcIiwgUmVmcmVzaERlZmluaXRpb24sIHRydWUpO1xyXG4gICAgQWRhcHRpdmVDYXJkLmF1dGhlbnRpY2F0aW9uUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLlNlcmlhbGl6YWJsZU9iamVjdFByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV80LCBcImF1dGhlbnRpY2F0aW9uXCIsIEF1dGhlbnRpY2F0aW9uLCB0cnVlKTtcclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgQWRhcHRpdmVDYXJkLl9oYXZlV2FybmVkQWJvdXROb01hcmtkb3duUHJvY2Vzc2luZyA9IGZhbHNlO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoQWRhcHRpdmVDYXJkLnZlcnNpb25Qcm9wZXJ0eSlcclxuICAgIF0sIEFkYXB0aXZlQ2FyZC5wcm90b3R5cGUsIFwidmVyc2lvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoQWRhcHRpdmVDYXJkLmZhbGxiYWNrVGV4dFByb3BlcnR5KVxyXG4gICAgXSwgQWRhcHRpdmVDYXJkLnByb3RvdHlwZSwgXCJmYWxsYmFja1RleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEFkYXB0aXZlQ2FyZC5zcGVha1Byb3BlcnR5KVxyXG4gICAgXSwgQWRhcHRpdmVDYXJkLnByb3RvdHlwZSwgXCJzcGVha1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoQWRhcHRpdmVDYXJkLnJlZnJlc2hQcm9wZXJ0eSlcclxuICAgIF0sIEFkYXB0aXZlQ2FyZC5wcm90b3R5cGUsIFwicmVmcmVzaFwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKEFkYXB0aXZlQ2FyZC5hdXRoZW50aWNhdGlvblByb3BlcnR5KVxyXG4gICAgXSwgQWRhcHRpdmVDYXJkLnByb3RvdHlwZSwgXCJhdXRoZW50aWNhdGlvblwiLCB2b2lkIDApO1xyXG4gICAgcmV0dXJuIEFkYXB0aXZlQ2FyZDtcclxufShDb250YWluZXJXaXRoQWN0aW9ucykpO1xyXG5leHBvcnRzLkFkYXB0aXZlQ2FyZCA9IEFkYXB0aXZlQ2FyZDtcclxudmFyIElubGluZUFkYXB0aXZlQ2FyZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhJbmxpbmVBZGFwdGl2ZUNhcmQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBJbmxpbmVBZGFwdGl2ZUNhcmQoKSB7XHJcbiAgICAgICAgLy8jcmVnaW9uIFNjaGVtYVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnN1cHByZXNzU3R5bGUgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBJbmxpbmVBZGFwdGl2ZUNhcmQucHJvdG90eXBlLmdldFNjaGVtYUtleSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXCJJbmxpbmVBZGFwdGl2ZUNhcmRcIjtcclxuICAgIH07XHJcbiAgICBJbmxpbmVBZGFwdGl2ZUNhcmQucHJvdG90eXBlLnBvcHVsYXRlU2NoZW1hID0gZnVuY3Rpb24gKHNjaGVtYSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucG9wdWxhdGVTY2hlbWEuY2FsbCh0aGlzLCBzY2hlbWEpO1xyXG4gICAgICAgIHNjaGVtYS5yZW1vdmUoQWRhcHRpdmVDYXJkLiRzY2hlbWFQcm9wZXJ0eSwgQWRhcHRpdmVDYXJkLnZlcnNpb25Qcm9wZXJ0eSk7XHJcbiAgICB9O1xyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgICBJbmxpbmVBZGFwdGl2ZUNhcmQucHJvdG90eXBlLmdldERlZmF1bHRQYWRkaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgc2hhcmVkXzEuUGFkZGluZ0RlZmluaXRpb24odGhpcy5zdXBwcmVzc1N0eWxlID8gRW51bXMuU3BhY2luZy5Ob25lIDogRW51bXMuU3BhY2luZy5QYWRkaW5nLCBFbnVtcy5TcGFjaW5nLlBhZGRpbmcsIHRoaXMuc3VwcHJlc3NTdHlsZSA/IEVudW1zLlNwYWNpbmcuTm9uZSA6IEVudW1zLlNwYWNpbmcuUGFkZGluZywgRW51bXMuU3BhY2luZy5QYWRkaW5nKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5saW5lQWRhcHRpdmVDYXJkLnByb3RvdHlwZSwgXCJieXBhc3NWZXJzaW9uQ2hlY2tcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5saW5lQWRhcHRpdmVDYXJkLnByb3RvdHlwZSwgXCJkZWZhdWx0U3R5bGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdXBwcmVzc1N0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRW51bXMuQ29udGFpbmVyU3R5bGUuRGVmYXVsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhvc3RDb25maWcuYWN0aW9ucy5zaG93Q2FyZC5zdHlsZVxyXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5ob3N0Q29uZmlnLmFjdGlvbnMuc2hvd0NhcmQuc3R5bGVcclxuICAgICAgICAgICAgICAgICAgICA6IEVudW1zLkNvbnRhaW5lclN0eWxlLkVtcGhhc2lzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgSW5saW5lQWRhcHRpdmVDYXJkLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVkQ2FyZCA9IF9zdXBlci5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcywgdGFyZ2V0KTtcclxuICAgICAgICBpZiAocmVuZGVyZWRDYXJkKSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVkQ2FyZC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIiwgXCJwb2xpdGVcIik7XHJcbiAgICAgICAgICAgIHJlbmRlcmVkQ2FyZC5yZW1vdmVBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkQ2FyZDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSW5saW5lQWRhcHRpdmVDYXJkO1xyXG59KEFkYXB0aXZlQ2FyZCkpO1xyXG52YXIgU2VyaWFsaXphdGlvbkNvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU2VyaWFsaXphdGlvbkNvbnRleHQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTZXJpYWxpemF0aW9uQ29udGV4dCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fZm9yYmlkZGVuVHlwZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgU2VyaWFsaXphdGlvbkNvbnRleHQucHJvdG90eXBlLmludGVybmFsUGFyc2VDYXJkT2JqZWN0ID0gZnVuY3Rpb24gKHBhcmVudCwgc291cmNlLCBmb3JiaWRkZW5UeXBlcywgYWxsb3dGYWxsYmFjaywgY3JlYXRlSW5zdGFuY2VDYWxsYmFjaywgbG9nUGFyc2VFdmVudCwgcGFyc2luZ1NpbmdsZXRvbk9iamVjdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHBhcnNpbmdTaW5nbGV0b25PYmplY3QgPT09IHZvaWQgMCkgeyBwYXJzaW5nU2luZ2xldG9uT2JqZWN0ID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChzb3VyY2UgJiYgdHlwZW9mIHNvdXJjZSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICB2YXIgb2xkRm9yYmlkZGVuVHlwZXNfMSA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgdGhpcy5fZm9yYmlkZGVuVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgb2xkRm9yYmlkZGVuVHlwZXNfMS5hZGQodHlwZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBmb3JiaWRkZW5UeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fZm9yYmlkZGVuVHlwZXMuYWRkKHR5cGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIHR5cGVOYW1lID0gVXRpbHMucGFyc2VTdHJpbmcoc291cmNlW1widHlwZVwiXSk7XHJcbiAgICAgICAgICAgIHZhciBpZ25vcmVGb3JiaWRkZW5UeXBlID0gcGFyc2luZ1NpbmdsZXRvbk9iamVjdCAmJiB0eXBlTmFtZSA9PT0gXCJDYXJvdXNlbFwiO1xyXG4gICAgICAgICAgICBpZiAodHlwZU5hbWUgJiYgdGhpcy5fZm9yYmlkZGVuVHlwZXMuaGFzKHR5cGVOYW1lKSAmJiAhaWdub3JlRm9yYmlkZGVuVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgbG9nUGFyc2VFdmVudCh0eXBlTmFtZSwgRW51bXMuVHlwZUVycm9yVHlwZS5Gb3JiaWRkZW5UeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciB0cnlUb0ZhbGxiYWNrID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjcmVhdGVJbnN0YW5jZUNhbGxiYWNrKHR5cGVOYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5VG9GYWxsYmFjayA9IHNoYXJlZF8xLkdsb2JhbFNldHRpbmdzLmVuYWJsZUZhbGxiYWNrICYmIGFsbG93RmFsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nUGFyc2VFdmVudCh0eXBlTmFtZSwgRW51bXMuVHlwZUVycm9yVHlwZS5Vbmtub3duVHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0UGFyZW50KHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBhcnNlKHNvdXJjZSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5VG9GYWxsYmFjayA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZF8xLkdsb2JhbFNldHRpbmdzLmVuYWJsZUZhbGxiYWNrICYmIGFsbG93RmFsbGJhY2sgJiYgcmVzdWx0LnNob3VsZEZhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHJ5VG9GYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWxsYmFjayA9IHNvdXJjZVtcImZhbGxiYWNrXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZmFsbGJhY2sgJiYgcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5zZXRTaG91bGRGYWxsYmFjayh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmYWxsYmFjayA9PT0gXCJzdHJpbmdcIiAmJiBmYWxsYmFjay50b0xvd2VyQ2FzZSgpID09PSBcImRyb3BcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmYWxsYmFjayA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmludGVybmFsUGFyc2VDYXJkT2JqZWN0KHBhcmVudCwgZmFsbGJhY2ssIGZvcmJpZGRlblR5cGVzLCB0cnVlLCBjcmVhdGVJbnN0YW5jZUNhbGxiYWNrLCBsb2dQYXJzZUV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZm9yYmlkZGVuVHlwZXMgPSBvbGRGb3JiaWRkZW5UeXBlc18xO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIFNlcmlhbGl6YXRpb25Db250ZXh0LnByb3RvdHlwZS5jYXJkT2JqZWN0UGFyc2VkID0gZnVuY3Rpb24gKG8sIHNvdXJjZSkge1xyXG4gICAgICAgIGlmIChvIGluc3RhbmNlb2YgQWN0aW9uICYmIHRoaXMub25QYXJzZUFjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLm9uUGFyc2VBY3Rpb24obywgc291cmNlLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobyBpbnN0YW5jZW9mIENhcmRFbGVtZW50ICYmIHRoaXMub25QYXJzZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5vblBhcnNlRWxlbWVudChvLCBzb3VyY2UsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTZXJpYWxpemF0aW9uQ29udGV4dC5wcm90b3R5cGUuc2hvdWxkU2VyaWFsaXplID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBpZiAobyBpbnN0YW5jZW9mIEFjdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25SZWdpc3RyeS5maW5kQnlOYW1lKG8uZ2V0SnNvblR5cGVOYW1lKCkpICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG8gaW5zdGFuY2VvZiBDYXJkRWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVnaXN0cnkuZmluZEJ5TmFtZShvLmdldEpzb25UeXBlTmFtZSgpKSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNlcmlhbGl6YXRpb25Db250ZXh0LnByb3RvdHlwZS5wYXJzZUNhcmRPYmplY3QgPSBmdW5jdGlvbiAocGFyZW50LCBzb3VyY2UsIGZvcmJpZGRlblR5cGVOYW1lcywgYWxsb3dGYWxsYmFjaywgY3JlYXRlSW5zdGFuY2VDYWxsYmFjaywgbG9nUGFyc2VFdmVudCwgcGFyc2luZ1NpbmdsZXRvbk9iamVjdCkge1xyXG4gICAgICAgIGlmIChwYXJzaW5nU2luZ2xldG9uT2JqZWN0ID09PSB2b2lkIDApIHsgcGFyc2luZ1NpbmdsZXRvbk9iamVjdCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGZvcmJpZGRlblR5cGVzID0gbmV3IFNldChmb3JiaWRkZW5UeXBlTmFtZXMpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmludGVybmFsUGFyc2VDYXJkT2JqZWN0KHBhcmVudCwgc291cmNlLCBmb3JiaWRkZW5UeXBlcywgYWxsb3dGYWxsYmFjaywgY3JlYXRlSW5zdGFuY2VDYWxsYmFjaywgbG9nUGFyc2VFdmVudCwgcGFyc2luZ1NpbmdsZXRvbk9iamVjdCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FyZE9iamVjdFBhcnNlZChyZXN1bHQsIHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgU2VyaWFsaXphdGlvbkNvbnRleHQucHJvdG90eXBlLnBhcnNlRWxlbWVudCA9IGZ1bmN0aW9uIChwYXJlbnQsIHNvdXJjZSwgZm9yYmlkZGVuVHlwZXMsIGFsbG93RmFsbGJhY2ssIF9wYXJzaW5nU2luZ2xldG9uT2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoX3BhcnNpbmdTaW5nbGV0b25PYmplY3QgPT09IHZvaWQgMCkgeyBfcGFyc2luZ1NpbmdsZXRvbk9iamVjdCA9IGZhbHNlOyB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDYXJkT2JqZWN0KHBhcmVudCwgc291cmNlLCBmb3JiaWRkZW5UeXBlcywgYWxsb3dGYWxsYmFjaywgZnVuY3Rpb24gKHR5cGVOYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbGVtZW50UmVnaXN0cnkuY3JlYXRlSW5zdGFuY2UodHlwZU5hbWUsIF90aGlzLnRhcmdldFZlcnNpb24pO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uICh0eXBlTmFtZSwgZXJyb3JUeXBlKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvclR5cGUgPT09IEVudW1zLlR5cGVFcnJvclR5cGUuVW5rbm93blR5cGUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmxvZ1BhcnNlRXZlbnQodW5kZWZpbmVkLCBFbnVtcy5WYWxpZGF0aW9uRXZlbnQuVW5rbm93bkVsZW1lbnRUeXBlLCBzdHJpbmdzXzEuU3RyaW5ncy5lcnJvcnMudW5rbm93bkVsZW1lbnRUeXBlKHR5cGVOYW1lKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dQYXJzZUV2ZW50KHVuZGVmaW5lZCwgRW51bXMuVmFsaWRhdGlvbkV2ZW50LkVsZW1lbnRUeXBlTm90QWxsb3dlZCwgc3RyaW5nc18xLlN0cmluZ3MuZXJyb3JzLmVsZW1lbnRUeXBlTm90QWxsb3dlZCh0eXBlTmFtZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgX3BhcnNpbmdTaW5nbGV0b25PYmplY3QpO1xyXG4gICAgfTtcclxuICAgIFNlcmlhbGl6YXRpb25Db250ZXh0LnByb3RvdHlwZS5wYXJzZUFjdGlvbiA9IGZ1bmN0aW9uIChwYXJlbnQsIHNvdXJjZSwgZm9yYmlkZGVuQWN0aW9uVHlwZXMsIGFsbG93RmFsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2FyZE9iamVjdChwYXJlbnQsIHNvdXJjZSwgZm9yYmlkZGVuQWN0aW9uVHlwZXMsIGFsbG93RmFsbGJhY2ssIGZ1bmN0aW9uICh0eXBlTmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYWN0aW9uUmVnaXN0cnkuY3JlYXRlSW5zdGFuY2UodHlwZU5hbWUsIF90aGlzLnRhcmdldFZlcnNpb24pO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uICh0eXBlTmFtZSwgZXJyb3JUeXBlKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvclR5cGUgPT09IEVudW1zLlR5cGVFcnJvclR5cGUuVW5rbm93blR5cGUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmxvZ1BhcnNlRXZlbnQodW5kZWZpbmVkLCBFbnVtcy5WYWxpZGF0aW9uRXZlbnQuVW5rbm93bkFjdGlvblR5cGUsIHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy51bmtub3duQWN0aW9uVHlwZSh0eXBlTmFtZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubG9nUGFyc2VFdmVudCh1bmRlZmluZWQsIEVudW1zLlZhbGlkYXRpb25FdmVudC5BY3Rpb25UeXBlTm90QWxsb3dlZCwgc3RyaW5nc18xLlN0cmluZ3MuZXJyb3JzLmFjdGlvblR5cGVOb3RBbGxvd2VkKHR5cGVOYW1lKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VyaWFsaXphdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImVsZW1lbnRSZWdpc3RyeVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX2VsZW1lbnRSZWdpc3RyeSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcmVnaXN0cnlfMS5HbG9iYWxSZWdpc3RyeS5lbGVtZW50cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvLyBOb3QgdXNpbmcgYSBwcm9wZXJ0eSBzZXR0ZXIgaGVyZSBiZWNhdXNlIHRoZSBzZXR0ZXIgc2hvdWxkIGFjY2VwdCBcInVuZGVmaW5lZFwiXHJcbiAgICAvLyB3aGVyZWFzIHRoZSBnZXR0ZXIgc2hvdWxkIG5ldmVyIHJldHVybiB1bmRlZmluZWQuXHJcbiAgICBTZXJpYWxpemF0aW9uQ29udGV4dC5wcm90b3R5cGUuc2V0RWxlbWVudFJlZ2lzdHJ5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZ2lzdHJ5ID0gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcmlhbGl6YXRpb25Db250ZXh0LnByb3RvdHlwZSwgXCJhY3Rpb25SZWdpc3RyeVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX2FjdGlvblJlZ2lzdHJ5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiByZWdpc3RyeV8xLkdsb2JhbFJlZ2lzdHJ5LmFjdGlvbnM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLy8gTm90IHVzaW5nIGEgcHJvcGVydHkgc2V0dGVyIGhlcmUgYmVjYXVzZSB0aGUgc2V0dGVyIHNob3VsZCBhY2NlcHQgXCJ1bmRlZmluZWRcIlxyXG4gICAgLy8gd2hlcmVhcyB0aGUgZ2V0dGVyIHNob3VsZCBuZXZlciByZXR1cm4gdW5kZWZpbmVkLlxyXG4gICAgU2VyaWFsaXphdGlvbkNvbnRleHQucHJvdG90eXBlLnNldEFjdGlvblJlZ2lzdHJ5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9uUmVnaXN0cnkgPSB2YWx1ZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU2VyaWFsaXphdGlvbkNvbnRleHQ7XHJcbn0oc2VyaWFsaXphdGlvbl8xLkJhc2VTZXJpYWxpemF0aW9uQ29udGV4dCkpO1xyXG5leHBvcnRzLlNlcmlhbGl6YXRpb25Db250ZXh0ID0gU2VyaWFsaXphdGlvbkNvbnRleHQ7XHJcbnJlZ2lzdHJ5XzEuR2xvYmFsUmVnaXN0cnkuZGVmYXVsdEVsZW1lbnRzLnJlZ2lzdGVyKFwiQ29udGFpbmVyXCIsIENvbnRhaW5lcik7XHJcbnJlZ2lzdHJ5XzEuR2xvYmFsUmVnaXN0cnkuZGVmYXVsdEVsZW1lbnRzLnJlZ2lzdGVyKFwiVGV4dEJsb2NrXCIsIFRleHRCbG9jayk7XHJcbnJlZ2lzdHJ5XzEuR2xvYmFsUmVnaXN0cnkuZGVmYXVsdEVsZW1lbnRzLnJlZ2lzdGVyKFwiUmljaFRleHRCbG9ja1wiLCBSaWNoVGV4dEJsb2NrLCBzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMik7XHJcbnJlZ2lzdHJ5XzEuR2xvYmFsUmVnaXN0cnkuZGVmYXVsdEVsZW1lbnRzLnJlZ2lzdGVyKFwiVGV4dFJ1blwiLCBUZXh0UnVuLCBzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMik7XHJcbnJlZ2lzdHJ5XzEuR2xvYmFsUmVnaXN0cnkuZGVmYXVsdEVsZW1lbnRzLnJlZ2lzdGVyKFwiSW1hZ2VcIiwgSW1hZ2UpO1xyXG5yZWdpc3RyeV8xLkdsb2JhbFJlZ2lzdHJ5LmRlZmF1bHRFbGVtZW50cy5yZWdpc3RlcihcIkltYWdlU2V0XCIsIEltYWdlU2V0KTtcclxucmVnaXN0cnlfMS5HbG9iYWxSZWdpc3RyeS5kZWZhdWx0RWxlbWVudHMucmVnaXN0ZXIoXCJNZWRpYVwiLCBNZWRpYSwgc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzEpO1xyXG5yZWdpc3RyeV8xLkdsb2JhbFJlZ2lzdHJ5LmRlZmF1bHRFbGVtZW50cy5yZWdpc3RlcihcIkZhY3RTZXRcIiwgRmFjdFNldCk7XHJcbnJlZ2lzdHJ5XzEuR2xvYmFsUmVnaXN0cnkuZGVmYXVsdEVsZW1lbnRzLnJlZ2lzdGVyKFwiQ29sdW1uU2V0XCIsIENvbHVtblNldCk7XHJcbnJlZ2lzdHJ5XzEuR2xvYmFsUmVnaXN0cnkuZGVmYXVsdEVsZW1lbnRzLnJlZ2lzdGVyKFwiQWN0aW9uU2V0XCIsIEFjdGlvblNldCwgc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzIpO1xyXG5yZWdpc3RyeV8xLkdsb2JhbFJlZ2lzdHJ5LmRlZmF1bHRFbGVtZW50cy5yZWdpc3RlcihcIklucHV0LlRleHRcIiwgVGV4dElucHV0KTtcclxucmVnaXN0cnlfMS5HbG9iYWxSZWdpc3RyeS5kZWZhdWx0RWxlbWVudHMucmVnaXN0ZXIoXCJJbnB1dC5EYXRlXCIsIERhdGVJbnB1dCk7XHJcbnJlZ2lzdHJ5XzEuR2xvYmFsUmVnaXN0cnkuZGVmYXVsdEVsZW1lbnRzLnJlZ2lzdGVyKFwiSW5wdXQuVGltZVwiLCBUaW1lSW5wdXQpO1xyXG5yZWdpc3RyeV8xLkdsb2JhbFJlZ2lzdHJ5LmRlZmF1bHRFbGVtZW50cy5yZWdpc3RlcihcIklucHV0Lk51bWJlclwiLCBOdW1iZXJJbnB1dCk7XHJcbnJlZ2lzdHJ5XzEuR2xvYmFsUmVnaXN0cnkuZGVmYXVsdEVsZW1lbnRzLnJlZ2lzdGVyKFwiSW5wdXQuQ2hvaWNlU2V0XCIsIENob2ljZVNldElucHV0KTtcclxucmVnaXN0cnlfMS5HbG9iYWxSZWdpc3RyeS5kZWZhdWx0RWxlbWVudHMucmVnaXN0ZXIoXCJJbnB1dC5Ub2dnbGVcIiwgVG9nZ2xlSW5wdXQpO1xyXG5yZWdpc3RyeV8xLkdsb2JhbFJlZ2lzdHJ5LmRlZmF1bHRBY3Rpb25zLnJlZ2lzdGVyKE9wZW5VcmxBY3Rpb24uSnNvblR5cGVOYW1lLCBPcGVuVXJsQWN0aW9uKTtcclxucmVnaXN0cnlfMS5HbG9iYWxSZWdpc3RyeS5kZWZhdWx0QWN0aW9ucy5yZWdpc3RlcihTdWJtaXRBY3Rpb24uSnNvblR5cGVOYW1lLCBTdWJtaXRBY3Rpb24pO1xyXG5yZWdpc3RyeV8xLkdsb2JhbFJlZ2lzdHJ5LmRlZmF1bHRBY3Rpb25zLnJlZ2lzdGVyKFNob3dDYXJkQWN0aW9uLkpzb25UeXBlTmFtZSwgU2hvd0NhcmRBY3Rpb24pO1xyXG5yZWdpc3RyeV8xLkdsb2JhbFJlZ2lzdHJ5LmRlZmF1bHRBY3Rpb25zLnJlZ2lzdGVyKFRvZ2dsZVZpc2liaWxpdHlBY3Rpb24uSnNvblR5cGVOYW1lLCBUb2dnbGVWaXNpYmlsaXR5QWN0aW9uLCBzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMik7XHJcbnJlZ2lzdHJ5XzEuR2xvYmFsUmVnaXN0cnkuZGVmYXVsdEFjdGlvbnMucmVnaXN0ZXIoRXhlY3V0ZUFjdGlvbi5Kc29uVHlwZU5hbWUsIEV4ZWN1dGVBY3Rpb24sIHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV80KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FyZC1lbGVtZW50cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5DYXJkT2JqZWN0ID0gZXhwb3J0cy5WYWxpZGF0aW9uUmVzdWx0cyA9IHZvaWQgMDtcclxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxudmFyIEVudW1zID0gcmVxdWlyZShcIi4vZW51bXNcIik7XHJcbnZhciBzdHJpbmdzXzEgPSByZXF1aXJlKFwiLi9zdHJpbmdzXCIpO1xyXG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKFwiLi9zaGFyZWRcIik7XHJcbnZhciBob3N0X2NhcGFiaWxpdGllc18xID0gcmVxdWlyZShcIi4vaG9zdC1jYXBhYmlsaXRpZXNcIik7XHJcbnZhciBzZXJpYWxpemF0aW9uXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemF0aW9uXCIpO1xyXG52YXIgVmFsaWRhdGlvblJlc3VsdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWYWxpZGF0aW9uUmVzdWx0cygpIHtcclxuICAgICAgICB0aGlzLmFsbElkcyA9IHt9O1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGlvbkV2ZW50cyA9IFtdO1xyXG4gICAgfVxyXG4gICAgVmFsaWRhdGlvblJlc3VsdHMucHJvdG90eXBlLmFkZEZhaWx1cmUgPSBmdW5jdGlvbiAoY2FyZE9iamVjdCwgZXZlbnQsIG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLnZhbGlkYXRpb25FdmVudHMucHVzaCh7XHJcbiAgICAgICAgICAgIHBoYXNlOiBFbnVtcy5WYWxpZGF0aW9uUGhhc2UuVmFsaWRhdGlvbixcclxuICAgICAgICAgICAgc291cmNlOiBjYXJkT2JqZWN0LFxyXG4gICAgICAgICAgICBldmVudDogZXZlbnQsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVmFsaWRhdGlvblJlc3VsdHM7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVmFsaWRhdGlvblJlc3VsdHMgPSBWYWxpZGF0aW9uUmVzdWx0cztcclxudmFyIENhcmRPYmplY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ2FyZE9iamVjdCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENhcmRPYmplY3QoKSB7XHJcbiAgICAgICAgLy8jcmVnaW9uIFNjaGVtYVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgICAgIF90aGlzLl9zaG91bGRGYWxsYmFjayA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIENhcmRPYmplY3QucHJvdG90eXBlLmdldFNjaGVtYUtleSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRKc29uVHlwZU5hbWUoKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FyZE9iamVjdC5wcm90b3R5cGUsIFwicmVxdWlyZXNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZShDYXJkT2JqZWN0LnJlcXVpcmVzUHJvcGVydHkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoaXMgQ2FyZE9iamVjdCBjb250YWlucyB0aGUgZ2l2ZW4gRE9NIE5vZGUuXHJcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgRE9NIE5vZGUgdG8gbG9vayBmb3IuXHJcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIERPTSBOb2RlIHdhcyBmb3VuZCwgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIENhcmRPYmplY3QucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlZEVsZW1lbnQuY29udGFpbnMobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBDYXJkT2JqZWN0LnByb3RvdHlwZS5wcmVQcm9jZXNzUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uIChwcm9wLCBwcm9wZXJ0eVZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gcHJvcGVydHlWYWx1ZSA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRWYWx1ZShwcm9wKSA6IHByb3BlcnR5VmFsdWU7XHJcbiAgICAgICAgaWYgKHNoYXJlZF8xLkdsb2JhbFNldHRpbmdzLmFsbG93UHJlUHJvY2Vzc2luZ1Byb3BlcnR5VmFsdWVzKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudE9iamVjdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50T2JqZWN0ICYmICFjdXJyZW50T2JqZWN0Lm9uUHJlUHJvY2Vzc1Byb3BlcnR5VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRPYmplY3QgPSBjdXJyZW50T2JqZWN0LnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY3VycmVudE9iamVjdCAmJiBjdXJyZW50T2JqZWN0Lm9uUHJlUHJvY2Vzc1Byb3BlcnR5VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50T2JqZWN0Lm9uUHJlUHJvY2Vzc1Byb3BlcnR5VmFsdWUodGhpcywgcHJvcCwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcbiAgICBDYXJkT2JqZWN0LnByb3RvdHlwZS5zZXRQYXJlbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9wYXJlbnQgPSB2YWx1ZTtcclxuICAgIH07XHJcbiAgICBDYXJkT2JqZWN0LnByb3RvdHlwZS5zZXRTaG91bGRGYWxsYmFjayA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3Nob3VsZEZhbGxiYWNrID0gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgQ2FyZE9iamVjdC5wcm90b3R5cGUuc2hvdWxkRmFsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3VsZEZhbGxiYWNrIHx8ICF0aGlzLnJlcXVpcmVzLmFyZUFsbE1ldCh0aGlzLmhvc3RDb25maWcuaG9zdENhcGFiaWxpdGllcyk7XHJcbiAgICB9O1xyXG4gICAgQ2FyZE9iamVjdC5wcm90b3R5cGUuZ2V0Um9vdE9iamVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcclxuICAgICAgICB2YXIgY3VycmVudE9iamVjdCA9IHRoaXM7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRPYmplY3QucGFyZW50KSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRPYmplY3QgPSBjdXJyZW50T2JqZWN0LnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRPYmplY3Q7XHJcbiAgICB9O1xyXG4gICAgQ2FyZE9iamVjdC5wcm90b3R5cGUuaW50ZXJuYWxWYWxpZGF0ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlkKSB7XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmFsbElkcy5oYXNPd25Qcm9wZXJ0eSh0aGlzLmlkKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuYWxsSWRzW3RoaXMuaWRdID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hZGRGYWlsdXJlKHRoaXMsIEVudW1zLlZhbGlkYXRpb25FdmVudC5EdXBsaWNhdGVJZCwgc3RyaW5nc18xLlN0cmluZ3MuZXJyb3JzLmR1cGxpY2F0ZUlkKHRoaXMuaWQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRleHQuYWxsSWRzW3RoaXMuaWRdICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFsbElkc1t0aGlzLmlkXSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FyZE9iamVjdC5wcm90b3R5cGUudmFsaWRhdGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdHMoKTtcclxuICAgICAgICB0aGlzLmludGVybmFsVmFsaWRhdGVQcm9wZXJ0aWVzKHJlc3VsdCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlY3Vyc2l2ZWx5IHNlYXJjaGVzIHRoaXMgQ2FyZE9iamVjdCBhbmQgYW55IGNoaWxkcmVuIHRvIGZpbmQgdGhlXHJcbiAgICAgKiBpbm5lcm1vc3QgQ2FyZE9iamVjdCB0aGF0IG93bnMgdGhlIGdpdmVuIERPTSBOb2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBET00gTm9kZSB0byBsb29rIGZvci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgb3duZXIgb2YgdGhlIGdpdmVuIERPTSBOb2RlLCBvciBgdW5kZWZpbmVkYCBpZiBubyBvd25lciB3YXMgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIENhcmRPYmplY3QucHJvdG90eXBlLmZpbmRET01Ob2RlT3duZXIgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIC8vIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIENhcmRPYmplY3RzIHdpdGggbm8gYXNzb2NpYXRlZCBjaGlsZHJlblxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5zKG5vZGUpID8gdGhpcyA6IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBDYXJkT2JqZWN0LnByb3RvdHlwZS5yZWxlYXNlRE9NUmVzb3VyY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaW4gYmFzZSBpbXBsZW1lbnRhdGlvblxyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXJkT2JqZWN0LnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXJkT2JqZWN0LnByb3RvdHlwZSwgXCJyZW5kZXJlZEVsZW1lbnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZWRFbGVtZW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIENhcmRPYmplY3QudHlwZU5hbWVQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuU3RyaW5nUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzAsIFwidHlwZVwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoc2VuZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbmRlci5nZXRKc29uVHlwZU5hbWUoKTtcclxuICAgIH0pO1xyXG4gICAgQ2FyZE9iamVjdC5pZFByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TdHJpbmdQcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfMCwgXCJpZFwiKTtcclxuICAgIENhcmRPYmplY3QucmVxdWlyZXNQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuU2VyaWFsaXphYmxlT2JqZWN0UHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzIsIFwicmVxdWlyZXNcIiwgaG9zdF9jYXBhYmlsaXRpZXNfMS5Ib3N0Q2FwYWJpbGl0aWVzLCBmYWxzZSwgbmV3IGhvc3RfY2FwYWJpbGl0aWVzXzEuSG9zdENhcGFiaWxpdGllcygpKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKENhcmRPYmplY3QuaWRQcm9wZXJ0eSlcclxuICAgIF0sIENhcmRPYmplY3QucHJvdG90eXBlLCBcImlkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShDYXJkT2JqZWN0LnJlcXVpcmVzUHJvcGVydHkpXHJcbiAgICBdLCBDYXJkT2JqZWN0LnByb3RvdHlwZSwgXCJyZXF1aXJlc1wiLCBudWxsKTtcclxuICAgIHJldHVybiBDYXJkT2JqZWN0O1xyXG59KHNlcmlhbGl6YXRpb25fMS5TZXJpYWxpemFibGVPYmplY3QpKTtcclxuZXhwb3J0cy5DYXJkT2JqZWN0ID0gQ2FyZE9iamVjdDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FyZC1vYmplY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5DaGFubmVsQWRhcHRlciA9IHZvaWQgMDtcclxudmFyIENoYW5uZWxBZGFwdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2hhbm5lbEFkYXB0ZXIoKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQ2hhbm5lbEFkYXB0ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQ2hhbm5lbEFkYXB0ZXIgPSBDaGFubmVsQWRhcHRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbC1hZGFwdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuQ29sbGVjdGlvbiA9IHZvaWQgMDtcclxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxudmFyIENvbGxlY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb2xsZWN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX2l0ZW1zID0gW107XHJcbiAgICB9XHJcbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbaW5kZXhdO1xyXG4gICAgfTtcclxuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgdGhpcy5faXRlbXMucHVzaChpdGVtKTtcclxuICAgICAgICBpZiAodGhpcy5vbkl0ZW1BZGRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLm9uSXRlbUFkZGVkKGl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5faXRlbXMuaW5kZXhPZihpdGVtKTtcclxuICAgICAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zID0gdGhpcy5faXRlbXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vbkl0ZW1SZW1vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uSXRlbVJlbW92ZWQoaXRlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmluZGV4T2YoaXRlbSk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbGxlY3Rpb24ucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIENvbGxlY3Rpb247XHJcbn0oKSk7XHJcbmV4cG9ydHMuQ29sbGVjdGlvbiA9IENvbGxlY3Rpb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbGxlY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5Db25zdGFudHMgPSB2b2lkIDA7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmFuZW91cy1jbGFzc1xyXG52YXIgQ29uc3RhbnRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29uc3RhbnRzKCkge1xyXG4gICAgfVxyXG4gICAgQ29uc3RhbnRzLmtleXMgPSB7XHJcbiAgICAgICAgdGFiOiBcIlRhYlwiLFxyXG4gICAgICAgIGVudGVyOiBcIkVudGVyXCIsXHJcbiAgICAgICAgZXNjYXBlOiBcIkVzY2FwZVwiLFxyXG4gICAgICAgIHNwYWNlOiBcIiBcIixcclxuICAgICAgICB1cDogXCJBcnJvd1VwXCIsXHJcbiAgICAgICAgZG93bjogXCJBcnJvd0Rvd25cIixcclxuICAgICAgICBkZWxldGU6IFwiRGVsZXRlXCJcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29uc3RhbnRzO1xyXG59KCkpO1xyXG5leHBvcnRzLkNvbnN0YW50cyA9IENvbnN0YW50cztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xyXG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcclxuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KSk7XHJcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIENvcHlyaWdodCAoQykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tZW51LWl0ZW1cIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcG9wdXAtbWVudVwiKSwgZXhwb3J0cyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuTWVudUl0ZW0gPSB2b2lkIDA7XHJcbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbnZhciBob3N0X2NvbmZpZ18xID0gcmVxdWlyZShcIi4uL2hvc3QtY29uZmlnXCIpO1xyXG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XHJcbnZhciBNZW51SXRlbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1lbnVJdGVtKGtleSwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBNZW51SXRlbS5wcm90b3R5cGUuY2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkICYmIHRoaXMub25DbGljaykge1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2xpY2sodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1lbnVJdGVtLnByb3RvdHlwZS51cGRhdGVDc3NDbGFzc2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBlZmZlY3RpdmVIb3N0Q29uZmlnID0gdGhpcy5faG9zdENvbmZpZyA/IHRoaXMuX2hvc3RDb25maWcgOiBob3N0X2NvbmZpZ18xLmRlZmF1bHRIb3N0Q29uZmlnO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTmFtZSA9IGVmZmVjdGl2ZUhvc3RDb25maWcubWFrZUNzc0NsYXNzTmFtZShcImFjLWN0cmxcIik7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChlZmZlY3RpdmVIb3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUodGhpcy5pc0VuYWJsZWQgPyBcImFjLWN0cmwtZHJvcGRvd24taXRlbVwiIDogXCJhYy1jdHJsLWRyb3Bkb3duLWl0ZW0tZGlzYWJsZWRcIikpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoZWZmZWN0aXZlSG9zdENvbmZpZy5tYWtlQ3NzQ2xhc3NOYW1lKFwiYWMtZGlzYWJsZWRcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1lbnVJdGVtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgIH07XHJcbiAgICBNZW51SXRlbS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGhvc3RDb25maWcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX2hvc3RDb25maWcgPSBob3N0Q29uZmlnO1xyXG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuaW5uZXJUZXh0ID0gdGhpcy52YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibWVudWl0ZW1cIik7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0VuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1kaXNhYmxlZFwiLCBcInRydWVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWN1cnJlbnRcIiwgXCJmYWxzZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5vbm1vdXNldXAgPSBmdW5jdGlvbiAoX2UpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNsaWNrKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQub25rZXlkb3duID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLmtleSA9PT0gY29uc3RhbnRzXzEuQ29uc3RhbnRzLmtleXMuZW50ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xpY2soKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDc3NDbGFzc2VzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZW51SXRlbS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5pbm5lclRleHQgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZW51SXRlbS5wcm90b3R5cGUsIFwiaXNFbmFibGVkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRW5hYmxlZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0VuYWJsZWQgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0VuYWJsZWQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ3NzQ2xhc3NlcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIE1lbnVJdGVtO1xyXG59KCkpO1xyXG5leHBvcnRzLk1lbnVJdGVtID0gTWVudUl0ZW07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbnUtaXRlbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlBvcHVwQ29udHJvbCA9IHZvaWQgMDtcclxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG52YXIgVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XHJcbnZhciBob3N0X2NvbmZpZ18xID0gcmVxdWlyZShcIi4uL2hvc3QtY29uZmlnXCIpO1xyXG52YXIgUG9wdXBDb250cm9sID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUG9wdXBDb250cm9sKCkge1xyXG4gICAgICAgIHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgUG9wdXBDb250cm9sLnByb3RvdHlwZS5rZXlEb3duID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XHJcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLmtleXMuZXNjYXBlOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVBvcHVwKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFBvcHVwQ29udHJvbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKF9yb290RWxlbWVudEJvdW5kcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIGVsZW1lbnQudGFiSW5kZXggPSAwO1xyXG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5ob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1jdHJsXCIsIFwiYWMtY3RybC1wb3B1cC1jb250YWluZXJcIik7XHJcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiZGlhbG9nXCIpO1xyXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1tb2RhbFwiLCBcInRydWVcIik7XHJcbiAgICAgICAgZWxlbWVudC5vbmtleWRvd24gPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5rZXlEb3duKGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gIWUuY2FuY2VsQnViYmxlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlckNvbnRlbnQoKSk7XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICB9O1xyXG4gICAgUG9wdXBDb250cm9sLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcG9wdXBFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZC5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQb3B1cENvbnRyb2wucHJvdG90eXBlLnBvcHVwID0gZnVuY3Rpb24gKHJvb3RFbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZjtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICghdGhpcy5faXNPcGVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheUVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5ob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1jdHJsLW92ZXJsYXlcIik7XHJcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlFbGVtZW50LnRhYkluZGV4ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheUVsZW1lbnQuc3R5bGUud2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlFbGVtZW50LnN0eWxlLmhlaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgKyBcInB4XCI7XHJcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlFbGVtZW50Lm9uZm9jdXMgPSBmdW5jdGlvbiAoX2UpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlUG9wdXAodHJ1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fb3ZlcmxheUVsZW1lbnQpO1xyXG4gICAgICAgICAgICB2YXIgcm9vdEVsZW1lbnRCb3VuZHMgPSByb290RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgdGhpcy5fcG9wdXBFbGVtZW50ID0gdGhpcy5yZW5kZXIocm9vdEVsZW1lbnRCb3VuZHMpO1xyXG4gICAgICAgICAgICAoX2EgPSB0aGlzLl9wb3B1cEVsZW1lbnQuY2xhc3NMaXN0KS5yZW1vdmUuYXBwbHkoX2EsIHRoaXMuaG9zdENvbmZpZy5tYWtlQ3NzQ2xhc3NOYW1lcyhcImFjLWN0cmwtc2xpZGVcIiwgXCJhYy1jdHJsLXNsaWRlTGVmdFRvUmlnaHRcIiwgXCJhYy1jdHJsLXNsaWRlUmlnaHRUb0xlZnRcIiwgXCJhYy1jdHJsLXNsaWRlVG9wVG9Cb3R0b21cIiwgXCJhYy1jdHJsLXNsaWRlUmlnaHRUb0xlZnRcIikpO1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBmdW5jdGlvbiAoX2UpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlUG9wdXAodHJ1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgcm9vdEVsZW1lbnRMYWJlbCA9IHJvb3RFbGVtZW50LmdldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIik7XHJcbiAgICAgICAgICAgIGlmIChyb290RWxlbWVudExhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3B1cEVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCByb290RWxlbWVudExhYmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9wb3B1cEVsZW1lbnQpO1xyXG4gICAgICAgICAgICB2YXIgcG9wdXBFbGVtZW50Qm91bmRzID0gdGhpcy5fcG9wdXBFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlU3BhY2VCZWxvdyA9IHdpbmRvdy5pbm5lckhlaWdodCAtIHJvb3RFbGVtZW50Qm91bmRzLmJvdHRvbTtcclxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVNwYWNlQWJvdmUgPSByb290RWxlbWVudEJvdW5kcy50b3A7XHJcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVTcGFjZVJpZ2h0ID0gd2luZG93LmlubmVyV2lkdGggLSByb290RWxlbWVudEJvdW5kcy5yaWdodDtcclxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVNwYWNlTGVmdCA9IHJvb3RFbGVtZW50Qm91bmRzLmxlZnQ7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gcm9vdEVsZW1lbnRCb3VuZHMubGVmdCArIFV0aWxzLmdldFNjcm9sbFgoKTtcclxuICAgICAgICAgICAgdmFyIHRvcF8xO1xyXG4gICAgICAgICAgICBpZiAoYXZhaWxhYmxlU3BhY2VBYm92ZSA8IHBvcHVwRWxlbWVudEJvdW5kcy5oZWlnaHQgJiZcclxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVNwYWNlQmVsb3cgPCBwb3B1cEVsZW1lbnRCb3VuZHMuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3QgZW5vdWdoIHNwYWNlIGFib3ZlIG9yIGJlbG93IHJvb3QgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgdmFyIGFjdHVhbFBvcHVwSGVpZ2h0ID0gTWF0aC5taW4ocG9wdXBFbGVtZW50Qm91bmRzLmhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVwRWxlbWVudC5zdHlsZS5tYXhIZWlnaHQgPSBhY3R1YWxQb3B1cEhlaWdodCArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIGlmIChhY3R1YWxQb3B1cEhlaWdodCA8IHBvcHVwRWxlbWVudEJvdW5kcy5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3BfMSA9IFV0aWxzLmdldFNjcm9sbFkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcF8xID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMuZ2V0U2Nyb2xsWSgpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50Qm91bmRzLnRvcCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocm9vdEVsZW1lbnRCb3VuZHMuaGVpZ2h0IC0gYWN0dWFsUG9wdXBIZWlnaHQpIC8gMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhdmFpbGFibGVTcGFjZUxlZnQgPCBwb3B1cEVsZW1lbnRCb3VuZHMud2lkdGggJiZcclxuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVTcGFjZVJpZ2h0IDwgcG9wdXBFbGVtZW50Qm91bmRzLndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IGVub3VnaCBzcGFjZSBsZWZ0IG9yIHJpZ2h0IG9mIHJvb3QgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3R1YWxQb3B1cFdpZHRoID0gTWF0aC5taW4ocG9wdXBFbGVtZW50Qm91bmRzLndpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9wdXBFbGVtZW50LnN0eWxlLm1heFdpZHRoID0gYWN0dWFsUG9wdXBXaWR0aCArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0dWFsUG9wdXBXaWR0aCA8IHBvcHVwRWxlbWVudEJvdW5kcy53aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gVXRpbHMuZ2V0U2Nyb2xsWCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVdGlscy5nZXRTY3JvbGxYKCkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50Qm91bmRzLmxlZnQgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyb290RWxlbWVudEJvdW5kcy53aWR0aCAtIGFjdHVhbFBvcHVwV2lkdGgpIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBFbm91Z2ggc3BhY2Ugb24gdGhlIGxlZnQgb3IgcmlnaHQgb2YgdGhlIHJvb3QgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdmFpbGFibGVTcGFjZVJpZ2h0ID49IHBvcHVwRWxlbWVudEJvdW5kcy53aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gVXRpbHMuZ2V0U2Nyb2xsWCgpICsgcm9vdEVsZW1lbnRCb3VuZHMucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IHRoaXMuX3BvcHVwRWxlbWVudC5jbGFzc0xpc3QpLmFkZC5hcHBseShfYiwgdGhpcy5ob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWVzKFwiYWMtY3RybC1zbGlkZVwiLCBcImFjLWN0cmwtc2xpZGVMZWZ0VG9SaWdodFwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFV0aWxzLmdldFNjcm9sbFgoKSArIHJvb3RFbGVtZW50Qm91bmRzLmxlZnQgLSBwb3B1cEVsZW1lbnRCb3VuZHMud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYyA9IHRoaXMuX3BvcHVwRWxlbWVudC5jbGFzc0xpc3QpLmFkZC5hcHBseShfYywgdGhpcy5ob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWVzKFwiYWMtY3RybC1zbGlkZVwiLCBcImFjLWN0cmwtc2xpZGVSaWdodFRvTGVmdFwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gRW5vdWdoIHNwYWNlIGFib3ZlIG9yIGJlbG93IHJvb3QgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgaWYgKGF2YWlsYWJsZVNwYWNlQmVsb3cgPj0gcG9wdXBFbGVtZW50Qm91bmRzLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcF8xID0gVXRpbHMuZ2V0U2Nyb2xsWSgpICsgcm9vdEVsZW1lbnRCb3VuZHMuYm90dG9tO1xyXG4gICAgICAgICAgICAgICAgICAgIChfZCA9IHRoaXMuX3BvcHVwRWxlbWVudC5jbGFzc0xpc3QpLmFkZC5hcHBseShfZCwgdGhpcy5ob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWVzKFwiYWMtY3RybC1zbGlkZVwiLCBcImFjLWN0cmwtc2xpZGVUb3BUb0JvdHRvbVwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3BfMSA9IFV0aWxzLmdldFNjcm9sbFkoKSArIHJvb3RFbGVtZW50Qm91bmRzLnRvcCAtIHBvcHVwRWxlbWVudEJvdW5kcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgKF9mID0gdGhpcy5fcG9wdXBFbGVtZW50LmNsYXNzTGlzdCkuYWRkLmFwcGx5KF9mLCB0aGlzLmhvc3RDb25maWcubWFrZUNzc0NsYXNzTmFtZXMoXCJhYy1jdHJsLXNsaWRlXCIsIFwiYWMtY3RybC1zbGlkZUJvdHRvbVRvVG9wXCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhdmFpbGFibGVTcGFjZVJpZ2h0IDwgcG9wdXBFbGVtZW50Qm91bmRzLndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IFV0aWxzLmdldFNjcm9sbFgoKSArIHJvb3RFbGVtZW50Qm91bmRzLnJpZ2h0IC0gcG9wdXBFbGVtZW50Qm91bmRzLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwRWxlbWVudC5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcclxuICAgICAgICAgICAgdGhpcy5fcG9wdXBFbGVtZW50LnN0eWxlLnRvcCA9IHRvcF8xICsgXCJweFwiO1xyXG4gICAgICAgICAgICB0aGlzLl9wb3B1cEVsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgICAgICAgdGhpcy5faXNPcGVuID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUG9wdXBDb250cm9sLnByb3RvdHlwZS5jbG9zZVBvcHVwID0gZnVuY3Rpb24gKHdhc0NhbmNlbGxlZCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9pc09wZW4pIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLl9vdmVybGF5RWxlbWVudCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vbkNsb3NlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UodGhpcywgd2FzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9wdXBDb250cm9sLnByb3RvdHlwZSwgXCJob3N0Q29uZmlnXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hvc3RDb25maWcgPyB0aGlzLl9ob3N0Q29uZmlnIDogaG9zdF9jb25maWdfMS5kZWZhdWx0SG9zdENvbmZpZztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hvc3RDb25maWcgPSB2YWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9wdXBDb250cm9sLnByb3RvdHlwZSwgXCJpc09wZW5cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNPcGVuO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBQb3B1cENvbnRyb2w7XHJcbn0oKSk7XHJcbmV4cG9ydHMuUG9wdXBDb250cm9sID0gUG9wdXBDb250cm9sO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3B1cC1jb250cm9sLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlBvcHVwTWVudSA9IHZvaWQgMDtcclxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZShcIi4vY29sbGVjdGlvblwiKTtcclxudmFyIHBvcHVwX2NvbnRyb2xfMSA9IHJlcXVpcmUoXCIuL3BvcHVwLWNvbnRyb2xcIik7XHJcbnZhciBQb3B1cE1lbnUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUG9wdXBNZW51LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUG9wdXBNZW51KCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLl9pdGVtcyA9IG5ldyBjb2xsZWN0aW9uXzEuQ29sbGVjdGlvbigpO1xyXG4gICAgICAgIF90aGlzLl9yZW5kZXJlZEl0ZW1zID0gW107XHJcbiAgICAgICAgX3RoaXMuX3NlbGVjdGVkSW5kZXggPSAtMTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBQb3B1cE1lbnUucHJvdG90eXBlLnJlbmRlckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5ob3N0Q29uZmlnLm1ha2VDc3NDbGFzc05hbWUoXCJhYy1jdHJsIGFjLXBvcHVwXCIpO1xyXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImxpc3Rib3hcIik7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pdGVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRJdGVtID0gdGhpcy5faXRlbXMuZ2V0KGkpLnJlbmRlcih0aGlzLmhvc3RDb25maWcpO1xyXG4gICAgICAgICAgICByZW5kZXJlZEl0ZW0udGFiSW5kZXggPSAwO1xyXG4gICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHJlbmRlcmVkSXRlbSk7XHJcbiAgICAgICAgICAgIGlmIChpID09PSB0aGlzLnNlbGVjdGVkSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVkSXRlbS5mb2N1cygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkSXRlbXMucHVzaChyZW5kZXJlZEl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH07XHJcbiAgICBQb3B1cE1lbnUucHJvdG90eXBlLmtleURvd24gPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUua2V5RG93bi5jYWxsKHRoaXMsIGUpO1xyXG4gICAgICAgIHZhciBzZWxlY3RlZEl0ZW1JbmRleCA9IHRoaXMuX3NlbGVjdGVkSW5kZXg7XHJcbiAgICAgICAgc3dpdGNoIChlLmtleSkge1xyXG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkNvbnN0YW50cy5rZXlzLnRhYjpcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VQb3B1cCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICBjYXNlIENvbnN0YW50cy5rZXlzLmVudGVyOlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gdGhpcy5zZWxlY3RlZEluZGV4O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLmtleXMudXA6XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRJdGVtSW5kZXggPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSXRlbUluZGV4ID0gdGhpcy5fcmVuZGVyZWRJdGVtcy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJdGVtSW5kZXgtLTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRJdGVtSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSXRlbUluZGV4ID0gdGhpcy5fcmVuZGVyZWRJdGVtcy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHNlbGVjdGVkSXRlbUluZGV4O1xyXG4gICAgICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuQ29uc3RhbnRzLmtleXMuZG93bjpcclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZEl0ZW1JbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEl0ZW1JbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEl0ZW1JbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZEl0ZW1JbmRleCA+PSB0aGlzLl9yZW5kZXJlZEl0ZW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEl0ZW1JbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gc2VsZWN0ZWRJdGVtSW5kZXg7XHJcbiAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvcHVwTWVudS5wcm90b3R5cGUsIFwiaXRlbXNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXRlbXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvcHVwTWVudS5wcm90b3R5cGUsIFwic2VsZWN0ZWRJbmRleFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZEluZGV4O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9yZW5kZXJlZEl0ZW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZWRJdGVtc1tpbmRleF0uZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkSW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBQb3B1cE1lbnU7XHJcbn0ocG9wdXBfY29udHJvbF8xLlBvcHVwQ29udHJvbCkpO1xyXG5leHBvcnRzLlBvcHVwTWVudSA9IFBvcHVwTWVudTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9wdXAtbWVudS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkxvZ0xldmVsID0gZXhwb3J0cy5SZWZyZXNoTW9kZSA9IGV4cG9ydHMuVHlwZUVycm9yVHlwZSA9IGV4cG9ydHMuQ29udGFpbmVyRml0U3RhdHVzID0gZXhwb3J0cy5WYWxpZGF0aW9uRXZlbnQgPSBleHBvcnRzLlZhbGlkYXRpb25QaGFzZSA9IGV4cG9ydHMuSW5wdXRUZXh0U3R5bGUgPSBleHBvcnRzLkFjdGlvbkljb25QbGFjZW1lbnQgPSBleHBvcnRzLkZpbGxNb2RlID0gZXhwb3J0cy5PcmllbnRhdGlvbiA9IGV4cG9ydHMuU2hvd0NhcmRBY3Rpb25Nb2RlID0gZXhwb3J0cy5JbWFnZVN0eWxlID0gZXhwb3J0cy5BY3Rpb25BbGlnbm1lbnQgPSBleHBvcnRzLlZlcnRpY2FsQWxpZ25tZW50ID0gZXhwb3J0cy5Ib3Jpem9udGFsQWxpZ25tZW50ID0gZXhwb3J0cy5UZXh0Q29sb3IgPSBleHBvcnRzLlNwYWNpbmcgPSBleHBvcnRzLkZvbnRUeXBlID0gZXhwb3J0cy5UZXh0V2VpZ2h0ID0gZXhwb3J0cy5UZXh0U2l6ZSA9IGV4cG9ydHMuU2l6ZVVuaXQgPSBleHBvcnRzLkltYWdlU2l6ZSA9IGV4cG9ydHMuU2l6ZSA9IGV4cG9ydHMuQWN0aW9uTW9kZSA9IGV4cG9ydHMuQWN0aW9uU3R5bGUgPSBleHBvcnRzLkNvbnRhaW5lclN0eWxlID0gdm9pZCAwO1xyXG4vKlxyXG4gICAgVGhpcyBzaG91bGQgcmVhbGx5IGJlIGEgc3RyaW5nIGVudW0sIGUuZy5cclxuXHJcbiAgICAgICAgZXhwb3J0IGVudW0gQ29udGFpbmVyU3R5bGUge1xyXG4gICAgICAgICAgICBEZWZhdWx0ID0gXCJkZWZhdWx0XCIsXHJcbiAgICAgICAgICAgIEVtcGhhc2lzID0gXCJlbXBoYXNpc1wiXHJcbiAgICAgICAgfVxyXG5cclxuICAgIEhvd2V2ZXIsIHNvbWUgaG9zdHMgZG8gbm90IHVzZSBhIHZlcnNpb24gb2YgVHlwZVNjcmlwdFxyXG4gICAgcmVjZW50IGVub3VnaCB0byB1bmRlcnN0YW5kIHN0cmluZyBlbnVtcy4gVGhpcyBpc1xyXG4gICAgYSBjb21wYXRpYmxlIGNvbnN0cnVjdCB0aGF0IGRvZXMgbm90IHJlcXVpcmUgdXNpbmdcclxuICAgIGEgbW9yZSByZWNlbnQgdmVyc2lvbiBvZiBUeXBlU2NyaXB0LlxyXG5cclxuICAgIEFsc28gbm90ZSB0aGUgXCJ3ZWlyZFwiIHdheSB0aGVzZSByZWFkb25seSBmaWVsZHMgYXJlIGRlY2xhcmVkIGlzIHRvIHdvcmsgYXJvdW5kXHJcbiAgICBhIGJyZWFraW5nIGNoYW5nZSBpbnRyb2R1Y2VkIGluIFRTIDMuMSB3cnQgZC50cyBnZW5lcmF0aW9uLiBETyBOT1QgQ0hBTkdFXHJcbiAgICBhbmQgYWRvcHQgdGhpcyBzeW50YXggZm9yIGFsbCBvdGhlciBzdGF0aWMgcmVhZG9ubHkgZmllbGRzLlxyXG4qL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmFuZW91cy1jbGFzcywgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXHJcbnZhciBDb250YWluZXJTdHlsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbnRhaW5lclN0eWxlKCkge1xyXG4gICAgfVxyXG4gICAgQ29udGFpbmVyU3R5bGUuRGVmYXVsdCA9IFwiZGVmYXVsdFwiO1xyXG4gICAgQ29udGFpbmVyU3R5bGUuRW1waGFzaXMgPSBcImVtcGhhc2lzXCI7XHJcbiAgICBDb250YWluZXJTdHlsZS5BY2NlbnQgPSBcImFjY2VudFwiO1xyXG4gICAgQ29udGFpbmVyU3R5bGUuR29vZCA9IFwiZ29vZFwiO1xyXG4gICAgQ29udGFpbmVyU3R5bGUuQXR0ZW50aW9uID0gXCJhdHRlbnRpb25cIjtcclxuICAgIENvbnRhaW5lclN0eWxlLldhcm5pbmcgPSBcIndhcm5pbmdcIjtcclxuICAgIHJldHVybiBDb250YWluZXJTdHlsZTtcclxufSgpKTtcclxuZXhwb3J0cy5Db250YWluZXJTdHlsZSA9IENvbnRhaW5lclN0eWxlO1xyXG52YXIgQWN0aW9uU3R5bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBY3Rpb25TdHlsZSgpIHtcclxuICAgIH1cclxuICAgIEFjdGlvblN0eWxlLkRlZmF1bHQgPSBcImRlZmF1bHRcIjtcclxuICAgIEFjdGlvblN0eWxlLlBvc2l0aXZlID0gXCJwb3NpdGl2ZVwiO1xyXG4gICAgQWN0aW9uU3R5bGUuRGVzdHJ1Y3RpdmUgPSBcImRlc3RydWN0aXZlXCI7XHJcbiAgICByZXR1cm4gQWN0aW9uU3R5bGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQWN0aW9uU3R5bGUgPSBBY3Rpb25TdHlsZTtcclxudmFyIEFjdGlvbk1vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBY3Rpb25Nb2RlKCkge1xyXG4gICAgfVxyXG4gICAgQWN0aW9uTW9kZS5QcmltYXJ5ID0gXCJwcmltYXJ5XCI7XHJcbiAgICBBY3Rpb25Nb2RlLlNlY29uZGFyeSA9IFwic2Vjb25kYXJ5XCI7XHJcbiAgICByZXR1cm4gQWN0aW9uTW9kZTtcclxufSgpKTtcclxuZXhwb3J0cy5BY3Rpb25Nb2RlID0gQWN0aW9uTW9kZTtcclxuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmFuZW91cy1jbGFzcywgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXHJcbnZhciBTaXplO1xyXG4oZnVuY3Rpb24gKFNpemUpIHtcclxuICAgIFNpemVbU2l6ZVtcIkF1dG9cIl0gPSAwXSA9IFwiQXV0b1wiO1xyXG4gICAgU2l6ZVtTaXplW1wiU3RyZXRjaFwiXSA9IDFdID0gXCJTdHJldGNoXCI7XHJcbiAgICBTaXplW1NpemVbXCJTbWFsbFwiXSA9IDJdID0gXCJTbWFsbFwiO1xyXG4gICAgU2l6ZVtTaXplW1wiTWVkaXVtXCJdID0gM10gPSBcIk1lZGl1bVwiO1xyXG4gICAgU2l6ZVtTaXplW1wiTGFyZ2VcIl0gPSA0XSA9IFwiTGFyZ2VcIjtcclxufSkoU2l6ZSA9IGV4cG9ydHMuU2l6ZSB8fCAoZXhwb3J0cy5TaXplID0ge30pKTtcclxudmFyIEltYWdlU2l6ZTtcclxuKGZ1bmN0aW9uIChJbWFnZVNpemUpIHtcclxuICAgIEltYWdlU2l6ZVtJbWFnZVNpemVbXCJTbWFsbFwiXSA9IDBdID0gXCJTbWFsbFwiO1xyXG4gICAgSW1hZ2VTaXplW0ltYWdlU2l6ZVtcIk1lZGl1bVwiXSA9IDFdID0gXCJNZWRpdW1cIjtcclxuICAgIEltYWdlU2l6ZVtJbWFnZVNpemVbXCJMYXJnZVwiXSA9IDJdID0gXCJMYXJnZVwiO1xyXG59KShJbWFnZVNpemUgPSBleHBvcnRzLkltYWdlU2l6ZSB8fCAoZXhwb3J0cy5JbWFnZVNpemUgPSB7fSkpO1xyXG52YXIgU2l6ZVVuaXQ7XHJcbihmdW5jdGlvbiAoU2l6ZVVuaXQpIHtcclxuICAgIFNpemVVbml0W1NpemVVbml0W1wiV2VpZ2h0XCJdID0gMF0gPSBcIldlaWdodFwiO1xyXG4gICAgU2l6ZVVuaXRbU2l6ZVVuaXRbXCJQaXhlbFwiXSA9IDFdID0gXCJQaXhlbFwiO1xyXG59KShTaXplVW5pdCA9IGV4cG9ydHMuU2l6ZVVuaXQgfHwgKGV4cG9ydHMuU2l6ZVVuaXQgPSB7fSkpO1xyXG52YXIgVGV4dFNpemU7XHJcbihmdW5jdGlvbiAoVGV4dFNpemUpIHtcclxuICAgIFRleHRTaXplW1RleHRTaXplW1wiU21hbGxcIl0gPSAwXSA9IFwiU21hbGxcIjtcclxuICAgIFRleHRTaXplW1RleHRTaXplW1wiRGVmYXVsdFwiXSA9IDFdID0gXCJEZWZhdWx0XCI7XHJcbiAgICBUZXh0U2l6ZVtUZXh0U2l6ZVtcIk1lZGl1bVwiXSA9IDJdID0gXCJNZWRpdW1cIjtcclxuICAgIFRleHRTaXplW1RleHRTaXplW1wiTGFyZ2VcIl0gPSAzXSA9IFwiTGFyZ2VcIjtcclxuICAgIFRleHRTaXplW1RleHRTaXplW1wiRXh0cmFMYXJnZVwiXSA9IDRdID0gXCJFeHRyYUxhcmdlXCI7XHJcbn0pKFRleHRTaXplID0gZXhwb3J0cy5UZXh0U2l6ZSB8fCAoZXhwb3J0cy5UZXh0U2l6ZSA9IHt9KSk7XHJcbnZhciBUZXh0V2VpZ2h0O1xyXG4oZnVuY3Rpb24gKFRleHRXZWlnaHQpIHtcclxuICAgIFRleHRXZWlnaHRbVGV4dFdlaWdodFtcIkxpZ2h0ZXJcIl0gPSAwXSA9IFwiTGlnaHRlclwiO1xyXG4gICAgVGV4dFdlaWdodFtUZXh0V2VpZ2h0W1wiRGVmYXVsdFwiXSA9IDFdID0gXCJEZWZhdWx0XCI7XHJcbiAgICBUZXh0V2VpZ2h0W1RleHRXZWlnaHRbXCJCb2xkZXJcIl0gPSAyXSA9IFwiQm9sZGVyXCI7XHJcbn0pKFRleHRXZWlnaHQgPSBleHBvcnRzLlRleHRXZWlnaHQgfHwgKGV4cG9ydHMuVGV4dFdlaWdodCA9IHt9KSk7XHJcbnZhciBGb250VHlwZTtcclxuKGZ1bmN0aW9uIChGb250VHlwZSkge1xyXG4gICAgRm9udFR5cGVbRm9udFR5cGVbXCJEZWZhdWx0XCJdID0gMF0gPSBcIkRlZmF1bHRcIjtcclxuICAgIEZvbnRUeXBlW0ZvbnRUeXBlW1wiTW9ub3NwYWNlXCJdID0gMV0gPSBcIk1vbm9zcGFjZVwiO1xyXG59KShGb250VHlwZSA9IGV4cG9ydHMuRm9udFR5cGUgfHwgKGV4cG9ydHMuRm9udFR5cGUgPSB7fSkpO1xyXG52YXIgU3BhY2luZztcclxuKGZ1bmN0aW9uIChTcGFjaW5nKSB7XHJcbiAgICBTcGFjaW5nW1NwYWNpbmdbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcclxuICAgIFNwYWNpbmdbU3BhY2luZ1tcIlNtYWxsXCJdID0gMV0gPSBcIlNtYWxsXCI7XHJcbiAgICBTcGFjaW5nW1NwYWNpbmdbXCJEZWZhdWx0XCJdID0gMl0gPSBcIkRlZmF1bHRcIjtcclxuICAgIFNwYWNpbmdbU3BhY2luZ1tcIk1lZGl1bVwiXSA9IDNdID0gXCJNZWRpdW1cIjtcclxuICAgIFNwYWNpbmdbU3BhY2luZ1tcIkxhcmdlXCJdID0gNF0gPSBcIkxhcmdlXCI7XHJcbiAgICBTcGFjaW5nW1NwYWNpbmdbXCJFeHRyYUxhcmdlXCJdID0gNV0gPSBcIkV4dHJhTGFyZ2VcIjtcclxuICAgIFNwYWNpbmdbU3BhY2luZ1tcIlBhZGRpbmdcIl0gPSA2XSA9IFwiUGFkZGluZ1wiO1xyXG59KShTcGFjaW5nID0gZXhwb3J0cy5TcGFjaW5nIHx8IChleHBvcnRzLlNwYWNpbmcgPSB7fSkpO1xyXG52YXIgVGV4dENvbG9yO1xyXG4oZnVuY3Rpb24gKFRleHRDb2xvcikge1xyXG4gICAgVGV4dENvbG9yW1RleHRDb2xvcltcIkRlZmF1bHRcIl0gPSAwXSA9IFwiRGVmYXVsdFwiO1xyXG4gICAgVGV4dENvbG9yW1RleHRDb2xvcltcIkRhcmtcIl0gPSAxXSA9IFwiRGFya1wiO1xyXG4gICAgVGV4dENvbG9yW1RleHRDb2xvcltcIkxpZ2h0XCJdID0gMl0gPSBcIkxpZ2h0XCI7XHJcbiAgICBUZXh0Q29sb3JbVGV4dENvbG9yW1wiQWNjZW50XCJdID0gM10gPSBcIkFjY2VudFwiO1xyXG4gICAgVGV4dENvbG9yW1RleHRDb2xvcltcIkdvb2RcIl0gPSA0XSA9IFwiR29vZFwiO1xyXG4gICAgVGV4dENvbG9yW1RleHRDb2xvcltcIldhcm5pbmdcIl0gPSA1XSA9IFwiV2FybmluZ1wiO1xyXG4gICAgVGV4dENvbG9yW1RleHRDb2xvcltcIkF0dGVudGlvblwiXSA9IDZdID0gXCJBdHRlbnRpb25cIjtcclxufSkoVGV4dENvbG9yID0gZXhwb3J0cy5UZXh0Q29sb3IgfHwgKGV4cG9ydHMuVGV4dENvbG9yID0ge30pKTtcclxudmFyIEhvcml6b250YWxBbGlnbm1lbnQ7XHJcbihmdW5jdGlvbiAoSG9yaXpvbnRhbEFsaWdubWVudCkge1xyXG4gICAgSG9yaXpvbnRhbEFsaWdubWVudFtIb3Jpem9udGFsQWxpZ25tZW50W1wiTGVmdFwiXSA9IDBdID0gXCJMZWZ0XCI7XHJcbiAgICBIb3Jpem9udGFsQWxpZ25tZW50W0hvcml6b250YWxBbGlnbm1lbnRbXCJDZW50ZXJcIl0gPSAxXSA9IFwiQ2VudGVyXCI7XHJcbiAgICBIb3Jpem9udGFsQWxpZ25tZW50W0hvcml6b250YWxBbGlnbm1lbnRbXCJSaWdodFwiXSA9IDJdID0gXCJSaWdodFwiO1xyXG59KShIb3Jpem9udGFsQWxpZ25tZW50ID0gZXhwb3J0cy5Ib3Jpem9udGFsQWxpZ25tZW50IHx8IChleHBvcnRzLkhvcml6b250YWxBbGlnbm1lbnQgPSB7fSkpO1xyXG52YXIgVmVydGljYWxBbGlnbm1lbnQ7XHJcbihmdW5jdGlvbiAoVmVydGljYWxBbGlnbm1lbnQpIHtcclxuICAgIFZlcnRpY2FsQWxpZ25tZW50W1ZlcnRpY2FsQWxpZ25tZW50W1wiVG9wXCJdID0gMF0gPSBcIlRvcFwiO1xyXG4gICAgVmVydGljYWxBbGlnbm1lbnRbVmVydGljYWxBbGlnbm1lbnRbXCJDZW50ZXJcIl0gPSAxXSA9IFwiQ2VudGVyXCI7XHJcbiAgICBWZXJ0aWNhbEFsaWdubWVudFtWZXJ0aWNhbEFsaWdubWVudFtcIkJvdHRvbVwiXSA9IDJdID0gXCJCb3R0b21cIjtcclxufSkoVmVydGljYWxBbGlnbm1lbnQgPSBleHBvcnRzLlZlcnRpY2FsQWxpZ25tZW50IHx8IChleHBvcnRzLlZlcnRpY2FsQWxpZ25tZW50ID0ge30pKTtcclxudmFyIEFjdGlvbkFsaWdubWVudDtcclxuKGZ1bmN0aW9uIChBY3Rpb25BbGlnbm1lbnQpIHtcclxuICAgIEFjdGlvbkFsaWdubWVudFtBY3Rpb25BbGlnbm1lbnRbXCJMZWZ0XCJdID0gMF0gPSBcIkxlZnRcIjtcclxuICAgIEFjdGlvbkFsaWdubWVudFtBY3Rpb25BbGlnbm1lbnRbXCJDZW50ZXJcIl0gPSAxXSA9IFwiQ2VudGVyXCI7XHJcbiAgICBBY3Rpb25BbGlnbm1lbnRbQWN0aW9uQWxpZ25tZW50W1wiUmlnaHRcIl0gPSAyXSA9IFwiUmlnaHRcIjtcclxuICAgIEFjdGlvbkFsaWdubWVudFtBY3Rpb25BbGlnbm1lbnRbXCJTdHJldGNoXCJdID0gM10gPSBcIlN0cmV0Y2hcIjtcclxufSkoQWN0aW9uQWxpZ25tZW50ID0gZXhwb3J0cy5BY3Rpb25BbGlnbm1lbnQgfHwgKGV4cG9ydHMuQWN0aW9uQWxpZ25tZW50ID0ge30pKTtcclxudmFyIEltYWdlU3R5bGU7XHJcbihmdW5jdGlvbiAoSW1hZ2VTdHlsZSkge1xyXG4gICAgSW1hZ2VTdHlsZVtJbWFnZVN0eWxlW1wiRGVmYXVsdFwiXSA9IDBdID0gXCJEZWZhdWx0XCI7XHJcbiAgICBJbWFnZVN0eWxlW0ltYWdlU3R5bGVbXCJQZXJzb25cIl0gPSAxXSA9IFwiUGVyc29uXCI7XHJcbn0pKEltYWdlU3R5bGUgPSBleHBvcnRzLkltYWdlU3R5bGUgfHwgKGV4cG9ydHMuSW1hZ2VTdHlsZSA9IHt9KSk7XHJcbnZhciBTaG93Q2FyZEFjdGlvbk1vZGU7XHJcbihmdW5jdGlvbiAoU2hvd0NhcmRBY3Rpb25Nb2RlKSB7XHJcbiAgICBTaG93Q2FyZEFjdGlvbk1vZGVbU2hvd0NhcmRBY3Rpb25Nb2RlW1wiSW5saW5lXCJdID0gMF0gPSBcIklubGluZVwiO1xyXG4gICAgU2hvd0NhcmRBY3Rpb25Nb2RlW1Nob3dDYXJkQWN0aW9uTW9kZVtcIlBvcHVwXCJdID0gMV0gPSBcIlBvcHVwXCI7XHJcbn0pKFNob3dDYXJkQWN0aW9uTW9kZSA9IGV4cG9ydHMuU2hvd0NhcmRBY3Rpb25Nb2RlIHx8IChleHBvcnRzLlNob3dDYXJkQWN0aW9uTW9kZSA9IHt9KSk7XHJcbnZhciBPcmllbnRhdGlvbjtcclxuKGZ1bmN0aW9uIChPcmllbnRhdGlvbikge1xyXG4gICAgT3JpZW50YXRpb25bT3JpZW50YXRpb25bXCJIb3Jpem9udGFsXCJdID0gMF0gPSBcIkhvcml6b250YWxcIjtcclxuICAgIE9yaWVudGF0aW9uW09yaWVudGF0aW9uW1wiVmVydGljYWxcIl0gPSAxXSA9IFwiVmVydGljYWxcIjtcclxufSkoT3JpZW50YXRpb24gPSBleHBvcnRzLk9yaWVudGF0aW9uIHx8IChleHBvcnRzLk9yaWVudGF0aW9uID0ge30pKTtcclxudmFyIEZpbGxNb2RlO1xyXG4oZnVuY3Rpb24gKEZpbGxNb2RlKSB7XHJcbiAgICBGaWxsTW9kZVtGaWxsTW9kZVtcIkNvdmVyXCJdID0gMF0gPSBcIkNvdmVyXCI7XHJcbiAgICBGaWxsTW9kZVtGaWxsTW9kZVtcIlJlcGVhdEhvcml6b250YWxseVwiXSA9IDFdID0gXCJSZXBlYXRIb3Jpem9udGFsbHlcIjtcclxuICAgIEZpbGxNb2RlW0ZpbGxNb2RlW1wiUmVwZWF0VmVydGljYWxseVwiXSA9IDJdID0gXCJSZXBlYXRWZXJ0aWNhbGx5XCI7XHJcbiAgICBGaWxsTW9kZVtGaWxsTW9kZVtcIlJlcGVhdFwiXSA9IDNdID0gXCJSZXBlYXRcIjtcclxufSkoRmlsbE1vZGUgPSBleHBvcnRzLkZpbGxNb2RlIHx8IChleHBvcnRzLkZpbGxNb2RlID0ge30pKTtcclxudmFyIEFjdGlvbkljb25QbGFjZW1lbnQ7XHJcbihmdW5jdGlvbiAoQWN0aW9uSWNvblBsYWNlbWVudCkge1xyXG4gICAgQWN0aW9uSWNvblBsYWNlbWVudFtBY3Rpb25JY29uUGxhY2VtZW50W1wiTGVmdE9mVGl0bGVcIl0gPSAwXSA9IFwiTGVmdE9mVGl0bGVcIjtcclxuICAgIEFjdGlvbkljb25QbGFjZW1lbnRbQWN0aW9uSWNvblBsYWNlbWVudFtcIkFib3ZlVGl0bGVcIl0gPSAxXSA9IFwiQWJvdmVUaXRsZVwiO1xyXG59KShBY3Rpb25JY29uUGxhY2VtZW50ID0gZXhwb3J0cy5BY3Rpb25JY29uUGxhY2VtZW50IHx8IChleHBvcnRzLkFjdGlvbkljb25QbGFjZW1lbnQgPSB7fSkpO1xyXG52YXIgSW5wdXRUZXh0U3R5bGU7XHJcbihmdW5jdGlvbiAoSW5wdXRUZXh0U3R5bGUpIHtcclxuICAgIElucHV0VGV4dFN0eWxlW0lucHV0VGV4dFN0eWxlW1wiVGV4dFwiXSA9IDBdID0gXCJUZXh0XCI7XHJcbiAgICBJbnB1dFRleHRTdHlsZVtJbnB1dFRleHRTdHlsZVtcIlRlbFwiXSA9IDFdID0gXCJUZWxcIjtcclxuICAgIElucHV0VGV4dFN0eWxlW0lucHV0VGV4dFN0eWxlW1wiVXJsXCJdID0gMl0gPSBcIlVybFwiO1xyXG4gICAgSW5wdXRUZXh0U3R5bGVbSW5wdXRUZXh0U3R5bGVbXCJFbWFpbFwiXSA9IDNdID0gXCJFbWFpbFwiO1xyXG4gICAgSW5wdXRUZXh0U3R5bGVbSW5wdXRUZXh0U3R5bGVbXCJQYXNzd29yZFwiXSA9IDRdID0gXCJQYXNzd29yZFwiO1xyXG59KShJbnB1dFRleHRTdHlsZSA9IGV4cG9ydHMuSW5wdXRUZXh0U3R5bGUgfHwgKGV4cG9ydHMuSW5wdXRUZXh0U3R5bGUgPSB7fSkpO1xyXG52YXIgVmFsaWRhdGlvblBoYXNlO1xyXG4oZnVuY3Rpb24gKFZhbGlkYXRpb25QaGFzZSkge1xyXG4gICAgVmFsaWRhdGlvblBoYXNlW1ZhbGlkYXRpb25QaGFzZVtcIlBhcnNlXCJdID0gMF0gPSBcIlBhcnNlXCI7XHJcbiAgICBWYWxpZGF0aW9uUGhhc2VbVmFsaWRhdGlvblBoYXNlW1wiVG9KU09OXCJdID0gMV0gPSBcIlRvSlNPTlwiO1xyXG4gICAgVmFsaWRhdGlvblBoYXNlW1ZhbGlkYXRpb25QaGFzZVtcIlZhbGlkYXRpb25cIl0gPSAyXSA9IFwiVmFsaWRhdGlvblwiO1xyXG59KShWYWxpZGF0aW9uUGhhc2UgPSBleHBvcnRzLlZhbGlkYXRpb25QaGFzZSB8fCAoZXhwb3J0cy5WYWxpZGF0aW9uUGhhc2UgPSB7fSkpO1xyXG52YXIgVmFsaWRhdGlvbkV2ZW50O1xyXG4oZnVuY3Rpb24gKFZhbGlkYXRpb25FdmVudCkge1xyXG4gICAgVmFsaWRhdGlvbkV2ZW50W1ZhbGlkYXRpb25FdmVudFtcIkhpbnRcIl0gPSAwXSA9IFwiSGludFwiO1xyXG4gICAgVmFsaWRhdGlvbkV2ZW50W1ZhbGlkYXRpb25FdmVudFtcIkFjdGlvblR5cGVOb3RBbGxvd2VkXCJdID0gMV0gPSBcIkFjdGlvblR5cGVOb3RBbGxvd2VkXCI7XHJcbiAgICBWYWxpZGF0aW9uRXZlbnRbVmFsaWRhdGlvbkV2ZW50W1wiQ29sbGVjdGlvbkNhbnRCZUVtcHR5XCJdID0gMl0gPSBcIkNvbGxlY3Rpb25DYW50QmVFbXB0eVwiO1xyXG4gICAgVmFsaWRhdGlvbkV2ZW50W1ZhbGlkYXRpb25FdmVudFtcIkRlcHJlY2F0ZWRcIl0gPSAzXSA9IFwiRGVwcmVjYXRlZFwiO1xyXG4gICAgVmFsaWRhdGlvbkV2ZW50W1ZhbGlkYXRpb25FdmVudFtcIkVsZW1lbnRUeXBlTm90QWxsb3dlZFwiXSA9IDRdID0gXCJFbGVtZW50VHlwZU5vdEFsbG93ZWRcIjtcclxuICAgIFZhbGlkYXRpb25FdmVudFtWYWxpZGF0aW9uRXZlbnRbXCJJbnRlcmFjdGl2aXR5Tm90QWxsb3dlZFwiXSA9IDVdID0gXCJJbnRlcmFjdGl2aXR5Tm90QWxsb3dlZFwiO1xyXG4gICAgVmFsaWRhdGlvbkV2ZW50W1ZhbGlkYXRpb25FdmVudFtcIkludmFsaWRQcm9wZXJ0eVZhbHVlXCJdID0gNl0gPSBcIkludmFsaWRQcm9wZXJ0eVZhbHVlXCI7XHJcbiAgICBWYWxpZGF0aW9uRXZlbnRbVmFsaWRhdGlvbkV2ZW50W1wiTWlzc2luZ0NhcmRUeXBlXCJdID0gN10gPSBcIk1pc3NpbmdDYXJkVHlwZVwiO1xyXG4gICAgVmFsaWRhdGlvbkV2ZW50W1ZhbGlkYXRpb25FdmVudFtcIlByb3BlcnR5Q2FudEJlTnVsbFwiXSA9IDhdID0gXCJQcm9wZXJ0eUNhbnRCZU51bGxcIjtcclxuICAgIFZhbGlkYXRpb25FdmVudFtWYWxpZGF0aW9uRXZlbnRbXCJUb29NYW55QWN0aW9uc1wiXSA9IDldID0gXCJUb29NYW55QWN0aW9uc1wiO1xyXG4gICAgVmFsaWRhdGlvbkV2ZW50W1ZhbGlkYXRpb25FdmVudFtcIlVua25vd25BY3Rpb25UeXBlXCJdID0gMTBdID0gXCJVbmtub3duQWN0aW9uVHlwZVwiO1xyXG4gICAgVmFsaWRhdGlvbkV2ZW50W1ZhbGlkYXRpb25FdmVudFtcIlVua25vd25FbGVtZW50VHlwZVwiXSA9IDExXSA9IFwiVW5rbm93bkVsZW1lbnRUeXBlXCI7XHJcbiAgICBWYWxpZGF0aW9uRXZlbnRbVmFsaWRhdGlvbkV2ZW50W1wiVW5zdXBwb3J0ZWRDYXJkVmVyc2lvblwiXSA9IDEyXSA9IFwiVW5zdXBwb3J0ZWRDYXJkVmVyc2lvblwiO1xyXG4gICAgVmFsaWRhdGlvbkV2ZW50W1ZhbGlkYXRpb25FdmVudFtcIkR1cGxpY2F0ZUlkXCJdID0gMTNdID0gXCJEdXBsaWNhdGVJZFwiO1xyXG4gICAgVmFsaWRhdGlvbkV2ZW50W1ZhbGlkYXRpb25FdmVudFtcIlVuc3VwcG9ydGVkUHJvcGVydHlcIl0gPSAxNF0gPSBcIlVuc3VwcG9ydGVkUHJvcGVydHlcIjtcclxuICAgIFZhbGlkYXRpb25FdmVudFtWYWxpZGF0aW9uRXZlbnRbXCJSZXF1aXJlZElucHV0c1Nob3VsZEhhdmVMYWJlbFwiXSA9IDE1XSA9IFwiUmVxdWlyZWRJbnB1dHNTaG91bGRIYXZlTGFiZWxcIjtcclxuICAgIFZhbGlkYXRpb25FdmVudFtWYWxpZGF0aW9uRXZlbnRbXCJSZXF1aXJlZElucHV0c1Nob3VsZEhhdmVFcnJvck1lc3NhZ2VcIl0gPSAxNl0gPSBcIlJlcXVpcmVkSW5wdXRzU2hvdWxkSGF2ZUVycm9yTWVzc2FnZVwiO1xyXG4gICAgVmFsaWRhdGlvbkV2ZW50W1ZhbGlkYXRpb25FdmVudFtcIk90aGVyXCJdID0gMTddID0gXCJPdGhlclwiO1xyXG59KShWYWxpZGF0aW9uRXZlbnQgPSBleHBvcnRzLlZhbGlkYXRpb25FdmVudCB8fCAoZXhwb3J0cy5WYWxpZGF0aW9uRXZlbnQgPSB7fSkpO1xyXG52YXIgQ29udGFpbmVyRml0U3RhdHVzO1xyXG4oZnVuY3Rpb24gKENvbnRhaW5lckZpdFN0YXR1cykge1xyXG4gICAgQ29udGFpbmVyRml0U3RhdHVzW0NvbnRhaW5lckZpdFN0YXR1c1tcIkZ1bGx5SW5Db250YWluZXJcIl0gPSAwXSA9IFwiRnVsbHlJbkNvbnRhaW5lclwiO1xyXG4gICAgQ29udGFpbmVyRml0U3RhdHVzW0NvbnRhaW5lckZpdFN0YXR1c1tcIk92ZXJmbG93aW5nXCJdID0gMV0gPSBcIk92ZXJmbG93aW5nXCI7XHJcbiAgICBDb250YWluZXJGaXRTdGF0dXNbQ29udGFpbmVyRml0U3RhdHVzW1wiRnVsbHlPdXRPZkNvbnRhaW5lclwiXSA9IDJdID0gXCJGdWxseU91dE9mQ29udGFpbmVyXCI7XHJcbn0pKENvbnRhaW5lckZpdFN0YXR1cyA9IGV4cG9ydHMuQ29udGFpbmVyRml0U3RhdHVzIHx8IChleHBvcnRzLkNvbnRhaW5lckZpdFN0YXR1cyA9IHt9KSk7XHJcbnZhciBUeXBlRXJyb3JUeXBlO1xyXG4oZnVuY3Rpb24gKFR5cGVFcnJvclR5cGUpIHtcclxuICAgIFR5cGVFcnJvclR5cGVbVHlwZUVycm9yVHlwZVtcIlVua25vd25UeXBlXCJdID0gMF0gPSBcIlVua25vd25UeXBlXCI7XHJcbiAgICBUeXBlRXJyb3JUeXBlW1R5cGVFcnJvclR5cGVbXCJGb3JiaWRkZW5UeXBlXCJdID0gMV0gPSBcIkZvcmJpZGRlblR5cGVcIjtcclxufSkoVHlwZUVycm9yVHlwZSA9IGV4cG9ydHMuVHlwZUVycm9yVHlwZSB8fCAoZXhwb3J0cy5UeXBlRXJyb3JUeXBlID0ge30pKTtcclxudmFyIFJlZnJlc2hNb2RlO1xyXG4oZnVuY3Rpb24gKFJlZnJlc2hNb2RlKSB7XHJcbiAgICBSZWZyZXNoTW9kZVtSZWZyZXNoTW9kZVtcIkRpc2FibGVkXCJdID0gMF0gPSBcIkRpc2FibGVkXCI7XHJcbiAgICBSZWZyZXNoTW9kZVtSZWZyZXNoTW9kZVtcIk1hbnVhbFwiXSA9IDFdID0gXCJNYW51YWxcIjtcclxuICAgIFJlZnJlc2hNb2RlW1JlZnJlc2hNb2RlW1wiQXV0b21hdGljXCJdID0gMl0gPSBcIkF1dG9tYXRpY1wiO1xyXG59KShSZWZyZXNoTW9kZSA9IGV4cG9ydHMuUmVmcmVzaE1vZGUgfHwgKGV4cG9ydHMuUmVmcmVzaE1vZGUgPSB7fSkpO1xyXG52YXIgTG9nTGV2ZWw7XHJcbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiSW5mb1wiXSA9IDBdID0gXCJJbmZvXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldhcm5pbmdcIl0gPSAxXSA9IFwiV2FybmluZ1wiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJFcnJvclwiXSA9IDJdID0gXCJFcnJvclwiO1xyXG59KShMb2dMZXZlbCA9IGV4cG9ydHMuTG9nTGV2ZWwgfHwgKGV4cG9ydHMuTG9nTGV2ZWwgPSB7fSkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5Ib3N0Q2FwYWJpbGl0aWVzID0gdm9pZCAwO1xyXG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG52YXIgc2VyaWFsaXphdGlvbl8xID0gcmVxdWlyZShcIi4vc2VyaWFsaXphdGlvblwiKTtcclxudmFyIEhvc3RDYXBhYmlsaXRpZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSG9zdENhcGFiaWxpdGllcywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEhvc3RDYXBhYmlsaXRpZXMoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX2NhcGFiaWxpdGllcyA9IHt9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEhvc3RDYXBhYmlsaXRpZXMucHJvdG90eXBlLmdldFNjaGVtYUtleSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXCJIb3N0Q2FwYWJpbGl0aWVzXCI7XHJcbiAgICB9O1xyXG4gICAgSG9zdENhcGFiaWxpdGllcy5wcm90b3R5cGUuaW50ZXJuYWxQYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNvbnRleHQpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmludGVybmFsUGFyc2UuY2FsbCh0aGlzLCBzb3VyY2UsIGNvbnRleHQpO1xyXG4gICAgICAgIGlmIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxyXG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gc291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIganNvblZlcnNpb24gPSBzb3VyY2VbbmFtZV8xXTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YganNvblZlcnNpb24gPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvblZlcnNpb24gPT09IFwiKlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2FwYWJpbGl0eShuYW1lXzEsIFwiKlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJzaW9uID0gc2VyaWFsaXphdGlvbl8xLlZlcnNpb24ucGFyc2UoanNvblZlcnNpb24sIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gbnVsbCB8fCB2ZXJzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2ZXJzaW9uLmlzVmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2FwYWJpbGl0eShuYW1lXzEsIHZlcnNpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEhvc3RDYXBhYmlsaXRpZXMucHJvdG90eXBlLmludGVybmFsVG9KU09OID0gZnVuY3Rpb24gKHRhcmdldCwgY29udGV4dCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW50ZXJuYWxUb0pTT04uY2FsbCh0aGlzLCB0YXJnZXQsIGNvbnRleHQpO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fY2FwYWJpbGl0aWVzKSB7XHJcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gdGhpcy5fY2FwYWJpbGl0aWVzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEhvc3RDYXBhYmlsaXRpZXMucHJvdG90eXBlLmFkZENhcGFiaWxpdHkgPSBmdW5jdGlvbiAobmFtZSwgdmVyc2lvbikge1xyXG4gICAgICAgIHRoaXMuX2NhcGFiaWxpdGllc1tuYW1lXSA9IHZlcnNpb247XHJcbiAgICB9O1xyXG4gICAgSG9zdENhcGFiaWxpdGllcy5wcm90b3R5cGUucmVtb3ZlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX2NhcGFiaWxpdGllc1tuYW1lXTtcclxuICAgIH07XHJcbiAgICBIb3N0Q2FwYWJpbGl0aWVzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9jYXBhYmlsaXRpZXMgPSB7fTtcclxuICAgIH07XHJcbiAgICBIb3N0Q2FwYWJpbGl0aWVzLnByb3RvdHlwZS5oYXNDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZlcnNpb24pIHtcclxuICAgICAgICBpZiAodGhpcy5fY2FwYWJpbGl0aWVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSBcIipcIiB8fCB0aGlzLl9jYXBhYmlsaXRpZXNbbmFtZV0gPT09IFwiKlwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmVyc2lvbi5jb21wYXJlVG8odGhpcy5fY2FwYWJpbGl0aWVzW25hbWVdKSA8PSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgSG9zdENhcGFiaWxpdGllcy5wcm90b3R5cGUuYXJlQWxsTWV0ID0gZnVuY3Rpb24gKGhvc3RDYXBhYmlsaXRpZXMpIHtcclxuICAgICAgICBmb3IgKHZhciBjYXBhYmlsaXR5TmFtZSBpbiB0aGlzLl9jYXBhYmlsaXRpZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFob3N0Q2FwYWJpbGl0aWVzLmhhc0NhcGFiaWxpdHkoY2FwYWJpbGl0eU5hbWUsIHRoaXMuX2NhcGFiaWxpdGllc1tjYXBhYmlsaXR5TmFtZV0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEhvc3RDYXBhYmlsaXRpZXM7XHJcbn0oc2VyaWFsaXphdGlvbl8xLlNlcmlhbGl6YWJsZU9iamVjdCkpO1xyXG5leHBvcnRzLkhvc3RDYXBhYmlsaXRpZXMgPSBIb3N0Q2FwYWJpbGl0aWVzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob3N0LWNhcGFiaWxpdGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5kZWZhdWx0SG9zdENvbmZpZyA9IGV4cG9ydHMuSG9zdENvbmZpZyA9IGV4cG9ydHMuRm9udFR5cGVTZXQgPSBleHBvcnRzLkZvbnRUeXBlRGVmaW5pdGlvbiA9IGV4cG9ydHMuQ29udGFpbmVyU3R5bGVTZXQgPSBleHBvcnRzLkNvbnRhaW5lclN0eWxlRGVmaW5pdGlvbiA9IGV4cG9ydHMuQ29sb3JTZXREZWZpbml0aW9uID0gZXhwb3J0cy5BY3Rpb25zQ29uZmlnID0gZXhwb3J0cy5TaG93Q2FyZEFjdGlvbkNvbmZpZyA9IGV4cG9ydHMuRmFjdFNldENvbmZpZyA9IGV4cG9ydHMuRmFjdFRpdGxlRGVmaW5pdGlvbiA9IGV4cG9ydHMuRmFjdFRleHREZWZpbml0aW9uID0gZXhwb3J0cy5JbnB1dENvbmZpZyA9IGV4cG9ydHMuSW5wdXRMYWJlbENvbmZpZyA9IGV4cG9ydHMuUmVxdWlyZWRJbnB1dExhYmVsVGV4dERlZmluaXRpb24gPSBleHBvcnRzLlRleHRCbG9ja0NvbmZpZyA9IGV4cG9ydHMuVGV4dFN0eWxlU2V0ID0gZXhwb3J0cy5UZXh0U3R5bGVEZWZpbml0aW9uID0gZXhwb3J0cy5CYXNlVGV4dERlZmluaXRpb24gPSBleHBvcnRzLlRhYmxlQ29uZmlnID0gZXhwb3J0cy5NZWRpYUNvbmZpZyA9IGV4cG9ydHMuSW1hZ2VTZXRDb25maWcgPSBleHBvcnRzLkFkYXB0aXZlQ2FyZENvbmZpZyA9IGV4cG9ydHMuVGV4dENvbG9yRGVmaW5pdGlvbiA9IGV4cG9ydHMuQ29sb3JEZWZpbml0aW9uID0gdm9pZCAwO1xyXG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG52YXIgRW51bXMgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcclxudmFyIFV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XHJcbnZhciBTaGFyZWQgPSByZXF1aXJlKFwiLi9zaGFyZWRcIik7XHJcbnZhciBob3N0X2NhcGFiaWxpdGllc18xID0gcmVxdWlyZShcIi4vaG9zdC1jYXBhYmlsaXRpZXNcIik7XHJcbmZ1bmN0aW9uIHBhcnNlSG9zdENvbmZpZ0VudW0odGFyZ2V0RW51bSwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHZhciBwYXJzZWRWYWx1ZSA9IFV0aWxzLnBhcnNlRW51bSh0YXJnZXRFbnVtLCB2YWx1ZSwgZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICByZXR1cm4gcGFyc2VkVmFsdWUgIT09IHVuZGVmaW5lZCA/IHBhcnNlZFZhbHVlIDogZGVmYXVsdFZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxuICAgIH1cclxufVxyXG52YXIgQ29sb3JEZWZpbml0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29sb3JEZWZpbml0aW9uKGRlZmF1bHRDb2xvciwgc3VidGxlQ29sb3IpIHtcclxuICAgICAgICB0aGlzLmRlZmF1bHQgPSBcIiMwMDAwMDBcIjtcclxuICAgICAgICB0aGlzLnN1YnRsZSA9IFwiIzY2NjY2NlwiO1xyXG4gICAgICAgIGlmIChkZWZhdWx0Q29sb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0ID0gZGVmYXVsdENvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3VidGxlQ29sb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5zdWJ0bGUgPSBzdWJ0bGVDb2xvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBDb2xvckRlZmluaXRpb24ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0ID0gb2JqW1wiZGVmYXVsdFwiXSB8fCB0aGlzLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgIHRoaXMuc3VidGxlID0gb2JqW1wic3VidGxlXCJdIHx8IHRoaXMuc3VidGxlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29sb3JEZWZpbml0aW9uO1xyXG59KCkpO1xyXG5leHBvcnRzLkNvbG9yRGVmaW5pdGlvbiA9IENvbG9yRGVmaW5pdGlvbjtcclxudmFyIFRleHRDb2xvckRlZmluaXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVGV4dENvbG9yRGVmaW5pdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRleHRDb2xvckRlZmluaXRpb24oKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuaGlnaGxpZ2h0Q29sb3JzID0gbmV3IENvbG9yRGVmaW5pdGlvbihcIiMyMjAwMDAwMFwiLCBcIiMxMTAwMDAwMFwiKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBUZXh0Q29sb3JEZWZpbml0aW9uLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnBhcnNlLmNhbGwodGhpcywgb2JqKTtcclxuICAgICAgICBpZiAob2JqKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0Q29sb3JzLnBhcnNlKG9ialtcImhpZ2hsaWdodENvbG9yc1wiXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBUZXh0Q29sb3JEZWZpbml0aW9uO1xyXG59KENvbG9yRGVmaW5pdGlvbikpO1xyXG5leHBvcnRzLlRleHRDb2xvckRlZmluaXRpb24gPSBUZXh0Q29sb3JEZWZpbml0aW9uO1xyXG52YXIgQWRhcHRpdmVDYXJkQ29uZmlnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQWRhcHRpdmVDYXJkQ29uZmlnKG9iaikge1xyXG4gICAgICAgIHRoaXMuYWxsb3dDdXN0b21TdHlsZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgdGhpcy5hbGxvd0N1c3RvbVN0eWxlID0gb2JqW1wiYWxsb3dDdXN0b21TdHlsZVwiXSB8fCB0aGlzLmFsbG93Q3VzdG9tU3R5bGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIEFkYXB0aXZlQ2FyZENvbmZpZztcclxufSgpKTtcclxuZXhwb3J0cy5BZGFwdGl2ZUNhcmRDb25maWcgPSBBZGFwdGl2ZUNhcmRDb25maWc7XHJcbnZhciBJbWFnZVNldENvbmZpZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEltYWdlU2V0Q29uZmlnKG9iaikge1xyXG4gICAgICAgIHRoaXMuaW1hZ2VTaXplID0gRW51bXMuU2l6ZS5NZWRpdW07XHJcbiAgICAgICAgdGhpcy5tYXhJbWFnZUhlaWdodCA9IDEwMDtcclxuICAgICAgICBpZiAob2JqKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VTaXplID0gb2JqW1wiaW1hZ2VTaXplXCJdICE9IG51bGwgPyBvYmpbXCJpbWFnZVNpemVcIl0gOiB0aGlzLmltYWdlU2l6ZTtcclxuICAgICAgICAgICAgdGhpcy5tYXhJbWFnZUhlaWdodCA9IFV0aWxzLnBhcnNlTnVtYmVyKG9ialtcIm1heEltYWdlSGVpZ2h0XCJdLCAxMDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEltYWdlU2V0Q29uZmlnLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaW1hZ2VTaXplOiBFbnVtcy5TaXplW3RoaXMuaW1hZ2VTaXplXSxcclxuICAgICAgICAgICAgbWF4SW1hZ2VIZWlnaHQ6IHRoaXMubWF4SW1hZ2VIZWlnaHRcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBJbWFnZVNldENvbmZpZztcclxufSgpKTtcclxuZXhwb3J0cy5JbWFnZVNldENvbmZpZyA9IEltYWdlU2V0Q29uZmlnO1xyXG52YXIgTWVkaWFDb25maWcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNZWRpYUNvbmZpZyhvYmopIHtcclxuICAgICAgICB0aGlzLmFsbG93SW5saW5lUGxheWJhY2sgPSB0cnVlO1xyXG4gICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0UG9zdGVyID0gb2JqW1wiZGVmYXVsdFBvc3RlclwiXTtcclxuICAgICAgICAgICAgdGhpcy5hbGxvd0lubGluZVBsYXliYWNrID0gb2JqW1wiYWxsb3dJbmxpbmVQbGF5YmFja1wiXSB8fCB0aGlzLmFsbG93SW5saW5lUGxheWJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgTWVkaWFDb25maWcucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkZWZhdWx0UG9zdGVyOiB0aGlzLmRlZmF1bHRQb3N0ZXIsXHJcbiAgICAgICAgICAgIGFsbG93SW5saW5lUGxheWJhY2s6IHRoaXMuYWxsb3dJbmxpbmVQbGF5YmFja1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1lZGlhQ29uZmlnO1xyXG59KCkpO1xyXG5leHBvcnRzLk1lZGlhQ29uZmlnID0gTWVkaWFDb25maWc7XHJcbnZhciBUYWJsZUNvbmZpZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRhYmxlQ29uZmlnKG9iaikge1xyXG4gICAgICAgIHRoaXMuY2VsbFNwYWNpbmcgPSA4O1xyXG4gICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgdGhpcy5jZWxsU3BhY2luZyA9XHJcbiAgICAgICAgICAgICAgICBvYmouY2VsbFNwYWNpbmcgJiYgdHlwZW9mIG9iai5jZWxsU3BhY2luZyA9PT0gXCJudW1iZXJcIlxyXG4gICAgICAgICAgICAgICAgICAgID8gb2JqLmNlbGxTcGFjaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmNlbGxTcGFjaW5nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFRhYmxlQ29uZmlnLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY2VsbFNwYWNpbmc6IHRoaXMuY2VsbFNwYWNpbmdcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUYWJsZUNvbmZpZztcclxufSgpKTtcclxuZXhwb3J0cy5UYWJsZUNvbmZpZyA9IFRhYmxlQ29uZmlnO1xyXG52YXIgQmFzZVRleHREZWZpbml0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQmFzZVRleHREZWZpbml0aW9uKG9iaikge1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IEVudW1zLlRleHRTaXplLkRlZmF1bHQ7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IEVudW1zLlRleHRDb2xvci5EZWZhdWx0O1xyXG4gICAgICAgIHRoaXMuaXNTdWJ0bGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLndlaWdodCA9IEVudW1zLlRleHRXZWlnaHQuRGVmYXVsdDtcclxuICAgICAgICB0aGlzLnBhcnNlKG9iaik7XHJcbiAgICB9XHJcbiAgICBCYXNlVGV4dERlZmluaXRpb24ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgdGhpcy5zaXplID0gcGFyc2VIb3N0Q29uZmlnRW51bShFbnVtcy5UZXh0U2l6ZSwgb2JqW1wic2l6ZVwiXSwgdGhpcy5zaXplKTtcclxuICAgICAgICAgICAgdGhpcy5jb2xvciA9IHBhcnNlSG9zdENvbmZpZ0VudW0oRW51bXMuVGV4dENvbG9yLCBvYmpbXCJjb2xvclwiXSwgdGhpcy5jb2xvcik7XHJcbiAgICAgICAgICAgIHRoaXMuaXNTdWJ0bGUgPVxyXG4gICAgICAgICAgICAgICAgb2JqLmlzU3VidGxlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9iai5pc1N1YnRsZSA9PT0gXCJib29sZWFuXCJcclxuICAgICAgICAgICAgICAgICAgICA/IG9iai5pc1N1YnRsZVxyXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5pc1N1YnRsZTtcclxuICAgICAgICAgICAgdGhpcy53ZWlnaHQgPSBwYXJzZUhvc3RDb25maWdFbnVtKEVudW1zLlRleHRXZWlnaHQsIG9ialtcIndlaWdodFwiXSwgdGhpcy5nZXREZWZhdWx0V2VpZ2h0KCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCYXNlVGV4dERlZmluaXRpb24ucHJvdG90eXBlLmdldERlZmF1bHRXZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIEVudW1zLlRleHRXZWlnaHQuRGVmYXVsdDtcclxuICAgIH07XHJcbiAgICBCYXNlVGV4dERlZmluaXRpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzaXplOiBFbnVtcy5UZXh0U2l6ZVt0aGlzLnNpemVdLFxyXG4gICAgICAgICAgICBjb2xvcjogRW51bXMuVGV4dENvbG9yW3RoaXMuY29sb3JdLFxyXG4gICAgICAgICAgICBpc1N1YnRsZTogdGhpcy5pc1N1YnRsZSxcclxuICAgICAgICAgICAgd2VpZ2h0OiBFbnVtcy5UZXh0V2VpZ2h0W3RoaXMud2VpZ2h0XVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJhc2VUZXh0RGVmaW5pdGlvbjtcclxufSgpKTtcclxuZXhwb3J0cy5CYXNlVGV4dERlZmluaXRpb24gPSBCYXNlVGV4dERlZmluaXRpb247XHJcbnZhciBUZXh0U3R5bGVEZWZpbml0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFRleHRTdHlsZURlZmluaXRpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUZXh0U3R5bGVEZWZpbml0aW9uKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmZvbnRUeXBlID0gRW51bXMuRm9udFR5cGUuRGVmYXVsdDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBUZXh0U3R5bGVEZWZpbml0aW9uLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnBhcnNlLmNhbGwodGhpcywgb2JqKTtcclxuICAgICAgICBpZiAob2JqKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9udFR5cGUgPSBwYXJzZUhvc3RDb25maWdFbnVtKEVudW1zLkZvbnRUeXBlLCBvYmouZm9udFR5cGUsIHRoaXMuZm9udFR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gVGV4dFN0eWxlRGVmaW5pdGlvbjtcclxufShCYXNlVGV4dERlZmluaXRpb24pKTtcclxuZXhwb3J0cy5UZXh0U3R5bGVEZWZpbml0aW9uID0gVGV4dFN0eWxlRGVmaW5pdGlvbjtcclxudmFyIFRleHRTdHlsZVNldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRleHRTdHlsZVNldChvYmopIHtcclxuICAgICAgICB0aGlzLmRlZmF1bHQgPSBuZXcgVGV4dFN0eWxlRGVmaW5pdGlvbigpO1xyXG4gICAgICAgIHRoaXMuaGVhZGluZyA9IG5ldyBUZXh0U3R5bGVEZWZpbml0aW9uKHtcclxuICAgICAgICAgICAgc2l6ZTogXCJMYXJnZVwiLFxyXG4gICAgICAgICAgICB3ZWlnaHQ6IFwiQm9sZGVyXCJcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNvbHVtbkhlYWRlciA9IG5ldyBUZXh0U3R5bGVEZWZpbml0aW9uKHtcclxuICAgICAgICAgICAgd2VpZ2h0OiBcIkJvbGRlclwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKG9iaikge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRpbmcucGFyc2Uob2JqLmhlYWRpbmcpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlci5wYXJzZShvYmouY29sdW1uSGVhZGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBUZXh0U3R5bGVTZXQucHJvdG90eXBlLmdldFN0eWxlQnlOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBzd2l0Y2ggKG5hbWUudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiaGVhZGluZ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGluZztcclxuICAgICAgICAgICAgY2FzZSBcImNvbHVtbkhlYWRlclwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRleHRTdHlsZVNldDtcclxufSgpKTtcclxuZXhwb3J0cy5UZXh0U3R5bGVTZXQgPSBUZXh0U3R5bGVTZXQ7XHJcbnZhciBUZXh0QmxvY2tDb25maWcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUZXh0QmxvY2tDb25maWcob2JqKSB7XHJcbiAgICAgICAgaWYgKG9iaikge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRpbmdMZXZlbCA9IFV0aWxzLnBhcnNlTnVtYmVyKG9iai5oZWFkaW5nTGV2ZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBUZXh0QmxvY2tDb25maWc7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVGV4dEJsb2NrQ29uZmlnID0gVGV4dEJsb2NrQ29uZmlnO1xyXG52YXIgUmVxdWlyZWRJbnB1dExhYmVsVGV4dERlZmluaXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUmVxdWlyZWRJbnB1dExhYmVsVGV4dERlZmluaXRpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSZXF1aXJlZElucHV0TGFiZWxUZXh0RGVmaW5pdGlvbigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5zdWZmaXggPSBcIiAqXCI7XHJcbiAgICAgICAgX3RoaXMuc3VmZml4Q29sb3IgPSBFbnVtcy5UZXh0Q29sb3IuQXR0ZW50aW9uO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFJlcXVpcmVkSW5wdXRMYWJlbFRleHREZWZpbml0aW9uLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnBhcnNlLmNhbGwodGhpcywgb2JqKTtcclxuICAgICAgICBpZiAob2JqKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3VmZml4ID0gb2JqW1wic3VmZml4XCJdIHx8IHRoaXMuc3VmZml4O1xyXG4gICAgICAgICAgICB0aGlzLnN1ZmZpeENvbG9yID0gcGFyc2VIb3N0Q29uZmlnRW51bShFbnVtcy5UZXh0Q29sb3IsIG9ialtcInN1ZmZpeENvbG9yXCJdLCB0aGlzLnN1ZmZpeENvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVxdWlyZWRJbnB1dExhYmVsVGV4dERlZmluaXRpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzKTtcclxuICAgICAgICByZXN1bHRbXCJzdWZmaXhcIl0gPSB0aGlzLnN1ZmZpeDtcclxuICAgICAgICByZXN1bHRbXCJzdWZmaXhDb2xvclwiXSA9IEVudW1zLlRleHRDb2xvclt0aGlzLnN1ZmZpeENvbG9yXTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZXF1aXJlZElucHV0TGFiZWxUZXh0RGVmaW5pdGlvbjtcclxufShCYXNlVGV4dERlZmluaXRpb24pKTtcclxuZXhwb3J0cy5SZXF1aXJlZElucHV0TGFiZWxUZXh0RGVmaW5pdGlvbiA9IFJlcXVpcmVkSW5wdXRMYWJlbFRleHREZWZpbml0aW9uO1xyXG52YXIgSW5wdXRMYWJlbENvbmZpZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIElucHV0TGFiZWxDb25maWcob2JqKSB7XHJcbiAgICAgICAgdGhpcy5pbnB1dFNwYWNpbmcgPSBFbnVtcy5TcGFjaW5nLlNtYWxsO1xyXG4gICAgICAgIHRoaXMucmVxdWlyZWRJbnB1dHMgPSBuZXcgUmVxdWlyZWRJbnB1dExhYmVsVGV4dERlZmluaXRpb24oKTtcclxuICAgICAgICB0aGlzLm9wdGlvbmFsSW5wdXRzID0gbmV3IEJhc2VUZXh0RGVmaW5pdGlvbigpO1xyXG4gICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dFNwYWNpbmcgPSBwYXJzZUhvc3RDb25maWdFbnVtKEVudW1zLlNwYWNpbmcsIG9ialtcImlucHV0U3BhY2luZ1wiXSwgdGhpcy5pbnB1dFNwYWNpbmcpO1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVkSW5wdXRzID0gbmV3IFJlcXVpcmVkSW5wdXRMYWJlbFRleHREZWZpbml0aW9uKG9ialtcInJlcXVpcmVkSW5wdXRzXCJdKTtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25hbElucHV0cyA9IG5ldyBCYXNlVGV4dERlZmluaXRpb24ob2JqW1wib3B0aW9uYWxJbnB1dHNcIl0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBJbnB1dExhYmVsQ29uZmlnO1xyXG59KCkpO1xyXG5leHBvcnRzLklucHV0TGFiZWxDb25maWcgPSBJbnB1dExhYmVsQ29uZmlnO1xyXG52YXIgSW5wdXRDb25maWcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJbnB1dENvbmZpZyhvYmopIHtcclxuICAgICAgICB0aGlzLmxhYmVsID0gbmV3IElucHV0TGFiZWxDb25maWcoKTtcclxuICAgICAgICB0aGlzLmVycm9yTWVzc2FnZSA9IG5ldyBCYXNlVGV4dERlZmluaXRpb24oe1xyXG4gICAgICAgICAgICBjb2xvcjogRW51bXMuVGV4dENvbG9yLkF0dGVudGlvblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgdGhpcy5sYWJlbCA9IG5ldyBJbnB1dExhYmVsQ29uZmlnKG9ialtcImxhYmVsXCJdKTtcclxuICAgICAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UgPSBuZXcgQmFzZVRleHREZWZpbml0aW9uKG9ialtcImVycm9yTWVzc2FnZVwiXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIElucHV0Q29uZmlnO1xyXG59KCkpO1xyXG5leHBvcnRzLklucHV0Q29uZmlnID0gSW5wdXRDb25maWc7XHJcbnZhciBGYWN0VGV4dERlZmluaXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRmFjdFRleHREZWZpbml0aW9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRmFjdFRleHREZWZpbml0aW9uKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLndyYXAgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEZhY3RUZXh0RGVmaW5pdGlvbi5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5wYXJzZS5jYWxsKHRoaXMsIG9iaik7XHJcbiAgICAgICAgaWYgKG9iaikge1xyXG4gICAgICAgICAgICB0aGlzLndyYXAgPSBvYmpbXCJ3cmFwXCJdICE9IG51bGwgPyBvYmpbXCJ3cmFwXCJdIDogdGhpcy53cmFwO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBGYWN0VGV4dERlZmluaXRpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzKTtcclxuICAgICAgICByZXN1bHRbXCJ3cmFwXCJdID0gdGhpcy53cmFwO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZhY3RUZXh0RGVmaW5pdGlvbjtcclxufShCYXNlVGV4dERlZmluaXRpb24pKTtcclxuZXhwb3J0cy5GYWN0VGV4dERlZmluaXRpb24gPSBGYWN0VGV4dERlZmluaXRpb247XHJcbnZhciBGYWN0VGl0bGVEZWZpbml0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEZhY3RUaXRsZURlZmluaXRpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGYWN0VGl0bGVEZWZpbml0aW9uKG9iaikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9iaikgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5tYXhXaWR0aCA9IDE1MDtcclxuICAgICAgICBfdGhpcy53ZWlnaHQgPSBFbnVtcy5UZXh0V2VpZ2h0LkJvbGRlcjtcclxuICAgICAgICBpZiAob2JqKSB7XHJcbiAgICAgICAgICAgIF90aGlzLm1heFdpZHRoID0gb2JqW1wibWF4V2lkdGhcIl0gIT0gbnVsbCA/IG9ialtcIm1heFdpZHRoXCJdIDogX3RoaXMubWF4V2lkdGg7XHJcbiAgICAgICAgICAgIF90aGlzLndlaWdodCA9IHBhcnNlSG9zdENvbmZpZ0VudW0oRW51bXMuVGV4dFdlaWdodCwgb2JqW1wid2VpZ2h0XCJdLCBFbnVtcy5UZXh0V2VpZ2h0LkJvbGRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEZhY3RUaXRsZURlZmluaXRpb24ucHJvdG90eXBlLmdldERlZmF1bHRXZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIEVudW1zLlRleHRXZWlnaHQuQm9sZGVyO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGYWN0VGl0bGVEZWZpbml0aW9uO1xyXG59KEZhY3RUZXh0RGVmaW5pdGlvbikpO1xyXG5leHBvcnRzLkZhY3RUaXRsZURlZmluaXRpb24gPSBGYWN0VGl0bGVEZWZpbml0aW9uO1xyXG52YXIgRmFjdFNldENvbmZpZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEZhY3RTZXRDb25maWcob2JqKSB7XHJcbiAgICAgICAgdGhpcy50aXRsZSA9IG5ldyBGYWN0VGl0bGVEZWZpbml0aW9uKCk7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IG5ldyBGYWN0VGV4dERlZmluaXRpb24oKTtcclxuICAgICAgICB0aGlzLnNwYWNpbmcgPSAxMDtcclxuICAgICAgICBpZiAob2JqKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGl0bGUgPSBuZXcgRmFjdFRpdGxlRGVmaW5pdGlvbihvYmpbXCJ0aXRsZVwiXSk7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBuZXcgRmFjdFRleHREZWZpbml0aW9uKG9ialtcInZhbHVlXCJdKTtcclxuICAgICAgICAgICAgdGhpcy5zcGFjaW5nID1cclxuICAgICAgICAgICAgICAgIG9iai5zcGFjaW5nICYmIG9iai5zcGFjaW5nICE9IG51bGwgPyBvYmouc3BhY2luZyAmJiBvYmouc3BhY2luZyA6IHRoaXMuc3BhY2luZztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRmFjdFNldENvbmZpZztcclxufSgpKTtcclxuZXhwb3J0cy5GYWN0U2V0Q29uZmlnID0gRmFjdFNldENvbmZpZztcclxudmFyIFNob3dDYXJkQWN0aW9uQ29uZmlnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2hvd0NhcmRBY3Rpb25Db25maWcob2JqKSB7XHJcbiAgICAgICAgdGhpcy5hY3Rpb25Nb2RlID0gRW51bXMuU2hvd0NhcmRBY3Rpb25Nb2RlLklubGluZTtcclxuICAgICAgICB0aGlzLmlubGluZVRvcE1hcmdpbiA9IDE2O1xyXG4gICAgICAgIHRoaXMuc3R5bGUgPSBFbnVtcy5Db250YWluZXJTdHlsZS5FbXBoYXNpcztcclxuICAgICAgICBpZiAob2JqKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uTW9kZSA9IHBhcnNlSG9zdENvbmZpZ0VudW0oRW51bXMuU2hvd0NhcmRBY3Rpb25Nb2RlLCBvYmpbXCJhY3Rpb25Nb2RlXCJdLCBFbnVtcy5TaG93Q2FyZEFjdGlvbk1vZGUuSW5saW5lKTtcclxuICAgICAgICAgICAgdGhpcy5pbmxpbmVUb3BNYXJnaW4gPVxyXG4gICAgICAgICAgICAgICAgb2JqW1wiaW5saW5lVG9wTWFyZ2luXCJdICE9IG51bGwgPyBvYmpbXCJpbmxpbmVUb3BNYXJnaW5cIl0gOiB0aGlzLmlubGluZVRvcE1hcmdpbjtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZSA9XHJcbiAgICAgICAgICAgICAgICBvYmpbXCJzdHlsZVwiXSAmJiB0eXBlb2Ygb2JqW1wic3R5bGVcIl0gPT09IFwic3RyaW5nXCJcclxuICAgICAgICAgICAgICAgICAgICA/IG9ialtcInN0eWxlXCJdXHJcbiAgICAgICAgICAgICAgICAgICAgOiBFbnVtcy5Db250YWluZXJTdHlsZS5FbXBoYXNpcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBTaG93Q2FyZEFjdGlvbkNvbmZpZy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGFjdGlvbk1vZGU6IEVudW1zLlNob3dDYXJkQWN0aW9uTW9kZVt0aGlzLmFjdGlvbk1vZGVdLFxyXG4gICAgICAgICAgICBpbmxpbmVUb3BNYXJnaW46IHRoaXMuaW5saW5lVG9wTWFyZ2luLFxyXG4gICAgICAgICAgICBzdHlsZTogdGhpcy5zdHlsZVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNob3dDYXJkQWN0aW9uQ29uZmlnO1xyXG59KCkpO1xyXG5leHBvcnRzLlNob3dDYXJkQWN0aW9uQ29uZmlnID0gU2hvd0NhcmRBY3Rpb25Db25maWc7XHJcbnZhciBBY3Rpb25zQ29uZmlnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQWN0aW9uc0NvbmZpZyhvYmopIHtcclxuICAgICAgICB0aGlzLm1heEFjdGlvbnMgPSA1O1xyXG4gICAgICAgIHRoaXMuc3BhY2luZyA9IEVudW1zLlNwYWNpbmcuRGVmYXVsdDtcclxuICAgICAgICB0aGlzLmJ1dHRvblNwYWNpbmcgPSAyMDtcclxuICAgICAgICB0aGlzLnNob3dDYXJkID0gbmV3IFNob3dDYXJkQWN0aW9uQ29uZmlnKCk7XHJcbiAgICAgICAgdGhpcy5wcmVFeHBhbmRTaW5nbGVTaG93Q2FyZEFjdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYWN0aW9uc09yaWVudGF0aW9uID0gRW51bXMuT3JpZW50YXRpb24uSG9yaXpvbnRhbDtcclxuICAgICAgICB0aGlzLmFjdGlvbkFsaWdubWVudCA9IEVudW1zLkFjdGlvbkFsaWdubWVudC5MZWZ0O1xyXG4gICAgICAgIHRoaXMuaWNvblBsYWNlbWVudCA9IEVudW1zLkFjdGlvbkljb25QbGFjZW1lbnQuTGVmdE9mVGl0bGU7XHJcbiAgICAgICAgdGhpcy5hbGxvd1RpdGxlVG9XcmFwID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pY29uU2l6ZSA9IDE2O1xyXG4gICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgdGhpcy5tYXhBY3Rpb25zID0gb2JqW1wibWF4QWN0aW9uc1wiXSAhPSBudWxsID8gb2JqW1wibWF4QWN0aW9uc1wiXSA6IHRoaXMubWF4QWN0aW9ucztcclxuICAgICAgICAgICAgdGhpcy5zcGFjaW5nID0gcGFyc2VIb3N0Q29uZmlnRW51bShFbnVtcy5TcGFjaW5nLCBvYmouc3BhY2luZyAmJiBvYmouc3BhY2luZywgRW51bXMuU3BhY2luZy5EZWZhdWx0KTtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25TcGFjaW5nID1cclxuICAgICAgICAgICAgICAgIG9ialtcImJ1dHRvblNwYWNpbmdcIl0gIT0gbnVsbCA/IG9ialtcImJ1dHRvblNwYWNpbmdcIl0gOiB0aGlzLmJ1dHRvblNwYWNpbmc7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd0NhcmQgPSBuZXcgU2hvd0NhcmRBY3Rpb25Db25maWcob2JqW1wic2hvd0NhcmRcIl0pO1xyXG4gICAgICAgICAgICB0aGlzLnByZUV4cGFuZFNpbmdsZVNob3dDYXJkQWN0aW9uID0gVXRpbHMucGFyc2VCb29sKG9ialtcInByZUV4cGFuZFNpbmdsZVNob3dDYXJkQWN0aW9uXCJdLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uc09yaWVudGF0aW9uID0gcGFyc2VIb3N0Q29uZmlnRW51bShFbnVtcy5PcmllbnRhdGlvbiwgb2JqW1wiYWN0aW9uc09yaWVudGF0aW9uXCJdLCBFbnVtcy5PcmllbnRhdGlvbi5Ib3Jpem9udGFsKTtcclxuICAgICAgICAgICAgdGhpcy5hY3Rpb25BbGlnbm1lbnQgPSBwYXJzZUhvc3RDb25maWdFbnVtKEVudW1zLkFjdGlvbkFsaWdubWVudCwgb2JqW1wiYWN0aW9uQWxpZ25tZW50XCJdLCBFbnVtcy5BY3Rpb25BbGlnbm1lbnQuTGVmdCk7XHJcbiAgICAgICAgICAgIHRoaXMuaWNvblBsYWNlbWVudCA9IHBhcnNlSG9zdENvbmZpZ0VudW0oRW51bXMuQWN0aW9uSWNvblBsYWNlbWVudCwgb2JqW1wiaWNvblBsYWNlbWVudFwiXSwgRW51bXMuQWN0aW9uSWNvblBsYWNlbWVudC5MZWZ0T2ZUaXRsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWxsb3dUaXRsZVRvV3JhcCA9XHJcbiAgICAgICAgICAgICAgICBvYmpbXCJhbGxvd1RpdGxlVG9XcmFwXCJdICE9IG51bGwgPyBvYmpbXCJhbGxvd1RpdGxlVG9XcmFwXCJdIDogdGhpcy5hbGxvd1RpdGxlVG9XcmFwO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpemVBbmRVbml0ID0gU2hhcmVkLlNpemVBbmRVbml0LnBhcnNlKG9ialtcImljb25TaXplXCJdKTtcclxuICAgICAgICAgICAgICAgIGlmIChzaXplQW5kVW5pdC51bml0ID09PSBFbnVtcy5TaXplVW5pdC5QaXhlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWNvblNpemUgPSBzaXplQW5kVW5pdC5waHlzaWNhbFNpemU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFN3YWxsb3cgdGhpcywga2VlcCBkZWZhdWx0IGljb24gc2l6ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgQWN0aW9uc0NvbmZpZy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1heEFjdGlvbnM6IHRoaXMubWF4QWN0aW9ucyxcclxuICAgICAgICAgICAgc3BhY2luZzogRW51bXMuU3BhY2luZ1t0aGlzLnNwYWNpbmddLFxyXG4gICAgICAgICAgICBidXR0b25TcGFjaW5nOiB0aGlzLmJ1dHRvblNwYWNpbmcsXHJcbiAgICAgICAgICAgIHNob3dDYXJkOiB0aGlzLnNob3dDYXJkLFxyXG4gICAgICAgICAgICBwcmVFeHBhbmRTaW5nbGVTaG93Q2FyZEFjdGlvbjogdGhpcy5wcmVFeHBhbmRTaW5nbGVTaG93Q2FyZEFjdGlvbixcclxuICAgICAgICAgICAgYWN0aW9uc09yaWVudGF0aW9uOiBFbnVtcy5PcmllbnRhdGlvblt0aGlzLmFjdGlvbnNPcmllbnRhdGlvbl0sXHJcbiAgICAgICAgICAgIGFjdGlvbkFsaWdubWVudDogRW51bXMuQWN0aW9uQWxpZ25tZW50W3RoaXMuYWN0aW9uQWxpZ25tZW50XVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFjdGlvbnNDb25maWc7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQWN0aW9uc0NvbmZpZyA9IEFjdGlvbnNDb25maWc7XHJcbnZhciBDb2xvclNldERlZmluaXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb2xvclNldERlZmluaXRpb24ob2JqKSB7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gbmV3IFRleHRDb2xvckRlZmluaXRpb24oKTtcclxuICAgICAgICB0aGlzLmRhcmsgPSBuZXcgVGV4dENvbG9yRGVmaW5pdGlvbigpO1xyXG4gICAgICAgIHRoaXMubGlnaHQgPSBuZXcgVGV4dENvbG9yRGVmaW5pdGlvbigpO1xyXG4gICAgICAgIHRoaXMuYWNjZW50ID0gbmV3IFRleHRDb2xvckRlZmluaXRpb24oKTtcclxuICAgICAgICB0aGlzLmdvb2QgPSBuZXcgVGV4dENvbG9yRGVmaW5pdGlvbigpO1xyXG4gICAgICAgIHRoaXMud2FybmluZyA9IG5ldyBUZXh0Q29sb3JEZWZpbml0aW9uKCk7XHJcbiAgICAgICAgdGhpcy5hdHRlbnRpb24gPSBuZXcgVGV4dENvbG9yRGVmaW5pdGlvbigpO1xyXG4gICAgICAgIHRoaXMucGFyc2Uob2JqKTtcclxuICAgIH1cclxuICAgIENvbG9yU2V0RGVmaW5pdGlvbi5wcm90b3R5cGUucGFyc2VTaW5nbGVDb2xvciA9IGZ1bmN0aW9uIChvYmosIHByb3BlcnR5TmFtZSkge1xyXG4gICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdLnBhcnNlKG9ialtwcm9wZXJ0eU5hbWVdKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29sb3JTZXREZWZpbml0aW9uLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICBpZiAob2JqKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyc2VTaW5nbGVDb2xvcihvYmosIFwiZGVmYXVsdFwiKTtcclxuICAgICAgICAgICAgdGhpcy5wYXJzZVNpbmdsZUNvbG9yKG9iaiwgXCJkYXJrXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnBhcnNlU2luZ2xlQ29sb3Iob2JqLCBcImxpZ2h0XCIpO1xyXG4gICAgICAgICAgICB0aGlzLnBhcnNlU2luZ2xlQ29sb3Iob2JqLCBcImFjY2VudFwiKTtcclxuICAgICAgICAgICAgdGhpcy5wYXJzZVNpbmdsZUNvbG9yKG9iaiwgXCJnb29kXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnBhcnNlU2luZ2xlQ29sb3Iob2JqLCBcIndhcm5pbmdcIik7XHJcbiAgICAgICAgICAgIHRoaXMucGFyc2VTaW5nbGVDb2xvcihvYmosIFwiYXR0ZW50aW9uXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29sb3JTZXREZWZpbml0aW9uO1xyXG59KCkpO1xyXG5leHBvcnRzLkNvbG9yU2V0RGVmaW5pdGlvbiA9IENvbG9yU2V0RGVmaW5pdGlvbjtcclxudmFyIENvbnRhaW5lclN0eWxlRGVmaW5pdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbnRhaW5lclN0eWxlRGVmaW5pdGlvbihvYmopIHtcclxuICAgICAgICB0aGlzLmZvcmVncm91bmRDb2xvcnMgPSBuZXcgQ29sb3JTZXREZWZpbml0aW9uKHtcclxuICAgICAgICAgICAgXCJkZWZhdWx0XCI6IHsgZGVmYXVsdDogXCIjMzMzMzMzXCIsIHN1YnRsZTogXCIjRUUzMzMzMzNcIiB9LFxyXG4gICAgICAgICAgICBcImRhcmtcIjogeyBkZWZhdWx0OiBcIiMwMDAwMDBcIiwgc3VidGxlOiBcIiM2NjAwMDAwMFwiIH0sXHJcbiAgICAgICAgICAgIFwibGlnaHRcIjogeyBkZWZhdWx0OiBcIiNGRkZGRkZcIiwgc3VidGxlOiBcIiMzMzAwMDAwMFwiIH0sXHJcbiAgICAgICAgICAgIFwiYWNjZW50XCI6IHsgZGVmYXVsdDogXCIjMkU4OUZDXCIsIHN1YnRsZTogXCIjODgyRTg5RkNcIiB9LFxyXG4gICAgICAgICAgICBcImdvb2RcIjogeyBkZWZhdWx0OiBcIiMwMjhBMDJcIiwgc3VidGxlOiBcIiNERDAyNzUwMlwiIH0sXHJcbiAgICAgICAgICAgIFwid2FybmluZ1wiOiB7IGRlZmF1bHQ6IFwiI0U2OTUwMFwiLCBzdWJ0bGU6IFwiI0RERTY5NTAwXCIgfSxcclxuICAgICAgICAgICAgXCJhdHRlbnRpb25cIjogeyBkZWZhdWx0OiBcIiNDQzMzMDBcIiwgc3VidGxlOiBcIiNERENDMzMwMFwiIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnBhcnNlKG9iaik7XHJcbiAgICB9XHJcbiAgICBDb250YWluZXJTdHlsZURlZmluaXRpb24ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBvYmpbXCJiYWNrZ3JvdW5kQ29sb3JcIl07XHJcbiAgICAgICAgICAgIHRoaXMuZm9yZWdyb3VuZENvbG9ycy5wYXJzZShvYmpbXCJmb3JlZ3JvdW5kQ29sb3JzXCJdKTtcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRCYWNrZ3JvdW5kQ29sb3IgPSBvYmpbXCJoaWdobGlnaHRCYWNrZ3JvdW5kQ29sb3JcIl07XHJcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0Rm9yZWdyb3VuZENvbG9yID0gb2JqW1wiaGlnaGxpZ2h0Rm9yZWdyb3VuZENvbG9yXCJdO1xyXG4gICAgICAgICAgICB0aGlzLmJvcmRlckNvbG9yID0gb2JqW1wiYm9yZGVyQ29sb3JcIl07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250YWluZXJTdHlsZURlZmluaXRpb24ucHJvdG90eXBlLCBcImlzQnVpbHRJblwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gQ29udGFpbmVyU3R5bGVEZWZpbml0aW9uO1xyXG59KCkpO1xyXG5leHBvcnRzLkNvbnRhaW5lclN0eWxlRGVmaW5pdGlvbiA9IENvbnRhaW5lclN0eWxlRGVmaW5pdGlvbjtcclxudmFyIEJ1aWx0SW5Db250YWluZXJTdHlsZURlZmluaXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQnVpbHRJbkNvbnRhaW5lclN0eWxlRGVmaW5pdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJ1aWx0SW5Db250YWluZXJTdHlsZURlZmluaXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1aWx0SW5Db250YWluZXJTdHlsZURlZmluaXRpb24ucHJvdG90eXBlLCBcImlzQnVpbHRJblwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBCdWlsdEluQ29udGFpbmVyU3R5bGVEZWZpbml0aW9uO1xyXG59KENvbnRhaW5lclN0eWxlRGVmaW5pdGlvbikpO1xyXG52YXIgQ29udGFpbmVyU3R5bGVTZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb250YWluZXJTdHlsZVNldChvYmopIHtcclxuICAgICAgICB0aGlzLl9hbGxTdHlsZXMgPSB7fTtcclxuICAgICAgICB0aGlzLl9hbGxTdHlsZXNbRW51bXMuQ29udGFpbmVyU3R5bGUuRGVmYXVsdF0gPSBuZXcgQnVpbHRJbkNvbnRhaW5lclN0eWxlRGVmaW5pdGlvbigpO1xyXG4gICAgICAgIHRoaXMuX2FsbFN0eWxlc1tFbnVtcy5Db250YWluZXJTdHlsZS5FbXBoYXNpc10gPSBuZXcgQnVpbHRJbkNvbnRhaW5lclN0eWxlRGVmaW5pdGlvbigpO1xyXG4gICAgICAgIHRoaXMuX2FsbFN0eWxlc1tFbnVtcy5Db250YWluZXJTdHlsZS5BY2NlbnRdID0gbmV3IEJ1aWx0SW5Db250YWluZXJTdHlsZURlZmluaXRpb24oKTtcclxuICAgICAgICB0aGlzLl9hbGxTdHlsZXNbRW51bXMuQ29udGFpbmVyU3R5bGUuR29vZF0gPSBuZXcgQnVpbHRJbkNvbnRhaW5lclN0eWxlRGVmaW5pdGlvbigpO1xyXG4gICAgICAgIHRoaXMuX2FsbFN0eWxlc1tFbnVtcy5Db250YWluZXJTdHlsZS5BdHRlbnRpb25dID0gbmV3IEJ1aWx0SW5Db250YWluZXJTdHlsZURlZmluaXRpb24oKTtcclxuICAgICAgICB0aGlzLl9hbGxTdHlsZXNbRW51bXMuQ29udGFpbmVyU3R5bGUuV2FybmluZ10gPSBuZXcgQnVpbHRJbkNvbnRhaW5lclN0eWxlRGVmaW5pdGlvbigpO1xyXG4gICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgdGhpcy5fYWxsU3R5bGVzW0VudW1zLkNvbnRhaW5lclN0eWxlLkRlZmF1bHRdLnBhcnNlKG9ialtFbnVtcy5Db250YWluZXJTdHlsZS5EZWZhdWx0XSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FsbFN0eWxlc1tFbnVtcy5Db250YWluZXJTdHlsZS5FbXBoYXNpc10ucGFyc2Uob2JqW0VudW1zLkNvbnRhaW5lclN0eWxlLkVtcGhhc2lzXSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FsbFN0eWxlc1tFbnVtcy5Db250YWluZXJTdHlsZS5BY2NlbnRdLnBhcnNlKG9ialtFbnVtcy5Db250YWluZXJTdHlsZS5BY2NlbnRdKTtcclxuICAgICAgICAgICAgdGhpcy5fYWxsU3R5bGVzW0VudW1zLkNvbnRhaW5lclN0eWxlLkdvb2RdLnBhcnNlKG9ialtFbnVtcy5Db250YWluZXJTdHlsZS5Hb29kXSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FsbFN0eWxlc1tFbnVtcy5Db250YWluZXJTdHlsZS5BdHRlbnRpb25dLnBhcnNlKG9ialtFbnVtcy5Db250YWluZXJTdHlsZS5BdHRlbnRpb25dKTtcclxuICAgICAgICAgICAgdGhpcy5fYWxsU3R5bGVzW0VudW1zLkNvbnRhaW5lclN0eWxlLldhcm5pbmddLnBhcnNlKG9ialtFbnVtcy5Db250YWluZXJTdHlsZS5XYXJuaW5nXSk7XHJcbiAgICAgICAgICAgIHZhciBjdXN0b21TdHlsZUFycmF5ID0gb2JqW1wiY3VzdG9tU3R5bGVzXCJdO1xyXG4gICAgICAgICAgICBpZiAoY3VzdG9tU3R5bGVBcnJheSAmJiBBcnJheS5pc0FycmF5KGN1c3RvbVN0eWxlQXJyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGN1c3RvbVN0eWxlQXJyYXlfMSA9IGN1c3RvbVN0eWxlQXJyYXk7IF9pIDwgY3VzdG9tU3R5bGVBcnJheV8xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXN0b21TdHlsZSA9IGN1c3RvbVN0eWxlQXJyYXlfMVtfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1c3RvbVN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZU5hbWUgPSBjdXN0b21TdHlsZVtcIm5hbWVcIl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZU5hbWUgJiYgdHlwZW9mIHN0eWxlTmFtZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FsbFN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWxsU3R5bGVzW3N0eWxlTmFtZV0ucGFyc2UoY3VzdG9tU3R5bGVbXCJzdHlsZVwiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbGxTdHlsZXNbc3R5bGVOYW1lXSA9IG5ldyBDb250YWluZXJTdHlsZURlZmluaXRpb24oY3VzdG9tU3R5bGVbXCJzdHlsZVwiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBDb250YWluZXJTdHlsZVNldC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGN1c3RvbVN0eWxlQXJyYXkgPSBbXTtcclxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9hbGxTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAoIV90aGlzLl9hbGxTdHlsZXNba2V5XS5pc0J1aWx0SW4pIHtcclxuICAgICAgICAgICAgICAgIGN1c3RvbVN0eWxlQXJyYXkucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZToga2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBfdGhpcy5fYWxsU3R5bGVzW2tleV1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgZGVmYXVsdDogdGhpcy5kZWZhdWx0LFxyXG4gICAgICAgICAgICBlbXBoYXNpczogdGhpcy5lbXBoYXNpc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGN1c3RvbVN0eWxlQXJyYXkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXN1bHQuY3VzdG9tU3R5bGVzID0gY3VzdG9tU3R5bGVBcnJheTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBDb250YWluZXJTdHlsZVNldC5wcm90b3R5cGUuZ2V0U3R5bGVCeU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgJiYgdGhpcy5fYWxsU3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbGxTdHlsZXNbbmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlID8gZGVmYXVsdFZhbHVlIDogdGhpcy5fYWxsU3R5bGVzW0VudW1zLkNvbnRhaW5lclN0eWxlLkRlZmF1bHRdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGFpbmVyU3R5bGVTZXQucHJvdG90eXBlLCBcImRlZmF1bHRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWxsU3R5bGVzW0VudW1zLkNvbnRhaW5lclN0eWxlLkRlZmF1bHRdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250YWluZXJTdHlsZVNldC5wcm90b3R5cGUsIFwiZW1waGFzaXNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWxsU3R5bGVzW0VudW1zLkNvbnRhaW5lclN0eWxlLkVtcGhhc2lzXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gQ29udGFpbmVyU3R5bGVTZXQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQ29udGFpbmVyU3R5bGVTZXQgPSBDb250YWluZXJTdHlsZVNldDtcclxudmFyIEZvbnRUeXBlRGVmaW5pdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEZvbnRUeXBlRGVmaW5pdGlvbihmb250RmFtaWx5KSB7XHJcbiAgICAgICAgdGhpcy5mb250RmFtaWx5ID0gXCJTZWdvZSBVSSxTZWdvZSxTZWdvZSBXUCxIZWx2ZXRpY2EgTmV1ZSxIZWx2ZXRpY2Esc2Fucy1zZXJpZlwiO1xyXG4gICAgICAgIHRoaXMuZm9udFNpemVzID0ge1xyXG4gICAgICAgICAgICBzbWFsbDogMTIsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IDE0LFxyXG4gICAgICAgICAgICBtZWRpdW06IDE3LFxyXG4gICAgICAgICAgICBsYXJnZTogMjEsXHJcbiAgICAgICAgICAgIGV4dHJhTGFyZ2U6IDI2XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmZvbnRXZWlnaHRzID0ge1xyXG4gICAgICAgICAgICBsaWdodGVyOiAyMDAsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IDQwMCxcclxuICAgICAgICAgICAgYm9sZGVyOiA2MDBcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChmb250RmFtaWx5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgRm9udFR5cGVEZWZpbml0aW9uLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICB0aGlzLmZvbnRGYW1pbHkgPSBvYmpbXCJmb250RmFtaWx5XCJdIHx8IHRoaXMuZm9udEZhbWlseTtcclxuICAgICAgICB0aGlzLmZvbnRTaXplcyA9IHtcclxuICAgICAgICAgICAgc21hbGw6IChvYmouZm9udFNpemVzICYmIG9iai5mb250U2l6ZXNbXCJzbWFsbFwiXSkgfHwgdGhpcy5mb250U2l6ZXMuc21hbGwsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IChvYmouZm9udFNpemVzICYmIG9iai5mb250U2l6ZXNbXCJkZWZhdWx0XCJdKSB8fCB0aGlzLmZvbnRTaXplcy5kZWZhdWx0LFxyXG4gICAgICAgICAgICBtZWRpdW06IChvYmouZm9udFNpemVzICYmIG9iai5mb250U2l6ZXNbXCJtZWRpdW1cIl0pIHx8IHRoaXMuZm9udFNpemVzLm1lZGl1bSxcclxuICAgICAgICAgICAgbGFyZ2U6IChvYmouZm9udFNpemVzICYmIG9iai5mb250U2l6ZXNbXCJsYXJnZVwiXSkgfHwgdGhpcy5mb250U2l6ZXMubGFyZ2UsXHJcbiAgICAgICAgICAgIGV4dHJhTGFyZ2U6IChvYmouZm9udFNpemVzICYmIG9iai5mb250U2l6ZXNbXCJleHRyYUxhcmdlXCJdKSB8fCB0aGlzLmZvbnRTaXplcy5leHRyYUxhcmdlXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmZvbnRXZWlnaHRzID0ge1xyXG4gICAgICAgICAgICBsaWdodGVyOiAob2JqLmZvbnRXZWlnaHRzICYmIG9iai5mb250V2VpZ2h0c1tcImxpZ2h0ZXJcIl0pIHx8IHRoaXMuZm9udFdlaWdodHMubGlnaHRlcixcclxuICAgICAgICAgICAgZGVmYXVsdDogKG9iai5mb250V2VpZ2h0cyAmJiBvYmouZm9udFdlaWdodHNbXCJkZWZhdWx0XCJdKSB8fCB0aGlzLmZvbnRXZWlnaHRzLmRlZmF1bHQsXHJcbiAgICAgICAgICAgIGJvbGRlcjogKG9iai5mb250V2VpZ2h0cyAmJiBvYmouZm9udFdlaWdodHNbXCJib2xkZXJcIl0pIHx8IHRoaXMuZm9udFdlaWdodHMuYm9sZGVyXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBGb250VHlwZURlZmluaXRpb24ubW9ub3NwYWNlID0gbmV3IEZvbnRUeXBlRGVmaW5pdGlvbihcIidDb3VyaWVyIE5ldycsIENvdXJpZXIsIG1vbm9zcGFjZVwiKTtcclxuICAgIHJldHVybiBGb250VHlwZURlZmluaXRpb247XHJcbn0oKSk7XHJcbmV4cG9ydHMuRm9udFR5cGVEZWZpbml0aW9uID0gRm9udFR5cGVEZWZpbml0aW9uO1xyXG52YXIgRm9udFR5cGVTZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGb250VHlwZVNldChvYmopIHtcclxuICAgICAgICB0aGlzLmRlZmF1bHQgPSBuZXcgRm9udFR5cGVEZWZpbml0aW9uKCk7XHJcbiAgICAgICAgdGhpcy5tb25vc3BhY2UgPSBuZXcgRm9udFR5cGVEZWZpbml0aW9uKFwiJ0NvdXJpZXIgTmV3JywgQ291cmllciwgbW9ub3NwYWNlXCIpO1xyXG4gICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0LnBhcnNlKG9ialtcImRlZmF1bHRcIl0pO1xyXG4gICAgICAgICAgICB0aGlzLm1vbm9zcGFjZS5wYXJzZShvYmpbXCJtb25vc3BhY2VcIl0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEZvbnRUeXBlU2V0LnByb3RvdHlwZS5nZXRTdHlsZURlZmluaXRpb24gPSBmdW5jdGlvbiAoc3R5bGUpIHtcclxuICAgICAgICBzd2l0Y2ggKHN0eWxlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgRW51bXMuRm9udFR5cGUuTW9ub3NwYWNlOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9ub3NwYWNlO1xyXG4gICAgICAgICAgICBjYXNlIEVudW1zLkZvbnRUeXBlLkRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gRm9udFR5cGVTZXQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuRm9udFR5cGVTZXQgPSBGb250VHlwZVNldDtcclxudmFyIEhvc3RDb25maWcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIb3N0Q29uZmlnKG9iaikge1xyXG4gICAgICAgIHRoaXMuaG9zdENhcGFiaWxpdGllcyA9IG5ldyBob3N0X2NhcGFiaWxpdGllc18xLkhvc3RDYXBhYmlsaXRpZXMoKTtcclxuICAgICAgICB0aGlzLmNob2ljZVNldElucHV0VmFsdWVTZXBhcmF0b3IgPSBcIixcIjtcclxuICAgICAgICB0aGlzLnN1cHBvcnRzSW50ZXJhY3Rpdml0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zcGFjaW5nID0ge1xyXG4gICAgICAgICAgICBzbWFsbDogMyxcclxuICAgICAgICAgICAgZGVmYXVsdDogOCxcclxuICAgICAgICAgICAgbWVkaXVtOiAyMCxcclxuICAgICAgICAgICAgbGFyZ2U6IDMwLFxyXG4gICAgICAgICAgICBleHRyYUxhcmdlOiA0MCxcclxuICAgICAgICAgICAgcGFkZGluZzogMTVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuc2VwYXJhdG9yID0ge1xyXG4gICAgICAgICAgICBsaW5lVGhpY2tuZXNzOiAxLFxyXG4gICAgICAgICAgICBsaW5lQ29sb3I6IFwiI0VFRUVFRVwiXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmltYWdlU2l6ZXMgPSB7XHJcbiAgICAgICAgICAgIHNtYWxsOiA0MCxcclxuICAgICAgICAgICAgbWVkaXVtOiA4MCxcclxuICAgICAgICAgICAgbGFyZ2U6IDE2MFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5jb250YWluZXJTdHlsZXMgPSBuZXcgQ29udGFpbmVyU3R5bGVTZXQoKTtcclxuICAgICAgICB0aGlzLmlucHV0cyA9IG5ldyBJbnB1dENvbmZpZygpO1xyXG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IG5ldyBBY3Rpb25zQ29uZmlnKCk7XHJcbiAgICAgICAgdGhpcy5hZGFwdGl2ZUNhcmQgPSBuZXcgQWRhcHRpdmVDYXJkQ29uZmlnKCk7XHJcbiAgICAgICAgdGhpcy5pbWFnZVNldCA9IG5ldyBJbWFnZVNldENvbmZpZygpO1xyXG4gICAgICAgIHRoaXMubWVkaWEgPSBuZXcgTWVkaWFDb25maWcoKTtcclxuICAgICAgICB0aGlzLmZhY3RTZXQgPSBuZXcgRmFjdFNldENvbmZpZygpO1xyXG4gICAgICAgIHRoaXMudGFibGUgPSBuZXcgVGFibGVDb25maWcoKTtcclxuICAgICAgICB0aGlzLnRleHRTdHlsZXMgPSBuZXcgVGV4dFN0eWxlU2V0KCk7XHJcbiAgICAgICAgdGhpcy50ZXh0QmxvY2sgPSBuZXcgVGV4dEJsb2NrQ29uZmlnKCk7XHJcbiAgICAgICAgdGhpcy5hbHdheXNBbGxvd0JsZWVkID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKG9iaikge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIiB8fCBvYmogaW5zdGFuY2VvZiBTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgIG9iaiA9IEpTT04ucGFyc2Uob2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNob2ljZVNldElucHV0VmFsdWVTZXBhcmF0b3IgPVxyXG4gICAgICAgICAgICAgICAgb2JqICYmIHR5cGVvZiBvYmpbXCJjaG9pY2VTZXRJbnB1dFZhbHVlU2VwYXJhdG9yXCJdID09PSBcInN0cmluZ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgPyBvYmpbXCJjaG9pY2VTZXRJbnB1dFZhbHVlU2VwYXJhdG9yXCJdXHJcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmNob2ljZVNldElucHV0VmFsdWVTZXBhcmF0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuc3VwcG9ydHNJbnRlcmFjdGl2aXR5ID1cclxuICAgICAgICAgICAgICAgIG9iaiAmJiB0eXBlb2Ygb2JqW1wic3VwcG9ydHNJbnRlcmFjdGl2aXR5XCJdID09PSBcImJvb2xlYW5cIlxyXG4gICAgICAgICAgICAgICAgICAgID8gb2JqW1wic3VwcG9ydHNJbnRlcmFjdGl2aXR5XCJdXHJcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnN1cHBvcnRzSW50ZXJhY3Rpdml0eTtcclxuICAgICAgICAgICAgdGhpcy5fbGVnYWN5Rm9udFR5cGUgPSBuZXcgRm9udFR5cGVEZWZpbml0aW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlZ2FjeUZvbnRUeXBlLnBhcnNlKG9iaik7XHJcbiAgICAgICAgICAgIGlmIChvYmouZm9udFR5cGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZvbnRUeXBlcyA9IG5ldyBGb250VHlwZVNldChvYmouZm9udFR5cGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2JqLmxpbmVIZWlnaHRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVIZWlnaHRzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNtYWxsOiBvYmoubGluZUhlaWdodHNbXCJzbWFsbFwiXSxcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBvYmoubGluZUhlaWdodHNbXCJkZWZhdWx0XCJdLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lZGl1bTogb2JqLmxpbmVIZWlnaHRzW1wibWVkaXVtXCJdLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhcmdlOiBvYmoubGluZUhlaWdodHNbXCJsYXJnZVwiXSxcclxuICAgICAgICAgICAgICAgICAgICBleHRyYUxhcmdlOiBvYmoubGluZUhlaWdodHNbXCJleHRyYUxhcmdlXCJdXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VTaXplcyA9IHtcclxuICAgICAgICAgICAgICAgIHNtYWxsOiAob2JqLmltYWdlU2l6ZXMgJiYgb2JqLmltYWdlU2l6ZXNbXCJzbWFsbFwiXSkgfHwgdGhpcy5pbWFnZVNpemVzLnNtYWxsLFxyXG4gICAgICAgICAgICAgICAgbWVkaXVtOiAob2JqLmltYWdlU2l6ZXMgJiYgb2JqLmltYWdlU2l6ZXNbXCJtZWRpdW1cIl0pIHx8IHRoaXMuaW1hZ2VTaXplcy5tZWRpdW0sXHJcbiAgICAgICAgICAgICAgICBsYXJnZTogKG9iai5pbWFnZVNpemVzICYmIG9iai5pbWFnZVNpemVzW1wibGFyZ2VcIl0pIHx8IHRoaXMuaW1hZ2VTaXplcy5sYXJnZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lclN0eWxlcyA9IG5ldyBDb250YWluZXJTdHlsZVNldChvYmpbXCJjb250YWluZXJTdHlsZXNcIl0pO1xyXG4gICAgICAgICAgICB0aGlzLnNwYWNpbmcgPSB7XHJcbiAgICAgICAgICAgICAgICBzbWFsbDogKG9iai5zcGFjaW5nICYmIG9iai5zcGFjaW5nW1wic21hbGxcIl0pIHx8IHRoaXMuc3BhY2luZy5zbWFsbCxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IChvYmouc3BhY2luZyAmJiBvYmouc3BhY2luZ1tcImRlZmF1bHRcIl0pIHx8IHRoaXMuc3BhY2luZy5kZWZhdWx0LFxyXG4gICAgICAgICAgICAgICAgbWVkaXVtOiAob2JqLnNwYWNpbmcgJiYgb2JqLnNwYWNpbmdbXCJtZWRpdW1cIl0pIHx8IHRoaXMuc3BhY2luZy5tZWRpdW0sXHJcbiAgICAgICAgICAgICAgICBsYXJnZTogKG9iai5zcGFjaW5nICYmIG9iai5zcGFjaW5nW1wibGFyZ2VcIl0pIHx8IHRoaXMuc3BhY2luZy5sYXJnZSxcclxuICAgICAgICAgICAgICAgIGV4dHJhTGFyZ2U6IChvYmouc3BhY2luZyAmJiBvYmouc3BhY2luZ1tcImV4dHJhTGFyZ2VcIl0pIHx8IHRoaXMuc3BhY2luZy5leHRyYUxhcmdlLFxyXG4gICAgICAgICAgICAgICAgcGFkZGluZzogKG9iai5zcGFjaW5nICYmIG9iai5zcGFjaW5nW1wicGFkZGluZ1wiXSkgfHwgdGhpcy5zcGFjaW5nLnBhZGRpbmdcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5zZXBhcmF0b3IgPSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lVGhpY2tuZXNzOiAob2JqLnNlcGFyYXRvciAmJiBvYmouc2VwYXJhdG9yW1wibGluZVRoaWNrbmVzc1wiXSkgfHxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcGFyYXRvci5saW5lVGhpY2tuZXNzLFxyXG4gICAgICAgICAgICAgICAgbGluZUNvbG9yOiAob2JqLnNlcGFyYXRvciAmJiBvYmouc2VwYXJhdG9yW1wibGluZUNvbG9yXCJdKSB8fCB0aGlzLnNlcGFyYXRvci5saW5lQ29sb3JcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dHMgPSBuZXcgSW5wdXRDb25maWcob2JqLmlucHV0cyB8fCB0aGlzLmlucHV0cyk7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucyA9IG5ldyBBY3Rpb25zQ29uZmlnKG9iai5hY3Rpb25zIHx8IHRoaXMuYWN0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRhcHRpdmVDYXJkID0gbmV3IEFkYXB0aXZlQ2FyZENvbmZpZyhvYmouYWRhcHRpdmVDYXJkIHx8IHRoaXMuYWRhcHRpdmVDYXJkKTtcclxuICAgICAgICAgICAgdGhpcy5pbWFnZVNldCA9IG5ldyBJbWFnZVNldENvbmZpZyhvYmpbXCJpbWFnZVNldFwiXSk7XHJcbiAgICAgICAgICAgIHRoaXMuZmFjdFNldCA9IG5ldyBGYWN0U2V0Q29uZmlnKG9ialtcImZhY3RTZXRcIl0pO1xyXG4gICAgICAgICAgICB0aGlzLnRleHRTdHlsZXMgPSBuZXcgVGV4dFN0eWxlU2V0KG9ialtcInRleHRTdHlsZXNcIl0pO1xyXG4gICAgICAgICAgICB0aGlzLnRleHRCbG9jayA9IG5ldyBUZXh0QmxvY2tDb25maWcob2JqW1widGV4dEJsb2NrXCJdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBIb3N0Q29uZmlnLnByb3RvdHlwZS5nZXRGb250VHlwZURlZmluaXRpb24gPSBmdW5jdGlvbiAoc3R5bGUpIHtcclxuICAgICAgICBpZiAodGhpcy5mb250VHlwZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9udFR5cGVzLmdldFN0eWxlRGVmaW5pdGlvbihzdHlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3R5bGUgPT09IEVudW1zLkZvbnRUeXBlLk1vbm9zcGFjZVxyXG4gICAgICAgICAgICAgICAgPyBGb250VHlwZURlZmluaXRpb24ubW9ub3NwYWNlXHJcbiAgICAgICAgICAgICAgICA6IHRoaXMuX2xlZ2FjeUZvbnRUeXBlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBIb3N0Q29uZmlnLnByb3RvdHlwZS5nZXRFZmZlY3RpdmVTcGFjaW5nID0gZnVuY3Rpb24gKHNwYWNpbmcpIHtcclxuICAgICAgICBzd2l0Y2ggKHNwYWNpbmcpIHtcclxuICAgICAgICAgICAgY2FzZSBFbnVtcy5TcGFjaW5nLlNtYWxsOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BhY2luZy5zbWFsbDtcclxuICAgICAgICAgICAgY2FzZSBFbnVtcy5TcGFjaW5nLkRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zcGFjaW5nLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgIGNhc2UgRW51bXMuU3BhY2luZy5NZWRpdW06XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zcGFjaW5nLm1lZGl1bTtcclxuICAgICAgICAgICAgY2FzZSBFbnVtcy5TcGFjaW5nLkxhcmdlOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BhY2luZy5sYXJnZTtcclxuICAgICAgICAgICAgY2FzZSBFbnVtcy5TcGFjaW5nLkV4dHJhTGFyZ2U6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zcGFjaW5nLmV4dHJhTGFyZ2U7XHJcbiAgICAgICAgICAgIGNhc2UgRW51bXMuU3BhY2luZy5QYWRkaW5nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BhY2luZy5wYWRkaW5nO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEhvc3RDb25maWcucHJvdG90eXBlLnBhZGRpbmdEZWZpbml0aW9uVG9TcGFjaW5nRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIChwYWRkaW5nRGVmaW5pdGlvbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgU2hhcmVkLlNwYWNpbmdEZWZpbml0aW9uKHRoaXMuZ2V0RWZmZWN0aXZlU3BhY2luZyhwYWRkaW5nRGVmaW5pdGlvbi50b3ApLCB0aGlzLmdldEVmZmVjdGl2ZVNwYWNpbmcocGFkZGluZ0RlZmluaXRpb24ucmlnaHQpLCB0aGlzLmdldEVmZmVjdGl2ZVNwYWNpbmcocGFkZGluZ0RlZmluaXRpb24uYm90dG9tKSwgdGhpcy5nZXRFZmZlY3RpdmVTcGFjaW5nKHBhZGRpbmdEZWZpbml0aW9uLmxlZnQpKTtcclxuICAgIH07XHJcbiAgICBIb3N0Q29uZmlnLnByb3RvdHlwZS5tYWtlQ3NzQ2xhc3NOYW1lcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgY2xhc3NOYW1lc18xID0gY2xhc3NOYW1lczsgX2EgPCBjbGFzc05hbWVzXzEubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBjbGFzc05hbWVzXzFbX2FdO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCgodGhpcy5jc3NDbGFzc05hbWVQcmVmaXggPyB0aGlzLmNzc0NsYXNzTmFtZVByZWZpeCArIFwiLVwiIDogXCJcIikgKyBjbGFzc05hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIEhvc3RDb25maWcucHJvdG90eXBlLm1ha2VDc3NDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBjbGFzc05hbWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLm1ha2VDc3NDbGFzc05hbWVzLmFwcGx5KHRoaXMsIGNsYXNzTmFtZXMpLmpvaW4oXCIgXCIpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQgPyByZXN1bHQgOiBcIlwiO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIb3N0Q29uZmlnLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlZ2FjeUZvbnRUeXBlLmZvbnRGYW1pbHk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9sZWdhY3lGb250VHlwZS5mb250RmFtaWx5ID0gdmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhvc3RDb25maWcucHJvdG90eXBlLCBcImZvbnRTaXplc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZWdhY3lGb250VHlwZS5mb250U2l6ZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhvc3RDb25maWcucHJvdG90eXBlLCBcImZvbnRXZWlnaHRzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlZ2FjeUZvbnRUeXBlLmZvbnRXZWlnaHRzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBIb3N0Q29uZmlnO1xyXG59KCkpO1xyXG5leHBvcnRzLkhvc3RDb25maWcgPSBIb3N0Q29uZmlnO1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydHMuZGVmYXVsdEhvc3RDb25maWcgPSBuZXcgSG9zdENvbmZpZyh7XHJcbiAgICBzdXBwb3J0c0ludGVyYWN0aXZpdHk6IHRydWUsXHJcbiAgICBzcGFjaW5nOiB7XHJcbiAgICAgICAgc21hbGw6IDEwLFxyXG4gICAgICAgIGRlZmF1bHQ6IDIwLFxyXG4gICAgICAgIG1lZGl1bTogMzAsXHJcbiAgICAgICAgbGFyZ2U6IDQwLFxyXG4gICAgICAgIGV4dHJhTGFyZ2U6IDUwLFxyXG4gICAgICAgIHBhZGRpbmc6IDIwXHJcbiAgICB9LFxyXG4gICAgc2VwYXJhdG9yOiB7XHJcbiAgICAgICAgbGluZVRoaWNrbmVzczogMSxcclxuICAgICAgICBsaW5lQ29sb3I6IFwiI0VFRUVFRVwiXHJcbiAgICB9LFxyXG4gICAgZm9udFR5cGVzOiB7XHJcbiAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICBmb250RmFtaWx5OiBcIidTZWdvZSBVSScsIFRhaG9tYSwgR2VuZXZhLCBWZXJkYW5hLCBzYW5zLXNlcmlmXCIsXHJcbiAgICAgICAgICAgIGZvbnRTaXplczoge1xyXG4gICAgICAgICAgICAgICAgc21hbGw6IDEyLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMTQsXHJcbiAgICAgICAgICAgICAgICBtZWRpdW06IDE3LFxyXG4gICAgICAgICAgICAgICAgbGFyZ2U6IDIxLFxyXG4gICAgICAgICAgICAgICAgZXh0cmFMYXJnZTogMjZcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZm9udFdlaWdodHM6IHtcclxuICAgICAgICAgICAgICAgIGxpZ2h0ZXI6IDIwMCxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDQwMCxcclxuICAgICAgICAgICAgICAgIGJvbGRlcjogNjAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1vbm9zcGFjZToge1xyXG4gICAgICAgICAgICBmb250RmFtaWx5OiBcIidDb3VyaWVyIE5ldycsIENvdXJpZXIsIG1vbm9zcGFjZVwiLFxyXG4gICAgICAgICAgICBmb250U2l6ZXM6IHtcclxuICAgICAgICAgICAgICAgIHNtYWxsOiAxMixcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDE0LFxyXG4gICAgICAgICAgICAgICAgbWVkaXVtOiAxNyxcclxuICAgICAgICAgICAgICAgIGxhcmdlOiAyMSxcclxuICAgICAgICAgICAgICAgIGV4dHJhTGFyZ2U6IDI2XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZvbnRXZWlnaHRzOiB7XHJcbiAgICAgICAgICAgICAgICBsaWdodGVyOiAyMDAsXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiA0MDAsXHJcbiAgICAgICAgICAgICAgICBib2xkZXI6IDYwMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGltYWdlU2l6ZXM6IHtcclxuICAgICAgICBzbWFsbDogNDAsXHJcbiAgICAgICAgbWVkaXVtOiA4MCxcclxuICAgICAgICBsYXJnZTogMTYwXHJcbiAgICB9LFxyXG4gICAgY29udGFpbmVyU3R5bGVzOiB7XHJcbiAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI0ZGRkZGRlwiLFxyXG4gICAgICAgICAgICBmb3JlZ3JvdW5kQ29sb3JzOiB7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogXCIjMzMzMzMzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGxlOiBcIiNFRTMzMzMzM1wiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZGFyazoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRsZTogXCIjNjYwMDAwMDBcIlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGxpZ2h0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogXCIjRkZGRkZGXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGxlOiBcIiMzMzAwMDAwMFwiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYWNjZW50OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogXCIjMkU4OUZDXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGxlOiBcIiM4ODJFODlGQ1wiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYXR0ZW50aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogXCIjY2MzMzAwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGxlOiBcIiNERGNjMzMwMFwiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZ29vZDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFwiIzAyOEEwMlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRsZTogXCIjREQwMjc1MDJcIlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHdhcm5pbmc6IHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBcIiNlNjk1MDBcIixcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0bGU6IFwiI0REZTY5NTAwXCJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW1waGFzaXM6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMwODAwMDAwMFwiLFxyXG4gICAgICAgICAgICBmb3JlZ3JvdW5kQ29sb3JzOiB7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogXCIjMzMzMzMzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGxlOiBcIiNFRTMzMzMzM1wiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZGFyazoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRsZTogXCIjNjYwMDAwMDBcIlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGxpZ2h0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogXCIjRkZGRkZGXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGxlOiBcIiMzMzAwMDAwMFwiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYWNjZW50OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogXCIjMkU4OUZDXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGxlOiBcIiM4ODJFODlGQ1wiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYXR0ZW50aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogXCIjY2MzMzAwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGxlOiBcIiNERGNjMzMwMFwiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZ29vZDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFwiIzAyOEEwMlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRsZTogXCIjREQwMjc1MDJcIlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHdhcm5pbmc6IHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBcIiNlNjk1MDBcIixcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0bGU6IFwiI0REZTY5NTAwXCJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWNjZW50OiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjQzdERUY5XCIsXHJcbiAgICAgICAgICAgIGZvcmVncm91bmRDb2xvcnM6IHtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBcIiMzMzMzMzNcIixcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0bGU6IFwiI0VFMzMzMzMzXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkYXJrOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGxlOiBcIiM2NjAwMDAwMFwiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbGlnaHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBcIiNGRkZGRkZcIixcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0bGU6IFwiIzMzMDAwMDAwXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhY2NlbnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBcIiMyRTg5RkNcIixcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0bGU6IFwiIzg4MkU4OUZDXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhdHRlbnRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBcIiNjYzMzMDBcIixcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0bGU6IFwiI0REY2MzMzAwXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBnb29kOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogXCIjMDI4QTAyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGxlOiBcIiNERDAyNzUwMlwiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgd2FybmluZzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFwiI2U2OTUwMFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRsZTogXCIjRERlNjk1MDBcIlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnb29kOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjQ0NGRkNDXCIsXHJcbiAgICAgICAgICAgIGZvcmVncm91bmRDb2xvcnM6IHtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBcIiMzMzMzMzNcIixcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0bGU6IFwiI0VFMzMzMzMzXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkYXJrOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGxlOiBcIiM2NjAwMDAwMFwiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbGlnaHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBcIiNGRkZGRkZcIixcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0bGU6IFwiIzMzMDAwMDAwXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhY2NlbnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBcIiMyRTg5RkNcIixcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0bGU6IFwiIzg4MkU4OUZDXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhdHRlbnRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBcIiNjYzMzMDBcIixcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0bGU6IFwiI0REY2MzMzAwXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBnb29kOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogXCIjMDI4QTAyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGxlOiBcIiNERDAyNzUwMlwiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgd2FybmluZzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFwiI2U2OTUwMFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRsZTogXCIjRERlNjk1MDBcIlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhdHRlbnRpb246IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNGRkM1QjJcIixcclxuICAgICAgICAgICAgZm9yZWdyb3VuZENvbG9yczoge1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFwiIzMzMzMzM1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRsZTogXCIjRUUzMzMzMzNcIlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGRhcms6IHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBcIiMwMDAwMDBcIixcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0bGU6IFwiIzY2MDAwMDAwXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBsaWdodDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFwiI0ZGRkZGRlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRsZTogXCIjMzMwMDAwMDBcIlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGFjY2VudDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFwiIzJFODlGQ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRsZTogXCIjODgyRTg5RkNcIlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGF0dGVudGlvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFwiI2NjMzMwMFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRsZTogXCIjRERjYzMzMDBcIlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGdvb2Q6IHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBcIiMwMjhBMDJcIixcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0bGU6IFwiI0REMDI3NTAyXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB3YXJuaW5nOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogXCIjZTY5NTAwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGxlOiBcIiNERGU2OTUwMFwiXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHdhcm5pbmc6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNGRkUyQjJcIixcclxuICAgICAgICAgICAgZm9yZWdyb3VuZENvbG9yczoge1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFwiIzMzMzMzM1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRsZTogXCIjRUUzMzMzMzNcIlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGRhcms6IHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBcIiMwMDAwMDBcIixcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0bGU6IFwiIzY2MDAwMDAwXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBsaWdodDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFwiI0ZGRkZGRlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRsZTogXCIjMzMwMDAwMDBcIlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGFjY2VudDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFwiIzJFODlGQ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRsZTogXCIjODgyRTg5RkNcIlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGF0dGVudGlvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFwiI2NjMzMwMFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRsZTogXCIjRERjYzMzMDBcIlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGdvb2Q6IHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBcIiMwMjhBMDJcIixcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0bGU6IFwiI0REMDI3NTAyXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB3YXJuaW5nOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogXCIjZTY5NTAwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGxlOiBcIiNERGU2OTUwMFwiXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgaW5wdXRzOiB7XHJcbiAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgcmVxdWlyZWRJbnB1dHM6IHtcclxuICAgICAgICAgICAgICAgIHdlaWdodDogRW51bXMuVGV4dFdlaWdodC5Cb2xkZXIsXHJcbiAgICAgICAgICAgICAgICBzdWZmaXg6IFwiICpcIixcclxuICAgICAgICAgICAgICAgIHN1ZmZpeENvbG9yOiBFbnVtcy5UZXh0Q29sb3IuQXR0ZW50aW9uXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9wdGlvbmFsSW5wdXRzOiB7XHJcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6IEVudW1zLlRleHRXZWlnaHQuQm9sZGVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVycm9yTWVzc2FnZToge1xyXG4gICAgICAgICAgICBjb2xvcjogRW51bXMuVGV4dENvbG9yLkF0dGVudGlvbixcclxuICAgICAgICAgICAgd2VpZ2h0OiBFbnVtcy5UZXh0V2VpZ2h0LkJvbGRlclxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBhY3Rpb25zOiB7XHJcbiAgICAgICAgbWF4QWN0aW9uczogNSxcclxuICAgICAgICBzcGFjaW5nOiBFbnVtcy5TcGFjaW5nLkRlZmF1bHQsXHJcbiAgICAgICAgYnV0dG9uU3BhY2luZzogMTAsXHJcbiAgICAgICAgc2hvd0NhcmQ6IHtcclxuICAgICAgICAgICAgYWN0aW9uTW9kZTogRW51bXMuU2hvd0NhcmRBY3Rpb25Nb2RlLklubGluZSxcclxuICAgICAgICAgICAgaW5saW5lVG9wTWFyZ2luOiAxNlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWN0aW9uc09yaWVudGF0aW9uOiBFbnVtcy5PcmllbnRhdGlvbi5Ib3Jpem9udGFsLFxyXG4gICAgICAgIGFjdGlvbkFsaWdubWVudDogRW51bXMuQWN0aW9uQWxpZ25tZW50LkxlZnRcclxuICAgIH0sXHJcbiAgICBhZGFwdGl2ZUNhcmQ6IHtcclxuICAgICAgICBhbGxvd0N1c3RvbVN0eWxlOiBmYWxzZVxyXG4gICAgfSxcclxuICAgIGltYWdlU2V0OiB7XHJcbiAgICAgICAgaW1hZ2VTaXplOiBFbnVtcy5TaXplLk1lZGl1bSxcclxuICAgICAgICBtYXhJbWFnZUhlaWdodDogMTAwXHJcbiAgICB9LFxyXG4gICAgZmFjdFNldDoge1xyXG4gICAgICAgIHRpdGxlOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiBFbnVtcy5UZXh0Q29sb3IuRGVmYXVsdCxcclxuICAgICAgICAgICAgc2l6ZTogRW51bXMuVGV4dFNpemUuRGVmYXVsdCxcclxuICAgICAgICAgICAgaXNTdWJ0bGU6IGZhbHNlLFxyXG4gICAgICAgICAgICB3ZWlnaHQ6IEVudW1zLlRleHRXZWlnaHQuQm9sZGVyLFxyXG4gICAgICAgICAgICB3cmFwOiB0cnVlLFxyXG4gICAgICAgICAgICBtYXhXaWR0aDogMTUwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgICBjb2xvcjogRW51bXMuVGV4dENvbG9yLkRlZmF1bHQsXHJcbiAgICAgICAgICAgIHNpemU6IEVudW1zLlRleHRTaXplLkRlZmF1bHQsXHJcbiAgICAgICAgICAgIGlzU3VidGxlOiBmYWxzZSxcclxuICAgICAgICAgICAgd2VpZ2h0OiBFbnVtcy5UZXh0V2VpZ2h0LkRlZmF1bHQsXHJcbiAgICAgICAgICAgIHdyYXA6IHRydWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNwYWNpbmc6IDEwXHJcbiAgICB9XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob3N0LWNvbmZpZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkdsb2JhbFJlZ2lzdHJ5ID0gZXhwb3J0cy5DYXJkT2JqZWN0UmVnaXN0cnkgPSBleHBvcnRzLkVsZW1lbnRTaW5nbGV0b25CZWhhdmlvciA9IHZvaWQgMDtcclxudmFyIHNlcmlhbGl6YXRpb25fMSA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6YXRpb25cIik7XHJcbi8qKlxyXG4gKiBEZXNjcmliZXMgd2hldGhlciBhIGNlcnRhaW4gZWxlbWVudCBjYW4gYmUgcGFyc2VkIGluIGEgXCJzaW5nbGV0b25cIiBjb250ZXh0LlxyXG4gKiBTcGVjaWZpY2FsbHksIGlzIHRoZSBlbGVtZW50IGFsbG93ZWQgdG8gZXhpc3QgYXMgYW4gb2JqZWN0IGluIGEgY29udGV4dCB3aGVyZSB0aGVcclxuICogcGFyZW50IGV4cGVjdHMgYW4gQXJyYXkgb2YgZWxlbWVudHMgKGUuZy4gYEFkYXB0aXZlQ2FyZC5ib2R5YClcclxuICpcclxuICogQGV4YW1wbGUgLSBTaW5nbGV0b24gZWxlbWVudCBpbiBhIGNvbnRhaW5lciAobm90ZSBgaXRlbXNgIGNvbnRhaW5zIGFuIGBvYmplY3RgIHJhdGhlciB0aGFuIGFuIGBBcnJheTxvYmplY3Q+YClcclxuICogYGBganNvblxyXG4gKiB7XHJcbiAqICAgICBcInR5cGVcIjogXCJDb250YWluZXJcIixcclxuICogICAgIFwiaXRlbXNcIjoge1xyXG4gKiAgICAgICAgIFwidHlwZVwiOiBcIkFsbG93ZWRTaW5nbGV0b25FbGVtZW50XCJcclxuICogICAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbnZhciBFbGVtZW50U2luZ2xldG9uQmVoYXZpb3I7XHJcbihmdW5jdGlvbiAoRWxlbWVudFNpbmdsZXRvbkJlaGF2aW9yKSB7XHJcbiAgICAvKiogRWxlbWVudCBvbmx5IHZhbGlkIGluIGEgc2luZ2xldG9uIGNvbnRleHQuICovXHJcbiAgICBFbGVtZW50U2luZ2xldG9uQmVoYXZpb3JbRWxlbWVudFNpbmdsZXRvbkJlaGF2aW9yW1wiT25seVwiXSA9IDBdID0gXCJPbmx5XCI7XHJcbiAgICAvKiogRWxlbWVudCBpcyBhbGxvd2VkIGluIGEgc2luZ2xldG9uIGNvbnRleHQsIGJ1dCBub3QgcmVxdWlyZWQgdG8gYmUgYSBzaW5nbGV0b24uICovXHJcbiAgICBFbGVtZW50U2luZ2xldG9uQmVoYXZpb3JbRWxlbWVudFNpbmdsZXRvbkJlaGF2aW9yW1wiQWxsb3dlZFwiXSA9IDFdID0gXCJBbGxvd2VkXCI7XHJcbiAgICAvKiogRWxlbWVudCBpcyBub3QgYWxsb3dlZCB0byBleGlzdCBpbiBhIHNpbmdsZXRvbiBjb250ZXh0LiAqL1xyXG4gICAgRWxlbWVudFNpbmdsZXRvbkJlaGF2aW9yW0VsZW1lbnRTaW5nbGV0b25CZWhhdmlvcltcIk5vdEFsbG93ZWRcIl0gPSAyXSA9IFwiTm90QWxsb3dlZFwiO1xyXG59KShFbGVtZW50U2luZ2xldG9uQmVoYXZpb3IgPSBleHBvcnRzLkVsZW1lbnRTaW5nbGV0b25CZWhhdmlvciB8fCAoZXhwb3J0cy5FbGVtZW50U2luZ2xldG9uQmVoYXZpb3IgPSB7fSkpO1xyXG52YXIgQ2FyZE9iamVjdFJlZ2lzdHJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2FyZE9iamVjdFJlZ2lzdHJ5KCkge1xyXG4gICAgICAgIHRoaXMuX2l0ZW1zID0ge307XHJcbiAgICB9XHJcbiAgICBDYXJkT2JqZWN0UmVnaXN0cnkucHJvdG90eXBlLmZpbmRCeU5hbWUgPSBmdW5jdGlvbiAodHlwZU5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMuaGFzT3duUHJvcGVydHkodHlwZU5hbWUpID8gdGhpcy5faXRlbXNbdHlwZU5hbWVdIDogdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIENhcmRPYmplY3RSZWdpc3RyeS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5faXRlbXMgPSB7fTtcclxuICAgIH07XHJcbiAgICBDYXJkT2JqZWN0UmVnaXN0cnkucHJvdG90eXBlLmNvcHlUbyA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2l0ZW1zKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGtleXNfMSA9IGtleXM7IF9pIDwga2V5c18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c18xW19pXTtcclxuICAgICAgICAgICAgdmFyIHR5cGVSZWdpc3RyYXRpb24gPSB0aGlzLl9pdGVtc1trZXldO1xyXG4gICAgICAgICAgICB0YXJnZXQucmVnaXN0ZXIodHlwZVJlZ2lzdHJhdGlvbi50eXBlTmFtZSwgdHlwZVJlZ2lzdHJhdGlvbi5vYmplY3RUeXBlLCB0eXBlUmVnaXN0cmF0aW9uLnNjaGVtYVZlcnNpb24sIHR5cGVSZWdpc3RyYXRpb24uc2luZ2xldG9uQmVoYXZpb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYXJkT2JqZWN0UmVnaXN0cnkucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHR5cGVOYW1lLCBvYmplY3RUeXBlLCBzY2hlbWFWZXJzaW9uLCBzaW5nbGV0b25CZWhhdmlvcikge1xyXG4gICAgICAgIGlmIChzY2hlbWFWZXJzaW9uID09PSB2b2lkIDApIHsgc2NoZW1hVmVyc2lvbiA9IHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV8wOyB9XHJcbiAgICAgICAgaWYgKHNpbmdsZXRvbkJlaGF2aW9yID09PSB2b2lkIDApIHsgc2luZ2xldG9uQmVoYXZpb3IgPSBFbGVtZW50U2luZ2xldG9uQmVoYXZpb3IuTm90QWxsb3dlZDsgfVxyXG4gICAgICAgIHZhciByZWdpc3RyYXRpb25JbmZvID0gdGhpcy5maW5kQnlOYW1lKHR5cGVOYW1lKTtcclxuICAgICAgICBpZiAocmVnaXN0cmF0aW9uSW5mbyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbkluZm8ub2JqZWN0VHlwZSA9IG9iamVjdFR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZWdpc3RyYXRpb25JbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgdHlwZU5hbWU6IHR5cGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgb2JqZWN0VHlwZTogb2JqZWN0VHlwZSxcclxuICAgICAgICAgICAgICAgIHNjaGVtYVZlcnNpb246IHNjaGVtYVZlcnNpb24sXHJcbiAgICAgICAgICAgICAgICBzaW5nbGV0b25CZWhhdmlvcjogc2luZ2xldG9uQmVoYXZpb3JcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faXRlbXNbdHlwZU5hbWVdID0gcmVnaXN0cmF0aW9uSW5mbztcclxuICAgIH07XHJcbiAgICBDYXJkT2JqZWN0UmVnaXN0cnkucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiAodHlwZU5hbWUpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5faXRlbXNbdHlwZU5hbWVdO1xyXG4gICAgfTtcclxuICAgIENhcmRPYmplY3RSZWdpc3RyeS5wcm90b3R5cGUuY3JlYXRlSW5zdGFuY2UgPSBmdW5jdGlvbiAodHlwZU5hbWUsIHRhcmdldFZlcnNpb24pIHtcclxuICAgICAgICB2YXIgcmVnaXN0cmF0aW9uSW5mbyA9IHRoaXMuZmluZEJ5TmFtZSh0eXBlTmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlZ2lzdHJhdGlvbkluZm8gJiYgcmVnaXN0cmF0aW9uSW5mby5zY2hlbWFWZXJzaW9uLmNvbXBhcmVUbyh0YXJnZXRWZXJzaW9uKSA8PSAwXHJcbiAgICAgICAgICAgID8gbmV3IHJlZ2lzdHJhdGlvbkluZm8ub2JqZWN0VHlwZSgpXHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIENhcmRPYmplY3RSZWdpc3RyeS5wcm90b3R5cGUuZ2V0SXRlbUNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9pdGVtcykubGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIENhcmRPYmplY3RSZWdpc3RyeS5wcm90b3R5cGUuZ2V0SXRlbUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5faXRlbXMpLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX2l0ZW1zW2VdOyB9KVtpbmRleF07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENhcmRPYmplY3RSZWdpc3RyeTtcclxufSgpKTtcclxuZXhwb3J0cy5DYXJkT2JqZWN0UmVnaXN0cnkgPSBDYXJkT2JqZWN0UmVnaXN0cnk7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmFuZW91cy1jbGFzc1xyXG52YXIgR2xvYmFsUmVnaXN0cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBHbG9iYWxSZWdpc3RyeSgpIHtcclxuICAgIH1cclxuICAgIEdsb2JhbFJlZ2lzdHJ5LnBvcHVsYXRlV2l0aERlZmF1bHRFbGVtZW50cyA9IGZ1bmN0aW9uIChyZWdpc3RyeSkge1xyXG4gICAgICAgIHJlZ2lzdHJ5LmNsZWFyKCk7XHJcbiAgICAgICAgR2xvYmFsUmVnaXN0cnkuZGVmYXVsdEVsZW1lbnRzLmNvcHlUbyhyZWdpc3RyeSk7XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsUmVnaXN0cnkucG9wdWxhdGVXaXRoRGVmYXVsdEFjdGlvbnMgPSBmdW5jdGlvbiAocmVnaXN0cnkpIHtcclxuICAgICAgICByZWdpc3RyeS5jbGVhcigpO1xyXG4gICAgICAgIEdsb2JhbFJlZ2lzdHJ5LmRlZmF1bHRBY3Rpb25zLmNvcHlUbyhyZWdpc3RyeSk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdsb2JhbFJlZ2lzdHJ5LCBcImVsZW1lbnRzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFHbG9iYWxSZWdpc3RyeS5fZWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgIEdsb2JhbFJlZ2lzdHJ5Ll9lbGVtZW50cyA9IG5ldyBDYXJkT2JqZWN0UmVnaXN0cnkoKTtcclxuICAgICAgICAgICAgICAgIEdsb2JhbFJlZ2lzdHJ5LnBvcHVsYXRlV2l0aERlZmF1bHRFbGVtZW50cyhHbG9iYWxSZWdpc3RyeS5fZWxlbWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBHbG9iYWxSZWdpc3RyeS5fZWxlbWVudHM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdsb2JhbFJlZ2lzdHJ5LCBcImFjdGlvbnNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIUdsb2JhbFJlZ2lzdHJ5Ll9hY3Rpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBHbG9iYWxSZWdpc3RyeS5fYWN0aW9ucyA9IG5ldyBDYXJkT2JqZWN0UmVnaXN0cnkoKTtcclxuICAgICAgICAgICAgICAgIEdsb2JhbFJlZ2lzdHJ5LnBvcHVsYXRlV2l0aERlZmF1bHRBY3Rpb25zKEdsb2JhbFJlZ2lzdHJ5Ll9hY3Rpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gR2xvYmFsUmVnaXN0cnkuX2FjdGlvbnM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgR2xvYmFsUmVnaXN0cnkucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgR2xvYmFsUmVnaXN0cnkuX2VsZW1lbnRzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIEdsb2JhbFJlZ2lzdHJ5Ll9hY3Rpb25zID0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIEdsb2JhbFJlZ2lzdHJ5LmRlZmF1bHRFbGVtZW50cyA9IG5ldyBDYXJkT2JqZWN0UmVnaXN0cnkoKTtcclxuICAgIEdsb2JhbFJlZ2lzdHJ5LmRlZmF1bHRBY3Rpb25zID0gbmV3IENhcmRPYmplY3RSZWdpc3RyeSgpO1xyXG4gICAgcmV0dXJuIEdsb2JhbFJlZ2lzdHJ5O1xyXG59KCkpO1xyXG5leHBvcnRzLkdsb2JhbFJlZ2lzdHJ5ID0gR2xvYmFsUmVnaXN0cnk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZ2lzdHJ5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlNlcmlhbGl6YWJsZU9iamVjdCA9IGV4cG9ydHMucHJvcGVydHkgPSBleHBvcnRzLlNlcmlhbGl6YWJsZU9iamVjdFNjaGVtYSA9IGV4cG9ydHMuQ3VzdG9tUHJvcGVydHkgPSBleHBvcnRzLlNlcmlhbGl6YWJsZU9iamVjdENvbGxlY3Rpb25Qcm9wZXJ0eSA9IGV4cG9ydHMuU2VyaWFsaXphYmxlT2JqZWN0UHJvcGVydHkgPSBleHBvcnRzLkVudW1Qcm9wZXJ0eSA9IGV4cG9ydHMuVmFsdWVTZXRQcm9wZXJ0eSA9IGV4cG9ydHMuU3RyaW5nQXJyYXlQcm9wZXJ0eSA9IGV4cG9ydHMuUGl4ZWxTaXplUHJvcGVydHkgPSBleHBvcnRzLk51bVByb3BlcnR5ID0gZXhwb3J0cy5Cb29sUHJvcGVydHkgPSBleHBvcnRzLlN0cmluZ1Byb3BlcnR5ID0gZXhwb3J0cy5Qcm9wZXJ0eURlZmluaXRpb24gPSBleHBvcnRzLkJhc2VTZXJpYWxpemF0aW9uQ29udGV4dCA9IGV4cG9ydHMuaXNWZXJzaW9uTGVzc09yRXF1YWwgPSBleHBvcnRzLlZlcnNpb25zID0gZXhwb3J0cy5WZXJzaW9uID0gdm9pZCAwO1xyXG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKFwiLi9zaGFyZWRcIik7XHJcbnZhciBVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xyXG52YXIgRW51bXMgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcclxudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ3NcIik7XHJcbnZhciBWZXJzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmVyc2lvbihtYWpvciwgbWlub3IsIGxhYmVsKSB7XHJcbiAgICAgICAgaWYgKG1ham9yID09PSB2b2lkIDApIHsgbWFqb3IgPSAxOyB9XHJcbiAgICAgICAgaWYgKG1pbm9yID09PSB2b2lkIDApIHsgbWlub3IgPSAxOyB9XHJcbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fbWFqb3IgPSBtYWpvcjtcclxuICAgICAgICB0aGlzLl9taW5vciA9IG1pbm9yO1xyXG4gICAgICAgIHRoaXMuX2xhYmVsID0gbGFiZWw7XHJcbiAgICB9XHJcbiAgICBWZXJzaW9uLnBhcnNlID0gZnVuY3Rpb24gKHZlcnNpb25TdHJpbmcsIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAoIXZlcnNpb25TdHJpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBWZXJzaW9uKCk7XHJcbiAgICAgICAgcmVzdWx0Ll92ZXJzaW9uU3RyaW5nID0gdmVyc2lvblN0cmluZztcclxuICAgICAgICB2YXIgcmVnRXggPSAvKFxcZCspLihcXGQrKS9naTtcclxuICAgICAgICB2YXIgbWF0Y2hlcyA9IHJlZ0V4LmV4ZWModmVyc2lvblN0cmluZyk7XHJcbiAgICAgICAgaWYgKG1hdGNoZXMgIT0gbnVsbCAmJiBtYXRjaGVzLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICAgICAgICByZXN1bHQuX21ham9yID0gcGFyc2VJbnQobWF0Y2hlc1sxXSk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5fbWlub3IgPSBwYXJzZUludChtYXRjaGVzWzJdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5faXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXJlc3VsdC5faXNWYWxpZCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmxvZ1BhcnNlRXZlbnQodW5kZWZpbmVkLCBFbnVtcy5WYWxpZGF0aW9uRXZlbnQuSW52YWxpZFByb3BlcnR5VmFsdWUsIHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy5pbnZhbGlkVmVyc2lvblN0cmluZyhyZXN1bHQuX3ZlcnNpb25TdHJpbmcpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBWZXJzaW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuX2lzVmFsaWQgPyB0aGlzLl92ZXJzaW9uU3RyaW5nIDogdGhpcy5fbWFqb3IgKyBcIi5cIiArIHRoaXMuX21pbm9yO1xyXG4gICAgfTtcclxuICAgIFZlcnNpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG4gICAgfTtcclxuICAgIFZlcnNpb24ucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIChvdGhlclZlcnNpb24pIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCAhb3RoZXJWZXJzaW9uLmlzVmFsaWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXBhcmUgaW52YWxpZCB2ZXJzaW9uLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubWFqb3IgPiBvdGhlclZlcnNpb24ubWFqb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubWFqb3IgPCBvdGhlclZlcnNpb24ubWFqb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLm1pbm9yID4gb3RoZXJWZXJzaW9uLm1pbm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLm1pbm9yIDwgb3RoZXJWZXJzaW9uLm1pbm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlcnNpb24ucHJvdG90eXBlLCBcImxhYmVsXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhYmVsID8gdGhpcy5fbGFiZWwgOiB0aGlzLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlcnNpb24ucHJvdG90eXBlLCBcIm1ham9yXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21ham9yO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWZXJzaW9uLnByb3RvdHlwZSwgXCJtaW5vclwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9taW5vcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmVyc2lvbi5wcm90b3R5cGUsIFwiaXNWYWxpZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBWZXJzaW9uO1xyXG59KCkpO1xyXG5leHBvcnRzLlZlcnNpb24gPSBWZXJzaW9uO1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhbmVvdXMtY2xhc3NcclxudmFyIFZlcnNpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmVyc2lvbnMoKSB7XHJcbiAgICB9XHJcbiAgICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xyXG4gICAgVmVyc2lvbnMuZ2V0QWxsRGVjbGFyZWRWZXJzaW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY3RvciA9IFZlcnNpb25zO1xyXG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIGN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnR5TmFtZS5tYXRjaCgvXnZbMC05X10qJC8pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgbGF0ZXN0XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eVZhbHVlID0gY3Rvcltwcm9wZXJ0eU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVZhbHVlIGluc3RhbmNlb2YgVmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2gocHJvcGVydHlWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBwcm9wZXJ0eSBoYXBwZW5zIHRvIGhhdmUgYSBnZXR0ZXIgZnVuY3Rpb24gYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgd2UgbmVlZCB0byBjYXRjaCBpdCBoZXJlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXMuc29ydChmdW5jdGlvbiAodjEsIHYyKSB7IHJldHVybiB2MS5jb21wYXJlVG8odjIpOyB9KTtcclxuICAgIH07XHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cclxuICAgIFZlcnNpb25zLnYxXzAgPSBuZXcgVmVyc2lvbigxLCAwKTtcclxuICAgIFZlcnNpb25zLnYxXzEgPSBuZXcgVmVyc2lvbigxLCAxKTtcclxuICAgIFZlcnNpb25zLnYxXzIgPSBuZXcgVmVyc2lvbigxLCAyKTtcclxuICAgIFZlcnNpb25zLnYxXzMgPSBuZXcgVmVyc2lvbigxLCAzKTtcclxuICAgIFZlcnNpb25zLnYxXzQgPSBuZXcgVmVyc2lvbigxLCA0KTtcclxuICAgIFZlcnNpb25zLnYxXzUgPSBuZXcgVmVyc2lvbigxLCA1KTtcclxuICAgIC8vIElmIHByZXZpZXcgdGFnIGlzIGFkZGVkL3JlbW92ZWQgZnJvbSBhbnkgdmVyc2lvbixcclxuICAgIC8vIGRvbid0IGZvcmdldCB0byB1cGRhdGUgLmFjLXNjaGVtYS12ZXJzaW9uLTEtPzo6YWZ0ZXIgdG9vIGluIGFkYXB0aXZlY2FyZHMtc2l0ZVxcdGhlbWVzXFxhZGFwdGl2ZWNhcmRzXFxzb3VyY2VcXGNzc1xcc3R5bGUuY3NzXHJcbiAgICBWZXJzaW9ucy52MV82ID0gbmV3IFZlcnNpb24oMSwgNiwgXCIxLjYgUHJldmlld1wiKTtcclxuICAgIFZlcnNpb25zLmxhdGVzdCA9IFZlcnNpb25zLnYxXzU7XHJcbiAgICByZXR1cm4gVmVyc2lvbnM7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVmVyc2lvbnMgPSBWZXJzaW9ucztcclxuZnVuY3Rpb24gaXNWZXJzaW9uTGVzc09yRXF1YWwodmVyc2lvbiwgdGFyZ2V0VmVyc2lvbikge1xyXG4gICAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBWZXJzaW9uKSB7XHJcbiAgICAgICAgaWYgKHRhcmdldFZlcnNpb24gaW5zdGFuY2VvZiBWZXJzaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRWZXJzaW9uLmNvbXBhcmVUbyh2ZXJzaW9uKSA+PSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGFyZ2V0IHZlcnNpb24gaXMgKlxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBWZXJzaW9uIGlzICpcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmlzVmVyc2lvbkxlc3NPckVxdWFsID0gaXNWZXJzaW9uTGVzc09yRXF1YWw7XHJcbnZhciBCYXNlU2VyaWFsaXphdGlvbkNvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCYXNlU2VyaWFsaXphdGlvbkNvbnRleHQodGFyZ2V0VmVyc2lvbikge1xyXG4gICAgICAgIGlmICh0YXJnZXRWZXJzaW9uID09PSB2b2lkIDApIHsgdGFyZ2V0VmVyc2lvbiA9IFZlcnNpb25zLmxhdGVzdDsgfVxyXG4gICAgICAgIHRoaXMuX3ZhbGlkYXRpb25FdmVudHMgPSBbXTtcclxuICAgICAgICB0aGlzLnRhcmdldFZlcnNpb24gPSB0YXJnZXRWZXJzaW9uO1xyXG4gICAgfVxyXG4gICAgQmFzZVNlcmlhbGl6YXRpb25Db250ZXh0LnByb3RvdHlwZS5zZXJpYWxpemVWYWx1ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSwgZGVmYXVsdFZhbHVlLCBmb3JjZURlbGV0ZUlmTnVsbE9yRGVmYXVsdCkge1xyXG4gICAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT09IHZvaWQgMCkgeyBkZWZhdWx0VmFsdWUgPSB1bmRlZmluZWQ7IH1cclxuICAgICAgICBpZiAoZm9yY2VEZWxldGVJZk51bGxPckRlZmF1bHQgPT09IHZvaWQgMCkgeyBmb3JjZURlbGV0ZUlmTnVsbE9yRGVmYXVsdCA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKHByb3BlcnR5VmFsdWUgPT09IG51bGwgfHxcclxuICAgICAgICAgICAgcHJvcGVydHlWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgIHByb3BlcnR5VmFsdWUgPT09IGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAoIXNoYXJlZF8xLkdsb2JhbFNldHRpbmdzLmVuYWJsZUZ1bGxKc29uUm91bmRUcmlwIHx8IGZvcmNlRGVsZXRlSWZOdWxsT3JEZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5TmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJvcGVydHlWYWx1ZSA9PT0gZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcGVydHlOYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRhcmdldFtwcm9wZXJ0eU5hbWVdID0gcHJvcGVydHlWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQmFzZVNlcmlhbGl6YXRpb25Db250ZXh0LnByb3RvdHlwZS5zZXJpYWxpemVTdHJpbmcgPSBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGlmIChwcm9wZXJ0eVZhbHVlID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgIHByb3BlcnR5VmFsdWUgPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICBwcm9wZXJ0eVZhbHVlID09PSBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKCFzaGFyZWRfMS5HbG9iYWxTZXR0aW5ncy5lbmFibGVGdWxsSnNvblJvdW5kVHJpcCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRhcmdldFtwcm9wZXJ0eU5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0YXJnZXRbcHJvcGVydHlOYW1lXSA9IHByb3BlcnR5VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJhc2VTZXJpYWxpemF0aW9uQ29udGV4dC5wcm90b3R5cGUuc2VyaWFsaXplQm9vbCA9IGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHByb3BlcnR5VmFsdWUgPT09IG51bGwgfHxcclxuICAgICAgICAgICAgcHJvcGVydHlWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgIHByb3BlcnR5VmFsdWUgPT09IGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAoIXNoYXJlZF8xLkdsb2JhbFNldHRpbmdzLmVuYWJsZUZ1bGxKc29uUm91bmRUcmlwKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5TmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRhcmdldFtwcm9wZXJ0eU5hbWVdID0gcHJvcGVydHlWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQmFzZVNlcmlhbGl6YXRpb25Db250ZXh0LnByb3RvdHlwZS5zZXJpYWxpemVOdW1iZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGlmIChwcm9wZXJ0eVZhbHVlID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgIHByb3BlcnR5VmFsdWUgPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICBwcm9wZXJ0eVZhbHVlID09PSBkZWZhdWx0VmFsdWUgfHxcclxuICAgICAgICAgICAgaXNOYU4ocHJvcGVydHlWYWx1ZSkpIHtcclxuICAgICAgICAgICAgaWYgKCFzaGFyZWRfMS5HbG9iYWxTZXR0aW5ncy5lbmFibGVGdWxsSnNvblJvdW5kVHJpcCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRhcmdldFtwcm9wZXJ0eU5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0YXJnZXRbcHJvcGVydHlOYW1lXSA9IHByb3BlcnR5VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJhc2VTZXJpYWxpemF0aW9uQ29udGV4dC5wcm90b3R5cGUuc2VyaWFsaXplRW51bSA9IGZ1bmN0aW9uIChlbnVtVHlwZSwgdGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT09IHZvaWQgMCkgeyBkZWZhdWx0VmFsdWUgPSB1bmRlZmluZWQ7IH1cclxuICAgICAgICBpZiAocHJvcGVydHlWYWx1ZSA9PT0gbnVsbCB8fFxyXG4gICAgICAgICAgICBwcm9wZXJ0eVZhbHVlID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgcHJvcGVydHlWYWx1ZSA9PT0gZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICghc2hhcmVkXzEuR2xvYmFsU2V0dGluZ3MuZW5hYmxlRnVsbEpzb25Sb3VuZFRyaXApIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcGVydHlOYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5TmFtZV0gPSBlbnVtVHlwZVtwcm9wZXJ0eVZhbHVlXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQmFzZVNlcmlhbGl6YXRpb25Db250ZXh0LnByb3RvdHlwZS5zZXJpYWxpemVBcnJheSA9IGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSkge1xyXG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xyXG4gICAgICAgIGlmIChwcm9wZXJ0eVZhbHVlKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgcHJvcGVydHlWYWx1ZV8xID0gcHJvcGVydHlWYWx1ZTsgX2kgPCBwcm9wZXJ0eVZhbHVlXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHByb3BlcnR5VmFsdWVfMVtfaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWFsaXplZEl0ZW0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFNlcmlhbGl6YWJsZU9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRJdGVtID0gaXRlbS50b0pTT04odGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpdGVtLnRvSlNPTikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRJdGVtID0gaXRlbS50b0pTT04oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRJdGVtID0gaXRlbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVkSXRlbSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChzZXJpYWxpemVkSXRlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkgJiYgQXJyYXkuaXNBcnJheSh0YXJnZXRbcHJvcGVydHlOYW1lXSkpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcGVydHlOYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVWYWx1ZSh0YXJnZXQsIHByb3BlcnR5TmFtZSwgaXRlbXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCYXNlU2VyaWFsaXphdGlvbkNvbnRleHQucHJvdG90eXBlLmNsZWFyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3ZhbGlkYXRpb25FdmVudHMgPSBbXTtcclxuICAgIH07XHJcbiAgICBCYXNlU2VyaWFsaXphdGlvbkNvbnRleHQucHJvdG90eXBlLmxvZ0V2ZW50ID0gZnVuY3Rpb24gKHNvdXJjZSwgcGhhc2UsIGV2ZW50LCBtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5fdmFsaWRhdGlvbkV2ZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXHJcbiAgICAgICAgICAgIHBoYXNlOiBwaGFzZSxcclxuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQmFzZVNlcmlhbGl6YXRpb25Db250ZXh0LnByb3RvdHlwZS5sb2dQYXJzZUV2ZW50ID0gZnVuY3Rpb24gKHNvdXJjZSwgZXZlbnQsIG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLmxvZ0V2ZW50KHNvdXJjZSwgRW51bXMuVmFsaWRhdGlvblBoYXNlLlBhcnNlLCBldmVudCwgbWVzc2FnZSk7XHJcbiAgICB9O1xyXG4gICAgQmFzZVNlcmlhbGl6YXRpb25Db250ZXh0LnByb3RvdHlwZS5nZXRFdmVudEF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRpb25FdmVudHNbaW5kZXhdO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlU2VyaWFsaXphdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImV2ZW50Q291bnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGlvbkV2ZW50cy5sZW5ndGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIEJhc2VTZXJpYWxpemF0aW9uQ29udGV4dDtcclxufSgpKTtcclxuZXhwb3J0cy5CYXNlU2VyaWFsaXphdGlvbkNvbnRleHQgPSBCYXNlU2VyaWFsaXphdGlvbkNvbnRleHQ7XHJcbnZhciBTaW1wbGVTZXJpYWxpemF0aW9uQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTaW1wbGVTZXJpYWxpemF0aW9uQ29udGV4dCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNpbXBsZVNlcmlhbGl6YXRpb25Db250ZXh0KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBTaW1wbGVTZXJpYWxpemF0aW9uQ29udGV4dDtcclxufShCYXNlU2VyaWFsaXphdGlvbkNvbnRleHQpKTtcclxudmFyIFByb3BlcnR5RGVmaW5pdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByb3BlcnR5RGVmaW5pdGlvbih0YXJnZXRWZXJzaW9uLCBuYW1lLCBkZWZhdWx0VmFsdWUsIG9uR2V0SW5pdGlhbFZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXRWZXJzaW9uID0gdGFyZ2V0VmVyc2lvbjtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIHRoaXMub25HZXRJbml0aWFsVmFsdWUgPSBvbkdldEluaXRpYWxWYWx1ZTtcclxuICAgICAgICB0aGlzLmlzU2VyaWFsaXphdGlvbkVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2VxdWVudGlhbE51bWJlciA9IFByb3BlcnR5RGVmaW5pdGlvbi5fc2VxdWVudGlhbE51bWJlcjtcclxuICAgICAgICBQcm9wZXJ0eURlZmluaXRpb24uX3NlcXVlbnRpYWxOdW1iZXIrKztcclxuICAgIH1cclxuICAgIFByb3BlcnR5RGVmaW5pdGlvbi5wcm90b3R5cGUuZ2V0SW50ZXJuYWxOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XHJcbiAgICB9O1xyXG4gICAgUHJvcGVydHlEZWZpbml0aW9uLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzZW5kZXIsIHNvdXJjZSwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2VbdGhpcy5uYW1lXTtcclxuICAgIH07XHJcbiAgICBQcm9wZXJ0eURlZmluaXRpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChzZW5kZXIsIHRhcmdldCwgdmFsdWUsIGNvbnRleHQpIHtcclxuICAgICAgICBjb250ZXh0LnNlcmlhbGl6ZVZhbHVlKHRhcmdldCwgdGhpcy5uYW1lLCB2YWx1ZSwgdGhpcy5kZWZhdWx0VmFsdWUpO1xyXG4gICAgfTtcclxuICAgIFByb3BlcnR5RGVmaW5pdGlvbi5fc2VxdWVudGlhbE51bWJlciA9IDA7XHJcbiAgICByZXR1cm4gUHJvcGVydHlEZWZpbml0aW9uO1xyXG59KCkpO1xyXG5leHBvcnRzLlByb3BlcnR5RGVmaW5pdGlvbiA9IFByb3BlcnR5RGVmaW5pdGlvbjtcclxudmFyIFN0cmluZ1Byb3BlcnR5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFN0cmluZ1Byb3BlcnR5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU3RyaW5nUHJvcGVydHkodGFyZ2V0VmVyc2lvbiwgbmFtZSwgdHJlYXRFbXB0eUFzVW5kZWZpbmVkLCByZWdFeCwgZGVmYXVsdFZhbHVlLCBvbkdldEluaXRpYWxWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0cmVhdEVtcHR5QXNVbmRlZmluZWQgPT09IHZvaWQgMCkgeyB0cmVhdEVtcHR5QXNVbmRlZmluZWQgPSB0cnVlOyB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdGFyZ2V0VmVyc2lvbiwgbmFtZSwgZGVmYXVsdFZhbHVlLCBvbkdldEluaXRpYWxWYWx1ZSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy50YXJnZXRWZXJzaW9uID0gdGFyZ2V0VmVyc2lvbjtcclxuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICBfdGhpcy50cmVhdEVtcHR5QXNVbmRlZmluZWQgPSB0cmVhdEVtcHR5QXNVbmRlZmluZWQ7XHJcbiAgICAgICAgX3RoaXMucmVnRXggPSByZWdFeDtcclxuICAgICAgICBfdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgX3RoaXMub25HZXRJbml0aWFsVmFsdWUgPSBvbkdldEluaXRpYWxWYWx1ZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBTdHJpbmdQcm9wZXJ0eS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc2VuZGVyLCBzb3VyY2UsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgcGFyc2VkVmFsdWUgPSBVdGlscy5wYXJzZVN0cmluZyhzb3VyY2VbdGhpcy5uYW1lXSwgdGhpcy5kZWZhdWx0VmFsdWUpO1xyXG4gICAgICAgIHZhciBpc1VuZGVmaW5lZCA9IHBhcnNlZFZhbHVlID09PSB1bmRlZmluZWQgfHwgKHBhcnNlZFZhbHVlID09PSBcIlwiICYmIHRoaXMudHJlYXRFbXB0eUFzVW5kZWZpbmVkKTtcclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkICYmIHRoaXMucmVnRXggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHRoaXMucmVnRXguZXhlYyhwYXJzZWRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICghbWF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5sb2dQYXJzZUV2ZW50KHNlbmRlciwgRW51bXMuVmFsaWRhdGlvbkV2ZW50LkludmFsaWRQcm9wZXJ0eVZhbHVlLCBzdHJpbmdzXzEuU3RyaW5ncy5lcnJvcnMuaW52YWxpZFByb3BlcnR5VmFsdWUocGFyc2VkVmFsdWUsIHRoaXMubmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyc2VkVmFsdWU7XHJcbiAgICB9O1xyXG4gICAgU3RyaW5nUHJvcGVydHkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChzZW5kZXIsIHRhcmdldCwgdmFsdWUsIGNvbnRleHQpIHtcclxuICAgICAgICBjb250ZXh0LnNlcmlhbGl6ZVN0cmluZyh0YXJnZXQsIHRoaXMubmFtZSwgdmFsdWUgPT09IFwiXCIgJiYgdGhpcy50cmVhdEVtcHR5QXNVbmRlZmluZWQgPyB1bmRlZmluZWQgOiB2YWx1ZSwgdGhpcy5kZWZhdWx0VmFsdWUpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTdHJpbmdQcm9wZXJ0eTtcclxufShQcm9wZXJ0eURlZmluaXRpb24pKTtcclxuZXhwb3J0cy5TdHJpbmdQcm9wZXJ0eSA9IFN0cmluZ1Byb3BlcnR5O1xyXG52YXIgQm9vbFByb3BlcnR5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEJvb2xQcm9wZXJ0eSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJvb2xQcm9wZXJ0eSh0YXJnZXRWZXJzaW9uLCBuYW1lLCBkZWZhdWx0VmFsdWUsIG9uR2V0SW5pdGlhbFZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdGFyZ2V0VmVyc2lvbiwgbmFtZSwgZGVmYXVsdFZhbHVlLCBvbkdldEluaXRpYWxWYWx1ZSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy50YXJnZXRWZXJzaW9uID0gdGFyZ2V0VmVyc2lvbjtcclxuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICBfdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgX3RoaXMub25HZXRJbml0aWFsVmFsdWUgPSBvbkdldEluaXRpYWxWYWx1ZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBCb29sUHJvcGVydHkucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNlbmRlciwgc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIFV0aWxzLnBhcnNlQm9vbChzb3VyY2VbdGhpcy5uYW1lXSwgdGhpcy5kZWZhdWx0VmFsdWUpO1xyXG4gICAgfTtcclxuICAgIEJvb2xQcm9wZXJ0eS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKHNlbmRlciwgdGFyZ2V0LCB2YWx1ZSwgY29udGV4dCkge1xyXG4gICAgICAgIGNvbnRleHQuc2VyaWFsaXplQm9vbCh0YXJnZXQsIHRoaXMubmFtZSwgdmFsdWUsIHRoaXMuZGVmYXVsdFZhbHVlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQm9vbFByb3BlcnR5O1xyXG59KFByb3BlcnR5RGVmaW5pdGlvbikpO1xyXG5leHBvcnRzLkJvb2xQcm9wZXJ0eSA9IEJvb2xQcm9wZXJ0eTtcclxudmFyIE51bVByb3BlcnR5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE51bVByb3BlcnR5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTnVtUHJvcGVydHkodGFyZ2V0VmVyc2lvbiwgbmFtZSwgZGVmYXVsdFZhbHVlLCBvbkdldEluaXRpYWxWYWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRhcmdldFZlcnNpb24sIG5hbWUsIGRlZmF1bHRWYWx1ZSwgb25HZXRJbml0aWFsVmFsdWUpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudGFyZ2V0VmVyc2lvbiA9IHRhcmdldFZlcnNpb247XHJcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgX3RoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIF90aGlzLm9uR2V0SW5pdGlhbFZhbHVlID0gb25HZXRJbml0aWFsVmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTnVtUHJvcGVydHkucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNlbmRlciwgc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIFV0aWxzLnBhcnNlTnVtYmVyKHNvdXJjZVt0aGlzLm5hbWVdLCB0aGlzLmRlZmF1bHRWYWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgTnVtUHJvcGVydHkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChzZW5kZXIsIHRhcmdldCwgdmFsdWUsIGNvbnRleHQpIHtcclxuICAgICAgICBjb250ZXh0LnNlcmlhbGl6ZU51bWJlcih0YXJnZXQsIHRoaXMubmFtZSwgdmFsdWUsIHRoaXMuZGVmYXVsdFZhbHVlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTnVtUHJvcGVydHk7XHJcbn0oUHJvcGVydHlEZWZpbml0aW9uKSk7XHJcbmV4cG9ydHMuTnVtUHJvcGVydHkgPSBOdW1Qcm9wZXJ0eTtcclxudmFyIFBpeGVsU2l6ZVByb3BlcnR5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFBpeGVsU2l6ZVByb3BlcnR5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUGl4ZWxTaXplUHJvcGVydHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgUGl4ZWxTaXplUHJvcGVydHkucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNlbmRlciwgc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbdGhpcy5uYW1lXTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHZhciBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IHNoYXJlZF8xLlNpemVBbmRVbml0LnBhcnNlKHZhbHVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChzaXplLnVuaXQgPT09IEVudW1zLlNpemVVbml0LlBpeGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2l6ZS5waHlzaWNhbFNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nLiBBIHBhcnNlIGVycm9yIGlzIGVtaXR0ZWQgYmVsb3dcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQubG9nUGFyc2VFdmVudChzZW5kZXIsIEVudW1zLlZhbGlkYXRpb25FdmVudC5JbnZhbGlkUHJvcGVydHlWYWx1ZSwgc3RyaW5nc18xLlN0cmluZ3MuZXJyb3JzLmludmFsaWRQcm9wZXJ0eVZhbHVlKHNvdXJjZVt0aGlzLm5hbWVdLCBcIm1pbkhlaWdodFwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBQaXhlbFNpemVQcm9wZXJ0eS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKHNlbmRlciwgdGFyZ2V0LCB2YWx1ZSwgY29udGV4dCkge1xyXG4gICAgICAgIGNvbnRleHQuc2VyaWFsaXplVmFsdWUodGFyZ2V0LCB0aGlzLm5hbWUsIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4odmFsdWUpID8gdmFsdWUgKyBcInB4XCIgOiB1bmRlZmluZWQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQaXhlbFNpemVQcm9wZXJ0eTtcclxufShQcm9wZXJ0eURlZmluaXRpb24pKTtcclxuZXhwb3J0cy5QaXhlbFNpemVQcm9wZXJ0eSA9IFBpeGVsU2l6ZVByb3BlcnR5O1xyXG52YXIgU3RyaW5nQXJyYXlQcm9wZXJ0eSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTdHJpbmdBcnJheVByb3BlcnR5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU3RyaW5nQXJyYXlQcm9wZXJ0eSh0YXJnZXRWZXJzaW9uLCBuYW1lLCBkZWZhdWx0VmFsdWUsIG9uR2V0SW5pdGlhbFZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdGFyZ2V0VmVyc2lvbiwgbmFtZSwgZGVmYXVsdFZhbHVlLCBvbkdldEluaXRpYWxWYWx1ZSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy50YXJnZXRWZXJzaW9uID0gdGFyZ2V0VmVyc2lvbjtcclxuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICBfdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgX3RoaXMub25HZXRJbml0aWFsVmFsdWUgPSBvbkdldEluaXRpYWxWYWx1ZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBTdHJpbmdBcnJheVByb3BlcnR5LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzZW5kZXIsIHNvdXJjZSwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBzb3VyY2VWYWx1ZSA9IHNvdXJjZVt0aGlzLm5hbWVdO1xyXG4gICAgICAgIGlmIChzb3VyY2VWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICFBcnJheS5pc0FycmF5KHNvdXJjZVZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNvdXJjZVZhbHVlXzEgPSBzb3VyY2VWYWx1ZTsgX2kgPCBzb3VyY2VWYWx1ZV8xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VWYWx1ZV8xW19pXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5sb2dQYXJzZUV2ZW50KHNlbmRlciwgRW51bXMuVmFsaWRhdGlvbkV2ZW50LkludmFsaWRQcm9wZXJ0eVZhbHVlLCBcIkludmFsaWQgYXJyYXkgdmFsdWUgXFxcIlwiLmNvbmNhdChKU09OLnN0cmluZ2lmeSh2YWx1ZSksIFwiXFxcIiBvZiB0eXBlIFxcXCJcIikuY29uY2F0KHR5cGVvZiB2YWx1ZSwgXCJcXFwiIGlnbm9yZWQgZm9yIFxcXCJcIikuY29uY2F0KHRoaXMubmFtZSwgXCJcXFwiLlwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBTdHJpbmdBcnJheVByb3BlcnR5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoc2VuZGVyLCB0YXJnZXQsIHZhbHVlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgY29udGV4dC5zZXJpYWxpemVBcnJheSh0YXJnZXQsIHRoaXMubmFtZSwgdmFsdWUpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTdHJpbmdBcnJheVByb3BlcnR5O1xyXG59KFByb3BlcnR5RGVmaW5pdGlvbikpO1xyXG5leHBvcnRzLlN0cmluZ0FycmF5UHJvcGVydHkgPSBTdHJpbmdBcnJheVByb3BlcnR5O1xyXG52YXIgVmFsdWVTZXRQcm9wZXJ0eSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhWYWx1ZVNldFByb3BlcnR5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVmFsdWVTZXRQcm9wZXJ0eSh0YXJnZXRWZXJzaW9uLCBuYW1lLCB2YWx1ZXMsIGRlZmF1bHRWYWx1ZSwgb25HZXRJbml0aWFsVmFsdWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0YXJnZXRWZXJzaW9uLCBuYW1lLCBkZWZhdWx0VmFsdWUsIG9uR2V0SW5pdGlhbFZhbHVlKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnRhcmdldFZlcnNpb24gPSB0YXJnZXRWZXJzaW9uO1xyXG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIF90aGlzLnZhbHVlcyA9IHZhbHVlcztcclxuICAgICAgICBfdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgX3RoaXMub25HZXRJbml0aWFsVmFsdWUgPSBvbkdldEluaXRpYWxWYWx1ZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBWYWx1ZVNldFByb3BlcnR5LnByb3RvdHlwZS5pc1ZhbGlkVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy52YWx1ZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB2ZXJzaW9uZWRWYWx1ZSA9IF9hW19pXTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IHZlcnNpb25lZFZhbHVlLnZhbHVlLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRWZXJzaW9uID0gdmVyc2lvbmVkVmFsdWUudGFyZ2V0VmVyc2lvblxyXG4gICAgICAgICAgICAgICAgICAgID8gdmVyc2lvbmVkVmFsdWUudGFyZ2V0VmVyc2lvblxyXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy50YXJnZXRWZXJzaW9uO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFZlcnNpb24uY29tcGFyZVRvKGNvbnRleHQudGFyZ2V0VmVyc2lvbikgPD0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgVmFsdWVTZXRQcm9wZXJ0eS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc2VuZGVyLCBzb3VyY2UsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgc291cmNlVmFsdWUgPSBzb3VyY2VbdGhpcy5uYW1lXTtcclxuICAgICAgICBpZiAoc291cmNlVmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMudmFsdWVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnNpb25lZFZhbHVlID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IHZlcnNpb25lZFZhbHVlLnZhbHVlLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VmVyc2lvbiA9IHZlcnNpb25lZFZhbHVlLnRhcmdldFZlcnNpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB2ZXJzaW9uZWRWYWx1ZS50YXJnZXRWZXJzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy50YXJnZXRWZXJzaW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRWZXJzaW9uLmNvbXBhcmVUbyhjb250ZXh0LnRhcmdldFZlcnNpb24pIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb25lZFZhbHVlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5sb2dQYXJzZUV2ZW50KHNlbmRlciwgRW51bXMuVmFsaWRhdGlvbkV2ZW50LkludmFsaWRQcm9wZXJ0eVZhbHVlLCBzdHJpbmdzXzEuU3RyaW5ncy5lcnJvcnMucHJvcGVydHlWYWx1ZU5vdFN1cHBvcnRlZChzb3VyY2VWYWx1ZSwgdGhpcy5uYW1lLCB0YXJnZXRWZXJzaW9uLnRvU3RyaW5nKCksIGNvbnRleHQudGFyZ2V0VmVyc2lvbi50b1N0cmluZygpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGV4dC5sb2dQYXJzZUV2ZW50KHNlbmRlciwgRW51bXMuVmFsaWRhdGlvbkV2ZW50LkludmFsaWRQcm9wZXJ0eVZhbHVlLCBzdHJpbmdzXzEuU3RyaW5ncy5lcnJvcnMuaW52YWxpZFByb3BlcnR5VmFsdWUoc291cmNlVmFsdWUsIHRoaXMubmFtZSkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRWYWx1ZTtcclxuICAgIH07XHJcbiAgICBWYWx1ZVNldFByb3BlcnR5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoc2VuZGVyLCB0YXJnZXQsIHZhbHVlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGludmFsaWRWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGludmFsaWRWYWx1ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnZhbHVlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB2ZXJzaW9uZWRWYWx1ZSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uZWRWYWx1ZS52YWx1ZSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VmVyc2lvbiA9IHZlcnNpb25lZFZhbHVlLnRhcmdldFZlcnNpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB2ZXJzaW9uZWRWYWx1ZS50YXJnZXRWZXJzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy50YXJnZXRWZXJzaW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRWZXJzaW9uLmNvbXBhcmVUbyhjb250ZXh0LnRhcmdldFZlcnNpb24pIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZFZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5sb2dFdmVudChzZW5kZXIsIEVudW1zLlZhbGlkYXRpb25QaGFzZS5Ub0pTT04sIEVudW1zLlZhbGlkYXRpb25FdmVudC5JbnZhbGlkUHJvcGVydHlWYWx1ZSwgc3RyaW5nc18xLlN0cmluZ3MuZXJyb3JzLnByb3BlcnR5VmFsdWVOb3RTdXBwb3J0ZWQodmFsdWUsIHRoaXMubmFtZSwgdGFyZ2V0VmVyc2lvbi50b1N0cmluZygpLCBjb250ZXh0LnRhcmdldFZlcnNpb24udG9TdHJpbmcoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWludmFsaWRWYWx1ZSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LnNlcmlhbGl6ZVZhbHVlKHRhcmdldCwgdGhpcy5uYW1lLCB2YWx1ZSwgdGhpcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gVmFsdWVTZXRQcm9wZXJ0eTtcclxufShQcm9wZXJ0eURlZmluaXRpb24pKTtcclxuZXhwb3J0cy5WYWx1ZVNldFByb3BlcnR5ID0gVmFsdWVTZXRQcm9wZXJ0eTtcclxudmFyIEVudW1Qcm9wZXJ0eSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhFbnVtUHJvcGVydHksIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBFbnVtUHJvcGVydHkodGFyZ2V0VmVyc2lvbiwgbmFtZSwgZW51bVR5cGUsIGRlZmF1bHRWYWx1ZSwgdmFsdWVzLCBvbkdldEluaXRpYWxWYWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRhcmdldFZlcnNpb24sIG5hbWUsIGRlZmF1bHRWYWx1ZSwgb25HZXRJbml0aWFsVmFsdWUpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudGFyZ2V0VmVyc2lvbiA9IHRhcmdldFZlcnNpb247XHJcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgX3RoaXMuZW51bVR5cGUgPSBlbnVtVHlwZTtcclxuICAgICAgICBfdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgX3RoaXMub25HZXRJbml0aWFsVmFsdWUgPSBvbkdldEluaXRpYWxWYWx1ZTtcclxuICAgICAgICBfdGhpcy5fdmFsdWVzID0gW107XHJcbiAgICAgICAgaWYgKCF2YWx1ZXMpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZW51bVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlBc051bWJlciA9IHBhcnNlSW50KGtleSwgMTApO1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleUFzTnVtYmVyID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdmFsdWVzLnB1c2goeyB2YWx1ZToga2V5QXNOdW1iZXIgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF90aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEVudW1Qcm9wZXJ0eS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc2VuZGVyLCBzb3VyY2UsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgc291cmNlVmFsdWUgPSBzb3VyY2VbdGhpcy5uYW1lXTtcclxuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVZhbHVlICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGVudW1WYWx1ZSA9IFV0aWxzLmdldEVudW1WYWx1ZUJ5TmFtZSh0aGlzLmVudW1UeXBlLCBzb3VyY2VWYWx1ZSk7XHJcbiAgICAgICAgaWYgKGVudW1WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnZhbHVlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB2ZXJzaW9uZWRWYWx1ZSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uZWRWYWx1ZS52YWx1ZSA9PT0gZW51bVZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldFZlcnNpb24gPSB2ZXJzaW9uZWRWYWx1ZS50YXJnZXRWZXJzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmVyc2lvbmVkVmFsdWUudGFyZ2V0VmVyc2lvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMudGFyZ2V0VmVyc2lvbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0VmVyc2lvbi5jb21wYXJlVG8oY29udGV4dC50YXJnZXRWZXJzaW9uKSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnVtVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmxvZ1BhcnNlRXZlbnQoc2VuZGVyLCBFbnVtcy5WYWxpZGF0aW9uRXZlbnQuSW52YWxpZFByb3BlcnR5VmFsdWUsIHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy5wcm9wZXJ0eVZhbHVlTm90U3VwcG9ydGVkKHNvdXJjZVZhbHVlLCB0aGlzLm5hbWUsIHRhcmdldFZlcnNpb24udG9TdHJpbmcoKSwgY29udGV4dC50YXJnZXRWZXJzaW9uLnRvU3RyaW5nKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb250ZXh0LmxvZ1BhcnNlRXZlbnQoc2VuZGVyLCBFbnVtcy5WYWxpZGF0aW9uRXZlbnQuSW52YWxpZFByb3BlcnR5VmFsdWUsIHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy5pbnZhbGlkUHJvcGVydHlWYWx1ZShzb3VyY2VWYWx1ZSwgdGhpcy5uYW1lKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFZhbHVlO1xyXG4gICAgfTtcclxuICAgIEVudW1Qcm9wZXJ0eS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKHNlbmRlciwgdGFyZ2V0LCB2YWx1ZSwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBpbnZhbGlkVmFsdWUgPSBmYWxzZTtcclxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpbnZhbGlkVmFsdWUgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy52YWx1ZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmVyc2lvbmVkVmFsdWUgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbmVkVmFsdWUudmFsdWUgPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldFZlcnNpb24gPSB2ZXJzaW9uZWRWYWx1ZS50YXJnZXRWZXJzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmVyc2lvbmVkVmFsdWUudGFyZ2V0VmVyc2lvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMudGFyZ2V0VmVyc2lvbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0VmVyc2lvbi5jb21wYXJlVG8oY29udGV4dC50YXJnZXRWZXJzaW9uKSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubG9nRXZlbnQoc2VuZGVyLCBFbnVtcy5WYWxpZGF0aW9uUGhhc2UuVG9KU09OLCBFbnVtcy5WYWxpZGF0aW9uRXZlbnQuSW52YWxpZFByb3BlcnR5VmFsdWUsIHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy5pbnZhbGlkUHJvcGVydHlWYWx1ZSh2YWx1ZSwgdGhpcy5uYW1lKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaW52YWxpZFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2VyaWFsaXplRW51bSh0aGlzLmVudW1UeXBlLCB0YXJnZXQsIHRoaXMubmFtZSwgdmFsdWUsIHRoaXMuZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVudW1Qcm9wZXJ0eS5wcm90b3R5cGUsIFwidmFsdWVzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gRW51bVByb3BlcnR5O1xyXG59KFByb3BlcnR5RGVmaW5pdGlvbikpO1xyXG5leHBvcnRzLkVudW1Qcm9wZXJ0eSA9IEVudW1Qcm9wZXJ0eTtcclxudmFyIFNlcmlhbGl6YWJsZU9iamVjdFByb3BlcnR5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNlcmlhbGl6YWJsZU9iamVjdFByb3BlcnR5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU2VyaWFsaXphYmxlT2JqZWN0UHJvcGVydHkodGFyZ2V0VmVyc2lvbiwgbmFtZSwgb2JqZWN0VHlwZSwgbnVsbGFibGUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGlmIChudWxsYWJsZSA9PT0gdm9pZCAwKSB7IG51bGxhYmxlID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0YXJnZXRWZXJzaW9uLCBuYW1lLCBkZWZhdWx0VmFsdWUsIGZ1bmN0aW9uIChzZW5kZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm51bGxhYmxlID8gdW5kZWZpbmVkIDogbmV3IF90aGlzLm9iamVjdFR5cGUoKTtcclxuICAgICAgICB9KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnRhcmdldFZlcnNpb24gPSB0YXJnZXRWZXJzaW9uO1xyXG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIF90aGlzLm9iamVjdFR5cGUgPSBvYmplY3RUeXBlO1xyXG4gICAgICAgIF90aGlzLm51bGxhYmxlID0gbnVsbGFibGU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgU2VyaWFsaXphYmxlT2JqZWN0UHJvcGVydHkucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNlbmRlciwgc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZVZhbHVlID0gc291cmNlW3RoaXMubmFtZV07XHJcbiAgICAgICAgaWYgKHNvdXJjZVZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25HZXRJbml0aWFsVmFsdWUgPyB0aGlzLm9uR2V0SW5pdGlhbFZhbHVlKHNlbmRlcikgOiB0aGlzLmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyB0aGlzLm9iamVjdFR5cGUoKTtcclxuICAgICAgICByZXN1bHQucGFyc2Uoc291cmNlVmFsdWUsIGNvbnRleHQpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgU2VyaWFsaXphYmxlT2JqZWN0UHJvcGVydHkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChzZW5kZXIsIHRhcmdldCwgdmFsdWUsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgc2VyaWFsaXplZFZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICF2YWx1ZS5oYXNBbGxEZWZhdWx0VmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgc2VyaWFsaXplZFZhbHVlID0gdmFsdWUudG9KU09OKGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHNlcmlhbGl6ZWRWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhzZXJpYWxpemVkVmFsdWUpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBzZXJpYWxpemVkVmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHQuc2VyaWFsaXplVmFsdWUodGFyZ2V0LCB0aGlzLm5hbWUsIHNlcmlhbGl6ZWRWYWx1ZSwgdGhpcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTZXJpYWxpemFibGVPYmplY3RQcm9wZXJ0eTtcclxufShQcm9wZXJ0eURlZmluaXRpb24pKTtcclxuZXhwb3J0cy5TZXJpYWxpemFibGVPYmplY3RQcm9wZXJ0eSA9IFNlcmlhbGl6YWJsZU9iamVjdFByb3BlcnR5O1xyXG52YXIgU2VyaWFsaXphYmxlT2JqZWN0Q29sbGVjdGlvblByb3BlcnR5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNlcmlhbGl6YWJsZU9iamVjdENvbGxlY3Rpb25Qcm9wZXJ0eSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNlcmlhbGl6YWJsZU9iamVjdENvbGxlY3Rpb25Qcm9wZXJ0eSh0YXJnZXRWZXJzaW9uLCBuYW1lLCBvYmplY3RUeXBlLCBvbkl0ZW1BZGRlZCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRhcmdldFZlcnNpb24sIG5hbWUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHNlbmRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy50YXJnZXRWZXJzaW9uID0gdGFyZ2V0VmVyc2lvbjtcclxuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICBfdGhpcy5vYmplY3RUeXBlID0gb2JqZWN0VHlwZTtcclxuICAgICAgICBfdGhpcy5vbkl0ZW1BZGRlZCA9IG9uSXRlbUFkZGVkO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFNlcmlhbGl6YWJsZU9iamVjdENvbGxlY3Rpb25Qcm9wZXJ0eS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc2VuZGVyLCBzb3VyY2UsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgdmFyIHNvdXJjZUNvbGxlY3Rpb24gPSBzb3VyY2VbdGhpcy5uYW1lXTtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2VDb2xsZWN0aW9uKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNvdXJjZUNvbGxlY3Rpb25fMSA9IHNvdXJjZUNvbGxlY3Rpb247IF9pIDwgc291cmNlQ29sbGVjdGlvbl8xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZUl0ZW0gPSBzb3VyY2VDb2xsZWN0aW9uXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBuZXcgdGhpcy5vYmplY3RUeXBlKCk7XHJcbiAgICAgICAgICAgICAgICBpdGVtLnBhcnNlKHNvdXJjZUl0ZW0sIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbkl0ZW1BZGRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25JdGVtQWRkZWQoc2VuZGVyLCBpdGVtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA+IDBcclxuICAgICAgICAgICAgPyByZXN1bHRcclxuICAgICAgICAgICAgOiB0aGlzLm9uR2V0SW5pdGlhbFZhbHVlXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMub25HZXRJbml0aWFsVmFsdWUoc2VuZGVyKVxyXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgU2VyaWFsaXphYmxlT2JqZWN0Q29sbGVjdGlvblByb3BlcnR5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoc2VuZGVyLCB0YXJnZXQsIHZhbHVlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgY29udGV4dC5zZXJpYWxpemVBcnJheSh0YXJnZXQsIHRoaXMubmFtZSwgdmFsdWUpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTZXJpYWxpemFibGVPYmplY3RDb2xsZWN0aW9uUHJvcGVydHk7XHJcbn0oUHJvcGVydHlEZWZpbml0aW9uKSk7XHJcbmV4cG9ydHMuU2VyaWFsaXphYmxlT2JqZWN0Q29sbGVjdGlvblByb3BlcnR5ID0gU2VyaWFsaXphYmxlT2JqZWN0Q29sbGVjdGlvblByb3BlcnR5O1xyXG52YXIgQ3VzdG9tUHJvcGVydHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ3VzdG9tUHJvcGVydHksIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDdXN0b21Qcm9wZXJ0eSh0YXJnZXRWZXJzaW9uLCBuYW1lLCBvblBhcnNlLCBvblRvSlNPTiwgZGVmYXVsdFZhbHVlLCBvbkdldEluaXRpYWxWYWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRhcmdldFZlcnNpb24sIG5hbWUsIGRlZmF1bHRWYWx1ZSwgb25HZXRJbml0aWFsVmFsdWUpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudGFyZ2V0VmVyc2lvbiA9IHRhcmdldFZlcnNpb247XHJcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgX3RoaXMub25QYXJzZSA9IG9uUGFyc2U7XHJcbiAgICAgICAgX3RoaXMub25Ub0pTT04gPSBvblRvSlNPTjtcclxuICAgICAgICBfdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgX3RoaXMub25HZXRJbml0aWFsVmFsdWUgPSBvbkdldEluaXRpYWxWYWx1ZTtcclxuICAgICAgICBpZiAoIV90aGlzLm9uUGFyc2UpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3VzdG9tUHJvcGVydHlEZWZpbml0aW9uIGluc3RhbmNlcyBtdXN0IGhhdmUgYW4gb25QYXJzZSBoYW5kbGVyLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFfdGhpcy5vblRvSlNPTikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdXN0b21Qcm9wZXJ0eURlZmluaXRpb24gaW5zdGFuY2VzIG11c3QgaGF2ZSBhbiBvblRvSlNPTiBoYW5kbGVyLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQ3VzdG9tUHJvcGVydHkucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNlbmRlciwgc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub25QYXJzZShzZW5kZXIsIHRoaXMsIHNvdXJjZSwgY29udGV4dCk7XHJcbiAgICB9O1xyXG4gICAgQ3VzdG9tUHJvcGVydHkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChzZW5kZXIsIHRhcmdldCwgdmFsdWUsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLm9uVG9KU09OKHNlbmRlciwgdGhpcywgdGFyZ2V0LCB2YWx1ZSwgY29udGV4dCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEN1c3RvbVByb3BlcnR5O1xyXG59KFByb3BlcnR5RGVmaW5pdGlvbikpO1xyXG5leHBvcnRzLkN1c3RvbVByb3BlcnR5ID0gQ3VzdG9tUHJvcGVydHk7XHJcbnZhciBTZXJpYWxpemFibGVPYmplY3RTY2hlbWEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZXJpYWxpemFibGVPYmplY3RTY2hlbWEoKSB7XHJcbiAgICAgICAgdGhpcy5fcHJvcGVydGllcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgU2VyaWFsaXphYmxlT2JqZWN0U2NoZW1hLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Byb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Byb3BlcnRpZXNbaV0gPT09IHByb3ApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH07XHJcbiAgICBTZXJpYWxpemFibGVPYmplY3RTY2hlbWEucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcHJvcGVydGllcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHByb3BlcnRpZXNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBwcm9wZXJ0aWVzXzEgPSBwcm9wZXJ0aWVzOyBfYSA8IHByb3BlcnRpZXNfMS5sZW5ndGg7IF9hKyspIHtcclxuICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wZXJ0aWVzXzFbX2FdO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllcy5wdXNoKHByb3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNlcmlhbGl6YWJsZU9iamVjdFNjaGVtYS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgcHJvcGVydGllc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHByb3BlcnRpZXNfMiA9IHByb3BlcnRpZXM7IF9hIDwgcHJvcGVydGllc18yLmxlbmd0aDsgX2ErKykge1xyXG4gICAgICAgICAgICB2YXIgcHJvcCA9IHByb3BlcnRpZXNfMltfYV07XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YocHJvcCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNlcmlhbGl6YWJsZU9iamVjdFNjaGVtYS5wcm90b3R5cGUuZ2V0SXRlbUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXNbaW5kZXhdO1xyXG4gICAgfTtcclxuICAgIFNlcmlhbGl6YWJsZU9iamVjdFNjaGVtYS5wcm90b3R5cGUuZ2V0Q291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXMubGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTZXJpYWxpemFibGVPYmplY3RTY2hlbWE7XHJcbn0oKSk7XHJcbmV4cG9ydHMuU2VyaWFsaXphYmxlT2JqZWN0U2NoZW1hID0gU2VyaWFsaXphYmxlT2JqZWN0U2NoZW1hO1xyXG4vLyBUaGlzIGlzIGEgZGVjb3JhdG9yIGZ1bmN0aW9uLCB1c2VkIHRvIG1hcCBTZXJpYWxpemFibGVPYmplY3QgZGVzY2VuZGFudCBjbGFzcyBtZW1iZXJzIHRvXHJcbi8vIHNjaGVtYSBwcm9wZXJ0aWVzXHJcbmZ1bmN0aW9uIHByb3BlcnR5KHByb3ApIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KSB8fCB7fTtcclxuICAgICAgICBpZiAoIWRlc2NyaXB0b3IuZ2V0ICYmICFkZXNjcmlwdG9yLnNldCkge1xyXG4gICAgICAgICAgICBkZXNjcmlwdG9yLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlKHByb3ApO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBkZXNjcmlwdG9yLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShwcm9wLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMucHJvcGVydHkgPSBwcm9wZXJ0eTtcclxudmFyIFNlcmlhbGl6YWJsZU9iamVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNlcmlhbGl6YWJsZU9iamVjdCgpIHtcclxuICAgICAgICB0aGlzLl9wcm9wZXJ0eUJhZyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3Jhd1Byb3BlcnRpZXMgPSB7fTtcclxuICAgICAgICB0aGlzLm1heFZlcnNpb24gPSBTZXJpYWxpemFibGVPYmplY3QuZGVmYXVsdE1heFZlcnNpb247XHJcbiAgICAgICAgdmFyIHMgPSB0aGlzLmdldFNjaGVtYSgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5nZXRDb3VudCgpOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHByb3AgPSBzLmdldEl0ZW1BdChpKTtcclxuICAgICAgICAgICAgaWYgKHByb3Aub25HZXRJbml0aWFsVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUocHJvcCwgcHJvcC5vbkdldEluaXRpYWxWYWx1ZSh0aGlzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBTZXJpYWxpemFibGVPYmplY3QucHJvdG90eXBlLmdldERlZmF1bHRTZXJpYWxpemF0aW9uQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZVNlcmlhbGl6YXRpb25Db250ZXh0KCk7XHJcbiAgICB9O1xyXG4gICAgU2VyaWFsaXphYmxlT2JqZWN0LnByb3RvdHlwZS5wb3B1bGF0ZVNjaGVtYSA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcclxuICAgICAgICB2YXIgY3RvciA9IHRoaXMuY29uc3RydWN0b3I7XHJcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBbXTtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXHJcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIGN0b3IpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eVZhbHVlID0gY3Rvcltwcm9wZXJ0eU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5VmFsdWUgaW5zdGFuY2VvZiBQcm9wZXJ0eURlZmluaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2gocHJvcGVydHlWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBhIHByb3BlcnR5IGhhcHBlbnMgdG8gaGF2ZSBhIGdldHRlciBmdW5jdGlvbiBhbmRcclxuICAgICAgICAgICAgICAgIC8vIGl0IHRocm93cyBhbiBleGNlcHRpb24sIHdlIG5lZWQgdG8gY2F0Y2ggaXQgaGVyZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIHNvcnRlZFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLnNvcnQoZnVuY3Rpb24gKHAxLCBwMikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAxLnNlcXVlbnRpYWxOdW1iZXIgPiBwMi5zZXF1ZW50aWFsTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwMS5zZXF1ZW50aWFsTnVtYmVyIDwgcDIuc2VxdWVudGlhbE51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2NoZW1hLmFkZC5hcHBseShzY2hlbWEsIHNvcnRlZFByb3BlcnRpZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoU2VyaWFsaXphYmxlT2JqZWN0Lm9uUmVnaXN0ZXJDdXN0b21Qcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIFNlcmlhbGl6YWJsZU9iamVjdC5vblJlZ2lzdGVyQ3VzdG9tUHJvcGVydGllcyh0aGlzLCBzY2hlbWEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTZXJpYWxpemFibGVPYmplY3QucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydHlCYWcuaGFzT3duUHJvcGVydHkocHJvcC5nZXRJbnRlcm5hbE5hbWUoKSlcclxuICAgICAgICAgICAgPyB0aGlzLl9wcm9wZXJ0eUJhZ1twcm9wLmdldEludGVybmFsTmFtZSgpXVxyXG4gICAgICAgICAgICA6IHByb3AuZGVmYXVsdFZhbHVlO1xyXG4gICAgfTtcclxuICAgIFNlcmlhbGl6YWJsZU9iamVjdC5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAocHJvcCwgdmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcHJvcGVydHlCYWdbcHJvcC5nZXRJbnRlcm5hbE5hbWUoKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eUJhZ1twcm9wLmdldEludGVybmFsTmFtZSgpXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTZXJpYWxpemFibGVPYmplY3QucHJvdG90eXBlLmludGVybmFsUGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fcHJvcGVydHlCYWcgPSB7fTtcclxuICAgICAgICB0aGlzLl9yYXdQcm9wZXJ0aWVzID0gc2hhcmVkXzEuR2xvYmFsU2V0dGluZ3MuZW5hYmxlRnVsbEpzb25Sb3VuZFRyaXAgPyAoc291cmNlID8gc291cmNlIDoge30pIDoge307XHJcbiAgICAgICAgaWYgKHNvdXJjZSkge1xyXG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMuZ2V0U2NoZW1hKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5nZXRDb3VudCgpOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9wID0gcy5nZXRJdGVtQXQoaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcC5pc1NlcmlhbGl6YXRpb25FbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5VmFsdWUgPSBwcm9wLm9uR2V0SW5pdGlhbFZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcHJvcC5vbkdldEluaXRpYWxWYWx1ZSh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3AubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AudGFyZ2V0VmVyc2lvbi5jb21wYXJlVG8oY29udGV4dC50YXJnZXRWZXJzaW9uKSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eVZhbHVlID0gcHJvcC5wYXJzZSh0aGlzLCBzb3VyY2UsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5sb2dQYXJzZUV2ZW50KHRoaXMsIEVudW1zLlZhbGlkYXRpb25FdmVudC5VbnN1cHBvcnRlZFByb3BlcnR5LCBzdHJpbmdzXzEuU3RyaW5ncy5lcnJvcnMucHJvcGVydHlOb3RTdXBwb3J0ZWQocHJvcC5uYW1lLCBwcm9wLnRhcmdldFZlcnNpb24udG9TdHJpbmcoKSwgY29udGV4dC50YXJnZXRWZXJzaW9uLnRvU3RyaW5nKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlKHByb3AsIHByb3BlcnR5VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0RGVmYXVsdFZhbHVlcygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTZXJpYWxpemFibGVPYmplY3QucHJvdG90eXBlLmludGVybmFsVG9KU09OID0gZnVuY3Rpb24gKHRhcmdldCwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBzID0gdGhpcy5nZXRTY2hlbWEoKTtcclxuICAgICAgICB2YXIgc2VyaWFsaXplZFByb3BlcnRpZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMuZ2V0Q291bnQoKTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wID0gcy5nZXRJdGVtQXQoaSk7XHJcbiAgICAgICAgICAgIC8vIEF2b2lkIHNlcmlhbGl6aW5nIHRoZSBzYW1lIHByb3BlcnR5IG11bHRpcGxlIHRpbWVzLiBUaGlzIGlzIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHNvbWUgcHJvcGVydHkgZGVmaW5pdGlvbnMgbWFwIHRvIHRoZSBzYW1lIHVuZGVybHlpbmcgc2NoZW1hXHJcbiAgICAgICAgICAgIC8vIHByb3BlcnR5XHJcbiAgICAgICAgICAgIGlmIChwcm9wLmlzU2VyaWFsaXphdGlvbkVuYWJsZWQgJiZcclxuICAgICAgICAgICAgICAgIHByb3AudGFyZ2V0VmVyc2lvbi5jb21wYXJlVG8oY29udGV4dC50YXJnZXRWZXJzaW9uKSA8PSAwICYmXHJcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkUHJvcGVydGllcy5pbmRleE9mKHByb3AubmFtZSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wLnRvSlNPTih0aGlzLCB0YXJnZXQsIHRoaXMuZ2V0VmFsdWUocHJvcCksIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZFByb3BlcnRpZXMucHVzaChwcm9wLm5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNlcmlhbGl6YWJsZU9iamVjdC5wcm90b3R5cGUuc2hvdWxkU2VyaWFsaXplID0gZnVuY3Rpb24gKF9jb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgU2VyaWFsaXphYmxlT2JqZWN0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLmludGVybmFsUGFyc2Uoc291cmNlLCBjb250ZXh0ID8gY29udGV4dCA6IG5ldyBTaW1wbGVTZXJpYWxpemF0aW9uQ29udGV4dCgpKTtcclxuICAgIH07XHJcbiAgICBTZXJpYWxpemFibGVPYmplY3QucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGVmZmVjdGl2ZUNvbnRleHQ7XHJcbiAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dCBpbnN0YW5jZW9mIEJhc2VTZXJpYWxpemF0aW9uQ29udGV4dCkge1xyXG4gICAgICAgICAgICBlZmZlY3RpdmVDb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVmZmVjdGl2ZUNvbnRleHQgPSB0aGlzLmdldERlZmF1bHRTZXJpYWxpemF0aW9uQ29udGV4dCgpO1xyXG4gICAgICAgICAgICBlZmZlY3RpdmVDb250ZXh0LnRvSlNPTk9yaWdpbmFsUGFyYW0gPSBjb250ZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zaG91bGRTZXJpYWxpemUoZWZmZWN0aXZlQ29udGV4dCkpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgaWYgKHNoYXJlZF8xLkdsb2JhbFNldHRpbmdzLmVuYWJsZUZ1bGxKc29uUm91bmRUcmlwICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXdQcm9wZXJ0aWVzICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGhpcy5fcmF3UHJvcGVydGllcyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fcmF3UHJvcGVydGllcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxUb0pTT04ocmVzdWx0LCBlZmZlY3RpdmVDb250ZXh0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNlcmlhbGl6YWJsZU9iamVjdC5wcm90b3R5cGUuaGFzRGVmYXVsdFZhbHVlID0gZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZShwcm9wKSA9PT0gcHJvcC5kZWZhdWx0VmFsdWU7XHJcbiAgICB9O1xyXG4gICAgU2VyaWFsaXphYmxlT2JqZWN0LnByb3RvdHlwZS5oYXNBbGxEZWZhdWx0VmFsdWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzID0gdGhpcy5nZXRTY2hlbWEoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMuZ2V0Q291bnQoKTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wID0gcy5nZXRJdGVtQXQoaSk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNEZWZhdWx0VmFsdWUocHJvcCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBTZXJpYWxpemFibGVPYmplY3QucHJvdG90eXBlLnJlc2V0RGVmYXVsdFZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcyA9IHRoaXMuZ2V0U2NoZW1hKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmdldENvdW50KCk7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcHJvcCA9IHMuZ2V0SXRlbUF0KGkpO1xyXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKHByb3AsIHByb3AuZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgU2VyaWFsaXphYmxlT2JqZWN0LnByb3RvdHlwZS5zZXRDdXN0b21Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBzaG91bGREZWxldGVQcm9wZXJ0eSA9ICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXZhbHVlKSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsO1xyXG4gICAgICAgIGlmIChzaG91bGREZWxldGVQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcmF3UHJvcGVydGllc1tuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jhd1Byb3BlcnRpZXNbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgU2VyaWFsaXphYmxlT2JqZWN0LnByb3RvdHlwZS5nZXRDdXN0b21Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jhd1Byb3BlcnRpZXNbbmFtZV07XHJcbiAgICB9O1xyXG4gICAgU2VyaWFsaXphYmxlT2JqZWN0LnByb3RvdHlwZS5nZXRTY2hlbWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNjaGVtYSA9IFNlcmlhbGl6YWJsZU9iamVjdC5fc2NoZW1hQ2FjaGVbdGhpcy5nZXRTY2hlbWFLZXkoKV07XHJcbiAgICAgICAgaWYgKCFzY2hlbWEpIHtcclxuICAgICAgICAgICAgc2NoZW1hID0gbmV3IFNlcmlhbGl6YWJsZU9iamVjdFNjaGVtYSgpO1xyXG4gICAgICAgICAgICB0aGlzLnBvcHVsYXRlU2NoZW1hKHNjaGVtYSk7XHJcbiAgICAgICAgICAgIFNlcmlhbGl6YWJsZU9iamVjdC5fc2NoZW1hQ2FjaGVbdGhpcy5nZXRTY2hlbWFLZXkoKV0gPSBzY2hlbWE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzY2hlbWE7XHJcbiAgICB9O1xyXG4gICAgU2VyaWFsaXphYmxlT2JqZWN0LmRlZmF1bHRNYXhWZXJzaW9uID0gVmVyc2lvbnMubGF0ZXN0O1xyXG4gICAgU2VyaWFsaXphYmxlT2JqZWN0Ll9zY2hlbWFDYWNoZSA9IHt9O1xyXG4gICAgcmV0dXJuIFNlcmlhbGl6YWJsZU9iamVjdDtcclxufSgpKTtcclxuZXhwb3J0cy5TZXJpYWxpemFibGVPYmplY3QgPSBTZXJpYWxpemFibGVPYmplY3Q7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcmlhbGl6YXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5VVUlEID0gZXhwb3J0cy5TaXplQW5kVW5pdCA9IGV4cG9ydHMuUGFkZGluZ0RlZmluaXRpb24gPSBleHBvcnRzLlNwYWNpbmdEZWZpbml0aW9uID0gZXhwb3J0cy5TdHJpbmdXaXRoU3Vic3RpdHV0aW9ucyA9IGV4cG9ydHMuQ29udGVudFR5cGVzID0gZXhwb3J0cy5HbG9iYWxTZXR0aW5ncyA9IHZvaWQgMDtcclxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxudmFyIEVudW1zID0gcmVxdWlyZShcIi4vZW51bXNcIik7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmFuZW91cy1jbGFzc1xyXG52YXIgR2xvYmFsU2V0dGluZ3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBHbG9iYWxTZXR0aW5ncygpIHtcclxuICAgIH1cclxuICAgIEdsb2JhbFNldHRpbmdzLnVzZUFkdmFuY2VkVGV4dEJsb2NrVHJ1bmNhdGlvbiA9IHRydWU7XHJcbiAgICBHbG9iYWxTZXR0aW5ncy51c2VBZHZhbmNlZENhcmRCb3R0b21UcnVuY2F0aW9uID0gZmFsc2U7XHJcbiAgICBHbG9iYWxTZXR0aW5ncy51c2VNYXJrZG93bkluUmFkaW9CdXR0b25BbmRDaGVja2JveCA9IHRydWU7XHJcbiAgICBHbG9iYWxTZXR0aW5ncy5hbGxvd01hcmtGb3JUZXh0SGlnaGxpZ2h0aW5nID0gZmFsc2U7XHJcbiAgICBHbG9iYWxTZXR0aW5ncy5hbHdheXNCbGVlZFNlcGFyYXRvcnMgPSBmYWxzZTtcclxuICAgIEdsb2JhbFNldHRpbmdzLmVuYWJsZUZ1bGxKc29uUm91bmRUcmlwID0gZmFsc2U7XHJcbiAgICBHbG9iYWxTZXR0aW5ncy5kaXNwbGF5SW5wdXRWYWxpZGF0aW9uRXJyb3JzID0gdHJ1ZTtcclxuICAgIEdsb2JhbFNldHRpbmdzLmFsbG93UHJlUHJvY2Vzc2luZ1Byb3BlcnR5VmFsdWVzID0gZmFsc2U7XHJcbiAgICBHbG9iYWxTZXR0aW5ncy5zZXRUYWJJbmRleEF0Q2FyZFJvb3QgPSB0cnVlO1xyXG4gICAgR2xvYmFsU2V0dGluZ3MuZW5hYmxlRmFsbGJhY2sgPSB0cnVlO1xyXG4gICAgR2xvYmFsU2V0dGluZ3MudXNlV2Via2l0TGluZUNsYW1wID0gdHJ1ZTtcclxuICAgIEdsb2JhbFNldHRpbmdzLmFsbG93TW9yZVRoYW5NYXhBY3Rpb25zSW5PdmVyZmxvd01lbnUgPSBmYWxzZTtcclxuICAgIEdsb2JhbFNldHRpbmdzLnJlbW92ZVBhZGRpbmdGcm9tQ29udGFpbmVyc1dpdGhCYWNrZ3JvdW5kSW1hZ2UgPSBmYWxzZTtcclxuICAgIEdsb2JhbFNldHRpbmdzLnJlc2V0SW5wdXRzRGlydHlTdGF0ZUFmdGVyQWN0aW9uRXhlY3V0aW9uID0gdHJ1ZTtcclxuICAgIEdsb2JhbFNldHRpbmdzLmFwcGxldHMgPSB7XHJcbiAgICAgICAgbG9nRW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICBsb2dMZXZlbDogRW51bXMuTG9nTGV2ZWwuRXJyb3IsXHJcbiAgICAgICAgbWF4aW11bVJldHJ5QXR0ZW1wdHM6IDMsXHJcbiAgICAgICAgZGVmYXVsdFRpbWVCZXR3ZWVuUmV0cnlBdHRlbXB0czogMzAwMCxcclxuICAgICAgICBhdXRoUHJvbXB0V2lkdGg6IDQwMCxcclxuICAgICAgICBhdXRoUHJvbXB0SGVpZ2h0OiA2MDAsXHJcbiAgICAgICAgcmVmcmVzaDoge1xyXG4gICAgICAgICAgICBtb2RlOiBFbnVtcy5SZWZyZXNoTW9kZS5NYW51YWwsXHJcbiAgICAgICAgICAgIHRpbWVCZXR3ZWVuQXV0b21hdGljUmVmcmVzaGVzOiAzMDAwLFxyXG4gICAgICAgICAgICBtYXhpbXVtQ29uc2VjdXRpdmVBdXRvbWF0aWNSZWZyZXNoZXM6IDMsXHJcbiAgICAgICAgICAgIGFsbG93TWFudWFsUmVmcmVzaGVzQWZ0ZXJBdXRvbWF0aWNSZWZyZXNoZXM6IHRydWVcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEdsb2JhbFNldHRpbmdzO1xyXG59KCkpO1xyXG5leHBvcnRzLkdsb2JhbFNldHRpbmdzID0gR2xvYmFsU2V0dGluZ3M7XHJcbmV4cG9ydHMuQ29udGVudFR5cGVzID0ge1xyXG4gICAgYXBwbGljYXRpb25Kc29uOiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuICAgIGFwcGxpY2F0aW9uWFd3d0Zvcm1VcmxlbmNvZGVkOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiXHJcbn07XHJcbnZhciBTdHJpbmdXaXRoU3Vic3RpdHV0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFN0cmluZ1dpdGhTdWJzdGl0dXRpb25zKCkge1xyXG4gICAgICAgIHRoaXMuX2lzUHJvY2Vzc2VkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBTdHJpbmdXaXRoU3Vic3RpdHV0aW9ucy5wcm90b3R5cGUuZ2V0UmVmZXJlbmNlZElucHV0cyA9IGZ1bmN0aW9uIChpbnB1dHMsIHJlZmVyZW5jZWRJbnB1dHMpIHtcclxuICAgICAgICBpZiAoIXJlZmVyZW5jZWRJbnB1dHMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlZmVyZW5jZWRJbnB1dHMgcGFyYW1ldGVyIGNhbm5vdCBiZSBudWxsLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX29yaWdpbmFsKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgaW5wdXRzXzEgPSBpbnB1dHM7IF9pIDwgaW5wdXRzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dHNfMVtfaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IG5ldyBSZWdFeHAoXCJcXFxce3syfShcIiArIGlucHV0LmlkICsgXCIpLnZhbHVlXFxcXH17Mn1cIiwgXCJnaVwiKS5leGVjKHRoaXMuX29yaWdpbmFsKTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzICE9IG51bGwgJiYgaW5wdXQuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VkSW5wdXRzW2lucHV0LmlkXSA9IGlucHV0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFN0cmluZ1dpdGhTdWJzdGl0dXRpb25zLnByb3RvdHlwZS5zdWJzdGl0dXRlSW5wdXRWYWx1ZXMgPSBmdW5jdGlvbiAoaW5wdXRzLCBjb250ZW50VHlwZSkge1xyXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NlZCA9IHRoaXMuX29yaWdpbmFsO1xyXG4gICAgICAgIGlmICh0aGlzLl9vcmlnaW5hbCkge1xyXG4gICAgICAgICAgICB2YXIgcmVnRXggPSAvXFx7ezJ9KFthLXowLTlfJEBdKykudmFsdWVcXH17Mn0vZ2k7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gdm9pZCAwO1xyXG4gICAgICAgICAgICB3aGlsZSAoKG1hdGNoZXMgPSByZWdFeC5leGVjKHRoaXMuX29yaWdpbmFsKSkgIT09IG51bGwgJiYgdGhpcy5fcHJvY2Vzc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMoaW5wdXRzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVkSW5wdXQgPSBpbnB1dHNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlRm9yUmVwbGFjZSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkSW5wdXQudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlRm9yUmVwbGFjZSA9IG1hdGNoZWRJbnB1dC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGUgPT09IGV4cG9ydHMuQ29udGVudFR5cGVzLmFwcGxpY2F0aW9uSnNvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVGb3JSZXBsYWNlID0gSlNPTi5zdHJpbmdpZnkodmFsdWVGb3JSZXBsYWNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlRm9yUmVwbGFjZSA9IHZhbHVlRm9yUmVwbGFjZS5zbGljZSgxLCAtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGVudFR5cGUgPT09IGV4cG9ydHMuQ29udGVudFR5cGVzLmFwcGxpY2F0aW9uWFd3d0Zvcm1VcmxlbmNvZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUZvclJlcGxhY2UgPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWVGb3JSZXBsYWNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzZWQgPSB0aGlzLl9wcm9jZXNzZWQucmVwbGFjZShtYXRjaGVzWzBdLCB2YWx1ZUZvclJlcGxhY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faXNQcm9jZXNzZWQgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIFN0cmluZ1dpdGhTdWJzdGl0dXRpb25zLnByb3RvdHlwZS5nZXRPcmlnaW5hbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWw7XHJcbiAgICB9O1xyXG4gICAgU3RyaW5nV2l0aFN1YnN0aXR1dGlvbnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzUHJvY2Vzc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFN0cmluZ1dpdGhTdWJzdGl0dXRpb25zLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9vcmlnaW5hbCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2lzUHJvY2Vzc2VkID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFN0cmluZ1dpdGhTdWJzdGl0dXRpb25zO1xyXG59KCkpO1xyXG5leHBvcnRzLlN0cmluZ1dpdGhTdWJzdGl0dXRpb25zID0gU3RyaW5nV2l0aFN1YnN0aXR1dGlvbnM7XHJcbnZhciBTcGFjaW5nRGVmaW5pdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNwYWNpbmdEZWZpbml0aW9uKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCkge1xyXG4gICAgICAgIGlmICh0b3AgPT09IHZvaWQgMCkgeyB0b3AgPSAwOyB9XHJcbiAgICAgICAgaWYgKHJpZ2h0ID09PSB2b2lkIDApIHsgcmlnaHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKGJvdHRvbSA9PT0gdm9pZCAwKSB7IGJvdHRvbSA9IDA7IH1cclxuICAgICAgICBpZiAobGVmdCA9PT0gdm9pZCAwKSB7IGxlZnQgPSAwOyB9XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gMDtcclxuICAgICAgICB0aGlzLnRvcCA9IDA7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IDA7XHJcbiAgICAgICAgdGhpcy5ib3R0b20gPSAwO1xyXG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xyXG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuICAgICAgICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcclxuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFNwYWNpbmdEZWZpbml0aW9uO1xyXG59KCkpO1xyXG5leHBvcnRzLlNwYWNpbmdEZWZpbml0aW9uID0gU3BhY2luZ0RlZmluaXRpb247XHJcbnZhciBQYWRkaW5nRGVmaW5pdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBhZGRpbmdEZWZpbml0aW9uKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCkge1xyXG4gICAgICAgIGlmICh0b3AgPT09IHZvaWQgMCkgeyB0b3AgPSBFbnVtcy5TcGFjaW5nLk5vbmU7IH1cclxuICAgICAgICBpZiAocmlnaHQgPT09IHZvaWQgMCkgeyByaWdodCA9IEVudW1zLlNwYWNpbmcuTm9uZTsgfVxyXG4gICAgICAgIGlmIChib3R0b20gPT09IHZvaWQgMCkgeyBib3R0b20gPSBFbnVtcy5TcGFjaW5nLk5vbmU7IH1cclxuICAgICAgICBpZiAobGVmdCA9PT0gdm9pZCAwKSB7IGxlZnQgPSBFbnVtcy5TcGFjaW5nLk5vbmU7IH1cclxuICAgICAgICB0aGlzLnRvcCA9IEVudW1zLlNwYWNpbmcuTm9uZTtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gRW51bXMuU3BhY2luZy5Ob25lO1xyXG4gICAgICAgIHRoaXMuYm90dG9tID0gRW51bXMuU3BhY2luZy5Ob25lO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IEVudW1zLlNwYWNpbmcuTm9uZTtcclxuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcbiAgICAgICAgdGhpcy5ib3R0b20gPSBib3R0b207XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuICAgIH1cclxuICAgIHJldHVybiBQYWRkaW5nRGVmaW5pdGlvbjtcclxufSgpKTtcclxuZXhwb3J0cy5QYWRkaW5nRGVmaW5pdGlvbiA9IFBhZGRpbmdEZWZpbml0aW9uO1xyXG52YXIgU2l6ZUFuZFVuaXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTaXplQW5kVW5pdChwaHlzaWNhbFNpemUsIHVuaXQpIHtcclxuICAgICAgICB0aGlzLnBoeXNpY2FsU2l6ZSA9IHBoeXNpY2FsU2l6ZTtcclxuICAgICAgICB0aGlzLnVuaXQgPSB1bml0O1xyXG4gICAgfVxyXG4gICAgU2l6ZUFuZFVuaXQucGFyc2UgPSBmdW5jdGlvbiAoaW5wdXQsIHJlcXVpcmVVbml0U3BlY2lmaWVyKSB7XHJcbiAgICAgICAgaWYgKHJlcXVpcmVVbml0U3BlY2lmaWVyID09PSB2b2lkIDApIHsgcmVxdWlyZVVuaXRTcGVjaWZpZXIgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgU2l6ZUFuZFVuaXQoMCwgRW51bXMuU2l6ZVVuaXQuV2VpZ2h0KTtcclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5waHlzaWNhbFNpemUgPSBpbnB1dDtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHZhciByZWdFeHAgPSAvXihbMC05XSspKHB4fFxcKik/JC9nO1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHJlZ0V4cC5leGVjKGlucHV0KTtcclxuICAgICAgICAgICAgdmFyIGV4cGVjdGVkTWF0Y2hDb3VudCA9IHJlcXVpcmVVbml0U3BlY2lmaWVyID8gMyA6IDI7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID49IGV4cGVjdGVkTWF0Y2hDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnBoeXNpY2FsU2l6ZSA9IHBhcnNlSW50KG1hdGNoZXNbMV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNbMl0gPT09IFwicHhcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudW5pdCA9IEVudW1zLlNpemVVbml0LlBpeGVsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaXplOiBcIiArIGlucHV0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU2l6ZUFuZFVuaXQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuU2l6ZUFuZFVuaXQgPSBTaXplQW5kVW5pdDtcclxuLyoqXHJcbiAqIEZhc3QgVVVJRCBnZW5lcmF0b3IsIFJGQzQxMjIgdmVyc2lvbiA0IGNvbXBsaWFudC5cclxuICogQGF1dGhvciBKZWZmIFdhcmQgKGpjd2FyZC5jb20pLlxyXG4gKiBAbGljZW5zZSBNSVQgbGljZW5zZVxyXG4gKiBAbGluayBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9ob3ctdG8tY3JlYXRlLWEtZ3VpZC11dWlkLWluLWphdmFzY3JpcHQvMjE5NjMxMzYjMjE5NjMxMzZcclxuICoqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmFuZW91cy1jbGFzcywgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uLCBuby1iaXR3aXNlICovXHJcbnZhciBVVUlEID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVVVJRCgpIHtcclxuICAgIH1cclxuICAgIFVVSUQuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGQwID0gKE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmKSB8IDA7XHJcbiAgICAgICAgdmFyIGQxID0gKE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmKSB8IDA7XHJcbiAgICAgICAgdmFyIGQyID0gKE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmKSB8IDA7XHJcbiAgICAgICAgdmFyIGQzID0gKE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmKSB8IDA7XHJcbiAgICAgICAgcmV0dXJuIChVVUlELmx1dFtkMCAmIDB4ZmZdICtcclxuICAgICAgICAgICAgVVVJRC5sdXRbKGQwID4+IDgpICYgMHhmZl0gK1xyXG4gICAgICAgICAgICBVVUlELmx1dFsoZDAgPj4gMTYpICYgMHhmZl0gK1xyXG4gICAgICAgICAgICBVVUlELmx1dFsoZDAgPj4gMjQpICYgMHhmZl0gK1xyXG4gICAgICAgICAgICBcIi1cIiArXHJcbiAgICAgICAgICAgIFVVSUQubHV0W2QxICYgMHhmZl0gK1xyXG4gICAgICAgICAgICBVVUlELmx1dFsoZDEgPj4gOCkgJiAweGZmXSArXHJcbiAgICAgICAgICAgIFwiLVwiICtcclxuICAgICAgICAgICAgVVVJRC5sdXRbKChkMSA+PiAxNikgJiAweDBmKSB8IDB4NDBdICtcclxuICAgICAgICAgICAgVVVJRC5sdXRbKGQxID4+IDI0KSAmIDB4ZmZdICtcclxuICAgICAgICAgICAgXCItXCIgK1xyXG4gICAgICAgICAgICBVVUlELmx1dFsoZDIgJiAweDNmKSB8IDB4ODBdICtcclxuICAgICAgICAgICAgVVVJRC5sdXRbKGQyID4+IDgpICYgMHhmZl0gK1xyXG4gICAgICAgICAgICBcIi1cIiArXHJcbiAgICAgICAgICAgIFVVSUQubHV0WyhkMiA+PiAxNikgJiAweGZmXSArXHJcbiAgICAgICAgICAgIFVVSUQubHV0WyhkMiA+PiAyNCkgJiAweGZmXSArXHJcbiAgICAgICAgICAgIFVVSUQubHV0W2QzICYgMHhmZl0gK1xyXG4gICAgICAgICAgICBVVUlELmx1dFsoZDMgPj4gOCkgJiAweGZmXSArXHJcbiAgICAgICAgICAgIFVVSUQubHV0WyhkMyA+PiAxNikgJiAweGZmXSArXHJcbiAgICAgICAgICAgIFVVSUQubHV0WyhkMyA+PiAyNCkgJiAweGZmXSk7XHJcbiAgICB9O1xyXG4gICAgVVVJRC5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcclxuICAgICAgICAgICAgVVVJRC5sdXRbaV0gPSAoaSA8IDE2ID8gXCIwXCIgOiBcIlwiKSArIGkudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBVVUlELmx1dCA9IFtdO1xyXG4gICAgcmV0dXJuIFVVSUQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVVVJRCA9IFVVSUQ7XHJcblVVSUQuaW5pdGlhbGl6ZSgpO1xyXG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYW5lb3VzLWNsYXNzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIG5vLWJpdHdpc2UgKi9cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhcmVkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuU3RyaW5ncyA9IHZvaWQgMDtcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYW5lb3VzLWNsYXNzXHJcbnZhciBTdHJpbmdzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3RyaW5ncygpIHtcclxuICAgIH1cclxuICAgIFN0cmluZ3MuZXJyb3JzID0ge1xyXG4gICAgICAgIHVua25vd25FbGVtZW50VHlwZTogZnVuY3Rpb24gKHR5cGVOYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlVua25vd24gZWxlbWVudCB0eXBlIFxcXCJcIi5jb25jYXQodHlwZU5hbWUsIFwiXFxcIi4gRmFsbGJhY2sgd2lsbCBiZSB1c2VkIGlmIHByZXNlbnQuXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdW5rbm93bkFjdGlvblR5cGU6IGZ1bmN0aW9uICh0eXBlTmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJVbmtub3duIGFjdGlvbiB0eXBlIFxcXCJcIi5jb25jYXQodHlwZU5hbWUsIFwiXFxcIi4gRmFsbGJhY2sgd2lsbCBiZSB1c2VkIGlmIHByZXNlbnQuXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZWxlbWVudFR5cGVOb3RBbGxvd2VkOiBmdW5jdGlvbiAodHlwZU5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiRWxlbWVudCB0eXBlIFxcXCJcIi5jb25jYXQodHlwZU5hbWUsIFwiXFxcIiBpcyBub3QgYWxsb3dlZCBpbiB0aGlzIGNvbnRleHQuXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWN0aW9uVHlwZU5vdEFsbG93ZWQ6IGZ1bmN0aW9uICh0eXBlTmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJBY3Rpb24gdHlwZSBcXFwiXCIuY29uY2F0KHR5cGVOYW1lLCBcIlxcXCIgaXMgbm90IGFsbG93ZWQgaW4gdGhpcyBjb250ZXh0LlwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGludmFsaWRQcm9wZXJ0eVZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIHByb3BlcnR5TmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJJbnZhbGlkIHZhbHVlIFxcXCJcIi5jb25jYXQodmFsdWUsIFwiXFxcIiBmb3IgcHJvcGVydHkgXFxcIlwiKS5jb25jYXQocHJvcGVydHlOYW1lLCBcIlxcXCIuXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hvd0NhcmRNdXN0SGF2ZUNhcmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXFxcIkFuIEFjdGlvbi5TaG93Q2FyZCBtdXN0IGhhdmUgaXRzIFxcXCJjYXJkXFxcIiBwcm9wZXJ0eSBzZXQgdG8gYSB2YWxpZCBBZGFwdGl2ZUNhcmQgb2JqZWN0LlwiO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW52YWxpZENvbHVtbldpZHRoOiBmdW5jdGlvbiAoaW52YWxpZFdpZHRoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgY29sdW1uIHdpZHRoIFxcXCJcIi5jb25jYXQoaW52YWxpZFdpZHRoLCBcIlxcXCIgLSBkZWZhdWx0aW5nIHRvIFxcXCJhdXRvXFxcIi5cIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbnZhbGlkQ2FyZFZlcnNpb246IGZ1bmN0aW9uIChkZWZhdWx0aW5nVG9WZXJzaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgY2FyZCB2ZXJzaW9uLiBEZWZhdWx0aW5nIHRvIFxcXCJcIi5jb25jYXQoZGVmYXVsdGluZ1RvVmVyc2lvbiwgXCJcXFwiLlwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGludmFsaWRWZXJzaW9uU3RyaW5nOiBmdW5jdGlvbiAodmVyc2lvblN0cmluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJJbnZhbGlkIHZlcnNpb24gc3RyaW5nIFxcXCJcIi5jb25jYXQodmVyc2lvblN0cmluZywgXCJcXFwiLlwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByb3BlcnR5VmFsdWVOb3RTdXBwb3J0ZWQ6IGZ1bmN0aW9uICh2YWx1ZSwgcHJvcGVydHlOYW1lLCBzdXBwb3J0ZWRJblZlcnNpb24sIHZlcnNpb25Vc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlZhbHVlIFxcXCJcIi5jb25jYXQodmFsdWUsIFwiXFxcIiBmb3IgcHJvcGVydHkgXFxcIlwiKS5jb25jYXQocHJvcGVydHlOYW1lLCBcIlxcXCIgaXMgc3VwcG9ydGVkIGluIHZlcnNpb24gXCIpLmNvbmNhdChzdXBwb3J0ZWRJblZlcnNpb24sIFwiLCBidXQgeW91IGFyZSB1c2luZyB2ZXJzaW9uIFwiKS5jb25jYXQodmVyc2lvblVzZWQsIFwiLlwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByb3BlcnR5Tm90U3VwcG9ydGVkOiBmdW5jdGlvbiAocHJvcGVydHlOYW1lLCBzdXBwb3J0ZWRJblZlcnNpb24sIHZlcnNpb25Vc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlByb3BlcnR5IFxcXCJcIi5jb25jYXQocHJvcGVydHlOYW1lLCBcIlxcXCIgaXMgc3VwcG9ydGVkIGluIHZlcnNpb24gXCIpLmNvbmNhdChzdXBwb3J0ZWRJblZlcnNpb24sIFwiLCBidXQgeW91IGFyZSB1c2luZyB2ZXJzaW9uIFwiKS5jb25jYXQodmVyc2lvblVzZWQsIFwiLlwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluZGV4T3V0T2ZSYW5nZTogZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBcIkluZGV4IG91dCBvZiByYW5nZSAoXCIuY29uY2F0KGluZGV4LCBcIikuXCIpOyB9LFxyXG4gICAgICAgIGVsZW1lbnRDYW5ub3RCZVVzZWRBc0lubGluZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJSaWNoVGV4dEJsb2NrLmFkZElubGluZTogdGhlIHNwZWNpZmllZCBjYXJkIGVsZW1lbnQgY2Fubm90IGJlIHVzZWQgYXMgYSBSaWNoVGV4dEJsb2NrIGlubGluZS5cIjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlubGluZUFscmVhZHlQYXJlbnRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJSaWNoVGV4dEJsb2NrLmFkZElubGluZTogdGhlIHNwZWNpZmllZCBpbmxpbmUgYWxyZWFkeSBiZWxvbmdzIHRvIGFub3RoZXIgUmljaFRleHRCbG9jay5cIjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGludGVyYWN0aXZpdHlOb3RBbGxvd2VkOiBmdW5jdGlvbiAoKSB7IHJldHVybiBcIkludGVyYWN0aXZpdHkgaXMgbm90IGFsbG93ZWQuXCI7IH0sXHJcbiAgICAgICAgaW5wdXRzTXVzdEhhdmVVbmlxdWVJZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJBbGwgaW5wdXRzIG11c3QgaGF2ZSBhIHVuaXF1ZSBJZC5cIjsgfSxcclxuICAgICAgICBjaG9pY2VTZXRNdXN0SGF2ZUF0TGVhc3RPbmVDaG9pY2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiQW4gSW5wdXQuQ2hvaWNlU2V0IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgY2hvaWNlIGRlZmluZWQuXCI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjaG9pY2VTZXRDaG9pY2VzTXVzdEhhdmVUaXRsZUFuZFZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIkFsbCBjaG9pY2VzIGluIGFuIElucHV0LkNob2ljZVNldCBtdXN0IGhhdmUgdGhlaXIgdGl0bGUgYW5kIHZhbHVlIHByb3BlcnRpZXMgc2V0LlwiO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJvcGVydHlNdXN0QmVTZXQ6IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHsgcmV0dXJuIFwiUHJvcGVydHkgXFxcIlwiLmNvbmNhdChwcm9wZXJ0eU5hbWUsIFwiXFxcIiBtdXN0IGJlIHNldC5cIik7IH0sXHJcbiAgICAgICAgYWN0aW9uSHR0cEhlYWRlcnNNdXN0SGF2ZU5hbWVBbmRWYWx1ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJBbGwgaGVhZGVycyBvZiBhbiBBY3Rpb24uSHR0cCBtdXN0IGhhdmUgdGhlaXIgbmFtZSBhbmQgdmFsdWUgcHJvcGVydGllcyBzZXQuXCI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b29NYW55QWN0aW9uczogZnVuY3Rpb24gKG1heGltdW1BY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIk1heGltdW0gbnVtYmVyIG9mIGFjdGlvbnMgZXhjZWVkZWQgKFwiLmNvbmNhdChtYXhpbXVtQWN0aW9ucywgXCIpLlwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvb0xpdHRsZVRpbWVEZWxheTogZnVuY3Rpb24gKG1pbkF1dG9wbGF5RGVsYXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiQXV0b3BsYXkgRGVsYXkgaXMgdG9vIHNob3J0IChcIi5jb25jYXQobWluQXV0b3BsYXlEZWxheSwgXCIpLlwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbHVtbkFscmVhZHlCZWxvbmdzVG9Bbm90aGVyU2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBcIlRoaXMgY29sdW1uIGFscmVhZHkgYmVsb25ncyB0byBhbm90aGVyIENvbHVtblNldC5cIjsgfSxcclxuICAgICAgICBpbnZhbGlkQ2FyZFR5cGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiSW52YWxpZCBvciBtaXNzaW5nIGNhcmQgdHlwZS4gTWFrZSBzdXJlIHRoZSBjYXJkJ3MgdHlwZSBwcm9wZXJ0eSBpcyBzZXQgdG8gXFxcIkFkYXB0aXZlQ2FyZFxcXCIuXCI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1bnN1cHBvcnRlZENhcmRWZXJzaW9uOiBmdW5jdGlvbiAodmVyc2lvbiwgbWF4U3VwcG9ydGVkVmVyc2lvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJUaGUgc3BlY2lmaWVkIGNhcmQgdmVyc2lvbiAoXCIuY29uY2F0KHZlcnNpb24sIFwiKSBpcyBub3Qgc3VwcG9ydGVkIG9yIHN0aWxsIGluIHByZXZpZXcuIFRoZSBsYXRlc3QgcmVsZWFzZWQgY2FyZCB2ZXJzaW9uIGlzIFwiKS5jb25jYXQobWF4U3VwcG9ydGVkVmVyc2lvbiwgXCIuXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZHVwbGljYXRlSWQ6IGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gXCJEdXBsaWNhdGUgSWQgXFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiLlwiKTsgfSxcclxuICAgICAgICBtYXJrZG93blByb2Nlc3NpbmdOb3RFbmFibGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIk1hcmtkb3duIHByb2Nlc3NpbmcgaXNuJ3QgZW5hYmxlZC4gUGxlYXNlIHNlZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9hZGFwdGl2ZWNhcmRzI3N1cHBvcnRpbmctbWFya2Rvd25cIjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByb2Nlc3NNYXJrZG93bkV2ZW50UmVtb3ZlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJUaGUgcHJvY2Vzc01hcmtkb3duIGV2ZW50IGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1cGRhdGUgeW91ciBjb2RlIGFuZCBzZXQgb25Qcm9jZXNzTWFya2Rvd24gaW5zdGVhZC5cIjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVsZW1lbnRBbHJlYWR5UGFyZW50ZWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiVGhlIGVsZW1lbnQgYWxyZWFkeSBiZWxvbmdzIHRvIGFub3RoZXIgY29udGFpbmVyLlwiOyB9LFxyXG4gICAgICAgIGFjdGlvbkFscmVhZHlQYXJlbnRlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJUaGUgYWN0aW9uIGFscmVhZHkgYmVsb25ncyB0byBhbm90aGVyIGVsZW1lbnQuXCI7IH0sXHJcbiAgICAgICAgZWxlbWVudFR5cGVOb3RTdGFuZGFsb25lOiBmdW5jdGlvbiAodHlwZU5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiRWxlbWVudHMgb2YgdHlwZSBcIi5jb25jYXQodHlwZU5hbWUsIFwiIGNhbm5vdCBiZSB1c2VkIGFzIHN0YW5kYWxvbmUgZWxlbWVudHMuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTdHJpbmdzLm1hZ2ljQ29kZUlucHV0Q2FyZCA9IHtcclxuICAgICAgICB0cnlBZ2FpbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJUaGF0IGRpZG4ndCB3b3JrLi4uIGxldCdzIHRyeSBhZ2Fpbi5cIjsgfSxcclxuICAgICAgICBwbGVhc2VMb2dpbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ1BsZWFzZSBsb2dpbiBpbiB0aGUgcG9wdXAuIFlvdSB3aWxsIG9idGFpbiBhIG1hZ2ljIGNvZGUuIFBhc3RlIHRoYXQgY29kZSBiZWxvdyBhbmQgc2VsZWN0IFwiU3VibWl0XCInO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXJNYWdpY0NvZGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiRW50ZXIgbWFnaWMgY29kZVwiOyB9LFxyXG4gICAgICAgIHBsZWFzZUVudGVyTWFnaWNDb2RlWW91UmVjZWl2ZWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiUGxlYXNlIGVudGVyIHRoZSBtYWdpYyBjb2RlIHlvdSByZWNlaXZlZC5cIjsgfSxcclxuICAgICAgICBzdWJtaXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiU3VibWl0XCI7IH0sXHJcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7IHJldHVybiBcIkNhbmNlbFwiOyB9LFxyXG4gICAgICAgIHNvbWV0aGluZ1dlbnRXcm9uZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJTb21ldGhpbmcgd2VudCB3cm9uZy4gVGhpcyBhY3Rpb24gY2FuJ3QgYmUgaGFuZGxlZC5cIjsgfSxcclxuICAgICAgICBhdXRoZW50aWNhdGlvbkZhaWxlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJBdXRoZW50aWNhdGlvbiBmYWlsZWQuXCI7IH1cclxuICAgIH07XHJcbiAgICBTdHJpbmdzLnJ1bnRpbWUgPSB7XHJcbiAgICAgICAgYXV0b21hdGljUmVmcmVzaFBhdXNlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJBdXRvbWF0aWMgcmVmcmVzaCBwYXVzZWQuXCI7IH0sXHJcbiAgICAgICAgY2xja1RvUmVzdGFydEF1dG9tYXRpY1JlZnJlc2g6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiQ2xpY2sgdG8gcmVzdGFydC5cIjsgfSxcclxuICAgICAgICByZWZyZXNoVGhpc0NhcmQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiUmVmcmVzaCB0aGlzIGNhcmRcIjsgfVxyXG4gICAgfTtcclxuICAgIFN0cmluZ3MuaGludHMgPSB7XHJcbiAgICAgICAgZG9udFVzZVdlaWdodGVkQW5kU3RyZWN0aGVkQ29sdW1uc0luU2FtZVNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gdXNlIHdlaWdodGVkIGFuZCBzdHJldGNoZWQgY29sdW1ucyBpbiB0aGUgc2FtZSBDb2x1bW5TZXQsIGJlY2F1c2UgaW4gc3VjaCBhIHNpdHVhdGlvbiBzdHJldGNoZWQgY29sdW1ucyB3aWxsIGFsd2F5cyBnZXQgdGhlIG1pbmltdW0gYW1vdW50IG9mIHNwYWNlLlwiO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTdHJpbmdzLmRlZmF1bHRzID0ge1xyXG4gICAgICAgIGlubGluZUFjdGlvblRpdGxlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBcIklubGluZSBBY3Rpb25cIjsgfSxcclxuICAgICAgICBvdmVyZmxvd0J1dHRvblRleHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiLi4uXCI7IH0sXHJcbiAgICAgICAgbWVkaWFQbGF5ZXJBcmlhTGFiZWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiTWVkaWEgY29udGVudFwiOyB9LFxyXG4gICAgICAgIG1lZGlhUGxheWVyUGxheU1lZGlhOiBmdW5jdGlvbiAoKSB7IHJldHVybiBcIlBsYXkgbWVkaWFcIjsgfSxcclxuICAgICAgICB5b3VUdWJlVmlkZW9QbGF5ZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiWW91VHViZSB2aWRlbyBwbGF5ZXJcIjsgfSxcclxuICAgICAgICB2aW1lb1ZpZGVvUGxheWVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBcIlZpbWVvIHZpZGVvIHBsYXllclwiOyB9LFxyXG4gICAgICAgIGRhaWx5bW90aW9uVmlkZW9QbGF5ZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiRGFpbHltb3Rpb24gdmlkZW8gcGxheWVyXCI7IH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gU3RyaW5ncztcclxufSgpKTtcclxuZXhwb3J0cy5TdHJpbmdzID0gU3RyaW5ncztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5ncy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5UYWJsZSA9IGV4cG9ydHMuVGFibGVSb3cgPSBleHBvcnRzLlRhYmxlQ2VsbCA9IGV4cG9ydHMuU3R5bGFibGVDb250YWluZXIgPSBleHBvcnRzLlRhYmxlQ29sdW1uRGVmaW5pdGlvbiA9IHZvaWQgMDtcclxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxudmFyIGNhcmRfZWxlbWVudHNfMSA9IHJlcXVpcmUoXCIuL2NhcmQtZWxlbWVudHNcIik7XHJcbnZhciBlbnVtc18xID0gcmVxdWlyZShcIi4vZW51bXNcIik7XHJcbnZhciByZWdpc3RyeV8xID0gcmVxdWlyZShcIi4vcmVnaXN0cnlcIik7XHJcbnZhciBzZXJpYWxpemF0aW9uXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemF0aW9uXCIpO1xyXG52YXIgc2hhcmVkXzEgPSByZXF1aXJlKFwiLi9zaGFyZWRcIik7XHJcbnZhciBzdHJpbmdzXzEgPSByZXF1aXJlKFwiLi9zdHJpbmdzXCIpO1xyXG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xyXG52YXIgVGFibGVDb2x1bW5EZWZpbml0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFRhYmxlQ29sdW1uRGVmaW5pdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRhYmxlQ29sdW1uRGVmaW5pdGlvbigpIHtcclxuICAgICAgICAvLyNyZWdpb24gU2NoZW1hXHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMud2lkdGggPSBuZXcgc2hhcmVkXzEuU2l6ZUFuZFVuaXQoMSwgZW51bXNfMS5TaXplVW5pdC5XZWlnaHQpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFRhYmxlQ29sdW1uRGVmaW5pdGlvbi5wcm90b3R5cGUuZ2V0U2NoZW1hS2V5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcIkNvbHVtbkRlZmluaXRpb25cIjtcclxuICAgIH07XHJcbiAgICBUYWJsZUNvbHVtbkRlZmluaXRpb24uaG9yaXpvbnRhbENlbGxDb250ZW50QWxpZ25tZW50UHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLkVudW1Qcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfNSwgXCJob3Jpem9udGFsQ2VsbENvbnRlbnRBbGlnbm1lbnRcIiwgZW51bXNfMS5Ib3Jpem9udGFsQWxpZ25tZW50KTtcclxuICAgIFRhYmxlQ29sdW1uRGVmaW5pdGlvbi52ZXJ0aWNhbENlbGxDb250ZW50QWxpZ25tZW50UHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLkVudW1Qcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfNSwgXCJ2ZXJ0aWNhbENlbGxDb250ZW50QWxpZ25tZW50XCIsIGVudW1zXzEuVmVydGljYWxBbGlnbm1lbnQpO1xyXG4gICAgVGFibGVDb2x1bW5EZWZpbml0aW9uLndpZHRoUHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLkN1c3RvbVByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV81LCBcIndpZHRoXCIsIGZ1bmN0aW9uIChzZW5kZXIsIHByb3AsIHNvdXJjZSwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBwcm9wLmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcC5uYW1lXTtcclxuICAgICAgICB2YXIgaW52YWxpZFdpZHRoID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4odmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBzaGFyZWRfMS5TaXplQW5kVW5pdCh2YWx1ZSwgZW51bXNfMS5TaXplVW5pdC5XZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNoYXJlZF8xLlNpemVBbmRVbml0LnBhcnNlKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgaW52YWxpZFdpZHRoID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaW52YWxpZFdpZHRoID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGludmFsaWRXaWR0aCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmxvZ1BhcnNlRXZlbnQoc2VuZGVyLCBlbnVtc18xLlZhbGlkYXRpb25FdmVudC5JbnZhbGlkUHJvcGVydHlWYWx1ZSwgc3RyaW5nc18xLlN0cmluZ3MuZXJyb3JzLmludmFsaWRDb2x1bW5XaWR0aCh2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSwgZnVuY3Rpb24gKHNlbmRlciwgcHJvcGVydHksIHRhcmdldCwgdmFsdWUsIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAodmFsdWUudW5pdCA9PT0gZW51bXNfMS5TaXplVW5pdC5QaXhlbCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LnNlcmlhbGl6ZVZhbHVlKHRhcmdldCwgXCJ3aWR0aFwiLCB2YWx1ZS5waHlzaWNhbFNpemUgKyBcInB4XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29udGV4dC5zZXJpYWxpemVOdW1iZXIodGFyZ2V0LCBcIndpZHRoXCIsIHZhbHVlLnBoeXNpY2FsU2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgbmV3IHNoYXJlZF8xLlNpemVBbmRVbml0KDEsIGVudW1zXzEuU2l6ZVVuaXQuV2VpZ2h0KSk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShUYWJsZUNvbHVtbkRlZmluaXRpb24uaG9yaXpvbnRhbENlbGxDb250ZW50QWxpZ25tZW50UHJvcGVydHkpXHJcbiAgICBdLCBUYWJsZUNvbHVtbkRlZmluaXRpb24ucHJvdG90eXBlLCBcImhvcml6b250YWxDZWxsQ29udGVudEFsaWdubWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoVGFibGVDb2x1bW5EZWZpbml0aW9uLnZlcnRpY2FsQ2VsbENvbnRlbnRBbGlnbm1lbnRQcm9wZXJ0eSlcclxuICAgIF0sIFRhYmxlQ29sdW1uRGVmaW5pdGlvbi5wcm90b3R5cGUsIFwidmVydGljYWxDZWxsQ29udGVudEFsaWdubWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoVGFibGVDb2x1bW5EZWZpbml0aW9uLndpZHRoUHJvcGVydHkpXHJcbiAgICBdLCBUYWJsZUNvbHVtbkRlZmluaXRpb24ucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XHJcbiAgICByZXR1cm4gVGFibGVDb2x1bW5EZWZpbml0aW9uO1xyXG59KHNlcmlhbGl6YXRpb25fMS5TZXJpYWxpemFibGVPYmplY3QpKTtcclxuZXhwb3J0cy5UYWJsZUNvbHVtbkRlZmluaXRpb24gPSBUYWJsZUNvbHVtbkRlZmluaXRpb247XHJcbnZhciBTdHlsYWJsZUNvbnRhaW5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTdHlsYWJsZUNvbnRhaW5lciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFN0eWxhYmxlQ29udGFpbmVyKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLl9pdGVtcyA9IFtdO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFN0eWxhYmxlQ29udGFpbmVyLnByb3RvdHlwZS5wYXJzZUl0ZW0gPSBmdW5jdGlvbiAoc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gY29udGV4dC5wYXJzZUNhcmRPYmplY3QodGhpcywgc291cmNlLCBbXSwgLy8gRm9yYmlkZGVuIHR5cGVzIG5vdCBzdXBwb3J0ZWQgZm9yIGVsZW1lbnRzIGZvciBub3dcclxuICAgICAgICAhdGhpcy5pc0Rlc2lnbk1vZGUoKSwgZnVuY3Rpb24gKHR5cGVOYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jcmVhdGVJdGVtSW5zdGFuY2UodHlwZU5hbWUpO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uICh0eXBlTmFtZSwgX2Vycm9yVHlwZSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmxvZ1BhcnNlRXZlbnQodW5kZWZpbmVkLCBlbnVtc18xLlZhbGlkYXRpb25FdmVudC5FbGVtZW50VHlwZU5vdEFsbG93ZWQsIHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy5lbGVtZW50VHlwZU5vdEFsbG93ZWQodHlwZU5hbWUpKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTdHlsYWJsZUNvbnRhaW5lci5wcm90b3R5cGUuaW50ZXJuYWxBZGRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICBpZiAoIWl0ZW0ucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgIGl0ZW0uc2V0UGFyZW50KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cmluZ3NfMS5TdHJpbmdzLmVycm9ycy5lbGVtZW50QWxyZWFkeVBhcmVudGVkKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTdHlsYWJsZUNvbnRhaW5lci5wcm90b3R5cGUuaW50ZXJuYWxSZW1vdmVJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB2YXIgaXRlbUluZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihpdGVtKTtcclxuICAgICAgICBpZiAoaXRlbUluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgdGhpcy5faXRlbXMuc3BsaWNlKGl0ZW1JbmRleCwgMSk7XHJcbiAgICAgICAgICAgIGl0ZW0uc2V0UGFyZW50KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGF5b3V0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgU3R5bGFibGVDb250YWluZXIucHJvdG90eXBlLmludGVybmFsSW5kZXhPZiA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmluZGV4T2YoaXRlbSk7XHJcbiAgICB9O1xyXG4gICAgU3R5bGFibGVDb250YWluZXIucHJvdG90eXBlLmludGVybmFsUGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbnRlcm5hbFBhcnNlLmNhbGwodGhpcywgc291cmNlLCBjb250ZXh0KTtcclxuICAgICAgICB0aGlzLl9pdGVtcyA9IFtdO1xyXG4gICAgICAgIHZhciBpdGVtcyA9IHNvdXJjZVt0aGlzLmdldENvbGxlY3Rpb25Qcm9wZXJ0eU5hbWUoKV07XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgaXRlbXNfMSA9IGl0ZW1zOyBfaSA8IGl0ZW1zXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5wYXJzZUl0ZW0oaXRlbSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVtcy5wdXNoKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTdHlsYWJsZUNvbnRhaW5lci5wcm90b3R5cGUuaW50ZXJuYWxUb0pTT04gPSBmdW5jdGlvbiAodGFyZ2V0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbnRlcm5hbFRvSlNPTi5jYWxsKHRoaXMsIHRhcmdldCwgY29udGV4dCk7XHJcbiAgICAgICAgY29udGV4dC5zZXJpYWxpemVBcnJheSh0YXJnZXQsIHRoaXMuZ2V0Q29sbGVjdGlvblByb3BlcnR5TmFtZSgpLCB0aGlzLl9pdGVtcyk7XHJcbiAgICB9O1xyXG4gICAgU3R5bGFibGVDb250YWluZXIucHJvdG90eXBlLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsUmVtb3ZlSXRlbShpdGVtKTtcclxuICAgIH07XHJcbiAgICBTdHlsYWJsZUNvbnRhaW5lci5wcm90b3R5cGUuZ2V0SXRlbUNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgU3R5bGFibGVDb250YWluZXIucHJvdG90eXBlLmdldEl0ZW1BdCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtc1tpbmRleF07XHJcbiAgICB9O1xyXG4gICAgU3R5bGFibGVDb250YWluZXIucHJvdG90eXBlLmdldEZpcnN0VmlzaWJsZVJlbmRlcmVkSXRlbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtQ291bnQoKSA+IDAgPyB0aGlzLmdldEl0ZW1BdCgwKSA6IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBTdHlsYWJsZUNvbnRhaW5lci5wcm90b3R5cGUuZ2V0TGFzdFZpc2libGVSZW5kZXJlZEl0ZW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbUNvdW50KCkgPiAwID8gdGhpcy5nZXRJdGVtQXQodGhpcy5nZXRJdGVtQ291bnQoKSAtIDEpIDogdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTdHlsYWJsZUNvbnRhaW5lcjtcclxufShjYXJkX2VsZW1lbnRzXzEuU3R5bGFibGVDYXJkRWxlbWVudENvbnRhaW5lcikpO1xyXG5leHBvcnRzLlN0eWxhYmxlQ29udGFpbmVyID0gU3R5bGFibGVDb250YWluZXI7XHJcbnZhciBUYWJsZUNlbGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVGFibGVDZWxsLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVGFibGVDZWxsKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLl9jb2x1bW5JbmRleCA9IC0xO1xyXG4gICAgICAgIF90aGlzLl9jZWxsVHlwZSA9IFwiZGF0YVwiO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFRhYmxlQ2VsbC5wcm90b3R5cGUuZ2V0SGFzQm9yZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudFJvdy5wYXJlbnRUYWJsZS5zaG93R3JpZExpbmVzO1xyXG4gICAgfTtcclxuICAgIFRhYmxlQ2VsbC5wcm90b3R5cGUuYXBwbHlCb3JkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRFbGVtZW50ICYmIHRoaXMuZ2V0SGFzQm9yZGVyKCkpIHtcclxuICAgICAgICAgICAgdmFyIHN0eWxlRGVmaW5pdGlvbiA9IHRoaXMuaG9zdENvbmZpZy5jb250YWluZXJTdHlsZXMuZ2V0U3R5bGVCeU5hbWUodGhpcy5wYXJlbnRSb3cucGFyZW50VGFibGUuZ3JpZFN0eWxlKTtcclxuICAgICAgICAgICAgaWYgKHN0eWxlRGVmaW5pdGlvbi5ib3JkZXJDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvcmRlckNvbG9yID0gKDAsIHV0aWxzXzEuc3RyaW5nVG9Dc3NDb2xvcikoc3R5bGVEZWZpbml0aW9uLmJvcmRlckNvbG9yKTtcclxuICAgICAgICAgICAgICAgIGlmIChib3JkZXJDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50LnN0eWxlLmJvcmRlclJpZ2h0ID0gXCIxcHggc29saWQgXCIgKyBib3JkZXJDb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudC5zdHlsZS5ib3JkZXJCb3R0b20gPSBcIjFweCBzb2xpZCBcIiArIGJvcmRlckNvbG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRhYmxlQ2VsbC5wcm90b3R5cGUuZ2V0RGVmYXVsdFBhZGRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SGFzQmFja2dyb3VuZCgpIHx8IHRoaXMuZ2V0SGFzQm9yZGVyKClcclxuICAgICAgICAgICAgPyBuZXcgc2hhcmVkXzEuUGFkZGluZ0RlZmluaXRpb24oZW51bXNfMS5TcGFjaW5nLlNtYWxsLCBlbnVtc18xLlNwYWNpbmcuU21hbGwsIGVudW1zXzEuU3BhY2luZy5TbWFsbCwgZW51bXNfMS5TcGFjaW5nLlNtYWxsKVxyXG4gICAgICAgICAgICA6IF9zdXBlci5wcm90b3R5cGUuZ2V0RGVmYXVsdFBhZGRpbmcuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBUYWJsZUNlbGwucHJvdG90eXBlLmludGVybmFsUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjZWxsRWxlbWVudCA9IF9zdXBlci5wcm90b3R5cGUuaW50ZXJuYWxSZW5kZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAoY2VsbEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY2VsbEVsZW1lbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCB0aGlzLmNlbGxUeXBlID09PSBcImRhdGFcIiA/IFwiY2VsbFwiIDogXCJjb2x1bW5oZWFkZXJcIik7XHJcbiAgICAgICAgICAgIGNlbGxFbGVtZW50LnN0eWxlLm1pbldpZHRoID0gXCIwXCI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNlbGxUeXBlID09PSBcImhlYWRlclwiKSB7XHJcbiAgICAgICAgICAgICAgICBjZWxsRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzY29wZVwiLCBcImNvbFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2VsbEVsZW1lbnQ7XHJcbiAgICB9O1xyXG4gICAgVGFibGVDZWxsLnByb3RvdHlwZS5zaG91bGRTZXJpYWxpemUgPSBmdW5jdGlvbiAoX2NvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBUYWJsZUNlbGwucHJvdG90eXBlLmdldEpzb25UeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXCJUYWJsZUNlbGxcIjtcclxuICAgIH07XHJcbiAgICBUYWJsZUNlbGwucHJvdG90eXBlLmdldEVmZmVjdGl2ZVRleHRTdHlsZURlZmluaXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2VsbFR5cGUgPT09IFwiaGVhZGVyXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaG9zdENvbmZpZy50ZXh0U3R5bGVzLmNvbHVtbkhlYWRlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZ2V0RWZmZWN0aXZlVGV4dFN0eWxlRGVmaW5pdGlvbi5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIFRhYmxlQ2VsbC5wcm90b3R5cGUuZ2V0RWZmZWN0aXZlSG9yaXpvbnRhbEFsaWdubWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5ob3Jpem9udGFsQWxpZ25tZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaG9yaXpvbnRhbEFsaWdubWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Um93Lmhvcml6b250YWxDZWxsQ29udGVudEFsaWdubWVudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudFJvdy5ob3Jpem9udGFsQ2VsbENvbnRlbnRBbGlnbm1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgdmFyIGhvcml6b250YWxBbGlnbm1lbnQgPSB0aGlzLnBhcmVudFJvdy5wYXJlbnRUYWJsZS5nZXRDb2x1bW5BdCh0aGlzLmNvbHVtbkluZGV4KS5ob3Jpem9udGFsQ2VsbENvbnRlbnRBbGlnbm1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChob3Jpem9udGFsQWxpZ25tZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBob3Jpem9udGFsQWxpZ25tZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudFJvdy5wYXJlbnRUYWJsZS5ob3Jpem9udGFsQ2VsbENvbnRlbnRBbGlnbm1lbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRSb3cucGFyZW50VGFibGUuaG9yaXpvbnRhbENlbGxDb250ZW50QWxpZ25tZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5nZXRFZmZlY3RpdmVIb3Jpem9udGFsQWxpZ25tZW50LmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgVGFibGVDZWxsLnByb3RvdHlwZS5nZXRFZmZlY3RpdmVWZXJ0aWNhbENvbnRlbnRBbGlnbm1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmVydGljYWxDb250ZW50QWxpZ25tZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVydGljYWxDb250ZW50QWxpZ25tZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wYXJlbnRSb3cudmVydGljYWxDZWxsQ29udGVudEFsaWdubWVudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudFJvdy52ZXJ0aWNhbENlbGxDb250ZW50QWxpZ25tZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jb2x1bW5JbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbEFsaWdubWVudCA9IHRoaXMucGFyZW50Um93LnBhcmVudFRhYmxlLmdldENvbHVtbkF0KHRoaXMuY29sdW1uSW5kZXgpLnZlcnRpY2FsQ2VsbENvbnRlbnRBbGlnbm1lbnQ7XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNhbEFsaWdubWVudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVydGljYWxBbGlnbm1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Um93LnBhcmVudFRhYmxlLnZlcnRpY2FsQ2VsbENvbnRlbnRBbGlnbm1lbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRSb3cucGFyZW50VGFibGUudmVydGljYWxDZWxsQ29udGVudEFsaWdubWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZ2V0RWZmZWN0aXZlVmVydGljYWxDb250ZW50QWxpZ25tZW50LmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlQ2VsbC5wcm90b3R5cGUsIFwiY29sdW1uSW5kZXhcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sdW1uSW5kZXg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlQ2VsbC5wcm90b3R5cGUsIFwiY2VsbFR5cGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2VsbFR5cGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlQ2VsbC5wcm90b3R5cGUsIFwicGFyZW50Um93XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZUNlbGwucHJvdG90eXBlLCBcImlzU3RhbmRhbG9uZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gVGFibGVDZWxsO1xyXG59KGNhcmRfZWxlbWVudHNfMS5Db250YWluZXIpKTtcclxuZXhwb3J0cy5UYWJsZUNlbGwgPSBUYWJsZUNlbGw7XHJcbnZhciBUYWJsZVJvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhUYWJsZVJvdywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRhYmxlUm93KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgVGFibGVSb3cucHJvdG90eXBlLmdldERlZmF1bHRQYWRkaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgc2hhcmVkXzEuUGFkZGluZ0RlZmluaXRpb24oZW51bXNfMS5TcGFjaW5nLk5vbmUsIGVudW1zXzEuU3BhY2luZy5Ob25lLCBlbnVtc18xLlNwYWNpbmcuTm9uZSwgZW51bXNfMS5TcGFjaW5nLk5vbmUpO1xyXG4gICAgfTtcclxuICAgIFRhYmxlUm93LnByb3RvdHlwZS5hcHBseUJhY2tncm91bmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZURlZmluaXRpb24gPSB0aGlzLmhvc3RDb25maWcuY29udGFpbmVyU3R5bGVzLmdldFN0eWxlQnlOYW1lKHRoaXMuc3R5bGUsIHRoaXMuaG9zdENvbmZpZy5jb250YWluZXJTdHlsZXMuZ2V0U3R5bGVCeU5hbWUodGhpcy5kZWZhdWx0U3R5bGUpKTtcclxuICAgICAgICAgICAgaWYgKHN0eWxlRGVmaW5pdGlvbi5iYWNrZ3JvdW5kQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiZ0NvbG9yID0gKDAsIHV0aWxzXzEuc3RyaW5nVG9Dc3NDb2xvcikoc3R5bGVEZWZpbml0aW9uLmJhY2tncm91bmRDb2xvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmdDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGJnQ29sb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGFibGVSb3cucHJvdG90eXBlLmdldENvbGxlY3Rpb25Qcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiY2VsbHNcIjtcclxuICAgIH07XHJcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUuY3JlYXRlSXRlbUluc3RhbmNlID0gZnVuY3Rpb24gKHR5cGVOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuICF0eXBlTmFtZSB8fCB0eXBlTmFtZSA9PT0gXCJUYWJsZUNlbGxcIiA/IG5ldyBUYWJsZUNlbGwoKSA6IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUuaW50ZXJuYWxSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlzRmlyc3RSb3cgPSB0aGlzLmdldElzRmlyc3RSb3coKTtcclxuICAgICAgICB2YXIgY2VsbFNwYWNpbmcgPSB0aGlzLmhvc3RDb25maWcudGFibGUuY2VsbFNwYWNpbmc7XHJcbiAgICAgICAgdmFyIHJvd0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIHJvd0VsZW1lbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInJvd1wiKTtcclxuICAgICAgICByb3dFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcclxuICAgICAgICByb3dFbGVtZW50LnN0eWxlLmZsZXhEaXJlY3Rpb24gPSBcInJvd1wiO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5taW4odGhpcy5nZXRJdGVtQ291bnQoKSwgdGhpcy5wYXJlbnRUYWJsZS5nZXRDb2x1bW5Db3VudCgpKTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5nZXRJdGVtQXQoaSk7XHJcbiAgICAgICAgICAgIC8vIENoZWF0aW5nIGEgYml0IGluIG9yZGVyIHRvIGtlZXAgY2VsbFR5cGUgcmVhZC1vbmx5XHJcbiAgICAgICAgICAgIGNlbGxbXCJfY29sdW1uSW5kZXhcIl0gPSBpO1xyXG4gICAgICAgICAgICBjZWxsW1wiX2NlbGxUeXBlXCJdID1cclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50VGFibGUuZmlyc3RSb3dBc0hlYWRlcnMgJiYgaXNGaXJzdFJvdyA/IFwiaGVhZGVyXCIgOiBcImRhdGFcIjtcclxuICAgICAgICAgICAgdmFyIHJlbmRlcmVkQ2VsbCA9IGNlbGwucmVuZGVyKCk7XHJcbiAgICAgICAgICAgIGlmIChyZW5kZXJlZENlbGwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLnBhcmVudFRhYmxlLmdldENvbHVtbkF0KGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5jb21wdXRlZFdpZHRoLnVuaXQgPT09IGVudW1zXzEuU2l6ZVVuaXQuUGl4ZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZENlbGwuc3R5bGUuZmxleCA9IFwiMCAwIFwiICsgY29sdW1uLmNvbXB1dGVkV2lkdGgucGh5c2ljYWxTaXplICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRDZWxsLnN0eWxlLmZsZXggPSBcIjEgMSBcIiArIGNvbHVtbi5jb21wdXRlZFdpZHRoLnBoeXNpY2FsU2l6ZSArIFwiJVwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwICYmICF0aGlzLnBhcmVudFRhYmxlLnNob3dHcmlkTGluZXMgJiYgY2VsbFNwYWNpbmcgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRDZWxsLnN0eWxlLm1hcmdpbkxlZnQgPSBjZWxsU3BhY2luZyArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJvd0VsZW1lbnQuYXBwZW5kQ2hpbGQocmVuZGVyZWRDZWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcm93RWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPiAwID8gcm93RWxlbWVudCA6IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUuc2hvdWxkU2VyaWFsaXplID0gZnVuY3Rpb24gKF9jb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgVGFibGVSb3cucHJvdG90eXBlLmFkZENlbGwgPSBmdW5jdGlvbiAoY2VsbCkge1xyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxBZGRJdGVtKGNlbGwpO1xyXG4gICAgfTtcclxuICAgIFRhYmxlUm93LnByb3RvdHlwZS5yZW1vdmVDZWxsQXQgPSBmdW5jdGlvbiAoY29sdW1uSW5kZXgpIHtcclxuICAgICAgICBpZiAoY29sdW1uSW5kZXggPj0gMCAmJiBjb2x1bW5JbmRleCA8IHRoaXMuZ2V0SXRlbUNvdW50KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlSXRlbSh0aGlzLmdldEl0ZW1BdChjb2x1bW5JbmRleCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgVGFibGVSb3cucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoY2FyZEVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gY2FyZEVsZW1lbnQgaW5zdGFuY2VvZiBUYWJsZUNlbGwgPyB0aGlzLmludGVybmFsSW5kZXhPZihjYXJkRWxlbWVudCkgOiAtMTtcclxuICAgIH07XHJcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUuZW5zdXJlSGFzRW5vdWdoQ2VsbHMgPSBmdW5jdGlvbiAoY2VsbENvdW50KSB7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuZ2V0SXRlbUNvdW50KCkgPCBjZWxsQ291bnQpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRDZWxsKG5ldyBUYWJsZUNlbGwoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRhYmxlUm93LnByb3RvdHlwZS5nZXRKc29uVHlwZU5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiVGFibGVSb3dcIjtcclxuICAgIH07XHJcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUuZ2V0SXNGaXJzdFJvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRUYWJsZS5nZXRJdGVtQXQoMCkgPT09IHRoaXM7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlUm93LnByb3RvdHlwZSwgXCJwYXJlbnRUYWJsZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVSb3cucHJvdG90eXBlLCBcImlzU3RhbmRhbG9uZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvLyNyZWdpb24gU2NoZW1hXHJcbiAgICBUYWJsZVJvdy5zdHlsZVByb3BlcnR5ID0gbmV3IGNhcmRfZWxlbWVudHNfMS5Db250YWluZXJTdHlsZVByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV81LCBcInN0eWxlXCIpO1xyXG4gICAgVGFibGVSb3cuaG9yaXpvbnRhbENlbGxDb250ZW50QWxpZ25tZW50UHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLkVudW1Qcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfNSwgXCJob3Jpem9udGFsQ2VsbENvbnRlbnRBbGlnbm1lbnRcIiwgZW51bXNfMS5Ib3Jpem9udGFsQWxpZ25tZW50KTtcclxuICAgIFRhYmxlUm93LnZlcnRpY2FsQ2VsbENvbnRlbnRBbGlnbm1lbnRQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuRW51bVByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV81LCBcInZlcnRpY2FsQ2VsbENvbnRlbnRBbGlnbm1lbnRcIiwgZW51bXNfMS5WZXJ0aWNhbEFsaWdubWVudCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgc2VyaWFsaXphdGlvbl8xLnByb3BlcnR5KShUYWJsZVJvdy5ob3Jpem9udGFsQ2VsbENvbnRlbnRBbGlnbm1lbnRQcm9wZXJ0eSlcclxuICAgIF0sIFRhYmxlUm93LnByb3RvdHlwZSwgXCJob3Jpem9udGFsQ2VsbENvbnRlbnRBbGlnbm1lbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKFRhYmxlUm93LnZlcnRpY2FsQ2VsbENvbnRlbnRBbGlnbm1lbnRQcm9wZXJ0eSlcclxuICAgIF0sIFRhYmxlUm93LnByb3RvdHlwZSwgXCJ2ZXJ0aWNhbENlbGxDb250ZW50QWxpZ25tZW50XCIsIHZvaWQgMCk7XHJcbiAgICByZXR1cm4gVGFibGVSb3c7XHJcbn0oU3R5bGFibGVDb250YWluZXIpKTtcclxuZXhwb3J0cy5UYWJsZVJvdyA9IFRhYmxlUm93O1xyXG52YXIgVGFibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVGFibGUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUYWJsZSgpIHtcclxuICAgICAgICAvLyNyZWdpb24gU2NoZW1hXHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX2NvbHVtbnMgPSBbXTtcclxuICAgICAgICBfdGhpcy5maXJzdFJvd0FzSGVhZGVycyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuc2hvd0dyaWRMaW5lcyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlLnByb3RvdHlwZSwgXCJncmlkU3R5bGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmdldFZhbHVlKFRhYmxlLmdyaWRTdHlsZVByb3BlcnR5KTtcclxuICAgICAgICAgICAgaWYgKHN0eWxlICYmIHRoaXMuaG9zdENvbmZpZy5jb250YWluZXJTdHlsZXMuZ2V0U3R5bGVCeU5hbWUoc3R5bGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUoVGFibGUuZ3JpZFN0eWxlUHJvcGVydHksIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICAgIFRhYmxlLnByb3RvdHlwZS5lbnN1cmVSb3dzSGF2ZUVub3VnaENlbGxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nZXRJdGVtQ291bnQoKTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0SXRlbUF0KGkpLmVuc3VyZUhhc0Vub3VnaENlbGxzKHRoaXMuZ2V0Q29sdW1uQ291bnQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRhYmxlLnByb3RvdHlwZS5yZW1vdmVDZWxsc0Zyb21Db2x1bW4gPSBmdW5jdGlvbiAoY29sdW1uSW5kZXgpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ2V0SXRlbUNvdW50KCk7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmdldEl0ZW1BdChpKS5yZW1vdmVDZWxsQXQoY29sdW1uSW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUYWJsZS5wcm90b3R5cGUuZ2V0Q29sbGVjdGlvblByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXCJyb3dzXCI7XHJcbiAgICB9O1xyXG4gICAgVGFibGUucHJvdG90eXBlLmNyZWF0ZUl0ZW1JbnN0YW5jZSA9IGZ1bmN0aW9uICh0eXBlTmFtZSkge1xyXG4gICAgICAgIHJldHVybiAhdHlwZU5hbWUgfHwgdHlwZU5hbWUgPT09IFwiVGFibGVSb3dcIiA/IG5ldyBUYWJsZVJvdygpIDogdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIFRhYmxlLnByb3RvdHlwZS5pbnRlcm5hbFBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY29udGV4dCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW50ZXJuYWxQYXJzZS5jYWxsKHRoaXMsIHNvdXJjZSwgY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVSb3dzSGF2ZUVub3VnaENlbGxzKCk7XHJcbiAgICB9O1xyXG4gICAgVGFibGUucHJvdG90eXBlLmludGVybmFsUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmdldEl0ZW1Db3VudCgpID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgdG90YWxXZWlnaHRzID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX2NvbHVtbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi53aWR0aC51bml0ID09PSBlbnVtc18xLlNpemVVbml0LldlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsV2VpZ2h0cyArPSBjb2x1bW4ud2lkdGgucGh5c2ljYWxTaXplO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSB0aGlzLl9jb2x1bW5zOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IF9jW19iXTtcclxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4ud2lkdGgudW5pdCA9PT0gZW51bXNfMS5TaXplVW5pdC5QaXhlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5jb21wdXRlZFdpZHRoID0gbmV3IHNoYXJlZF8xLlNpemVBbmRVbml0KGNvbHVtbi53aWR0aC5waHlzaWNhbFNpemUsIGVudW1zXzEuU2l6ZVVuaXQuUGl4ZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLmNvbXB1dGVkV2lkdGggPSBuZXcgc2hhcmVkXzEuU2l6ZUFuZFVuaXQoKDEwMCAvIHRvdGFsV2VpZ2h0cykgKiBjb2x1bW4ud2lkdGgucGh5c2ljYWxTaXplLCBlbnVtc18xLlNpemVVbml0LldlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRhYmxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIHRhYmxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidGFibGVcIik7XHJcbiAgICAgICAgICAgIHRhYmxlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XHJcbiAgICAgICAgICAgIHRhYmxlRWxlbWVudC5zdHlsZS5mbGV4RGlyZWN0aW9uID0gXCJjb2x1bW5cIjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0dyaWRMaW5lcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlRGVmaW5pdGlvbiA9IHRoaXMuaG9zdENvbmZpZy5jb250YWluZXJTdHlsZXMuZ2V0U3R5bGVCeU5hbWUodGhpcy5ncmlkU3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlRGVmaW5pdGlvbi5ib3JkZXJDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib3JkZXJDb2xvciA9ICgwLCB1dGlsc18xLnN0cmluZ1RvQ3NzQ29sb3IpKHN0eWxlRGVmaW5pdGlvbi5ib3JkZXJDb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvcmRlckNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlRWxlbWVudC5zdHlsZS5ib3JkZXJUb3AgPSBcIjFweCBzb2xpZCBcIiArIGJvcmRlckNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZUVsZW1lbnQuc3R5bGUuYm9yZGVyTGVmdCA9IFwiMXB4IHNvbGlkIFwiICsgYm9yZGVyQ29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjZWxsU3BhY2luZyA9IHRoaXMuaG9zdENvbmZpZy50YWJsZS5jZWxsU3BhY2luZztcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdldEl0ZW1Db3VudCgpOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciByZW5kZXJlZFJvdyA9IHRoaXMuZ2V0SXRlbUF0KGkpLnJlbmRlcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlbmRlcmVkUm93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwICYmICF0aGlzLnNob3dHcmlkTGluZXMgJiYgY2VsbFNwYWNpbmcgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0b3JSb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3JSb3cuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3JSb3cuc3R5bGUuaGVpZ2h0ID0gY2VsbFNwYWNpbmcgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlRWxlbWVudC5hcHBlbmRDaGlsZChzZXBhcmF0b3JSb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0YWJsZUVsZW1lbnQuYXBwZW5kQ2hpbGQocmVuZGVyZWRSb3cpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YWJsZUVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgVGFibGUucHJvdG90eXBlLmFkZENvbHVtbiA9IGZ1bmN0aW9uIChjb2x1bW4pIHtcclxuICAgICAgICB0aGlzLl9jb2x1bW5zLnB1c2goY29sdW1uKTtcclxuICAgICAgICB0aGlzLmVuc3VyZVJvd3NIYXZlRW5vdWdoQ2VsbHMoKTtcclxuICAgIH07XHJcbiAgICBUYWJsZS5wcm90b3R5cGUucmVtb3ZlQ29sdW1uID0gZnVuY3Rpb24gKGNvbHVtbikge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2NvbHVtbnMuaW5kZXhPZihjb2x1bW4pO1xyXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2VsbHNGcm9tQ29sdW1uKGluZGV4KTtcclxuICAgICAgICAgICAgdGhpcy5fY29sdW1ucy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUYWJsZS5wcm90b3R5cGUuZ2V0Q29sdW1uQ291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbnMubGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIFRhYmxlLnByb3RvdHlwZS5nZXRDb2x1bW5BdCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zW2luZGV4XTtcclxuICAgIH07XHJcbiAgICBUYWJsZS5wcm90b3R5cGUuYWRkUm93ID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxBZGRJdGVtKHJvdyk7XHJcbiAgICAgICAgcm93LmVuc3VyZUhhc0Vub3VnaENlbGxzKHRoaXMuZ2V0Q29sdW1uQ291bnQoKSk7XHJcbiAgICB9O1xyXG4gICAgVGFibGUucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoY2FyZEVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gY2FyZEVsZW1lbnQgaW5zdGFuY2VvZiBUYWJsZVJvdyA/IHRoaXMuaW50ZXJuYWxJbmRleE9mKGNhcmRFbGVtZW50KSA6IC0xO1xyXG4gICAgfTtcclxuICAgIFRhYmxlLnByb3RvdHlwZS5nZXRKc29uVHlwZU5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiVGFibGVcIjtcclxuICAgIH07XHJcbiAgICBUYWJsZS5fY29sdW1uc1Byb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5TZXJpYWxpemFibGVPYmplY3RDb2xsZWN0aW9uUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzUsIFwiY29sdW1uc1wiLCBUYWJsZUNvbHVtbkRlZmluaXRpb24pO1xyXG4gICAgVGFibGUuZmlyc3RSb3dBc0hlYWRlcnNQcm9wZXJ0eSA9IG5ldyBzZXJpYWxpemF0aW9uXzEuQm9vbFByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV81LCBcImZpcnN0Um93QXNIZWFkZXJzXCIsIHRydWUpO1xyXG4gICAgVGFibGUuc2hvd0dyaWRMaW5lc1Byb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5Cb29sUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzUsIFwic2hvd0dyaWRMaW5lc1wiLCB0cnVlKTtcclxuICAgIFRhYmxlLmdyaWRTdHlsZVByb3BlcnR5ID0gbmV3IGNhcmRfZWxlbWVudHNfMS5Db250YWluZXJTdHlsZVByb3BlcnR5KHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV81LCBcImdyaWRTdHlsZVwiKTtcclxuICAgIFRhYmxlLmhvcml6b250YWxDZWxsQ29udGVudEFsaWdubWVudFByb3BlcnR5ID0gbmV3IHNlcmlhbGl6YXRpb25fMS5FbnVtUHJvcGVydHkoc2VyaWFsaXphdGlvbl8xLlZlcnNpb25zLnYxXzUsIFwiaG9yaXpvbnRhbENlbGxDb250ZW50QWxpZ25tZW50XCIsIGVudW1zXzEuSG9yaXpvbnRhbEFsaWdubWVudCk7XHJcbiAgICBUYWJsZS52ZXJ0aWNhbENlbGxDb250ZW50QWxpZ25tZW50UHJvcGVydHkgPSBuZXcgc2VyaWFsaXphdGlvbl8xLkVudW1Qcm9wZXJ0eShzZXJpYWxpemF0aW9uXzEuVmVyc2lvbnMudjFfNSwgXCJ2ZXJ0aWNhbENlbGxDb250ZW50QWxpZ25tZW50XCIsIGVudW1zXzEuVmVydGljYWxBbGlnbm1lbnQpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoVGFibGUuX2NvbHVtbnNQcm9wZXJ0eSlcclxuICAgIF0sIFRhYmxlLnByb3RvdHlwZSwgXCJfY29sdW1uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoVGFibGUuZmlyc3RSb3dBc0hlYWRlcnNQcm9wZXJ0eSlcclxuICAgIF0sIFRhYmxlLnByb3RvdHlwZSwgXCJmaXJzdFJvd0FzSGVhZGVyc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoVGFibGUuc2hvd0dyaWRMaW5lc1Byb3BlcnR5KVxyXG4gICAgXSwgVGFibGUucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKFRhYmxlLmdyaWRTdHlsZVByb3BlcnR5KVxyXG4gICAgXSwgVGFibGUucHJvdG90eXBlLCBcImdyaWRTdHlsZVwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCBzZXJpYWxpemF0aW9uXzEucHJvcGVydHkpKFRhYmxlLmhvcml6b250YWxDZWxsQ29udGVudEFsaWdubWVudFByb3BlcnR5KVxyXG4gICAgXSwgVGFibGUucHJvdG90eXBlLCBcImhvcml6b250YWxDZWxsQ29udGVudEFsaWdubWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHNlcmlhbGl6YXRpb25fMS5wcm9wZXJ0eSkoVGFibGUudmVydGljYWxDZWxsQ29udGVudEFsaWdubWVudFByb3BlcnR5KVxyXG4gICAgXSwgVGFibGUucHJvdG90eXBlLCBcInZlcnRpY2FsQ2VsbENvbnRlbnRBbGlnbm1lbnRcIiwgdm9pZCAwKTtcclxuICAgIHJldHVybiBUYWJsZTtcclxufShTdHlsYWJsZUNvbnRhaW5lcikpO1xyXG5leHBvcnRzLlRhYmxlID0gVGFibGU7XHJcbnJlZ2lzdHJ5XzEuR2xvYmFsUmVnaXN0cnkuZGVmYXVsdEVsZW1lbnRzLnJlZ2lzdGVyKFwiVGFibGVcIiwgVGFibGUsIHNlcmlhbGl6YXRpb25fMS5WZXJzaW9ucy52MV81KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZm9ybWF0VGV4dCA9IHZvaWQgMDtcclxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxudmFyIEFic3RyYWN0VGV4dEZvcm1hdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFic3RyYWN0VGV4dEZvcm1hdHRlcihyZWd1bGFyRXhwcmVzc2lvbikge1xyXG4gICAgICAgIHRoaXMuX3JlZ3VsYXJFeHByZXNzaW9uID0gcmVndWxhckV4cHJlc3Npb247XHJcbiAgICB9XHJcbiAgICBBYnN0cmFjdFRleHRGb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChsYW5nLCBpbnB1dCkge1xyXG4gICAgICAgIHZhciBtYXRjaGVzO1xyXG4gICAgICAgIGlmIChpbnB1dCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaW5wdXQ7XHJcbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2hlcyA9IHRoaXMuX3JlZ3VsYXJFeHByZXNzaW9uLmV4ZWMoaW5wdXQpKSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShtYXRjaGVzWzBdLCB0aGlzLmludGVybmFsRm9ybWF0KGxhbmcsIG1hdGNoZXMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gQWJzdHJhY3RUZXh0Rm9ybWF0dGVyO1xyXG59KCkpO1xyXG52YXIgRGF0ZUZvcm1hdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEYXRlRm9ybWF0dGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGF0ZUZvcm1hdHRlcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBEYXRlRm9ybWF0dGVyLnByb3RvdHlwZS5pbnRlcm5hbEZvcm1hdCA9IGZ1bmN0aW9uIChsYW5nLCBtYXRjaGVzKSB7XHJcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLnBhcnNlKG1hdGNoZXNbMV0pKTtcclxuICAgICAgICB2YXIgZm9ybWF0ID0gbWF0Y2hlc1syXSAhPT0gdW5kZWZpbmVkID8gbWF0Y2hlc1syXS50b0xvd2VyQ2FzZSgpIDogXCJjb21wYWN0XCI7XHJcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJjb21wYWN0XCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKGxhbmcsIHtcclxuICAgICAgICAgICAgICAgIGRheTogXCJudW1lcmljXCIsXHJcbiAgICAgICAgICAgICAgICB3ZWVrZGF5OiBmb3JtYXQsXHJcbiAgICAgICAgICAgICAgICBtb250aDogZm9ybWF0LFxyXG4gICAgICAgICAgICAgICAgeWVhcjogXCJudW1lcmljXCJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERhdGVGb3JtYXR0ZXI7XHJcbn0oQWJzdHJhY3RUZXh0Rm9ybWF0dGVyKSk7XHJcbnZhciBUaW1lRm9ybWF0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFRpbWVGb3JtYXR0ZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW1lRm9ybWF0dGVyKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFRpbWVGb3JtYXR0ZXIucHJvdG90eXBlLmludGVybmFsRm9ybWF0ID0gZnVuY3Rpb24gKGxhbmcsIG1hdGNoZXMpIHtcclxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUucGFyc2UobWF0Y2hlc1sxXSkpO1xyXG4gICAgICAgIHJldHVybiBkYXRlLnRvTG9jYWxlVGltZVN0cmluZyhsYW5nLCB7IGhvdXI6IFwibnVtZXJpY1wiLCBtaW51dGU6IFwiMi1kaWdpdFwiIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUaW1lRm9ybWF0dGVyO1xyXG59KEFic3RyYWN0VGV4dEZvcm1hdHRlcikpO1xyXG5mdW5jdGlvbiBmb3JtYXRUZXh0KGxhbmcsIHRleHQpIHtcclxuICAgIHZhciBmb3JtYXR0ZXJzID0gW1xyXG4gICAgICAgIG5ldyBEYXRlRm9ybWF0dGVyKC9cXHt7Mn1EQVRFXFwoKFxcZHs0fS1cXGR7Mn0tXFxkezJ9VFxcZHsyfTpcXGR7Mn06XFxkezJ9KD86WnwoPzooPzotfFxcKylcXGR7Mn06XFxkezJ9KSkpKD86LCA/KENPTVBBQ1R8TE9OR3xTSE9SVCkpP1xcKVxcfXsyfS9nKSxcclxuICAgICAgICBuZXcgVGltZUZvcm1hdHRlcigvXFx7ezJ9VElNRVxcKChcXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfSg/Olp8KD86KD86LXxcXCspXFxkezJ9OlxcZHsyfSkpKVxcKVxcfXsyfS9nKVxyXG4gICAgXTtcclxuICAgIHZhciByZXN1bHQgPSB0ZXh0O1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBmb3JtYXR0ZXJzXzEgPSBmb3JtYXR0ZXJzOyBfaSA8IGZvcm1hdHRlcnNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgZm9ybWF0dGVyID0gZm9ybWF0dGVyc18xW19pXTtcclxuICAgICAgICByZXN1bHQgPSBmb3JtYXR0ZXIuZm9ybWF0KGxhbmcsIHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmV4cG9ydHMuZm9ybWF0VGV4dCA9IGZvcm1hdFRleHQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHQtZm9ybWF0dGVycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9hO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuY2xlYXJFbGVtZW50Q2hpbGRyZW4gPSBleHBvcnRzLmdldFNjcm9sbFkgPSBleHBvcnRzLmdldFNjcm9sbFggPSBleHBvcnRzLmdldEZpdFN0YXR1cyA9IGV4cG9ydHMudHJ1bmNhdGUgPSBleHBvcnRzLnRydW5jYXRlVGV4dCA9IGV4cG9ydHMuc3RyaW5nVG9Dc3NDb2xvciA9IGV4cG9ydHMucGFyc2VFbnVtID0gZXhwb3J0cy5nZXRFbnVtVmFsdWVCeU5hbWUgPSBleHBvcnRzLnBhcnNlQm9vbCA9IGV4cG9ydHMucGFyc2VOdW1iZXIgPSBleHBvcnRzLnBhcnNlU3RyaW5nID0gZXhwb3J0cy5hcHBlbmRDaGlsZCA9IGV4cG9ydHMuZ2VuZXJhdGVVbmlxdWVJZCA9IGV4cG9ydHMuaXNNb2JpbGVPUyA9IGV4cG9ydHMuaXNJbnRlcm5ldEV4cGxvcmVyID0gdm9pZCAwO1xyXG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG52YXIgRW51bXMgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcclxudmFyIFNoYXJlZCA9IHJlcXVpcmUoXCIuL3NoYXJlZFwiKTtcclxuZnVuY3Rpb24gaXNJbnRlcm5ldEV4cGxvcmVyKCkge1xyXG4gICAgLy8gVGhlIGRvY3VtZW50TW9kZSBwcm9wZXJ0eSBvbmx5IGV4aXN0cyBpbiBJRVxyXG4gICAgcmV0dXJuIHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudE1vZGUgIT09IHVuZGVmaW5lZDtcclxufVxyXG5leHBvcnRzLmlzSW50ZXJuZXRFeHBsb3JlciA9IGlzSW50ZXJuZXRFeHBsb3JlcjtcclxuZnVuY3Rpb24gaXNNb2JpbGVPUygpIHtcclxuICAgIHZhciB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcclxuICAgIHJldHVybiAoISF1c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQvaSkgfHwgISF1c2VyQWdlbnQubWF0Y2goL2lQYWQvaSkgfHwgISF1c2VyQWdlbnQubWF0Y2goL2lQaG9uZS9pKSk7XHJcbn1cclxuZXhwb3J0cy5pc01vYmlsZU9TID0gaXNNb2JpbGVPUztcclxuLyoqXHJcbiAqIEdlbmVyYXRlIGEgVVVJRCBwcmVwZW5kZWQgd2l0aCBcIl9fYWMtXCJcclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlVW5pcXVlSWQoKSB7XHJcbiAgICByZXR1cm4gXCJfX2FjLVwiICsgU2hhcmVkLlVVSUQuZ2VuZXJhdGUoKTtcclxufVxyXG5leHBvcnRzLmdlbmVyYXRlVW5pcXVlSWQgPSBnZW5lcmF0ZVVuaXF1ZUlkO1xyXG5mdW5jdGlvbiBhcHBlbmRDaGlsZChub2RlLCBjaGlsZCkge1xyXG4gICAgaWYgKGNoaWxkKSB7XHJcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5hcHBlbmRDaGlsZCA9IGFwcGVuZENoaWxkO1xyXG5mdW5jdGlvbiBwYXJzZVN0cmluZyhvYmosIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIgPyBvYmogOiBkZWZhdWx0VmFsdWU7XHJcbn1cclxuZXhwb3J0cy5wYXJzZVN0cmluZyA9IHBhcnNlU3RyaW5nO1xyXG5mdW5jdGlvbiBwYXJzZU51bWJlcihvYmosIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwibnVtYmVyXCIgPyBvYmogOiBkZWZhdWx0VmFsdWU7XHJcbn1cclxuZXhwb3J0cy5wYXJzZU51bWJlciA9IHBhcnNlTnVtYmVyO1xyXG5mdW5jdGlvbiBwYXJzZUJvb2wodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBzd2l0Y2ggKHZhbHVlLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcInRydWVcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBjYXNlIFwiZmFsc2VcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxufVxyXG5leHBvcnRzLnBhcnNlQm9vbCA9IHBhcnNlQm9vbDtcclxuZnVuY3Rpb24gZ2V0RW51bVZhbHVlQnlOYW1lKGVudW1UeXBlLCBuYW1lKSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXHJcbiAgICBmb3IgKHZhciBrZXkgaW4gZW51bVR5cGUpIHtcclxuICAgICAgICB2YXIga2V5QXNOdW1iZXIgPSBwYXJzZUludChrZXksIDEwKTtcclxuICAgICAgICBpZiAoa2V5QXNOdW1iZXIgPj0gMCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBlbnVtVHlwZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleUFzTnVtYmVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5leHBvcnRzLmdldEVudW1WYWx1ZUJ5TmFtZSA9IGdldEVudW1WYWx1ZUJ5TmFtZTtcclxuZnVuY3Rpb24gcGFyc2VFbnVtKGVudW1UeXBlLCBuYW1lLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgIGlmICghbmFtZSkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcbiAgICB2YXIgZW51bVZhbHVlID0gZ2V0RW51bVZhbHVlQnlOYW1lKGVudW1UeXBlLCBuYW1lKTtcclxuICAgIHJldHVybiBlbnVtVmFsdWUgIT09IHVuZGVmaW5lZCA/IGVudW1WYWx1ZSA6IGRlZmF1bHRWYWx1ZTtcclxufVxyXG5leHBvcnRzLnBhcnNlRW51bSA9IHBhcnNlRW51bTtcclxuZnVuY3Rpb24gc3RyaW5nVG9Dc3NDb2xvcihjb2xvcikge1xyXG4gICAgaWYgKGNvbG9yKSB7XHJcbiAgICAgICAgdmFyIHJlZ0V4ID0gLyMoWzAtOUEtRl17Mn0pKFswLTlBLUZdezJ9KShbMC05QS1GXXsyfSkoWzAtOUEtRl17Mn0pPy9naTtcclxuICAgICAgICB2YXIgbWF0Y2hlcyA9IHJlZ0V4LmV4ZWMoY29sb3IpO1xyXG4gICAgICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXNbNF0pIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBwYXJzZUludChtYXRjaGVzWzFdLCAxNikgLyAyNTU7XHJcbiAgICAgICAgICAgIHZhciByID0gcGFyc2VJbnQobWF0Y2hlc1syXSwgMTYpO1xyXG4gICAgICAgICAgICB2YXIgZyA9IHBhcnNlSW50KG1hdGNoZXNbM10sIDE2KTtcclxuICAgICAgICAgICAgdmFyIGIgPSBwYXJzZUludChtYXRjaGVzWzRdLCAxNik7XHJcbiAgICAgICAgICAgIHJldHVybiBcInJnYmEoXCIgKyByICsgXCIsXCIgKyBnICsgXCIsXCIgKyBiICsgXCIsXCIgKyBhICsgXCIpXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbG9yO1xyXG59XHJcbmV4cG9ydHMuc3RyaW5nVG9Dc3NDb2xvciA9IHN0cmluZ1RvQ3NzQ29sb3I7XHJcbmZ1bmN0aW9uIHRydW5jYXRlV29ya2VyKGVsZW1lbnQsIG1heEhlaWdodCwgZnVsbFRleHQsIHRydW5jYXRlQXQsIGxpbmVIZWlnaHQpIHtcclxuICAgIHZhciBmaXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIEFsbG93IGEgb25lIHBpeGVsIG92ZXJmbG93IHRvIGFjY291bnQgZm9yIHJvdW5kaW5nIGRpZmZlcmVuY2VzXHJcbiAgICAgICAgLy8gYmV0d2VlbiBicm93c2Vyc1xyXG4gICAgICAgIHJldHVybiBtYXhIZWlnaHQgLSBlbGVtZW50LnNjcm9sbEhlaWdodCA+PSAtMS4wO1xyXG4gICAgfTtcclxuICAgIGlmIChmaXRzKCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgYnJlYWthYmxlSW5kaWNlcyA9IGZpbmRCcmVha2FibGVJbmRpY2VzKGZ1bGxUZXh0KTtcclxuICAgIHZhciBsbyA9IDA7XHJcbiAgICB2YXIgaGkgPSBicmVha2FibGVJbmRpY2VzLmxlbmd0aDtcclxuICAgIHZhciBiZXN0QnJlYWtJZHggPSAwO1xyXG4gICAgLy8gRG8gYSBiaW5hcnkgc2VhcmNoIGZvciB0aGUgbG9uZ2VzdCBzdHJpbmcgdGhhdCBmaXRzXHJcbiAgICB3aGlsZSAobG8gPCBoaSkge1xyXG4gICAgICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChsbyArIGhpKSAvIDIpO1xyXG4gICAgICAgIHRydW5jYXRlQXQoZnVsbFRleHQsIGJyZWFrYWJsZUluZGljZXNbbWlkXSk7XHJcbiAgICAgICAgaWYgKGZpdHMoKSkge1xyXG4gICAgICAgICAgICBiZXN0QnJlYWtJZHggPSBicmVha2FibGVJbmRpY2VzW21pZF07XHJcbiAgICAgICAgICAgIGxvID0gbWlkICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhpID0gbWlkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRydW5jYXRlQXQoZnVsbFRleHQsIGJlc3RCcmVha0lkeCk7XHJcbiAgICAvLyBJZiB3ZSBoYXZlIGV4dHJhIHJvb20sIHRyeSB0byBleHBhbmQgdGhlIHN0cmluZyBsZXR0ZXIgYnkgbGV0dGVyXHJcbiAgICAvLyAoY292ZXJzIHRoZSBjYXNlIHdoZXJlIHdlIGhhdmUgdG8gYnJlYWsgaW4gdGhlIG1pZGRsZSBvZiBhIGxvbmcgd29yZClcclxuICAgIGlmIChsaW5lSGVpZ2h0ICYmIG1heEhlaWdodCAtIGVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID49IGxpbmVIZWlnaHQgLSAxLjApIHtcclxuICAgICAgICB2YXIgaWR4ID0gZmluZE5leHRDaGFyYWN0ZXIoZnVsbFRleHQsIGJlc3RCcmVha0lkeCk7XHJcbiAgICAgICAgd2hpbGUgKGlkeCA8IGZ1bGxUZXh0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0cnVuY2F0ZUF0KGZ1bGxUZXh0LCBpZHgpO1xyXG4gICAgICAgICAgICBpZiAoZml0cygpKSB7XHJcbiAgICAgICAgICAgICAgICBiZXN0QnJlYWtJZHggPSBpZHg7XHJcbiAgICAgICAgICAgICAgICBpZHggPSBmaW5kTmV4dENoYXJhY3RlcihmdWxsVGV4dCwgaWR4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRydW5jYXRlQXQoZnVsbFRleHQsIGJlc3RCcmVha0lkeCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJ1bmNhdGVUZXh0KGVsZW1lbnQsIG1heEhlaWdodCwgbGluZUhlaWdodCkge1xyXG4gICAgdHJ1bmNhdGVXb3JrZXIoZWxlbWVudCwgbWF4SGVpZ2h0LCBlbGVtZW50LmlubmVyVGV4dCwgZnVuY3Rpb24gKHRleHQsIGlkeCkge1xyXG4gICAgICAgIGVsZW1lbnQuaW5uZXJUZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgaWR4KSArIFwiLi4uXCI7XHJcbiAgICB9LCBsaW5lSGVpZ2h0KTtcclxufVxyXG5leHBvcnRzLnRydW5jYXRlVGV4dCA9IHRydW5jYXRlVGV4dDtcclxuLyoqXHJcbiAqIHtAbGluayB0cnVuY2F0ZX0gaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgaXMgbm8gbG9uZ2VyIGluIHVzZSBpbnRlcm5hbGx5LiBUaGlzIHBvbGljeSBwYXNzZXNcclxuICogY29udGVudCB0aHJvdWdoIGFzIGl0IGFsd2F5cyBoYXMsIHdoaWNoIGlzIF9zdXBwb3NlZF8gdG8gYmUgZGVhbGluZyB3aXRoIHRleHQgb25seSAoc2VlIHtAbGlua1xyXG4gKiBUZXh0QmxvY2sudHJ1bmNhdGVJZlN1cHBvcnRlZH0pLCBidXQgaGFkIGEgYnVnIHdoZXJlIGl0IG1pZ2h0IGFjdHVhbGx5IHBhc3MgdGhyb3VnaCBhbiBlbGVtZW50XHJcbiAqIGZvciB3aGljaCBpbm5lckhUTUwgeWllbGRlZCBhY3R1YWwgSFRNTCAoc2luY2UgZml4ZWQpLlxyXG4gKi9cclxudmFyIHR0RGVwcmVjYXRlZFBvbGljeSA9ICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgPyB1bmRlZmluZWQgOiAoX2EgPSB3aW5kb3cudHJ1c3RlZFR5cGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3JlYXRlUG9saWN5KFwiYWRhcHRpdmVjYXJkcyNkZXByZWNhdGVkRXhwb3J0ZWRGdW5jdGlvblBvbGljeVwiLCB7XHJcbiAgICBjcmVhdGVIVE1MOiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9XHJcbn0pO1xyXG4vKiogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayB0cnVuY2F0ZVRleHR9IGluc3RlYWQuICovXHJcbmZ1bmN0aW9uIHRydW5jYXRlKGVsZW1lbnQsIG1heEhlaWdodCwgbGluZUhlaWdodCkge1xyXG4gICAgdHJ1bmNhdGVXb3JrZXIoZWxlbWVudCwgbWF4SGVpZ2h0LCBlbGVtZW50LmlubmVySFRNTCwgZnVuY3Rpb24gKHRleHQsIGlkeCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgdHJ1bmNhdGVkU3RyaW5nID0gdGV4dC5zdWJzdHJpbmcoMCwgaWR4KSArIFwiLi4uXCI7XHJcbiAgICAgICAgdmFyIHRydW5jYXRlZEhUTUwgPSAoX2EgPSB0dERlcHJlY2F0ZWRQb2xpY3kgPT09IG51bGwgfHwgdHREZXByZWNhdGVkUG9saWN5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0dERlcHJlY2F0ZWRQb2xpY3kuY3JlYXRlSFRNTCh0cnVuY2F0ZWRTdHJpbmcpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVuY2F0ZWRTdHJpbmc7XHJcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSB0cnVuY2F0ZWRIVE1MO1xyXG4gICAgfSwgbGluZUhlaWdodCk7XHJcbn1cclxuZXhwb3J0cy50cnVuY2F0ZSA9IHRydW5jYXRlO1xyXG5mdW5jdGlvbiBmaW5kQnJlYWthYmxlSW5kaWNlcyhodG1sKSB7XHJcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgdmFyIGlkeCA9IGZpbmROZXh0Q2hhcmFjdGVyKGh0bWwsIC0xKTtcclxuICAgIHdoaWxlIChpZHggPCBodG1sLmxlbmd0aCkge1xyXG4gICAgICAgIGlmIChodG1sW2lkeF0gPT09IFwiIFwiKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChpZHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZHggPSBmaW5kTmV4dENoYXJhY3RlcihodG1sLCBpZHgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbn1cclxuZnVuY3Rpb24gZmluZE5leHRDaGFyYWN0ZXIoaHRtbCwgY3VycklkeCkge1xyXG4gICAgY3VycklkeCArPSAxO1xyXG4gICAgLy8gSWYgd2UgZm91bmQgdGhlIHN0YXJ0IG9mIGFuIEhUTUwgdGFnLCBrZWVwIGFkdmFuY2luZyB1bnRpbCB3ZSBnZXRcclxuICAgIC8vIHBhc3QgaXQsIHNvIHdlIGRvbid0IGVuZCB1cCB0cnVuY2F0aW5nIGluIHRoZSBtaWRkbGUgb2YgdGhlIHRhZ1xyXG4gICAgd2hpbGUgKGN1cnJJZHggPCBodG1sLmxlbmd0aCAmJiBodG1sW2N1cnJJZHhdID09PSBcIjxcIikge1xyXG4gICAgICAgIHdoaWxlIChjdXJySWR4IDwgaHRtbC5sZW5ndGggJiYgaHRtbFtjdXJySWR4KytdICE9PSBcIj5cIikge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3VycklkeDtcclxufVxyXG5mdW5jdGlvbiBnZXRGaXRTdGF0dXMoZWxlbWVudCwgY29udGFpbmVyRW5kKSB7XHJcbiAgICB2YXIgc3RhcnQgPSBlbGVtZW50Lm9mZnNldFRvcDtcclxuICAgIHZhciBlbmQgPSBzdGFydCArIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gICAgaWYgKGVuZCA8PSBjb250YWluZXJFbmQpIHtcclxuICAgICAgICByZXR1cm4gRW51bXMuQ29udGFpbmVyRml0U3RhdHVzLkZ1bGx5SW5Db250YWluZXI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzdGFydCA8IGNvbnRhaW5lckVuZCkge1xyXG4gICAgICAgIHJldHVybiBFbnVtcy5Db250YWluZXJGaXRTdGF0dXMuT3ZlcmZsb3dpbmc7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gRW51bXMuQ29udGFpbmVyRml0U3RhdHVzLkZ1bGx5T3V0T2ZDb250YWluZXI7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5nZXRGaXRTdGF0dXMgPSBnZXRGaXRTdGF0dXM7XHJcbmZ1bmN0aW9uIGdldFNjcm9sbFgoKSB7XHJcbiAgICByZXR1cm4gd2luZG93LnBhZ2VYT2Zmc2V0O1xyXG59XHJcbmV4cG9ydHMuZ2V0U2Nyb2xsWCA9IGdldFNjcm9sbFg7XHJcbmZ1bmN0aW9uIGdldFNjcm9sbFkoKSB7XHJcbiAgICByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0O1xyXG59XHJcbmV4cG9ydHMuZ2V0U2Nyb2xsWSA9IGdldFNjcm9sbFk7XHJcbmZ1bmN0aW9uIGNsZWFyRWxlbWVudENoaWxkcmVuKGVsZW1lbnQpIHtcclxuICAgIHdoaWxlIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcclxuICAgICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQuZmlyc3RDaGlsZCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5jbGVhckVsZW1lbnRDaGlsZHJlbiA9IGNsZWFyRWxlbWVudENoaWxkcmVuO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG52YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGVsZW1lbnRUeXBlOiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSAgKyAnYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIVJlYWN0SXMuaXNWYWxpZEVsZW1lbnRUeXBlKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50IHR5cGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudHMgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LCBnb3QgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIGFyZ3VtZW50cy4gJyArXG4gICAgICAgICAgICAnQSBjb21tb24gbWlzdGFrZSBpcyB0byB3cml0ZSBvbmVPZih4LCB5LCB6KSBpbnN0ZWFkIG9mIG9uZU9mKFt4LCB5LCB6XSkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMsIGZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIFN0cmluZyhwcm9wVmFsdWUpICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChoYXMocHJvcFZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAnICsgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpICsgJyBhdCBpbmRleCAnICsgaSArICcuJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZmFsc3kgdmFsdWUgY2FuJ3QgYmUgYSBTeW1ib2xcbiAgICBpZiAoIXByb3BWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGU7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3Jhcnlcbi8vICh1bnN0YWJsZSkgQVBJcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiBDYW4gd2UgcmVtb3ZlIHRoZSBzeW1ib2xzP1xuXG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpIDogMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmJsb2NrJykgOiAweGVhZDk7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJykgOiAweGVhZDU7XG52YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKSA6IDB4ZWFkNztcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IC8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcblxudmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbnZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcblxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cbmNvbnN0IG1heEludCA9IDIxNDc0ODM2NDc7IC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuY29uc3QgYmFzZSA9IDM2O1xuY29uc3QgdE1pbiA9IDE7XG5jb25zdCB0TWF4ID0gMjY7XG5jb25zdCBza2V3ID0gMzg7XG5jb25zdCBkYW1wID0gNzAwO1xuY29uc3QgaW5pdGlhbEJpYXMgPSA3MjtcbmNvbnN0IGluaXRpYWxOID0gMTI4OyAvLyAweDgwXG5jb25zdCBkZWxpbWl0ZXIgPSAnLSc7IC8vICdcXHgyRCdcblxuLyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cbmNvbnN0IHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vO1xuY29uc3QgcmVnZXhOb25BU0NJSSA9IC9bXlxcMC1cXHg3RV0vOyAvLyBub24tQVNDSUkgY2hhcnNcbmNvbnN0IHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2c7IC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuLyoqIEVycm9yIG1lc3NhZ2VzICovXG5jb25zdCBlcnJvcnMgPSB7XG5cdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG59O1xuXG4vKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5jb25zdCBiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW47XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xufVxuXG4vKipcbiAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcbiAqIGl0ZW0uXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0Y29uc3QgcmVzdWx0ID0gW107XG5cdGxldCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcbiAqIGFkZHJlc3Nlcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG4gKiBjaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdGNvbnN0IHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdGxldCByZXN1bHQgPSAnJztcblx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0fVxuXHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdGNvbnN0IGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRjb25zdCBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBkZWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdGNvbnN0IG91dHB1dCA9IFtdO1xuXHRsZXQgY291bnRlciA9IDA7XG5cdGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdC8vIEl0J3MgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG5cdFx0XHRjb25zdCBleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gTG93IHN1cnJvZ2F0ZS5cblx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEl0J3MgYW4gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlXG5cdFx0XHRcdC8vIG5leHQgY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGVuY29kZVxuICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cbiAqL1xuY29uc3QgdWNzMmVuY29kZSA9IGFycmF5ID0+IFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmFycmF5KTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG4gKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cbiAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcbiAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuICovXG5jb25zdCBiYXNpY1RvRGlnaXQgPSBmdW5jdGlvbihjb2RlUG9pbnQpIHtcblx0aWYgKGNvZGVQb2ludCAtIDB4MzAgPCAweDBBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4MTY7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NDEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NDE7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NjEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NjE7XG5cdH1cblx0cmV0dXJuIGJhc2U7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2VcbiAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcbiAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG4gKi9cbmNvbnN0IGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uKGRpZ2l0LCBmbGFnKSB7XG5cdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xufTtcblxuLyoqXG4gKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGFkYXB0ID0gZnVuY3Rpb24oZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdGxldCBrID0gMDtcblx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0fVxuXHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcbiAqIHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqL1xuY29uc3QgZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0Ly8gRG9uJ3QgdXNlIFVDUy0yLlxuXHRjb25zdCBvdXRwdXQgPSBbXTtcblx0Y29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdGxldCBpID0gMDtcblx0bGV0IG4gPSBpbml0aWFsTjtcblx0bGV0IGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0bGV0IGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdGJhc2ljID0gMDtcblx0fVxuXG5cdGZvciAobGV0IGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHR9XG5cdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdH1cblxuXHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0Zm9yIChsZXQgaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdGxldCBvbGRpID0gaTtcblx0XHRmb3IgKGxldCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRjb25zdCB0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgb3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRpICU9IG91dDtcblxuXHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXQuXG5cdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdH1cblxuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4ub3V0cHV0KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcbiAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqL1xuY29uc3QgZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0Y29uc3Qgb3V0cHV0ID0gW107XG5cblx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gYW4gYXJyYXkgb2YgVW5pY29kZSBjb2RlIHBvaW50cy5cblx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHQvLyBDYWNoZSB0aGUgbGVuZ3RoLlxuXHRsZXQgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUuXG5cdGxldCBuID0gaW5pdGlhbE47XG5cdGxldCBkZWx0YSA9IDA7XG5cdGxldCBiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50cy5cblx0Zm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcblx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdH1cblx0fVxuXG5cdGxldCBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cdGxldCBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoO1xuXG5cdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgd2l0aCBhIGRlbGltaXRlciB1bmxlc3MgaXQncyBlbXB0eS5cblx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0fVxuXG5cdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdGxldCBtID0gbWF4SW50O1xuXHRcdGZvciAoY29uc3QgY3VycmVudFZhbHVlIG9mIGlucHV0KSB7XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvdy5cblx0XHRjb25zdCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdH1cblxuXHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0biA9IG07XG5cblx0XHRmb3IgKGNvbnN0IGN1cnJlbnRWYWx1ZSBvZiBpbnB1dCkge1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cblx0XHRcdFx0bGV0IHEgPSBkZWx0YTtcblx0XHRcdFx0Zm9yIChsZXQgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0Y29uc3QgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29uc3QgcU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdGNvbnN0IGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQrK2RlbHRhO1xuXHRcdCsrbjtcblxuXHR9XG5cdHJldHVybiBvdXRwdXQuam9pbignJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3NcbiAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cbiAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuICogY29udmVydGVkIHRvIFVuaWNvZGUuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cbiAqIGNvbnZlcnQgdG8gVW5pY29kZS5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuICogc3RyaW5nLlxuICovXG5jb25zdCB0b1VuaWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuXHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0OiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cbiAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG4gKiBBU0NJSS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcbiAqIFVuaWNvZGUgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuICogZW1haWwgYWRkcmVzcy5cbiAqL1xuY29uc3QgdG9BU0NJSSA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0OiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cbmNvbnN0IHB1bnljb2RlID0ge1xuXHQvKipcblx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqL1xuXHQndmVyc2lvbic6ICcyLjEuMCcsXG5cdC8qKlxuXHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0J3VjczInOiB7XG5cdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0fSxcblx0J2RlY29kZSc6IGRlY29kZSxcblx0J2VuY29kZSc6IGVuY29kZSxcblx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG59O1xuXG5leHBvcnQgeyB1Y3MyZGVjb2RlLCB1Y3MyZW5jb2RlLCBkZWNvZGUsIGVuY29kZSwgdG9BU0NJSSwgdG9Vbmljb2RlIH07XG5leHBvcnQgZGVmYXVsdCBwdW55Y29kZTtcbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgKiBhcyBBZGFwdGl2ZUNhcmRzIGZyb20gJ2FkYXB0aXZlY2FyZHMnO1xyXG5pbXBvcnQgUmVhY3QsIHtcclxuICAgIHVzZUNvbnRleHQsXHJcbiAgICB1c2VDYWxsYmFjayxcclxuICAgIHVzZUVmZmVjdCxcclxuICAgIHVzZVJlZixcclxuICAgIHVzZVN0YXRlLFxyXG59IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0ICogYXMgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgKiBhcyBtYXJrZG93biBmcm9tICdtYXJrZG93bi1pdCc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcclxuICAgIHBheWxvYWQ6IG9iamVjdDtcclxuICAgIG9uRXhlY3V0ZUFjdGlvbj86IEZ1bmN0aW9uO1xyXG4gICAgb25BY3Rpb25TdWJtaXQ/OiBGdW5jdGlvbjtcclxuICAgIG9uQWN0aW9uT3BlblVybD86IEZ1bmN0aW9uO1xyXG4gICAgb25BY3Rpb25TaG93Q2FyZD86IEZ1bmN0aW9uO1xyXG4gICAgb25FcnJvcj86IEZ1bmN0aW9uO1xyXG4gICAgc3R5bGU/OiBvYmplY3Q7XHJcbiAgICBob3N0Q29uZmlnPzogb2JqZWN0O1xyXG59XHJcblxyXG5jb25zdCBwcm9wVHlwZXMgPSB7XHJcbiAgICAvKiogVGhlIGNhcmQgc2NoZW1hLiAgSXQgbXVzdCBjb21wbHkgd2l0aCB0aGUgY2FyZCBzY2hlbWEuIFtNb3JlIEluZm9dKGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL2FkYXB0aXZlLWNhcmRzL2NyZWF0ZS9jYXJkc2NoZW1hKSAqL1xyXG4gICAgcGF5bG9hZDogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxyXG4gICAgLyoqIE1ldGhvZCB0aGF0IHdpbGwgYmUgaW52b2tlZCBhbnl0aW1lIGEgY2FyZCBhY3Rpb24gaXMgZXhlY3V0ZWQuIFtNb3JlIEluZm9dKGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL2FkYXB0aXZlLWNhcmRzL2Rpc3BsYXkvaW1wbGVtZW50aW5ncmVuZGVyZXIjYWN0aW9ucykgKi9cclxuICAgIG9uRXhlY3V0ZUFjdGlvbjogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICAvKiogTWV0aG9kIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gYSBTdWJtaXQgYWN0aW9uIGlzIGV4ZWN1dGVkLiBbTW9yZSBJbmZvXShodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9hZGFwdGl2ZS1jYXJkcy9kaXNwbGF5L2ltcGxlbWVudGluZ3JlbmRlcmVyI2FjdGlvbnN1Ym1pdCkgKi9cclxuICAgIG9uQWN0aW9uU3VibWl0OiBQcm9wVHlwZXMuZnVuYyxcclxuICAgIC8qKiBNZXRob2QgdGhhdCB3aWxsIGJlIGludm9rZWQgd2hlbiBhbiBPcGVuIFVybCBhY3Rpb24gaXMgZXhlY3V0ZWQuIFtNb3JlIEluZm9dKGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL2FkYXB0aXZlLWNhcmRzL2Rpc3BsYXkvaW1wbGVtZW50aW5ncmVuZGVyZXIjYWN0aW9ub3BlbnVybCkgKi9cclxuICAgIG9uQWN0aW9uT3BlblVybDogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICAvKiogTWV0aG9kIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gYSBTaG93IENhcmQgYWN0aW9uIGlzIGV4ZWN1dGVkLiBbTW9yZSBJbmZvXShodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9hZGFwdGl2ZS1jYXJkcy9kaXNwbGF5L2ltcGxlbWVudGluZ3JlbmRlcmVyI2FjdGlvbnNob3djYXJkKSAqL1xyXG4gICAgb25BY3Rpb25TaG93Q2FyZDogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICAvKiogTWV0aG9kIHRoYXQgd2lsbCBiZSBpbnZva2VkIGlmIGFuIGVycm9yIGlzIHRocm93biB3aGlsZSB0cnlpbmcgdG8gcmVuZGVyIGEgY2FyZC4gKi9cclxuICAgIG9uRXJyb3I6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgLyoqIEpTWCBzdHlsZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGNhcmQgY29uYXRpbmVyICovXHJcbiAgICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcclxuICAgIC8qKiBIb3N0Q29uZmlnLiBbTW9yZSBJbmZvXShodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9hZGFwdGl2ZS1jYXJkcy9yZW5kZXJpbmctY2FyZHMvaG9zdC1jb25maWcpICovXHJcbiAgICBob3N0Q29uZmlnOiBQcm9wVHlwZXMub2JqZWN0LFxyXG59O1xyXG5cclxuY29uc3QgZGVmYXVsdE9wZW5VcmxIYW5kbGVyID0gKGFjdGlvbjogQWRhcHRpdmVDYXJkcy5PcGVuVXJsQWN0aW9uKSA9PiB7XHJcbiAgICB3aW5kb3cub3BlbihhY3Rpb24udXJsLCAnX2JsYW5rJyk7XHJcbn07XHJcblxyXG5jb25zdCBzZXRVcE1hcmtkb3duSXQgPSAoKSA9PiB7XHJcbiAgICBpZiAoIUFkYXB0aXZlQ2FyZHMuQWRhcHRpdmVDYXJkLm9uUHJvY2Vzc01hcmtkb3duKSB7XHJcbiAgICAgICAgQWRhcHRpdmVDYXJkcy5BZGFwdGl2ZUNhcmQub25Qcm9jZXNzTWFya2Rvd24gPSAodGV4dCwgcmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5vdXRwdXRIdG1sID0gbmV3IG1hcmtkb3duLmRlZmF1bHQoKS5yZW5kZXIodGV4dCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5kaWRQcm9jZXNzID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG5cclxuc2V0VXBNYXJrZG93bkl0KCk7XHJcblxyXG5leHBvcnQgY29uc3QgQWRhcHRpdmVDYXJkID0gKHtcclxuICAgIHBheWxvYWQsXHJcbiAgICBvbkV4ZWN1dGVBY3Rpb24sXHJcbiAgICBvbkFjdGlvblN1Ym1pdCxcclxuICAgIG9uQWN0aW9uT3BlblVybCxcclxuICAgIG9uQWN0aW9uU2hvd0NhcmQsXHJcbiAgICBvbkVycm9yLFxyXG4gICAgc3R5bGUsXHJcbiAgICBob3N0Q29uZmlnLFxyXG59OiBQcm9wcykgPT4ge1xyXG4gICAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxFcnJvcj4oKTtcclxuICAgIGNvbnN0IHRhcmdldFJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XHJcbiAgICBjb25zdCBjYXJkUmVmID0gdXNlUmVmPEFkYXB0aXZlQ2FyZHMuQWRhcHRpdmVDYXJkPihcclxuICAgICAgICBuZXcgQWRhcHRpdmVDYXJkcy5BZGFwdGl2ZUNhcmQoKVxyXG4gICAgKTtcclxuICAgIGNvbnN0IGV4ZWN1dGVBY3Rpb24gPSB1c2VDYWxsYmFjayhcclxuICAgICAgICAoYTogQWRhcHRpdmVDYXJkcy5BY3Rpb24pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGEuZ2V0SnNvblR5cGVOYW1lKCk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBZGFwdGl2ZUNhcmRzLk9wZW5VcmxBY3Rpb24uSnNvblR5cGVOYW1lOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uQWN0aW9uT3BlblVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkFjdGlvbk9wZW5VcmwoYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE9wZW5VcmxIYW5kbGVyKGEgYXMgQWRhcHRpdmVDYXJkcy5PcGVuVXJsQWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBBZGFwdGl2ZUNhcmRzLlNob3dDYXJkQWN0aW9uLkpzb25UeXBlTmFtZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkFjdGlvblNob3dDYXJkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQWN0aW9uU2hvd0NhcmQoYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBBZGFwdGl2ZUNhcmRzLlN1Ym1pdEFjdGlvbi5Kc29uVHlwZU5hbWU6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob25BY3Rpb25TdWJtaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25BY3Rpb25TdWJtaXQoYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRPRE86IFdoeSBpcyB0aGVyZSBhIGdsb2JhbCBhY3Rpb24gaGFuZGxlciB3aGVuIHdlIGhhdmUgc3BlY2lmaWNcclxuICAgICAgICAgICAgLy8gaGFuZGxlcnMgZm9yIHRoZSBhYm92ZSBjYXNlcz8gQ2FuIHdlIHNpbXBsaWZ5IHRvIG9uZSBhcHByb2FjaD9cclxuICAgICAgICAgICAgaWYgKG9uRXhlY3V0ZUFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgb25FeGVjdXRlQWN0aW9uKGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBbb25BY3Rpb25PcGVuVXJsLCBvbkFjdGlvblNob3dDYXJkLCBvbkFjdGlvblN1Ym1pdCwgb25FeGVjdXRlQWN0aW9uXVxyXG4gICAgKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNhcmRSZWYuY3VycmVudC5vbkV4ZWN1dGVBY3Rpb24gPSBleGVjdXRlQWN0aW9uO1xyXG4gICAgfSwgW2V4ZWN1dGVBY3Rpb25dKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNhcmRSZWYuY3VycmVudC5ob3N0Q29uZmlnID0gbmV3IEFkYXB0aXZlQ2FyZHMuSG9zdENvbmZpZyhob3N0Q29uZmlnKTtcclxuICAgIH0sIFtob3N0Q29uZmlnXSk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIXRhcmdldFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2FyZCA9IGNhcmRSZWYuY3VycmVudDtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY2FyZC5wYXJzZShwYXlsb2FkKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2FyZC5yZW5kZXIoKSBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICAgICAgY29uc3QgdHJ1c3RlZEh0bWwgPSAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpID8gXCJcIiA6ICh3aW5kb3cudHJ1c3RlZFR5cGVzPy5lbXB0eUhUTUwgPz8gXCJcIik7XHJcbiAgICAgICAgICAgIHRhcmdldFJlZi5jdXJyZW50LmlubmVySFRNTCA9IHRydXN0ZWRIdG1sIGFzIHN0cmluZztcclxuICAgICAgICAgICAgdGFyZ2V0UmVmLmN1cnJlbnQuYXBwZW5kQ2hpbGQocmVzdWx0KTtcclxuICAgICAgICB9IGNhdGNoIChjYXJkUmVuZGVyRXJyb3IpIHtcclxuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIG9uRXJyb3IoY2FyZFJlbmRlckVycm9yKTtcclxuICAgICAgICAgICAgICAgIHNldEVycm9yKGNhcmRSZW5kZXJFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbaG9zdENvbmZpZywgcGF5bG9hZCwgb25FcnJvcl0pO1xyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIHJldHVybiA8ZGl2IHN0eWxlPXt7IGNvbG9yOiAncmVkJyB9fT57ZXJyb3IubWVzc2FnZX08L2Rpdj47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gPGRpdiBzdHlsZT17c3R5bGV9IHJlZj17dGFyZ2V0UmVmfSAvPjtcclxufTtcclxuXHJcbkFkYXB0aXZlQ2FyZC5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XHJcbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbmV4cG9ydCAqIGZyb20gXCIuL2FkYXB0aXZlLWNhcmRcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vaG9zdC1jb25maWctY29udGV4dFwiO1xyXG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIEZDLCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBQcm9wcywgQWRhcHRpdmVDYXJkIH0gZnJvbSAnLi9hZGFwdGl2ZS1jYXJkJ1xyXG5cclxuaW50ZXJmYWNlIEhvc3RDb25maWcge1xyXG4gICAgaG9zdENvbmZpZzogb2JqZWN0O1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgSG9zdENvbmZpZ0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PEhvc3RDb25maWc+KHsgaG9zdENvbmZpZzogbnVsbCB9KTtcclxuXHJcbmV4cG9ydCB0eXBlIFByb3BzV2l0aG91dEhvc3RDb25maWcgPSBPbWl0PFByb3BzLCAnaG9zdENvbmZpZyc+O1xyXG5cclxuZXhwb3J0IGNvbnN0IEFkYXB0aXZlQ2FyZFVzaW5nSG9zdENvbmZpZ0NvbnRleHQgPSAocHJvcHM6IFByb3BzV2l0aG91dEhvc3RDb25maWcpID0+IHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEhvc3RDb25maWdDb250ZXh0KTtcclxuICAgIHJldHVybiA8QWRhcHRpdmVDYXJkIHsuLi5wcm9wc30gaG9zdENvbmZpZz17Y29udGV4dC5ob3N0Q29uZmlnfSAvPlxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgUHJvdmlkZXNIb3N0Q29uZmlnQ29udGV4dDogRkM8eyBob3N0Q29uZmlnOiBvYmplY3QgfT4gPSAoeyBob3N0Q29uZmlnLCBjaGlsZHJlbiB9KSA9PiB7XHJcbiAgICByZXR1cm4gPEhvc3RDb25maWdDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7IGhvc3RDb25maWcgfX0gPntjaGlsZHJlbn08L0hvc3RDb25maWdDb250ZXh0LlByb3ZpZGVyPlxyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfcmVhY3RfXzsiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2FkYXB0aXZlY2FyZHMtcmVhY3QudHNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=